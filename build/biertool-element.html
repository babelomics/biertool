<html><head><!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><meta charset="UTF-8"><script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

var Utils = {
    //properties
    characters: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
    months: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov", "Dec"],
    number: {
        sign: function (x) {
            return x ? x < 0 ? -1 : 1 : 0;
        }
    },
    //Methods
    formatNumber: function (position) {
        return position.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    },
    formatText: function (text, spaceChar) {
        text = text.replace(new RegExp(spaceChar, "gi"), " ");
        text = text.charAt(0).toUpperCase() + text.slice(1);
        return text;
    },
    titleCase: function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);;
    },
    camelCase: function (str) {
        return str.toLowerCase().replace(/[.-_\s](.)/g, function (match, group1) {
            return group1.toUpperCase();
        })
    },
    camelToSpace: function (str) {
        var result = str.replace(/([A-Z])/g, ' $1').toLowerCase().trim();
        return result.charAt(0).toUpperCase() + result.slice(1);
    },
    closest: function (element, selector) {
        var matches = (element.matches) ? 'matches' : 'msMatchesSelector';
        while (element) {
            if (element[matches](selector)) {
                break;
            }
            element = element.parentElement;
        }
        return element;
    },
    isFunction: function (s) {
        return typeof (s) === 'function' || s instanceof Function;
    },
    parseDate: function (strDate) {
        return strDate.substring(4, 6) + "/" + strDate.substring(6, 8) + "/" + strDate.substring(0, 4) + " " + strDate.substring(8, 10) + ":" + strDate.substring(10, 12) + ":" + strDate.substring(12, 14);
    },
    genId: function (prefix) {
        prefix = prefix || '';
        prefix = prefix.length == 0 ? prefix : prefix + '-';
        return prefix + this.randomString(4) + this.getRandomInt(1000, 9999);
    },
    randomString: function (length) {
        length = length || 10;
        var str = "";
        for (var i = 0; i < length; i++) {
            str += this.characters.charAt(this.getRandomInt(0, this.characters.length - 1));
        }
        return str;
    },
    getRandomInt: function (min, max) {
        // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
        // Using Math.round() will give you a non-uniform distribution!
        return Math.floor(Math.random() * (max - min + 1)) + min;
    },
    endsWithIgnoreCase: function (str, test) {
        var regex = new RegExp('^.*\\.(' + test + ')$', 'i');
        return regex.test(str);
    },
    endsWith: function (str, test) {
        return str.length >= test.length && str.substr(str.length - test.length) == test;
    },
    addQueryParamtersToUrl: function (paramsWS, url) {
        var chr = "?";
        if (url.indexOf("?") != -1) {
            chr = "&";
        }
        var query = Utils.queryString(paramsWS);
        if (query != "")
            query = chr + query;
        return url + query;
    },
    queryString: function (obj) {
        var items = [];
        for (var key in obj) {
            if (obj[key] != null && obj[key] != undefined) {
                items.push(key + '=' + encodeURIComponent(obj[key]));
            }
        }
        return items.join('&');
    },
    randomColor: function () {
        var color = "";
        for (var i = 0; i < 6; i++) {
            color += ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f'][Math.floor(Math.random() * 16)]);
        }
        return "#" + color;
    },
    colorLuminance: function (hex, lum) {
        // validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');
        hex = String(hex).replace(/#/gi, '');
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;

        // convert to decimal and change luminosity
        var rgb = "#",
            c, i;
        for (i = 0; i < 3; i++) {
            c = parseInt(hex.substr(i * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb += ("00" + c).substr(c.length);
        }

        return rgb;
    },
    getSpeciesFromAvailable: function (availableSpecies, speciesCode) {
        for (var phylos in availableSpecies) {
            for (var i = 0; i < availableSpecies[phylos].length; i++) {
                var species = availableSpecies[phylos][i];
                if (species.id === speciesCode || species.scientificName.toLowerCase() === speciesCode.toLowerCase()) {
                    return species;
                }
            }
        }
    },
    getSpeciesCode: function (speciesName) {
        var pair = speciesName.split(" ");
        var code;
        if (pair.length < 3) {
            code = (pair[0].charAt(0) + pair[1]).toLowerCase();
        } else {
            code = (pair[0].charAt(0) + pair[1] + pair[pair.length - 1].replace(/[/_().\-]/g, '')).toLowerCase();

        }
        return code;
    },
    basicValidationForm: function (scope) {
        var validated = true;
        var msg = "";
        if (scope.$.outdir.selectedFile === undefined || scope.$.outdir.selectedFile.type != "FOLDER") {
            msg += "Error: Please select an output folder.\n";
            validated = false;
        }
        if (scope.$.inputFile.selectedFile === undefined || scope.$.inputFile.selectedFile.type != "FILE") {
            msg += "Error: Please select an input file.\n";
            validated = false;
        }
        if (scope.$.jobName.value == "") {
            msg += "Error: Please add a job name.\n";
            validated = false;
        }
        if (!validated) {
            alert(msg)
        }
        return validated;
    },
    getUrl: function (fileId) {
        return OpencgaManager.files.download({
            id: fileId,
            query: {
                sid: Cookies("bioinfo_sid")
            },
            request: {
                url: true
            }
        });
    },
    getFileContent: function (callback, fileId) {
        OpencgaManager.files.content({
            id: fileId,
            query: {
                sid: Cookies("bioinfo_sid")
            },
            request: {
                success: function (response) {
                    callback(response);
                },
                error: function () {
                    this.message = 'Server error, try again later.';
                }
            }
        })
    },
    loadExampleFile: function (callback, toolName, exampleFileName) {

        var me = this;
        OpencgaManager.files.contentExample({
            query: {
                toolName: toolName,
                fileName: exampleFileName
            },
            request: {
                //method: 'POST',
                success: function (response) {
                    callback(response);
                    //                            debugger
                    //                            me.loadedMainSelectChanged(false,true);
                },
                error: function () {
                    console.log('utils.js223:Server error, try again later.');
                }
            }
        })
    },
    downloadExampleFile: function (toolName, fileName) {
        var url = OpencgaManager.files.downloadExample({
            query: {
                toolName: toolName,
                fileName: fileName
            },
            request: {
                url: true
            }
        });
        var link = document.createElement('a');
        link.href = url;
        //link.setAttribute("download", "download.zip");
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        link.dispatchEvent(event);
    },
    argsParser: function (form, args) {
        if (form.toolName == args.tool) {
            for (var key in args) {
                if (typeof (args[key]) == "object") {
                    if (form.$[key] !== undefined)
                        form.$[key].selectedFile = args[key];
                } else {
                    var elems = form.shadowRoot.querySelectorAll('input[name="' + key + '"]');
                    if (form.$[key] !== undefined) {
                        switch (form.$[key].type) {
                        case "checkbox":
                            form.$[key].checked = args[key];
                        default:
                            form.$[key].value = args[key];
                        }
                    }
                    for (var i = 0; i < elems.length; i++) {
                        var elem = elems[i];
                        if (elem.value == args[key])
                            elem.checked = true;
                    }

                }
            }
        }
    },
    getLinks: function (terms) {
        var links = [];
        for (var i = 0; i < terms.length; i++) {
            var term = terms[i];
            links.push(Utils.getLink(term));
        }
        return links;
    },
    getLink: function (term) {
        var link = "http://www.ebi.ac.uk/QuickGO/GTerm?id=";
        if (term.indexOf("(") >= 0) {
            var id = term.split("(");
            if (id.length > 1)
                id = id[1];
            id = id.split(")")[0];

        } else
            id = term;
        if (id.indexOf("IPR") == 0)
            link = "http://www.ebi.ac.uk/interpro/entry/";
        link = link + id;
        return link;
    },
    myRound: function (value, decimals) {
        decimals = typeof decimals !== 'undefined' ? decimals : 2;
        value = parseFloat(value);
        /** rounding **/
        if (Math.abs(value) >= 1)
            value = value.toFixed(decimals);
        else
            value = value.toPrecision(decimals);
        value = parseFloat(value);
        return value;
    },
    formatNumber: function (value, decimals) {
        value = Utils.myRound(value, decimals);

        if (Math.abs(value) > 0 && Math.abs(value) < 0.001)
            value = value.toExponential();
        return value;
    },
    getSpecies: function (specieValue, species) {
        for (var i = 0; i < species.length; i++) {
            var specie = species[i];
            if (specie.value == specieValue) {
                return specie;
            }
        }
        return null;
    },
    test: function () {
        return this;
    },
    cancelFullscreen: function () {
        if (document.cancelFullScreen) {
            document.cancelFullScreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
        }
    },
    launchFullScreen: function (element) {
        if (element.requestFullScreen) {
            element.requestFullScreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.webkitRequestFullScreen) {
            element.webkitRequestFullScreen();
        }
    },
    parseJobCommand: function (item) {
        var commandObject = {};
        var commandArray = item.commandLine.split(/ -{1,2}/g);
        var tableHtml = '<table cellspacing="0" style="max-width:400px;border-collapse: collapse;border:1px solid #ccc;"><tbody>';
        tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;font-weight:bold;">';
        tableHtml += '<td style="min-width:50px;border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">Parameter</td>';
        tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">Value</td>';
        tableHtml += '</tr>';
        for (var i = 1; i < commandArray.length; i++) {
            //ignore first argument
            var paramenter = commandArray[i];
            var paramenterArray = paramenter.split(/ {1}/g);
            var name = '';
            var value = '';
            if (paramenterArray.length < 2) {
                name = paramenterArray[0];
                value = '<span color:darkgray;font-weight:bold;>This paramenter is a flag</span>';
            } else {
                name = paramenterArray[0];
                value = paramenterArray[1];
            }
            commandObject[name] = value;
            /* clean values for viz*/
            value = value.replace(/\/httpd\/bioinfo\/opencga\/analysis\/.+\/examples\//, '');
            value = value.replace('/httpd/bioinfo/opencga/accounts/', '');
            value = value.replace(/,/g, ", ");

            tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;">';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;color:steelblue;font-weight:bold;white-space: nowrap;">' + name + '</td>';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">' + value + '</td>';
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        return {
            html: tableHtml,
            data: commandObject
        };
    },
    htmlTable: function (object) {
        var tableHtml = '';
        tableHtml += '<table cellspacing="0" style="border-collapse: collapse;border:1px solid #ccc;"><tbody>';
        for (var key in object) {
            tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;">';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;color:steelblue;font-weight:bold;white-space: nowrap;">' + key + '</td>';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">' + object[key] + '</td>';
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        return tableHtml;
    },
    msg: function (title, msg) {
        var div = document.createElement('div');
        div.classList.add('jso-msg-hidden');
        var titleDiv = document.createElement('div');
        titleDiv.textContent = title;
        var msgDiv = document.createElement('div');
        msgDiv.textContent = msg;
        div.appendChild(titleDiv);
        div.appendChild(msgDiv);
        document.body.appendChild(div);
        div.addEventListener('click', function () {
            document.body.removeChild(div);
            div = null;
        });
        setTimeout(function () {
            div.classList.add('jso-msg-shown');
        }, 10);
        setTimeout(function () {
            if (div) {
                div.classList.remove('jso-msg-shown');
            }
        }, 4000);
        setTimeout(function () {
            if (div) {
                document.body.removeChild(div);
                div = null;
            }
        }, 4400);
    },
    repeat: function (string, count) {
        if (string == null) {
            throw new TypeError('can\'t convert ' + string + ' to object');
        }
        var str = '' + string;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (august 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += str;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            str += str;
        }
        return rpt;

    },
    clone: function (obj) {
        return JSON.parse(JSON.stringify(obj));
    },
    timeDiff: function (timeStart, timeEnd) {
        var ts = new Date(Date.parse(timeStart));
        var te = new Date(Date.parse(timeEnd));

        if (isNaN(ts) || isNaN(te)) {
            return "";
        }

        if (ts < te) {
            var milisec_diff = te - ts;
        } else {
            var milisec_diff = ts - te;
        }

        var days = Math.floor(milisec_diff / 1000 / 60 / (60 * 24));
        var daysMessage = days + " Days ";
        if (days === 0) {
            daysMessage = '';
        }
        var date_diff = new Date(milisec_diff);
        var hours = date_diff.getHours() - 1;
        var hoursMessage = hours + " hour";
        var minutesMessage = date_diff.getMinutes() + " minute";
        var secondsMessage = date_diff.getSeconds() + " second";
        if (hours !== 1) {
            hoursMessage += 's ';
        } else {
            hoursMessage += ' ';
        }
        if (date_diff.getMinutes() !== 1) {
            minutesMessage += 's ';
        } else {
            minutesMessage += ' ';
        }
        if (date_diff.getSeconds() !== 1) {
            secondsMessage += 's ';
        } else {
            secondsMessage += ' ';
        }
        if (hours === 0) {
            hoursMessage = '';
        }
        if (date_diff.getMinutes() === 0) {
            minutesMessage = '';
        }
        if (date_diff.getSeconds() === 0) {
            secondsMessage = '';
        }
        return daysMessage + hoursMessage + minutesMessage + secondsMessage;
    },
    deleteIndexedDB: function () {
        window.indexedDB.webkitGetDatabaseNames().onsuccess = function (sender, args) {
            var r = sender.target.result;
            for (var i in r) {
                indexedDB.deleteDatabase(r[i]);
            }
        };
    },
    subsetArray: function (array, from, to) {
        var aux = [];
        from = (from < 0) ? 0 : from;
        to = (to >= array.length) ? array.length : to;

        for (var i = from; i < to; i++) {
            aux.push(array[i]);
        }

        return aux;
    },
    applyFunctionBatch: function (array, batchsize, callback) {

        var end = batchsize;
        var auxArray = this.subsetArray(array, 0, end);

        while (auxArray.length > 0) {
            callback(auxArray);
            auxArray = this.subsetArray(array, end, end + batchsize);
            end += batchsize;
        }
    }

};

Utils.images = {
    add: "data:image/gif;base64,R0lGODlhEAAQAIcAAD2GNUKNNkOPOESMO0WNPEmPP0iNQUmPQlOVTFWWTVCZQVeeRV6cVmGeWGSgVWSgV2aiWGejW2WrVWirU2uqWGqsW2yqWm61WG+1WG+1WXS3W3S3XHC4WXK5W3O6XHG+X3asZ3iuaHe8YHi0ZH+yany6ZH28Zn2+Z3m9bn25an25a3+5bUD/QHDBY3nBZHrGa3zDa37BaX7Hb4K1boO1boa3cYi4d4y7doq5eYm+eI2+e5O/f4HMdYbJeobJfIXNeYrCeY/CfYnIf4rPfZW/gozLgY7MhI7Sg5LFgJXAgpfHhZfMhZPNiJjLhpjMh5jMipvBl5vBmJTTipbTiZXUipbUi5fVi5nRi53YkqTOlKbPlqbQlqDZlaDZlqXbm6rUnavUnKbIoKfJoa/fpa/fprPZpbTZpbTaprLbqLPdqbXbqLfaqrTdqrXfrLbdrLjVr7jdr7vcr7rWsbfgr77itr3ktsTcuMXducXowMvmw87pydTrz9fu0tzx2ODy3P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAACwALAAAAAAQABAAAAi/AFkIHEiwoME7SWrMwCHH4MAdWfLs0QNnRQiHN+L4qeOlyxg8QCAU3LGmDxYmRqpQOTJHRYSBdpTw4SJFyJ8/P2DIaLNAjEAibsgU8YHiZgURHq4gaSCQBh0rPW5K/cMhxpcCAkmkGcJj6k0OJ8AMEGjjyZQXLSR85dBhiY4EAt9MYOPig4ivFzacEQBlIIgUaJByyIBBQxkLBwo6GKHGiYkSTcxQAODwgYIgW7TkCGDAocAwDAoQQBDFs2mCAQEAOw==",
    del: "data:image/gif;base64,R0lGODlhEAAQAIcAAED/QLpSNL9TOr5WOb5cQL9cQMFNM8RQNMBVPcBZP8xSPNBPPttWS9ddUcJnTMRkTMdrVM1gUc5iVMxmVclrVs1oWNZgVNZuZNtpZdxraN5ratxuadRxZd14c955dOZWTOZYTOZZTulZTelbT+ZWUOZaUuddWepcUOxfVOBlXO5mUuljW+pmXO5qXvBkVvNzXeNrYeNuY+FvcOJwZuJ7deR4ceJ5eeN4eeJ/feN/fOl7cOh6del/ePJ3Y/N5Y+qDfe6Efe+Gfu6KdfaCaPaEbPCFcPCDe/CMd/GOeviGcPiMdvCRf/eRfveTfvmSfvqTf/iUf9ymltynl+6Mge2Tju6Sj/SOgfqah/qdi/GclvGdluGpnvSgnvSinvWjn/qjkfupnPqrneGroOqwrOuzr/Ono/WmoferofarovWsofWvpfKtqvivpPS0qvi2qPm5r/q6rvC1tfC2tvjDvvzHuvnLxPnTzPzUzf3b1P3c2P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAAALAAAAAAQABAAAAi6AAEIHEiwoEE5ODRk8EDG4EAbVObYqdNmxgWHMtbkgfMFCxg6OiQUvFEGz5UlSKA4UeImRoWBcX7cwdJECJGbRHywWSBGYA41YY6gGEq0hxUeFARuePOkiJ6nUEW00IJAIIYzSYZAjcoiywCBHaYweSGirNkRRmg8EDiGARoXKsyKAFHCy4EoAznASIPihIgQH0h0sVCgYIQUZoKsMAGES4MADico2FGlSg0DBBwK3AIhgQAHUjSLJhgQADs=",
    enable: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAKfSURBVDjLpZPrS1NhHMf9O3bOdmwDCWREIYKEUHsVJBI7mg3FvCxL09290jZj2EyLMnJexkgpLbPUanNOberU5taUMnHZUULMvelCtWF0sW/n7MVMEiN64AsPD8/n83uucQDi/id/DBT4Dolypw/qsz0pTMbj/WHpiDgsdSUyUmeiPt2+V7SrIM+bSss8ySGdR4abQQv6lrui6VxsRonrGCS9VEjSQ9E7CtiqdOZ4UuTqnBHO1X7YXl6Daa4yGq7vWO1D40wVDtj4kWQbn94myPGkCDPdSesczE2sCZShwl8CzcwZ6NiUs6n2nYX99T1cnKqA2EKui6+TwphA5k4yqMayopU5mANV3lNQTBdCMVUA9VQh3GuDMHiVcLCS3J4jSLhCGmKCjBEx0xlshjXYhApfMZRP5CyYD+UkG08+xt+4wLVQZA1tzxthm2tEfD3JxARH7QkbD1ZuozaggdZbxK5kAIsf5qGaKMTY2lAU/rH5HW3PLsEwUYy+YCcERmIjJpDcpzb6l7th9KtQ69fi09ePUej9l7cx2DJbD7UrG3r3afQHOyCo+V3QQzE35pvQvnAZukk5zL5qRL59jsKbPzdheXoBZc4saFhBS6AO7V4zqCpiawuptwQG+UAa7Ct3UT0hh9p9EnXT5Vh6t4C22QaUDh6HwnECOmcO7K+6kW49DKqS2DrEZCtfuI+9GrNHg4fMHVSO5kE7nAPVkAxKBxcOzsajpS4Yh4ohUPPWKTUh3PaQEptIOr6BiJjcZXCwktaAGfrRIpwblqOV3YKdhfXOIvBLeREWpnd8ynsaSJoyESFphwTtfjN6X1jRO2+FxWtCWksqBApeiFIR9K6fiTpPiigDoadqCEag5YUFKl6Yrciw0VOlhOivv/Ff8wtn0KzlebrUYwAAAABJRU5ErkJggg==",
    warning: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIsSURBVDjLpVNLSJQBEP7+h6uu62vLVAJDW1KQTMrINQ1vPQzq1GOpa9EppGOHLh0kCEKL7JBEhVCHihAsESyJiE4FWShGRmauu7KYiv6Pma+DGoFrBQ7MzGFmPr5vmDFIYj1mr1WYfrHPovA9VVOqbC7e/1rS9ZlrAVDYHig5WB0oPtBI0TNrUiC5yhP9jeF4X8NPcWfopoY48XT39PjjXeF0vWkZqOjd7LJYrmGasHPCCJbHwhS9/F8M4s8baid764Xi0Ilfp5voorpJfn2wwx/r3l77TwZUvR+qajXVn8PnvocYfXYH6k2ioOaCpaIdf11ivDcayyiMVudsOYqFb60gARJYHG9DbqQFmSVNjaO3K2NpAeK90ZCqtgcrjkP9aUCXp0moetDFEeRXnYCKXhm+uTW0CkBFu4JlxzZkFlbASz4CQGQVBFeEwZm8geyiMuRVntzsL3oXV+YMkvjRsydC1U+lhwZsWXgHb+oWVAEzIwvzyVlk5igsi7DymmHlHsFQR50rjl+981Jy1Fw6Gu0ObTtnU+cgs28AKgDiy+Awpj5OACBAhZ/qh2HOo6i+NeA73jUAML4/qWux8mt6NjW1w599CS9xb0mSEqQBEDAtwqALUmBaG5FV3oYPnTHMjAwetlWksyByaukxQg2wQ9FlccaK/OXA3/uAEUDp3rNIDQ1ctSk6kHh1/jRFoaL4M4snEMeD73gQx4M4PsT1IZ5AfYH68tZY7zv/ApRMY9mnuVMvAAAAAElFTkSuQmCC",
    edit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB80lEQVR42o2T30tTURzArb8ioiAI6kHoZeF7CGE/IISCUDNCqAeL3rIWPfSwByskYUEJIhSChBhJFAiNqMVYPqRuc4tcW3NLt3C7u3d3d3c/+nS+0GRK0134cC6c8/ncc+7ltgFt6jqgcCg6duGQYq84deoBR6lU0iqVSq1arfI/1Dxut3u0Htke6BC5UChgmuYm+XyeXC5HOp1GIsnQNJHJi3x/7WJh/CSLT9r7Rd4jAVlgWRa2bSOjYBgGmqaRyWQwkq9Y8wyhLb0BI0VuaRrfo671xoDIwmakWCyi6zrr36bILt/HXp1l7cNDioEZqnEvgYmr1paAOgYy1u/l3NrqHNngPWpFL8XodTa+3CD8YoCvz/o078i5o1sC29FT78kG7lCzfJgrl7ESvejLThLPuxk8fbhP3KaBVFCdeX7on9yP9bOHfPAu0bEzmKkg4jQNpEKzhOduqW1/xIoNUEpcQlM7WXl6Cj39Q9Y0D4Q/TRJ662Tx3WOS/guYsV42Fm4THe/G/B2T97Jz4OVwJ+hxImPn8Tj381k91TfShfErIvLuAde1Y9g+N7Z/FL/rBDODR8gmgpTL5To7B3o69zF8pR3Pg7PMT90kn47LJ22kaeCPghapidP4Lxy3bduUiVZktdaQH7AxcFAiUm0Rhzji/gUhbp0s2Zf2xwAAAABJRU5ErkJggg==",
    info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAJ1SURBVHjafJJdSJNhFMd/z3QzLWdZrnQmSA2DPqRCK4KuhIq66kLoAy/qoqCguqqL6JsgLwoKKhCMSIy6CDKKRFZZYYQRVhJl02nWmG5uc19u7/vuPV0lW7QOnIsHnt+P8z/Pg4gw26aZ0263uzEUCn2IxWJjXq/3JqBETLIZ8gkePLhfKyKy/Z5HHJf7xe0Jic/n65mejizPK0inUiSTKUSE0dHRhxf6JoSDb4Rjr4QDz0REJBgMtmczFrJKKYVSCjCYnPR/W1FuAwQSGjbHXAA0LRXKZnIm0NJpgAKvd/hSOBz2iIj0eiPS2vtDYsmUPH/uPg9YshklIrOyCb+/eUG5ve3au5C99W2AqGbgKivk8R4X1lSkv2pJZaNmmBQVWWeZnAiGoa+3KovdyBjsW2kn/SvK4Jcgtaf7cDqrGkQMUDkBcgXVS2tOHjp8dG2jOXT1yo5lYOpgFTB0wKTAOqdQMlqOoDD7EE8kREwGXr/oWTg4HjxONAklBayuKSUeT/hFTxrwnwlAMa8I1qyrP3H95RiQgUiC/RsWM+wZ6jIME0M38wtSM0mmojM4nc6mzr5xKDQgnWb/pmoedT29EU3pTMUS+QVKKerq6kqnI3EVHwmAplO8qBh7WTFnzpz9bOg6FovlfxGEixfOrfT6YxCOQ1rDUaIAG4EJ38+PAwNb/95Bzj8ITAZwLHbMT0yHw3N33YVwEnQDqss41VzPkaalX6Iz+m6Xy/Xp34JAAICR7187nLWuvbe6h9C0DA2uRTTVV9J++87OlpaWJxUVFf9+xj+1cfOWls6OO93Nq1zblMVm9flG3pcvXNPm90+E/777ewB+UIqdqtYXHAAAAABJRU5ErkJggg==",
    //    bucket: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90BCg4hBcbCoOMAAABsSURBVDjLY2RgYFBjYGCIZCAPLGeBam4g0wAGJgYKARMDA8NZCvSfZYQy6sk0oJEFiUNqODRQLQxGDYCAb2To/YZswEsyDHiJbMAHMgz4gO6F5aTkQpgXYElZkoGBgZeEbL2cgYHhMwMDw3MA93ARk+mSg4gAAAAASUVORK5CYII=",
    bucket: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QkQDC8RTstxRAAAAGBJREFUOMtjYBgswIWBgeE/idiFgYGBgRFqwH8GBoYGEi1tYGBgYGRBE9QjUvMlGANmgCsDA8NuElzRANXDwAQV2ENGuO1BNoBsMGoAlQ3wJTIdNEDVYgU+ROQBH6rmQgAWgB19xco60wAAAABJRU5ErkJggg==",
    //    dir: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsSAAALEgHS3X78AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKNJREFUeNrEk7sNwkAQBefQ5m6BTiAAQssZiMh0QFUIMrAEpKYD8ynAJeD4nXQEkJHgu4CXv9GsdteFEEjJgMQ4gPli+aWx227cLwAD8FK8QZ4XTyCL6B6qal+YlzLgCpSn87HpbTCdzAKwAkpg1Bdgn/nbmDLQmby6hC3W5qUGGEcCGpNUJwBq09tgHdO+Pe61eamNvIMLgEkaxuoDuL9/42sAM20/EZafbV8AAAAASUVORK5CYII=",
    dir: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDNzU0RUNBNzU3OEIxMUUyOEM3QzkxOEZDOTU1RTdFMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDNzU0RUNBODU3OEIxMUUyOEM3QzkxOEZDOTU1RTdFMCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkM3NTRFQ0E1NTc4QjExRTI4QzdDOTE4RkM5NTVFN0UwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkM3NTRFQ0E2NTc4QjExRTI4QzdDOTE4RkM5NTVFN0UwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+S/WxbAAAAERJREFUeNpi/P//PwMlgJFSA1g2bNiAzYQLQOwIxB8IGcCEQ9wAiPcDsQBBF+CRAxnynlwXEA1GDRg1gCqZiWIDAAIMADidE0PBoGsZAAAAAElFTkSuQmCC",
    r: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90CDRIvNbHTpbwAAADjSURBVDjLpZFBbsIwEEUfVRZYahcVK3qKXoauMFK5C91nkyUB+xC5BqeAA7SKq1B5ugl2EiC04UkjayzN17NnROTRWvvJFbTWL8CBHqbGWOlSlqVkWSbGWAGm3aGHZiMiAByPP6FOd1rP2W7NvhvSCvDe10E+VJPFQpPnm1ZIcsmgPgJVVZGmaejX63y/XL4/AV/JJYPTCeDcN7PZWyuwKAqA8wARqSsGKDVGqXGjV8H07AnRQPq21TK8+YSBAQMN4hb6Df7wB/5eA+4zmEyehxk451itPrhFksSxUeP+lf+z+wXwdayJk/mqtgAAAABJRU5ErkJggg==",
    box: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMHAwRAVvTmTAAAAK/SURBVDjLpZM9bFxFGEXPNzPvZ+39sb2xHceREjDQBwlDCqqIiiotokAghYKEjvSkQkKJkEiB0lOkoAHaBAokFCQKUATIIOLIMbHWrHfX+7zvvZk3MzQODUgU3PJK5+g2F/5n5N/Kb66/1NNK3hAxr4HcFqVuvfju18V/Cu58sPmMVnJZ4K32Qr+t8za+KnCz4kCUuiGibm5euTv5h+CL958/nxj1XivVF+e6C9TVhPmFdbROgEhwNU1d4m09UaJuInLjhct3DgDUh5ee7j14PLxulLvYP/0seadPkub88Wib0eB3bDkmxgbRoFPpxeCuKvjsyQIzOyqImT7/y8Mh++NveW7jLFmrx6m1NlWxz6PHA7otQ7tloAmYJE9isOeeCJRtIrULLLUTjsqG7+//xs72z7jZgCTNONlVJKEiuobW0jqSaoiet19dFQATJcc2FSFEciNoLYwOHcPDASvdjM5cQntxlbR9gqacoFSK84VsnOrkH11Zdmp0FFXjobSeCFgXSDS0Eo11ge7yGXSaU092UUlCaEpC8FK4tDcu4rzZ2a/S+bWI94HSAgFigDQD24Cvp4gIOp0juBJvC2L07B1Uc/Mtg9k7sHMbywZrA3lLECV4AtaCpAp79CcmzXHlhOBrAJrGyNbOVBY7qTO1C9r5EKyPSttAiJEs01SuQStFkrdp6gKd5AzHjixVxCDxp+1paZRUxoc4Kp36bndYbS53U5WlCq0CMYIPMY7GI0mNpiqmGK0oK4jIveGkPgRqfTBt3A8Pqtvrq52HtglnGh9XIaKUkCQ6nj6RyWBsmdXCtFI/bu2Fq5c+3roGzIAgWokCDNACOhfOLb781Ip+vd+RC2dXWibROkxKvvp1z376yZe7d4HpMdz8/YVjiQYyoA30Ti6la2++0n/n83vTW/e3ix1gcgzXgPchBoC/AFu/UBF5InryAAAAAElFTkSuQmCC",
    bluebox: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMHAwTE5pcivoAAALsSURBVDjLXZPPaxxlGMc/77wz+3N2k822tWsTIrQFe/BWEKxKCV5UohdFhJ60p6rgUfpP6C0K4kHx0ENEkV7aElHwUikhFVosRGoTm83+3pnZnXfed2beHtItIQ98+Z6+H57nga8AsNYKDkYcEofcHvKZEEJYcSTszPzqL3fmf3+w/+a51tytby9d6D0N5UecGeBZ8MPv/jh9fy/6dKzMpVPHmvWdbl/XCvKn5Wbl6+ufrNwGssMgYa2VgFj58sZr7VB/LqX3zlKrydJzTTzXxdqcx90hO+0Bk2l8Z74i1z6+cOba5VfOqGeAb3579M/NR53T40xwrDGHFALPEUjn4LoMi0ktwWTKXqCIqAVrbyycvHj2hHYBR+bO8Q/Ov0imEzZ2xrRDRalQwC9LLBalUgaJQy+tU6gvIBJbv3j2RA4IFxDdICFa9ulMCrz/UgOs5kEwpeh57I4Nt/dzsmLOYlEThgFjUePp33IHoD9SJAbuTVyudRweixJvnVtg3/i00wpLPiwQ0hkO6YYKawWj0UjONqAfKHwDkxTqqeW/RHA3hO2+Zqk05e5wTD9KmOqMKDEUqoLNzU0PyF2AQaBoaIhiw0h6TIwgUDCODb5NiWJNlKREyhAozXwOW1tbFSmlcAHbD2KaytCdGgyWglfEs4LeNKeaa4axYRgpwlgTTTXVDDqdTslaewAYh4kNlKUbZsTGonOwCYwm1vq5Ft1AMYgU08SQR5o0gziOcRxHuoCNtdl6uPHX6/Vmi3Yyh9I5IoEgMdkgT9x+qJhEGrdQo77cJMuy+4DJskwLa60DOCtf3HhZpfZKtVx+L3x+sfCv8CFxTINd72HfodQ4aQp5fP24/v/Hd4Nf/5RSJmma6lkXZn1wPvvq5qndsbhS9esf/Zy/UEtzxnURfn8+/fuHV7m353mecV1XSym1lDI72kaxvr5e3N7eruyP0tpG/e3LK/rW2mLNUb7vm3K5nFarVdNqtbJer2dXV1fzJ6cDpboAZRAGAAAAAElFTkSuQmCC",
    refresh: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAK8AAACvABQqw0mAAAAAd0SU1FB90CFA8bKScXIjIAAAJ1SURBVDjLlVJdSJNRGH7es+/7NlduWFLTKAskwjJqZYiBglJhLKguqou6EFkFIkLQH9IPBFI3BsouzMJupGYRajcqmeBFhWBU5oUgpZikrSnzZ9v3nW/ndKEbziXUAwfOOe/7Puc9z/MCq1DwMmB1NX/rzfCNnsc/gK08lPgnnT8Cs33BULg0HI4YKdkHX9DqKwKArXXv1bTMTFcoyruC89E8MxaDw659t6rKhIUwRBLdP2t2v/5bBwQA+5pH8ibnIj3BucgWIQRASw8RERTGYFUtsGmWYUXKmqmr7t4UAnal54GQ8lq8MBlyOU0CEnA67MiwqfvHbhZ+Smgg6o9eV2L8Nhk6wI2lZeggrpvE+TTjxgxxQ4IbmJsJYSa00JQiotnguacJ8zIZOmDosAnzTpowt8tGj0s0ejZqprnDKmPHSNebjHDkUPatt4cTTbZ+LsmO79XK52dZxTNp9/ovAEDnaM62lo8HHrd9SVfiOelVryrSq9vrEx0s8sW2tuEzDgDgT875bcIsjy6owwAwHhjnYT5bGTL29PiHyuwAMO873aL/Ct5PiPjwXe5vq7KJW2hdJxENMFInGCkhIblLj80WRoyxGxZmh1XJGlSIlV8s6A8kuVDXn+MF6JHC7GBkBSNlOSRgiihMsQhAgJGGNNU1atc2HPG6O8YSBABwt2/nGyFlGSCSB4UIBMuyoQKMFNiUjIApRH5t8YfpFOOrO/JrhZBVUiJLxq2ipIkY8Z36uivpC6txqb3YbhqhIingFlLmxmLSKyXAGAaYqh13aFjfcHJwfE2ClSitK9psc85PMVC3M999orX4Kcf/wuPb27VW7A+O2QVVA1M1CQAAAABJRU5ErkJggg==",
    newitem: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAtxJREFUeNqM0llIVHEUBvDv3vlfZ8ac6zZtWpmamtliUUHRDlFJWlEYLdBLtG/QBlFJQUTSU089RZRlG4EvkS9NlqkpldHyYLk1OurcOzp30vHO/y6nBwsSIvzgvBw+fpyHA8MwwDmHbdsjQwSbCACkYDBYp6pqU3Fxcfyf/Z+eYRjQOQf+Bnw+30IiIsMwhizL4n3lV6mn7BzZtm1yzn8SETU0NKz+J2ARobe3t85/+SI1506j9hOHqTEO9FYEtR/ZTx/n5FDH6eOkquoni2g00NjUtEzTtBYioneLCulVHKg2yUkNmelUn5VOtUlueu0SqDE/m4iIIpFI64fm5vU65xAMIlicR9rOn/UEKytgmQbYuARAEDAqRLCiQxBFhtTNWzDzxk1LcjgkFhuKIhLR2qJKcN5Al/q7reF/cXUHoA0MtA9Gh4klJIxz6ro+PZiVC0uOw1jimJEDWZbTDhw8lCi0+/3PtUeV696ePIPUnIwxAf3fOjG/7AK8e/e9ZH2K0uWdPRdivANm3NguED1OJBYWQunvDwgAXIqifO54+CC7/tSxMQELL11B/r6D3cnJybniQDis25Ikfn1wD2GdQLIMISkF5JFhudwgjwySkyCkpILkRER0wpf7d2FJkqSoapQRRPCYjoLDR+EY70VXbS2YxCC4nAARbAAQBJBlwTIMZJRsQN7W7eA6t9O8XkE0jRhWLV2y+Gdm9q0dT6rMhLw8dPn7EAoEMBSLIcpjCPUEEPD3gU1Kw+6qZ6TPKrizq3TbAjUUIkFRVYAIkkfG99bWp4P1b7Z0vq5BXtFGPN6zE6Zuo7SiAh01PkycV4jJRRt96VOmrOHhMESHiBEAgMkNlGwqmXC78mG1DXtQdruTgx/eF5g6x9Tly1pCmtYjMSnxatnFTeXXyn8wxiCMAgxz5EmcTjCXCynxblf1C9910eFwrl254nh/dDhqcQ5zeBgAwBiDIAr4NQAWJarVjshqqgAAAABJRU5ErkJggg=="
};
</script>
<script>var stv = (window.stv != null) ? window.stv : {};
stv.utils = {
    stevia: true,
    //properties
    characters: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
    months: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    number: {
        sign: function (x) {
            return x ? x < 0 ? -1 : 1 : 0;
        }
    },
    //Methods
    formatNumber: function (position) {
        return position.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    },
    formatText: function (text, spaceChar) {
        text = text.replace(new RegExp(spaceChar, "gi"), " ");
        text = text.charAt(0).toUpperCase() + text.slice(1);
        return text;
    },
    titleCase: function (str) {
        return str[0].toUpperCase() + str.slice(1);;
    },
    camelCase: function (str) {
        return str.toLowerCase().replace(/[.-_\s](.)/g, function (match, group1) {
            return group1.toUpperCase();
        })
    },
    camelToSpace: function (str) {
        var result = str.replace(/([A-Z])/g, ' $1').toLowerCase().trim();
        return result.charAt(0).toUpperCase() + result.slice(1);
    },
    closest: function (element, selector) {
        var matches = (element.matches) ? 'matches' : 'msMatchesSelector';
        while (element) {
            if (element[matches](selector)) {
                break;
            }
            element = element.parentElement;
        }
        return element;
    },
    isFunction: function (s) {
        return typeof (s) === 'function' || s instanceof Function;
    },
    parseDate: function (strDate) {
        return strDate.substring(4, 6) + "/" + strDate.substring(6, 8) + "/" + strDate.substring(0, 4) + " " + strDate.substring(8, 10) + ":" + strDate.substring(10, 12) + ":" + strDate.substring(12, 14);
    },
    genId: function (prefix) {
        prefix = prefix || '';
        prefix = prefix.length == 0 ? prefix : prefix + '-';
        return prefix + this.randomString(4) + this.getRandomInt(1000, 9999);
    },
    randomString: function (length) {
        length = length || 10;
        var str = "";
        for (var i = 0; i < length; i++) {
            str += this.characters.charAt(this.getRandomInt(0, this.characters.length - 1));
        }
        return str;
    },
    getRandomInt: function (min, max) {
        // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
        // Using Math.round() will give you a non-uniform distribution!
        return Math.floor(Math.random() * (max - min + 1)) + min;
    },
    endsWithIgnoreCase: function (str, test) {
        return this.endsWith(str.toLowerCase(), test.toLowerCase());
    },
    endsWith: function (str, test) {
        return str.length >= test.length && str.substr(str.length - test.length) == test;
    },
    addQueryParamtersToUrl: function (paramsWS, url) {
        var chr = "?";
        if (url.indexOf("?") != -1) {
            chr = "&";
        }
        var query = stv.utils.queryString(paramsWS);
        if (query != "")
            query = chr + query;
        return url + query;
    },
    queryString: function (obj) {
        var items = [];
        for (var key in obj) {
            if (obj[key] != null && obj[key] != undefined) {
                items.push(key + '=' + encodeURIComponent(obj[key]));
            }
        }
        return items.join('&');
    },
    randomColor: function () {
        var color = "";
        for (var i = 0; i < 6; i++) {
            color += ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f'][Math.floor(Math.random() * 16)]);
        }
        return "#" + color;
    },
    colorLuminance: function (hex, lum) {
        // validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');
        hex = String(hex).replace(/#/gi, '');
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;

        // convert to decimal and change luminosity
        var rgb = "#",
            c, i;
        for (i = 0; i < 3; i++) {
            c = parseInt(hex.substr(i * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb += ("00" + c).substr(c.length);
        }

        return rgb;
    },
    getSpeciesFromAvailable: function (availableSpecies, speciesCode) {
        for (var phylos in availableSpecies) {
            for (var i = 0; i < availableSpecies[phylos].length; i++) {
                var species = availableSpecies[phylos][i];
                if (species.id === speciesCode || species.scientificName.toLowerCase() === speciesCode.toLowerCase()) {
                    return species;
                }
            }
        }
    },
    getSpeciesCode: function (speciesName) {
        var pair = speciesName.split(" ");
        var code;
        if (pair.length < 3) {
            code = (pair[0].charAt(0) + pair[1]).toLowerCase();
        } else {
            code = (pair[0].charAt(0) + pair[1] + pair[pair.length - 1].replace(/[/_().\-]/g, '')).toLowerCase();

        }
        return code;
    },
    basicValidationForm: function (scope) {
        var validated = true;
        var msg = "";
        if (scope.$.outdir.selectedFile === undefined || scope.$.outdir.selectedFile.type != "FOLDER") {
            msg += "Error: Please select an output folder.\n";
            validated = false;
        }
        if (scope.$.inputFile.selectedFile === undefined || scope.$.inputFile.selectedFile.type != "FILE") {
            msg += "Error: Please select an input file.\n";
            validated = false;
        }
        if (scope.$.jobName.value == "") {
            msg += "Error: Please add a job name.\n";
            validated = false;
        }
        if (!validated) {
            alert(msg)
        }
        return validated;
    },
    getUrl: function (fileId) {
        return SteviaManager.files.download({
            id: fileId,
            request: {
                url: true
            }
        });
    },
    getFileContent: function (callback, fileId) {
        SteviaManager.files.content({
            id: fileId,
            request: {
                success: function (response) {
                    callback(response);
                },
                error: function () {
                    this.message = 'Server error, try again later.';
                }
            }
        })
    },
    loadExampleFile: function (callback, toolName, exampleFileName) {

        var me = this;
        SteviaManager.files.contentExample({
            query: {
                toolName: toolName,
                fileName: exampleFileName
            },
            request: {
                //method: 'POST',
                success: function (response) {
                    callback(response);
                    //                            debugger
                    //                            me.loadedMainSelectChanged(false,true);
                },
                error: function () {
                    alert('Server error, try again later.');
                }
            }
        })
    },
    downloadExampleFile: function (toolName, fileName) {
        var url = SteviaManager.files.downloadExample({
            query: {
                toolName: toolName,
                fileName: fileName
            },
            request: {
                url: true
            }
        });
        var link = document.createElement('a');
        link.href = url;
        //link.setAttribute("download", "download.zip");
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        link.dispatchEvent(event);
    },
    argsParser: function (form, args) {
        if (form.toolName == args.tool) {
            for (var key in args) {
                if (typeof (args[key]) == "object") {
                    if (form.$[key] !== undefined)
                        form.$[key].selectedFile = args[key];
                } else {
                    var elems = form.shadowRoot.querySelectorAll('input[name="' + key + '"]');
                    if (form.$[key] !== undefined) {
                        switch (form.$[key].type) {
                        case "checkbox":
                            form.$[key].checked = args[key];
                        default:
                            form.$[key].value = args[key];
                        }
                    }
                    for (var i = 0; i < elems.length; i++) {
                        var elem = elems[i];
                        if (elem.value == args[key])
                            elem.checked = true;
                    }

                }
            }
        }
    },
    getLinks: function (terms) {
        var links = [];
        for (var i = 0; i < terms.length; i++) {
            var term = terms[i];
            links.push(stv.utils.getLink(term));
        }
        return links;
    },
    getLink: function (term) {
        var link = "http://www.ebi.ac.uk/QuickGO/GTerm?id=";
        if (term.indexOf("(") >= 0) {
            var id = term.split("(");
            if (id.length > 1)
                id = id[1];
            id = id.split(")")[0];

        } else
            id = term;
        if (id.indexOf("IPR") == 0)
            link = "http://www.ebi.ac.uk/interpro/entry/";
        link = link + id;
        return link;
    },
    myRound: function (value, decimals) {
        decimals = typeof decimals !== 'undefined' ? decimals : 2;
        value = parseFloat(value);
        /** rounding **/
        if (Math.abs(value) >= 1)
            value = value.toFixed(decimals);
        else
            value = value.toPrecision(decimals);
        value = parseFloat(value);
        return value;
    },
    formatNumber: function (value, decimals) {
        value = stv.utils.myRound(value, decimals);

        if (Math.abs(value) > 0 && Math.abs(value) < 0.001)
            value = value.toExponential();
        return value;
    },
    getSpecies: function (specieValue, species) {
        for (var i = 0; i < species.length; i++) {
            var specie = species[i];
            if (specie.value == specieValue) {
                return specie;
            }
        }
        return null;
    },
    test: function () {
        return this;
    },
    cancelFullscreen: function () {
        if (document.cancelFullScreen) {
            document.cancelFullScreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
        }
    },
    launchFullScreen: function (element) {
        if (element.requestFullScreen) {
            element.requestFullScreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.webkitRequestFullScreen) {
            element.webkitRequestFullScreen();
        }
    },
    parseJobCommand: function (item) {
        var commandObject = {};
        var commandArray = item.commandLine.split(/ -{1,2}/g);
        var tableHtml = '<table cellspacing="0" style="max-width:400px;border-collapse: collapse;border:1px solid #ccc;"><tbody>';
        tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;font-weight:bold;">';
        tableHtml += '<td style="min-width:50px;border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">Parameter</td>';
        tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">Value</td>';
        tableHtml += '</tr>';
        for (var i = 1; i < commandArray.length; i++) {
            //ignore first argument
            var paramenter = commandArray[i];
            var paramenterArray = paramenter.split(/ {1}/g);
            var name = '';
            var value = '';
            if (paramenterArray.length < 2) {
                name = paramenterArray[0];
                value = '<span color:darkgray;font-weight:bold;>This paramenter is a flag</span>';
            } else {
                name = paramenterArray[0];
                value = paramenterArray[1];
            }
            commandObject[name] = value;
            /* clean values for viz*/
            value = value.replace(/\/httpd\/bioinfo\/stevia\/analysis\/.+\/examples\//, '');
            value = value.replace('/httpd/bioinfo/stevia/accounts/', '');
            value = value.replace(/,/g, ", ");

            tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;">';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;color:steelblue;font-weight:bold;white-space: nowrap;">' + name + '</td>';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">' + value + '</td>';
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        return {
            html: tableHtml,
            data: commandObject
        };
    },
    htmlTable: function (object) {
        var tableHtml = '';
        tableHtml += '<table cellspacing="0" style="border-collapse: collapse;border:1px solid #ccc;"><tbody>';
        for (var key in object) {
            tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;">';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;color:steelblue;font-weight:bold;white-space: nowrap;">' + key + '</td>';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">' + object[key] + '</td>';
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        return tableHtml;
    },
    msg: function (title, msg) {
        var div = document.createElement('div');
        div.classList.add('stv-msg-hidden');
        var titleDiv = document.createElement('div');
        titleDiv.textContent = title;
        var msgDiv = document.createElement('div');
        msgDiv.textContent = msg;
        div.appendChild(titleDiv);
        div.appendChild(msgDiv);
        document.body.appendChild(div);
        div.addEventListener('click', function () {
            document.body.removeChild(div);
            div = null;
        });
        setTimeout(function () {
            div.classList.add('stv-msg-shown');
        }, 10);
        setTimeout(function () {
            if (div) {
                div.classList.remove('stv-msg-shown');
            }
        }, 4000);
        setTimeout(function () {
            if (div) {
                document.body.removeChild(div);
                div = null;
            }
        }, 4400);
    },
    repeat: function (string, count) {
        if (string == null) {
            throw new TypeError('can\'t convert ' + string + ' to object');
        }
        var str = '' + string;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (august 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += str;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            str += str;
        }
        return rpt;

    },
    clone: function (obj) {
        return JSON.parse(JSON.stringify(obj));
    },
    timeDiff: function (timeStart, timeEnd) {
        var ts = new Date(Date.parse(timeStart));
        var te = new Date(Date.parse(timeEnd));

        if (isNaN(ts) || isNaN(te)) {
            return "";
        }

        if (ts < te) {
            var milisec_diff = te - ts;
        } else {
            var milisec_diff = ts - te;
        }

        var days = Math.floor(milisec_diff / 1000 / 60 / (60 * 24));
        var daysMessage = days + " Days ";
        if (days === 0) {
            daysMessage = '';
        }
        var date_diff = new Date(milisec_diff);
        var hours = date_diff.getHours() - 1;
        var hoursMessage = hours + " hour";
        var minutesMessage = date_diff.getMinutes() + " minute";
        var secondsMessage = date_diff.getSeconds() + " second";
        if (hours !== 1) {
            hoursMessage += 's ';
        } else {
            hoursMessage += ' ';
        }
        if (date_diff.getMinutes() !== 1) {
            minutesMessage += 's ';
        } else {
            minutesMessage += ' ';
        }
        if (date_diff.getSeconds() !== 1) {
            secondsMessage += 's ';
        } else {
            secondsMessage += ' ';
        }
        if (hours === 0) {
            hoursMessage = '';
        }
        if (date_diff.getMinutes() === 0) {
            minutesMessage = '';
        }
        if (date_diff.getSeconds() === 0) {
            secondsMessage = '';
        }
        return daysMessage + hoursMessage + minutesMessage + secondsMessage;
    },
    deleteIndexedDB: function () {
        window.indexedDB.webkitGetDatabaseNames().onsuccess = function (sender, args) {
            var r = sender.target.result;
            for (var i in r) {
                indexedDB.deleteDatabase(r[i]);
            }
        };
    },
    subsetArray: function (array, from, to) {
        var aux = [];
        from = (from < 0) ? 0 : from;
        to = (to >= array.length) ? array.length : to;

        for (var i = from; i < to; i++) {
            aux.push(array[i]);
        }

        return aux;
    },
    applyFunctionBatch: function (array, batchsize, callback) {

        var end = batchsize;
        var auxArray = this.subsetArray(array, 0, end);

        while (auxArray.length > 0) {
            callback(auxArray);
            auxArray = this.subsetArray(array, end, end + batchsize);
            end += batchsize;
        }
    },
    humanFileSize: function (bytes) {
        var thresh = 1024;
        if (Math.abs(bytes) < thresh) {
            return bytes + ' B';
        }
        var units = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        var u = -1;
        do {
            bytes /= thresh;
            ++u;
        } while (Math.abs(bytes) >= thresh && u < units.length - 1);
        return bytes.toFixed(1) + ' ' + units[u];
    },
    removeDuplicates: function (array) {
        var uniqueArray = array.filter(function (item, pos) {
            return array.indexOf(item) == pos;
        });
        return uniqueArray;
    },
    images: {
        add: "data:image/gif;base64,R0lGODlhEAAQAIcAAD2GNUKNNkOPOESMO0WNPEmPP0iNQUmPQlOVTFWWTVCZQVeeRV6cVmGeWGSgVWSgV2aiWGejW2WrVWirU2uqWGqsW2yqWm61WG+1WG+1WXS3W3S3XHC4WXK5W3O6XHG+X3asZ3iuaHe8YHi0ZH+yany6ZH28Zn2+Z3m9bn25an25a3+5bUD/QHDBY3nBZHrGa3zDa37BaX7Hb4K1boO1boa3cYi4d4y7doq5eYm+eI2+e5O/f4HMdYbJeobJfIXNeYrCeY/CfYnIf4rPfZW/gozLgY7MhI7Sg5LFgJXAgpfHhZfMhZPNiJjLhpjMh5jMipvBl5vBmJTTipbTiZXUipbUi5fVi5nRi53YkqTOlKbPlqbQlqDZlaDZlqXbm6rUnavUnKbIoKfJoa/fpa/fprPZpbTZpbTaprLbqLPdqbXbqLfaqrTdqrXfrLbdrLjVr7jdr7vcr7rWsbfgr77itr3ktsTcuMXducXowMvmw87pydTrz9fu0tzx2ODy3P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAACwALAAAAAAQABAAAAi/AFkIHEiwoME7SWrMwCHH4MAdWfLs0QNnRQiHN+L4qeOlyxg8QCAU3LGmDxYmRqpQOTJHRYSBdpTw4SJFyJ8/P2DIaLNAjEAibsgU8YHiZgURHq4gaSCQBh0rPW5K/cMhxpcCAkmkGcJj6k0OJ8AMEGjjyZQXLSR85dBhiY4EAt9MYOPig4ivFzacEQBlIIgUaJByyIBBQxkLBwo6GKHGiYkSTcxQAODwgYIgW7TkCGDAocAwDAoQQBDFs2mCAQEAOw==",
        del: "data:image/gif;base64,R0lGODlhEAAQAIcAAED/QLpSNL9TOr5WOb5cQL9cQMFNM8RQNMBVPcBZP8xSPNBPPttWS9ddUcJnTMRkTMdrVM1gUc5iVMxmVclrVs1oWNZgVNZuZNtpZdxraN5ratxuadRxZd14c955dOZWTOZYTOZZTulZTelbT+ZWUOZaUuddWepcUOxfVOBlXO5mUuljW+pmXO5qXvBkVvNzXeNrYeNuY+FvcOJwZuJ7deR4ceJ5eeN4eeJ/feN/fOl7cOh6del/ePJ3Y/N5Y+qDfe6Efe+Gfu6KdfaCaPaEbPCFcPCDe/CMd/GOeviGcPiMdvCRf/eRfveTfvmSfvqTf/iUf9ymltynl+6Mge2Tju6Sj/SOgfqah/qdi/GclvGdluGpnvSgnvSinvWjn/qjkfupnPqrneGroOqwrOuzr/Ono/WmoferofarovWsofWvpfKtqvivpPS0qvi2qPm5r/q6rvC1tfC2tvjDvvzHuvnLxPnTzPzUzf3b1P3c2P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAAALAAAAAAQABAAAAi6AAEIHEiwoEE5ODRk8EDG4EAbVObYqdNmxgWHMtbkgfMFCxg6OiQUvFEGz5UlSKA4UeImRoWBcX7cwdJECJGbRHywWSBGYA41YY6gGEq0hxUeFARuePOkiJ6nUEW00IJAIIYzSYZAjcoiywCBHaYweSGirNkRRmg8EDiGARoXKsyKAFHCy4EoAznASIPihIgQH0h0sVCgYIQUZoKsMAGES4MADico2FGlSg0DBBwK3AIhgQAHUjSLJhgQADs=",
        enable: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAKfSURBVDjLpZPrS1NhHMf9O3bOdmwDCWREIYKEUHsVJBI7mg3FvCxL09290jZj2EyLMnJexkgpLbPUanNOberU5taUMnHZUULMvelCtWF0sW/n7MVMEiN64AsPD8/n83uucQDi/id/DBT4Dolypw/qsz0pTMbj/WHpiDgsdSUyUmeiPt2+V7SrIM+bSss8ySGdR4abQQv6lrui6VxsRonrGCS9VEjSQ9E7CtiqdOZ4UuTqnBHO1X7YXl6Daa4yGq7vWO1D40wVDtj4kWQbn94myPGkCDPdSesczE2sCZShwl8CzcwZ6NiUs6n2nYX99T1cnKqA2EKui6+TwphA5k4yqMayopU5mANV3lNQTBdCMVUA9VQh3GuDMHiVcLCS3J4jSLhCGmKCjBEx0xlshjXYhApfMZRP5CyYD+UkG08+xt+4wLVQZA1tzxthm2tEfD3JxARH7QkbD1ZuozaggdZbxK5kAIsf5qGaKMTY2lAU/rH5HW3PLsEwUYy+YCcERmIjJpDcpzb6l7th9KtQ69fi09ePUej9l7cx2DJbD7UrG3r3afQHOyCo+V3QQzE35pvQvnAZukk5zL5qRL59jsKbPzdheXoBZc4saFhBS6AO7V4zqCpiawuptwQG+UAa7Ct3UT0hh9p9EnXT5Vh6t4C22QaUDh6HwnECOmcO7K+6kW49DKqS2DrEZCtfuI+9GrNHg4fMHVSO5kE7nAPVkAxKBxcOzsajpS4Yh4ohUPPWKTUh3PaQEptIOr6BiJjcZXCwktaAGfrRIpwblqOV3YKdhfXOIvBLeREWpnd8ynsaSJoyESFphwTtfjN6X1jRO2+FxWtCWksqBApeiFIR9K6fiTpPiigDoadqCEag5YUFKl6Yrciw0VOlhOivv/Ff8wtn0KzlebrUYwAAAABJRU5ErkJggg==",
        warning: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIsSURBVDjLpVNLSJQBEP7+h6uu62vLVAJDW1KQTMrINQ1vPQzq1GOpa9EppGOHLh0kCEKL7JBEhVCHihAsESyJiE4FWShGRmauu7KYiv6Pma+DGoFrBQ7MzGFmPr5vmDFIYj1mr1WYfrHPovA9VVOqbC7e/1rS9ZlrAVDYHig5WB0oPtBI0TNrUiC5yhP9jeF4X8NPcWfopoY48XT39PjjXeF0vWkZqOjd7LJYrmGasHPCCJbHwhS9/F8M4s8baid764Xi0Ilfp5voorpJfn2wwx/r3l77TwZUvR+qajXVn8PnvocYfXYH6k2ioOaCpaIdf11ivDcayyiMVudsOYqFb60gARJYHG9DbqQFmSVNjaO3K2NpAeK90ZCqtgcrjkP9aUCXp0moetDFEeRXnYCKXhm+uTW0CkBFu4JlxzZkFlbASz4CQGQVBFeEwZm8geyiMuRVntzsL3oXV+YMkvjRsydC1U+lhwZsWXgHb+oWVAEzIwvzyVlk5igsi7DymmHlHsFQR50rjl+981Jy1Fw6Gu0ObTtnU+cgs28AKgDiy+Awpj5OACBAhZ/qh2HOo6i+NeA73jUAML4/qWux8mt6NjW1w599CS9xb0mSEqQBEDAtwqALUmBaG5FV3oYPnTHMjAwetlWksyByaukxQg2wQ9FlccaK/OXA3/uAEUDp3rNIDQ1ctSk6kHh1/jRFoaL4M4snEMeD73gQx4M4PsT1IZ5AfYH68tZY7zv/ApRMY9mnuVMvAAAAAElFTkSuQmCC",
        edit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB80lEQVR42o2T30tTURzArb8ioiAI6kHoZeF7CGE/IISCUDNCqAeL3rIWPfSwByskYUEJIhSChBhJFAiNqMVYPqRuc4tcW3NLt3C7u3d3d3c/+nS+0GRK0134cC6c8/ncc+7ltgFt6jqgcCg6duGQYq84deoBR6lU0iqVSq1arfI/1Dxut3u0Htke6BC5UChgmuYm+XyeXC5HOp1GIsnQNJHJi3x/7WJh/CSLT9r7Rd4jAVlgWRa2bSOjYBgGmqaRyWQwkq9Y8wyhLb0BI0VuaRrfo671xoDIwmakWCyi6zrr36bILt/HXp1l7cNDioEZqnEvgYmr1paAOgYy1u/l3NrqHNngPWpFL8XodTa+3CD8YoCvz/o078i5o1sC29FT78kG7lCzfJgrl7ESvejLThLPuxk8fbhP3KaBVFCdeX7on9yP9bOHfPAu0bEzmKkg4jQNpEKzhOduqW1/xIoNUEpcQlM7WXl6Cj39Q9Y0D4Q/TRJ662Tx3WOS/guYsV42Fm4THe/G/B2T97Jz4OVwJ+hxImPn8Tj381k91TfShfErIvLuAde1Y9g+N7Z/FL/rBDODR8gmgpTL5To7B3o69zF8pR3Pg7PMT90kn47LJ22kaeCPghapidP4Lxy3bduUiVZktdaQH7AxcFAiUm0Rhzji/gUhbp0s2Zf2xwAAAABJRU5ErkJggg==",
        info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAJ1SURBVHjafJJdSJNhFMd/z3QzLWdZrnQmSA2DPqRCK4KuhIq66kLoAy/qoqCguqqL6JsgLwoKKhCMSIy6CDKKRFZZYYQRVhJl02nWmG5uc19u7/vuPV0lW7QOnIsHnt+P8z/Pg4gw26aZ0263uzEUCn2IxWJjXq/3JqBETLIZ8gkePLhfKyKy/Z5HHJf7xe0Jic/n65mejizPK0inUiSTKUSE0dHRhxf6JoSDb4Rjr4QDz0REJBgMtmczFrJKKYVSCjCYnPR/W1FuAwQSGjbHXAA0LRXKZnIm0NJpgAKvd/hSOBz2iIj0eiPS2vtDYsmUPH/uPg9YshklIrOyCb+/eUG5ve3au5C99W2AqGbgKivk8R4X1lSkv2pJZaNmmBQVWWeZnAiGoa+3KovdyBjsW2kn/SvK4Jcgtaf7cDqrGkQMUDkBcgXVS2tOHjp8dG2jOXT1yo5lYOpgFTB0wKTAOqdQMlqOoDD7EE8kREwGXr/oWTg4HjxONAklBayuKSUeT/hFTxrwnwlAMa8I1qyrP3H95RiQgUiC/RsWM+wZ6jIME0M38wtSM0mmojM4nc6mzr5xKDQgnWb/pmoedT29EU3pTMUS+QVKKerq6kqnI3EVHwmAplO8qBh7WTFnzpz9bOg6FovlfxGEixfOrfT6YxCOQ1rDUaIAG4EJ38+PAwNb/95Bzj8ITAZwLHbMT0yHw3N33YVwEnQDqss41VzPkaalX6Iz+m6Xy/Xp34JAAICR7187nLWuvbe6h9C0DA2uRTTVV9J++87OlpaWJxUVFf9+xj+1cfOWls6OO93Nq1zblMVm9flG3pcvXNPm90+E/777ewB+UIqdqtYXHAAAAABJRU5ErkJggg==",
        //    bucket: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90BCg4hBcbCoOMAAABsSURBVDjLY2RgYFBjYGCIZCAPLGeBam4g0wAGJgYKARMDA8NZCvSfZYQy6sk0oJEFiUNqODRQLQxGDYCAb2To/YZswEsyDHiJbMAHMgz4gO6F5aTkQpgXYElZkoGBgZeEbL2cgYHhMwMDw3MA93ARk+mSg4gAAAAASUVORK5CYII=",
        bucket: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QkQDC8RTstxRAAAAGBJREFUOMtjYBgswIWBgeE/idiFgYGBgRFqwH8GBoYGEi1tYGBgYGRBE9QjUvMlGANmgCsDA8NuElzRANXDwAQV2ENGuO1BNoBsMGoAlQ3wJTIdNEDVYgU+ROQBH6rmQgAWgB19xco60wAAAABJRU5ErkJggg==",
        //    dir: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsSAAALEgHS3X78AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKNJREFUeNrEk7sNwkAQBefQ5m6BTiAAQssZiMh0QFUIMrAEpKYD8ynAJeD4nXQEkJHgu4CXv9GsdteFEEjJgMQ4gPli+aWx227cLwAD8FK8QZ4XTyCL6B6qal+YlzLgCpSn87HpbTCdzAKwAkpg1Bdgn/nbmDLQmby6hC3W5qUGGEcCGpNUJwBq09tgHdO+Pe61eamNvIMLgEkaxuoDuL9/42sAM20/EZafbV8AAAAASUVORK5CYII=",
        dir: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDNzU0RUNBNzU3OEIxMUUyOEM3QzkxOEZDOTU1RTdFMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDNzU0RUNBODU3OEIxMUUyOEM3QzkxOEZDOTU1RTdFMCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkM3NTRFQ0E1NTc4QjExRTI4QzdDOTE4RkM5NTVFN0UwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkM3NTRFQ0E2NTc4QjExRTI4QzdDOTE4RkM5NTVFN0UwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+S/WxbAAAAERJREFUeNpi/P//PwMlgJFSA1g2bNiAzYQLQOwIxB8IGcCEQ9wAiPcDsQBBF+CRAxnynlwXEA1GDRg1gCqZiWIDAAIMADidE0PBoGsZAAAAAElFTkSuQmCC",
        r: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90CDRIvNbHTpbwAAADjSURBVDjLpZFBbsIwEEUfVRZYahcVK3qKXoauMFK5C91nkyUB+xC5BqeAA7SKq1B5ugl2EiC04UkjayzN17NnROTRWvvJFbTWL8CBHqbGWOlSlqVkWSbGWAGm3aGHZiMiAByPP6FOd1rP2W7NvhvSCvDe10E+VJPFQpPnm1ZIcsmgPgJVVZGmaejX63y/XL4/AV/JJYPTCeDcN7PZWyuwKAqA8wARqSsGKDVGqXGjV8H07AnRQPq21TK8+YSBAQMN4hb6Df7wB/5eA+4zmEyehxk451itPrhFksSxUeP+lf+z+wXwdayJk/mqtgAAAABJRU5ErkJggg==",
        box: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMHAwRAVvTmTAAAAK/SURBVDjLpZM9bFxFGEXPNzPvZ+39sb2xHceREjDQBwlDCqqIiiotokAghYKEjvSkQkKJkEiB0lOkoAHaBAokFCQKUATIIOLIMbHWrHfX+7zvvZk3MzQODUgU3PJK5+g2F/5n5N/Kb66/1NNK3hAxr4HcFqVuvfju18V/Cu58sPmMVnJZ4K32Qr+t8za+KnCz4kCUuiGibm5euTv5h+CL958/nxj1XivVF+e6C9TVhPmFdbROgEhwNU1d4m09UaJuInLjhct3DgDUh5ee7j14PLxulLvYP/0seadPkub88Wib0eB3bDkmxgbRoFPpxeCuKvjsyQIzOyqImT7/y8Mh++NveW7jLFmrx6m1NlWxz6PHA7otQ7tloAmYJE9isOeeCJRtIrULLLUTjsqG7+//xs72z7jZgCTNONlVJKEiuobW0jqSaoiet19dFQATJcc2FSFEciNoLYwOHcPDASvdjM5cQntxlbR9gqacoFSK84VsnOrkH11Zdmp0FFXjobSeCFgXSDS0Eo11ge7yGXSaU092UUlCaEpC8FK4tDcu4rzZ2a/S+bWI94HSAgFigDQD24Cvp4gIOp0juBJvC2L07B1Uc/Mtg9k7sHMbywZrA3lLECV4AtaCpAp79CcmzXHlhOBrAJrGyNbOVBY7qTO1C9r5EKyPSttAiJEs01SuQStFkrdp6gKd5AzHjixVxCDxp+1paZRUxoc4Kp36bndYbS53U5WlCq0CMYIPMY7GI0mNpiqmGK0oK4jIveGkPgRqfTBt3A8Pqtvrq52HtglnGh9XIaKUkCQ6nj6RyWBsmdXCtFI/bu2Fq5c+3roGzIAgWokCDNACOhfOLb781Ip+vd+RC2dXWibROkxKvvp1z376yZe7d4HpMdz8/YVjiQYyoA30Ti6la2++0n/n83vTW/e3ix1gcgzXgPchBoC/AFu/UBF5InryAAAAAElFTkSuQmCC",
        bluebox: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMHAwTE5pcivoAAALsSURBVDjLXZPPaxxlGMc/77wz+3N2k822tWsTIrQFe/BWEKxKCV5UohdFhJ60p6rgUfpP6C0K4kHx0ENEkV7aElHwUikhFVosRGoTm83+3pnZnXfed2beHtItIQ98+Z6+H57nga8AsNYKDkYcEofcHvKZEEJYcSTszPzqL3fmf3+w/+a51tytby9d6D0N5UecGeBZ8MPv/jh9fy/6dKzMpVPHmvWdbl/XCvKn5Wbl6+ufrNwGssMgYa2VgFj58sZr7VB/LqX3zlKrydJzTTzXxdqcx90hO+0Bk2l8Z74i1z6+cOba5VfOqGeAb3579M/NR53T40xwrDGHFALPEUjn4LoMi0ktwWTKXqCIqAVrbyycvHj2hHYBR+bO8Q/Ov0imEzZ2xrRDRalQwC9LLBalUgaJQy+tU6gvIBJbv3j2RA4IFxDdICFa9ulMCrz/UgOs5kEwpeh57I4Nt/dzsmLOYlEThgFjUePp33IHoD9SJAbuTVyudRweixJvnVtg3/i00wpLPiwQ0hkO6YYKawWj0UjONqAfKHwDkxTqqeW/RHA3hO2+Zqk05e5wTD9KmOqMKDEUqoLNzU0PyF2AQaBoaIhiw0h6TIwgUDCODb5NiWJNlKREyhAozXwOW1tbFSmlcAHbD2KaytCdGgyWglfEs4LeNKeaa4axYRgpwlgTTTXVDDqdTslaewAYh4kNlKUbZsTGonOwCYwm1vq5Ft1AMYgU08SQR5o0gziOcRxHuoCNtdl6uPHX6/Vmi3Yyh9I5IoEgMdkgT9x+qJhEGrdQo77cJMuy+4DJskwLa60DOCtf3HhZpfZKtVx+L3x+sfCv8CFxTINd72HfodQ4aQp5fP24/v/Hd4Nf/5RSJmma6lkXZn1wPvvq5qndsbhS9esf/Zy/UEtzxnURfn8+/fuHV7m353mecV1XSym1lDI72kaxvr5e3N7eruyP0tpG/e3LK/rW2mLNUb7vm3K5nFarVdNqtbJer2dXV1fzJ6cDpboAZRAGAAAAAElFTkSuQmCC",
        refresh: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAK8AAACvABQqw0mAAAAAd0SU1FB90CFA8bKScXIjIAAAJ1SURBVDjLlVJdSJNRGH7es+/7NlduWFLTKAskwjJqZYiBglJhLKguqou6EFkFIkLQH9IPBFI3BsouzMJupGYRajcqmeBFhWBU5oUgpZikrSnzZ9v3nW/ndKEbziXUAwfOOe/7Puc9z/MCq1DwMmB1NX/rzfCNnsc/gK08lPgnnT8Cs33BULg0HI4YKdkHX9DqKwKArXXv1bTMTFcoyruC89E8MxaDw659t6rKhIUwRBLdP2t2v/5bBwQA+5pH8ibnIj3BucgWIQRASw8RERTGYFUtsGmWYUXKmqmr7t4UAnal54GQ8lq8MBlyOU0CEnA67MiwqfvHbhZ+Smgg6o9eV2L8Nhk6wI2lZeggrpvE+TTjxgxxQ4IbmJsJYSa00JQiotnguacJ8zIZOmDosAnzTpowt8tGj0s0ejZqprnDKmPHSNebjHDkUPatt4cTTbZ+LsmO79XK52dZxTNp9/ovAEDnaM62lo8HHrd9SVfiOelVryrSq9vrEx0s8sW2tuEzDgDgT875bcIsjy6owwAwHhjnYT5bGTL29PiHyuwAMO873aL/Ct5PiPjwXe5vq7KJW2hdJxENMFInGCkhIblLj80WRoyxGxZmh1XJGlSIlV8s6A8kuVDXn+MF6JHC7GBkBSNlOSRgiihMsQhAgJGGNNU1atc2HPG6O8YSBABwt2/nGyFlGSCSB4UIBMuyoQKMFNiUjIApRH5t8YfpFOOrO/JrhZBVUiJLxq2ipIkY8Z36uivpC6txqb3YbhqhIingFlLmxmLSKyXAGAaYqh13aFjfcHJwfE2ClSitK9psc85PMVC3M999orX4Kcf/wuPb27VW7A+O2QVVA1M1CQAAAABJRU5ErkJggg==",
        newitem: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAtxJREFUeNqM0llIVHEUBvDv3vlfZ8ac6zZtWpmamtliUUHRDlFJWlEYLdBLtG/QBlFJQUTSU089RZRlG4EvkS9NlqkpldHyYLk1OurcOzp30vHO/y6nBwsSIvzgvBw+fpyHA8MwwDmHbdsjQwSbCACkYDBYp6pqU3Fxcfyf/Z+eYRjQOQf+Bnw+30IiIsMwhizL4n3lV6mn7BzZtm1yzn8SETU0NKz+J2ARobe3t85/+SI1506j9hOHqTEO9FYEtR/ZTx/n5FDH6eOkquoni2g00NjUtEzTtBYioneLCulVHKg2yUkNmelUn5VOtUlueu0SqDE/m4iIIpFI64fm5vU65xAMIlicR9rOn/UEKytgmQbYuARAEDAqRLCiQxBFhtTNWzDzxk1LcjgkFhuKIhLR2qJKcN5Al/q7reF/cXUHoA0MtA9Gh4klJIxz6ro+PZiVC0uOw1jimJEDWZbTDhw8lCi0+/3PtUeV696ePIPUnIwxAf3fOjG/7AK8e/e9ZH2K0uWdPRdivANm3NguED1OJBYWQunvDwgAXIqifO54+CC7/tSxMQELL11B/r6D3cnJybniQDis25Ikfn1wD2GdQLIMISkF5JFhudwgjwySkyCkpILkRER0wpf7d2FJkqSoapQRRPCYjoLDR+EY70VXbS2YxCC4nAARbAAQBJBlwTIMZJRsQN7W7eA6t9O8XkE0jRhWLV2y+Gdm9q0dT6rMhLw8dPn7EAoEMBSLIcpjCPUEEPD3gU1Kw+6qZ6TPKrizq3TbAjUUIkFRVYAIkkfG99bWp4P1b7Z0vq5BXtFGPN6zE6Zuo7SiAh01PkycV4jJRRt96VOmrOHhMESHiBEAgMkNlGwqmXC78mG1DXtQdruTgx/eF5g6x9Tly1pCmtYjMSnxatnFTeXXyn8wxiCMAgxz5EmcTjCXCynxblf1C9910eFwrl254nh/dDhqcQ5zeBgAwBiDIAr4NQAWJarVjshqqgAAAABJRU5ErkJggg=="
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Composes an url with the given parameters.
 * resourceType: any of OpencgaManager.resourceTypes.
 * resourceId: id of the resource in catalog.
 * action: all actions are in OpencgaManager.actions, but some methods don't allow every action.
 * queryParams: Object with the query parameters.
 * args: Object with extra arguments, like the success callback function, or host override.
 *
 * examples of use:
 *
 * OpencgaManager.users.create({
 *      query:{
 *          userId: 'user1',
 *          name: 'User One',
 *          email: 'user@example.com',
 *          password: 'password_one'
 *      },
 *      request:{
 *          success:function(response){
 *              console.log(response);
 *          },
 *          error:function(){
 *              console.log('Server error');
 *          }
 *      }
 * });
 *
 * OpencgaManager.users.login({
 *      id:'user1',
 *      query:{
 *          password: 'password_one'
 *      },
 *      request:{
 *          success:function(response){
 *              console.log(response);
 *          },
 *          error:function(){
 *              console.log('Server error');
 *          }
 *      }
 * });
 *
 * OpencgaManager.users.info({
 *      id:'user1',
 *      query:{
 *          sid: Cookies('bioinfo_sid'),
 *          lastActivity: 'lastActivity'
 *      },
 *      request:{
 *          success:function(response){
 *              console.log(response);
 *          },
 *          error:function(){
 *              console.log('Server error');
 *          }
 *      }
 * });
 *
 *    http://cafetal:8080/opencga/rest/files/3/fetch?region=20:100-200&sid=nsrblm
 *    http://cafetal:8080/opencga/rest/files/17/fetch?sid=eUZtTdnA9EU89vjACyAe&region=20%3A80000-82000&view_as_pairs=false&include_coverage=true&process_differences=false
 *    http://cafetal:8080/opencga/rest/files/17/fetch?sid=eUZtTdnA9EU89vjACyAe&region=20%3A80000-82000&view_as_pairs=false&include_coverage=true&process_differences=false
 */
var OpencgaManager = {
    host: (typeof window.OPENCGA_HOST === 'undefined') ? 'http://ws1.babelomics.org/opencga-0.7' : window.OPENCGA_HOST,
    version: (typeof window.OPENCGA_VERSION === 'undefined') ? 'v1' : window.OPENCGA_VERSION,

    users: {
        login: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'login');
        },
        logout: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'logout');
        },
        info: function(args){
          return OpencgaManager._doRequest(args, 'users', 'info');
        },
        read: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'info');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'update');
        },
        updateEmail: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'change-email');
        },
        updatePassword: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'change-password');
        },
        resetPassword: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'reset-password');
        },
        create: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'create');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'delete');
        }
    },

    projects: {
        list: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'all-projects');
        },
        read: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'info');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'update');
        },
        create: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'create');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'delete');
        },
        studies: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'studies');
        }
    },

    studies: {
        list: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'all-studies');
        },
        info: function(args){
          return OpencgaManager._doRequest(args, 'studies', 'info');
        },
        read: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'info');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'update');
        },
        create: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'create');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'delete');
        },
        analysis: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'analysis');
        },
        jobs: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'jobs');
        },
        samples: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'samples');
        },
        variants: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'variants');
        },
        files: function (args){
          return OpencgaManager._doRequest(args, 'studies', 'files');
        }
    },
    cohorts: {
        create: function (args) {
            return OpencgaManager._doRequest(args, 'cohorts', 'create');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'cohorts', 'update');
        }
    },

    files: {
        list: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'list');
        },
        fetch: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'fetch');
        },
        alignments: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'alignments');
        },
        variants: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'variants');
        },
        read: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'info');
        },
        info: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'info');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'delete');
        },
        index: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'index');
        },
        search: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'search');
        },
        filesByFolder: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'files');
        },
        content: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'content');
        },
        contentGrep: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'content-grep');
        },
        createFolder: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'create-folder');
        },
        setHeader: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'set-header');
        },
        contentExample: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'content-example');
        },
        downloadExample: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'download-example');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'update');
        },
        download: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'download');
        },
        upload: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'upload');
        },
        upload2: function (args) {
            /** Check if exists a file with the same name **/
            var query = {
                sid: Cookies('bioinfo_sid'),
                studyId: args.studyId,
            };
            // if (window.OPENCGA_OLD_URL_FORMAT != null && OPENCGA_OLD_URL_FORMAT === true) {
            //     var splitIndex = args.relativeFilePath.lastIndexOf("/") + 1;
            //     query.name = args.relativeFilePath.substring(splitIndex);
            //     query.directory = args.relativeFilePath.substring(0, splitIndex);
            // } else {
            // }
            query.path = args.relativeFilePath;
            OpencgaManager.files.search({
                query: query,
                request: {
                    success: function (response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            if (response.response[0].result.length == 0) {

                                /** No file found with the same name -> start upload **/
                                var url = OpencgaManager._url({
                                    query: {
                                        sid: args.sid
                                    },
                                    request: {}
                                }, 'files', 'upload');
                                args.url = url;
                                OpencgaManager._uploadFile(args);

                            } else {
                                args.error('File already exists', response.response[0].result);
                            }
                        } else {
                            args.error(response.response[0].errorMsg);
                        }
                    },
                    error: function () {
                        args.error('Server error, try again later.');
                    }
                }
            });
        }

    },
    jobs: {
        create: function (args) {
            return OpencgaManager._doRequest(args, 'jobs', 'create');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'jobs', 'delete');
        },
        info: function (args) {
            return OpencgaManager._doRequest(args, 'jobs', 'info');
        }
    },
    samples: {
        info: function (args) {
            return OpencgaManager._doRequest(args, 'samples', 'info');
        },
        search: function (args) {
            return OpencgaManager._doRequest(args, 'samples', 'search');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'samples', 'update');
        }
    },
    panels:{
      create: function (args) {
        return OpencgaManager._doRequest(args, 'panels', 'create');
      },
      info: function (args) {
        return OpencgaManager._doRequest(args, 'panels', 'info');
      }
    },
    util: {
        proxy: function (args) {
            return OpencgaManager._doRequest(args, 'util', 'proxy');
        }
    },
    tools: {
        search: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'search');
        },
        info: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'info');
        },
        help: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'help');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'update');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'delete');
        }
    },
    //analysis: {
    //    jobs: function (args) {
    //        return OpencgaManager._doRequest(args, 'analysis', 'jobs');
    //    },
    //    create: function (args) {
    //        return OpencgaManager._doRequest(args, 'analysis', 'create');
    //},
    _url: function (args, api, action) {
        var host = OpencgaManager.host;
        if (typeof args.request.host !== 'undefined' && args.request.host != null) {
            host = args.request.host;
        }
        var version = OpencgaManager.version;
        if (typeof args.request.version !== 'undefined' && args.request.version != null) {
            version = args.request.version;
        }
        var id = '';
        if (typeof args.id !== 'undefined' && args.id != null) {
            id = '/' + args.id;
        }

        var url = host + '/webservices/rest/' + version + '/' + api + id + '/' + action;
        // if (window.OPENCGA_OLD_URL_FORMAT != null && OPENCGA_OLD_URL_FORMAT === true) {
        //     if (action == 'jobs') {
        //         action = 'job'
        //     }
        //     if (api == 'jobs') {
        //         api = 'job'
        //     }
        //     url = host + '/rest/' + api + id + '/' + action;
        // }
        url = Utils.addQueryParamtersToUrl(args.query, url);
        return url;
    },

    _doRequest: function (args, api, action) {
        var url = OpencgaManager._url(args, api, action);
        if (args.request.url === true) {
            return url;
        } else {
            var method = 'GET';
            if (typeof args.request.method !== 'undefined' && args.request.method != null) {
                method = args.request.method;
            }
            var async = true;
            if (typeof args.request.async !== 'undefined' && args.request.async != null) {
                async = args.request.async;
            }

            if (window.OPENCGA_LOG != null && OPENCGA_LOG === true) {
                console.log(url);
            }
            var request = new XMLHttpRequest();
            request.onload = function () {
                var contentType = this.getResponseHeader('Content-Type');
                if (contentType === 'application/json') {
                    var json = JSON.parse(this.response);
                    if (json.error === '' || json.error == null) {
                        args.request.success(json, this);
                    } else {
                        if (window.OPENCGA_LOG != null && OPENCGA_LOG === true) {
                            console.log('! ----    OpencgaManager -------');
                            console.log(json.error);
                            console.log(json);
                            console.log('! ----    OpencgaManager -------');
                        }
                        args.request.error(json, this);
                    }
                } else {
                    args.request.success(this.response, this);
                }
            };
            request.onerror = function (e) {
                args.request.error({
                    error: 'Request error.',
                    errorEvent: e
                }, this);
            };
            request.open(method, url, async);
            request.send();
            return url;
        }
    },
    _uploadFile: function (args) {
        var url = args.url;
        var inputFile = args.inputFile;
        var fileName = args.fileName;
        var userId = args.userId;
        var studyId = args.studyId;
        var relativeFilePath = args.relativeFilePath;
        var fileFormat = args.fileFormat;
        var bioFormat = args.bioFormat;
        var description = args.description;
        var callbackProgress = args.callbackProgress;

        /**/
        var resume = true;
        var resumeInfo = {};
        var chunkMap = {};
        var chunkId = 0;
        var blob = inputFile;
        var BYTES_PER_CHUNK = 2 * 1024 * 1024;
        var SIZE = blob.size;
        var NUM_CHUNKS = Math.max(Math.ceil(SIZE / BYTES_PER_CHUNK), 1);
        var start;
        var end;

        var getResumeInfo = function (formData) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, false); //false = sync call
            xhr.send(formData);
            var response = JSON.parse(xhr.responseText);
            return response.response[0];
        };
        var checkChunk = function (id, size, resumeInfo) {
            if (typeof resumeInfo[id] === 'undefined') {
                return false;
            } else if (resumeInfo[id].size != size /*|| resumeInfo[id].hash != hash*/ ) {
                return false;
            }
            return true;
        };
        var processChunk = function (c) {
            var chunkBlob = blob.slice(c.start, c.end);

            if (checkChunk(c.id, chunkBlob.size, resumeInfo) == false) {
                var formData = new FormData();
                formData.append('chunk_content', chunkBlob);
                formData.append('chunk_id', c.id);
                formData.append('chunk_size', chunkBlob.size);
                /*formData.append('chunk_hash', hash);*/
                formData.append("filename", fileName);
                formData.append('userId', userId);
                formData.append('studyId', studyId);
                formData.append('relativeFilePath', relativeFilePath);
                /*formData.append('chunk_gzip', );*/
                if (c.last) {
                    formData.append("last_chunk", true);
                    formData.append("total_size", SIZE);
                    formData.append("fileFormat", fileFormat);
                    formData.append("bioFormat", bioFormat);
                    console.log(bioFormat);
                    formData.append("description", description);
                }
                uploadChunk(formData, c, function (chunkResponse) {
                    /* FIX--------- Remove this "FIX block" after the server fix */
                    /* Bioformat is modified on server due to BioformatDetector bug */
                    /* https://github.com/opencb/opencga/blob/develop/opencga-analysis/src/main/java/org/opencb/opencga/analysis/files/FileMetadataReader.java#L123 */
                    /* Remove this ASAP, Server bioformatDetector should be invoked if no bioformat is provided. */
                    OpencgaManager.__fix_fileBioformat(chunkResponse, bioFormat, function (f) {
                        callbackProgress(c, NUM_CHUNKS, f);
                    });
                    /* FIX-END----- Remove this "FIX block" after the server fix */

                    /* SAVE the next line!! Uncomment this line after the FIX!!! */
                    // callbackProgress(c, NUM_CHUNKS, chunkResponse);
                    if (!c.last) {
                        processChunk(chunkMap[(c.id + 1)]);
                    } else {

                    }
                });
            } else {
                callbackProgress(c, NUM_CHUNKS);
                if (!c.last) {
                    processChunk(chunkMap[(c.id + 1)]);
                } else {

                }
            }

        };
        var uploadChunk = function (formData, chunk, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, true);
            xhr.onload = function (e) {
                chunk.done = true;
                console.log("chunk done");
                callback(JSON.parse(xhr.responseText));
            };
            xhr.send(formData);
        };

        /**/
        /**/

        if (resume) {
            var resumeFormData = new FormData();
            resumeFormData.append('resume_upload', resume);
            resumeFormData.append('filename', fileName);
            resumeFormData.append('userId', userId);
            resumeFormData.append('studyId', studyId);
            resumeFormData.append('relativeFilePath', relativeFilePath);
            resumeInfo = getResumeInfo(resumeFormData);
        }

        start = 0;
        end = BYTES_PER_CHUNK;
        while (start < SIZE) {
            var last = false;
            if (chunkId == (NUM_CHUNKS - 1)) {
                last = true;
            }
            chunkMap[chunkId] = {
                id: chunkId,
                start: start,
                end: end,
                done: false,
                last: last
            };
            start = end;
            end = start + BYTES_PER_CHUNK;
            chunkId++;
        }
        processChunk(chunkMap[0]);

    },
    __fix_fileBioformat: function (chunkResponse, bioFormat, cb) {
        // THIS IS A TEMPORAL FIX, REMOVE THIS FUNCTION ASAP
        if (chunkResponse.response[0].result != null) {
            var file = chunkResponse.response[0].result[0];
            OpencgaManager.files.update({
                id: file.id,
                query: {
                    sid: Cookies('bioinfo_sid'),
                    bioformat: bioFormat
                },
                request: {
                    success: function (response) {
                        var f = response.response[0].result[0];
                        chunkResponse.response[0].result[0] = f;
                        cb(chunkResponse);
                    },
                    error: function (response) {}
                }
            });
        } else {
            cb(chunkResponse);
        }
    }
};

/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
// resourceTypes: {
//     USERS: "users",
//     PROJECTS: "projects",
//     STUDIES: "studies",
//     FILES: "files",
//     ANALYSES: "analyses",
//     JOBS: "jobs"
// },
// actions: {
//     LOGIN: "login",
//     LOGOUT: "logout",
//     CREATE: "create",
//     UPLOAD: "upload",
//     INFO: "info",
//     LIST: "list",
//     FETCH: "fetch",
//     UPDATE: "update",
//     DELETE: "delete"
// },
// httpMethods: {}, // defined after OpencgaManager
//
// /**
//  * @param queryParams required: password, sid (sessionId)
//  * @return sid (sessionId)
//  */
// login: function(userId, queryParams, args) {
//     this._call(this.resourceTypes.USERS, userId, this.actions.LOGIN, queryParams, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// logout: function(userId, queryParams, args) {
//     this._call(this.resourceTypes.USERS, "", this.actions.LOGOUT, queryParams, args);
// },
// /**
//  * @param queryParams required: {resource}Id, password, sid (sessionId)
//  */
// create: function(resourceType, queryParams, args) {
//     this._call(resourceType, "", this.actions.CREATE, queryParam, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// upload: function(resourceType, queryParams, args) {
//     this._call(resourceType, "", this.actions.UPLOAD, queryParams, args);
// },
// /**
//  * @param action restricted to OpencgaManager.actions.INFO, OpencgaManager.actions.FETCH
//  * @param queryParams required: sid (sessionId)
//  */
// get: function(resourceType, resourceId, action, queryParams, args) {
//     //        resourceId = "7";
//     _.extend(queryParams, {
//         sid: "RNk4P0ttFGHyqLA3YGS8",
//         view_as_pairs: 'false',
//         include_coverage: 'true',
//         process_differences: 'false'
//     });
//     this._call(resourceType, resourceId, action, queryParams, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// list: function(resourceType, queryParams, args) {
//     this._call(resourceType, "", this.actions.LIST, queryParams, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// update: function(resourceType, resourceId, queryParams, args) {
//     this._call(resourceType, resourceId, this.actions.UPDATE, queryParams, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// delete: function(resourceType, resourceId, queryParams, args) {
//     this._call(resourceType, resourceId, this.actions.DELETE, queryParams, args);
// },
//
// _call: function(resourceType, resourceId, action, queryParams, args) {
//     var url = this._url(resourceType, resourceId, action, queryParams, args);
//
//     if (typeof url === 'undefined' || url == null) {
//         return;
//     }
//     console.log(url);
//     var async = (_.isUndefined(args.async) || _.isNull(args.async)) ? true: args.async;
//     var success = args.success;
//     var error = args.error;
//
//     var d;
//     $.ajax({
//         type: OpencgaManager.httpMethods[resourceType],
//         url: url,
//         dataType: 'json', //still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//         async: async,
//         success: function(data, textStatus, jqXHR) {
//             if ($.isPlainObject(data) || $.isArray(data)) {
//                 //                    data.params = args.params;
//                 //                    data.resource = args.resource;
//                 //                    data.category = args.category;
//                 //                    data.subCategory = args.subCategory;
//                 if (_.isFunction(success)) {
//                     success(data);
//                 }
//                 d = data;
//             } else {
//                 console.log('Cellbase returned a non json object or list, please check the url.');
//                 console.log(url);
//                 console.log(data)
//             }
//         },
//         error: function(jqXHR, textStatus, errorThrown) {
//             console.log("CellBaseManager: Ajax call returned : " + errorThrown + '\t' + textStatus + '\t' + jqXHR.statusText + " END");
//             if (_.isFunction(error)) {
//                 error(jqXHR, textStatus, errorThrown);
//             }
//         }
//     });
//     return url;
// },
//
// _url2: function(resourceType, resourceId, action, queryParams, args) {
//     if (resourceId == undefined || resourceId == null) {
//         resourceId = "";
//     } else {
//         resourceId = resourceId + "/";
//     }
//     var host = this.host;
//     if (typeof args.host !== 'undefined' && args.host != null) {
//         host = args.host;
//     }
//     var opencga = this.opencga;
//     if (typeof args.opencga !== 'undefined' && args.opencga != null) {
//         opencga = args.opencga;
//     }
//     /* still no version in the REST api
//      var version = this.version;
//      if(typeof args.version !== 'undefined' && args.version != null){
//      version = args.version
//      }
//      */
//     var url = host + opencga + resourceType + '/' + resourceId + action;
//     /*
//      _.extend(queryParams, {
//      sid: 'RNk4P0ttFGHyqLA3YGS8',
//      view_as_pairs: 'false',
//      include_coverage: 'true',
//      process_differences: 'false'
//      });*/
//
//     url = Utils.addQueryParamtersToUrl(queryParams, url);
//     return url;
// }

/*
 get: function (args) {
 var success = args.success;
 var error = args.error;
 var async = (_.isUndefined(args.async) || _.isNull(args.async) ) ? true : args.async;
 var urlConfig = _.omit(args, ['success', 'error', 'async']);

 var url = OpencgaManager.url(urlConfig);
 if(typeof url === 'undefined'){
 return;
 }
 console.log(url);

 var d;
 $.ajax({
 type: "GET",
 url: url,
 dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
 async: async,
 success: function (data, textStatus, jqXHR) {
 if($.isPlainObject(data) || $.isArray(data)){
 //                    data.params = args.params;
 //                    data.resource = args.resource;
 //                    data.category = args.category;
 //                    data.subCategory = args.subCategory;
 if (_.isFunction(success)) {
 success(data);
 }
 d = data;
 }else{
 console.log('Cellbase returned a non json object or list, please check the url.');
 console.log(url);
 console.log(data)
 }
 },
 error: function (jqXHR, textStatus, errorThrown) {
 console.log("CellBaseManager: Ajax call returned : " + errorThrown + '\t' + textStatus + '\t' + jqXHR.statusText + " END");
 if (_.isFunction(error)) error(jqXHR, textStatus, errorThrown);
 }
 });
 return d;
 },*/
//////// old version
//    host: (typeof OPENCGA_HOST === 'undefined') ? 'http://ws.bioinfo.cipf.es/opencga/rest' : OPENCGA_HOST,
//    getHost: function () {
//        return OpencgaManager.host;
//    },
//    setHost: function (hostUrl) {
//        OpencgaManager.host = hostUrl;
//    },
//    doGet: function (url, successCallback, errorCallback) {
//        $.ajax({
//            type: "GET",
//            url: url,
//            success: successCallback,
//            error: errorCallback
//        });
//    },
//    doPost: function (url, formData, successCallback, errorCallback) {
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: formData,
//            processData: false,  // tell jQuery not to process the data
//            contentType: false,  // tell jQuery not to set contentType
//            success: successCallback,
//            error: errorCallback
//        });
//    },
//    getQuery: function (paramsWS) {
//        var query = "";
//        for (var key in paramsWS) {
//            if (paramsWS[key] != null)
//                query += key + '=' + paramsWS[key] + '&';
//        }
//        if (query != '')
//            query = "?" + query.slice(0, -1);
//        return query;
//    },
//
//
//    getAccountUrl: function (accountId) {
//        return OpencgaManager.getHost() + '/account/' + accountId;
//    },
//    getStorageUrl: function (accountId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/storage';
//    },
//    getAdminProfileUrl: function (accountId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/admin/profile';
//    },
//    getAdminBucketUrl: function (accountId, bucketId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/admin/bucket/' + bucketId;
//    },
//    getAdminProjectUrl: function (accountId, projectId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/admin/project/' + projectId;
//    },
//    getBucketUrl: function (accountId, bucketId) {
//        return OpencgaManager.getStorageUrl(accountId) + '/' + bucketId;
//    },
//    getObjectUrl: function (accountId, bucketId, objectId) {
//        return OpencgaManager.getStorageUrl(accountId) + '/' + bucketId + '/' + objectId;
//    },
//    getAnalysisUrl: function (accountId, analysis) {
//        return OpencgaManager.getAccountUrl(accountId) + '/analysis/' + analysis;
//    },
//    getJobAnalysisUrl: function (accountId, jobId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/analysis/job/' + jobId;
//    },
//    getUtilsUrl: function () {
//        return OpencgaManager.getHost() + '/utils';
//    },
//    /*ACCOUNT METHODS*/
//    createAccount: function (args) {
////      accountId, email, name, password, suiteId
//        var queryParams = {
//            'name': args.name,
//            'email': args.email,
//            'password': args.password,
//            'suiteid': args.suiteId
//        };
//        var url = OpencgaManager.getAccountUrl(args.accountId) + '/create' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    login: function (args) {
////        accountId, password, suiteId
//        var queryParams = {
//            'password': args.password,
//            'suiteid': args.suiteId
//        };
//        var url = OpencgaManager.getAccountUrl(args.accountId) + '/login' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    logout: function (args) {
////        accountId, sessionId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAccountUrl(args.accountId) + '/logout' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    getAccountInfo: function (args) {
////        accountId, sessionId, lastActivity
////        console.log(args.lastActivity)
//        var queryParams = {
//            'last_activity': args.lastActivity,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAccountUrl(args.accountId) + '/info' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                if (data.response.errorMsg === '') {
//                    args.success(data.response.result[0]);
//                } else {
//                    $.cookie('bioinfo_sid', null);
//                    $.cookie('bioinfo_sid', null, {path: '/'});
//                    $.cookie('bioinfo_account', null);
//                    $.cookie('bioinfo_account', null, {path: '/'});
//                    console.log(data);
//                }
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    changePassword: function (args) {
////        accountId, sessionId, old_password, new_password1, new_password2
//        var queryParams = {
//            'old_password': args.old_password,
//            'new_password1': args.new_password1,
//            'new_password2': args.new_password2,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminProfileUrl(args.accountId) + '/change_password' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    resetPassword: function (args) {
////        accountId, email
//        var queryParams = {
//            'email': args.email
//        };
//        var url = OpencgaManager.getAdminProfileUrl(args.accountId) + '/reset_password' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    changeEmail: function (args) {
////        accountId, sessionId, new_email
//        var queryParams = {
//            'new_email': args.new_email,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminProfileUrl(args.accountId) + '/change_email' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    /* BUCKET METHODS */
//    getBuckets: function () {
//        return 'TODO';
//    },
//
//    createBucket: function (args) {
////        bucketId, description, accountId, sessionId
//        var queryParams = {
//            'description': args.description,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminBucketUrl(args.accountId, args.bucketId) + '/create' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    refreshBucket: function (args) {
////        accountId, bucketId, sessionId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminBucketUrl(args.accountId, args.bucketId) + '/refresh' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    renameBucket: function (args) {
////        accountId, bucketId, newBucketId, sessionId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminBucketUrl(args.accountId, args.bucketId) + '/rename/' + args.newBucketId + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    deleteBucket: 'TODO',
//    shareBucket: 'TODO',
//
//    uploadObjectToBucket: function (args) {
////        accountId, sessionId, bucketId, objectId, formData, parents
//        var queryParams = {
//            'parents': (args.parents || false),
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/upload' + OpencgaManager.getQuery(queryParams);
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: args.formData,
//            processData: false,  // tell jQuery not to process the data
//            contentType: false,  // tell jQuery not to set contentType
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    createDirectory: function (args) {
////        accountId, sessionId, bucketId, objectId, parents
//        args.objectId = args.objectId.replace(new RegExp("/", "gi"), ":");
//        var queryParams = {
//            'parents': (args.parents || false),
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/create_directory' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    deleteObjectFromBucket: function (args) {
////        accountId, sessionId, bucketId, objectId
//        args.objectId = args.objectId.replace(new RegExp("/", "gi"), ":");
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/delete' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    pollObject: function (args) {
////       accountId, sessionId, bucketId, objectId
//        var queryParams = {
//            'start': args.start,
//            'limit': args.limit,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/poll' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            async: args.async,
//            success: function (data, textStatus, jqXHR) {
//                args.success(data);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    grepObject: function (args) {
////       accountId, sessionId, bucketId, objectId
//        var queryParams = {
//            'pattern': encodeURIComponent(args.pattern),
//            'ignoreCase': args.ignoreCase,
//            'multi': args.multi,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/grep' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            async: args.async,
//            success: function (data, textStatus, jqXHR) {
//                args.success(data);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    region: function (args) {
////        accountId, sessionId, bucketId, objectId, region, queryParams
//        args.objectId = args.objectId.replace(new RegExp("/", "gi"), ":");
//        args.queryParams["sessionid"] = args.sessionId;
//        args.queryParams["region"] = args.region;
//        args.queryParams["cellbasehost"] = CELLBASE_HOST + '/' + CELLBASE_VERSION;
//
//        if (OpencgaManager.host.indexOf("localhost") != -1) {
//            args.queryParams["region"] = args.region;
//            args.queryParams["filepath"] = args.objectId;
//            var url = OpencgaManager.host + '/storage/fetch' + OpencgaManager.getQuery(args.queryParams);
//        } else {
//            var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/fetch' + OpencgaManager.getQuery(args.queryParams);
//        }
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
////                args.success(data.response);
//
////               TODO fix
//                if (!(data.substr(0, 5).indexOf('ERROR') != -1)) {
//                    var jsonData = JSON.parse(data);
//                    var r = {response: []};
//                    for (var i = 0; i < args.region.length; i++) {
//                        var result = jsonData[i];
//                        // TODO temporal fix
//                        r.response.push({
//                            id: args.region[i],
//                            result: jsonData[i]
//                        });
//                    }
//                    args.success(r);
////                args.success({resource: args.queryParams["category"], response: JSON.parse(data), filename: args.objectId, query: args.region, params: args.queryParams});
//                }
//
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//
//        function success(data) {
//
//        }
//    },
//
//    /* JOB METHODS */
//    jobResult: function (args) {
////        accountId, sessionId, jobId, format
//        //@Path("/{accountid}/{bucketname}/job/{jobid}/result.{format}")
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/result.js' + OpencgaManager.getQuery(queryParams);
//        //var url = OpencgaManager.getHost() + '/job/'+jobId+'/result.'+format+'?incvisites=true&sessionid='+sessionId;
//
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//
////        function success(data) {
////            args.success(data);
////        }
////
////        function error(data) {
////            if (_.isFunction(args.error)) args.error(data);
////        }
////
////        OpencgaManager.doGet(url, success, error);
////        console.log(url);
//    },
//    jobResultUrl: function (args) {
////        accountId, sessionId, jobId, format
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        return OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/result.js' + OpencgaManager.getQuery(queryParams);
//    },
//    jobStatus: function (args) {
////        accountId, sessionId, jobId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/status' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    table: function (args) {
////        accountId, sessionId, jobId, filename, colNames, colVisibility
//        var queryParams = {
//            'filename': args.filename,
//            'colNames': args.colNames,
//            'colVisibility': args.colVisibility,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/table' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    tableurl: function (args) {
////        accountId, sessionId, jobId, filename, colNames, colVisibility
//        var queryParams = {
//            'filename': args.filename,
//            'colNames': args.colNames,
//            'colVisibility': args.colVisibility,
//            'sessionid': args.sessionId
//        };
//        return OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/table' + OpencgaManager.getQuery(queryParams);
//    },
//
//    poll: function (args) {
////        accountId, sessionId, jobId, filename, zip
//        var queryParams = {
//            'filename': args.filename,
//            'sessionid': args.sessionId
//        };
//        var url;
//        if (args.zip == true) {
//            url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/poll' + OpencgaManager.getQuery(queryParams);
//            open(url);
//        } else {
//            queryParams['zip'] = false;
//            url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/poll' + OpencgaManager.getQuery(queryParams);
//
//            $.ajax({
//                type: "GET",
//                url: url,
//                async: args.async,
//                success: function (data, textStatus, jqXHR) {
//                    args.success(data);
//                },
//                error: function (jqXHR, textStatus, errorThrown) {
//                    if (_.isFunction(args.error)) args.error(jqXHR);
//                }
//            });
//        }
//    },
//
//    jobFileGrep: function (args) {
////        accountId, sessionId, jobId, filename, zip
//        var queryParams = {
//            'pattern': encodeURIComponent(args.pattern),
//            'ignoreCase': args.ignoreCase,
//            'multi': args.multi,
//            'filename': args.filename,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/grep' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            async: args.async,
//            success: function (data, textStatus, jqXHR) {
//                args.success(data);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//
//    pollurl: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'filename': args.filename,
//            'sessionid': args.sessionId,
//            'zip': false
//        };
//        return OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/poll' + OpencgaManager.getQuery(queryParams);
//        //debugger
//    },
//
//    deleteJob: function (args) {
////        accountId, sessionId, jobId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/delete' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    downloadJob: function (args) {
////        accountId, sessionId, jobId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        open(OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/download' + OpencgaManager.getQuery(queryParams));
//    },
//
//    jobInfo: function (args) {
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/info' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    /* ANALYSIS */
//    runAnalysis: function (args) {
////        analysis, paramsWS
//        var accountId = args.paramsWS.accountid;
//        var queryParams = {
////            'projectId':'default'
//        };
//        var url = OpencgaManager.getAnalysisUrl(accountId, args.analysis) + '/run' + OpencgaManager.getQuery(queryParams);
//        console.log(url);
//
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: args.paramsWS,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    indexer: function (args) {
////        accountId, sessionId, bucketId, objectId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/index' + OpencgaManager.getQuery(queryParams);
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    indexerStatus: function (args) {
////        accountId, sessionId, bucketId, objectId, indexerId
//        var queryParams = {
//            'sessionid': args.sessionId,
//            'indexerid': args.indexerId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/index_status' + OpencgaManager.getQuery(queryParams);
//        console.log(url);
//
//        function success(data) {
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        OpencgaManager.doGet(url, success, error);
//    },
//
//    localFileList: function (args) {
//
//        var url = OpencgaManager.host + '/getdirs';
//        console.log(url);
//
//        function success(data) {
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        OpencgaManager.doGet(url, success, error);
//    },
//
//
//    /********/
//    /********/
//    /********/
//    /********/
//    /********/
//    // variation
//    variantsUrl: function (args) {
////        accountId, jobId
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variantsMongo'
//        return url
//    },
//    variantInfoMongo: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'sessionid': args.sessionId
////            'filename': args.filename
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variantInfoMongo' + OpencgaManager.getQuery(queryParams);
//
//        function success(data) {
//            console.log(data);
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            async: args.async,
//            success: success,
//            error: error
//        });
//        //	console.log(url);
//    },
//
//
//    variant_effects: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'sessionid': args.sessionId,
//            'filename': args.filename
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variant_effects' + OpencgaManager.getQuery(queryParams);
//
//        function success(data) {
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: args.formData,
//            dataType: 'json',
//            success: success,
//            error: error
//        });
//
////        OpencgaManager.doPost(url, args.formData ,success, error);
//        //	console.log(url);
//    },
//    variantInfo: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'sessionid': args.sessionId,
//            'filename': args.filename
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variant_info' + OpencgaManager.getQuery(queryParams);
//
//        function success(data) {
//            console.log(data);
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        OpencgaManager.doGet(url, success, error);
//        //	console.log(url);
//    },
//    variantStats: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'sessionid': args.sessionId,
//            'filename': args.fileName
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variant_stats' + OpencgaManager.getQuery(queryParams);
//
//        function success(data) {
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: args.formData,
//            dataType: 'json',
//            success: success,
//            error: error
//        });
//
////        OpencgaManager.doPost(url, args.formData ,success, error);
//        //	console.log(url);
//    }
// };

// OpencgaManager.httpMethods[OpencgaManager.actions.LOGIN] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.LOGOUT] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.CREATE] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.UPLOAD] = "POST";
// OpencgaManager.httpMethods[OpencgaManager.actions.INFO] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.LIST] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.FETCH] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.UPDATE] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.DELETE] = "GET";
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

var CellBaseManager = {
    host: (typeof window.CELLBASE_HOST === 'undefined') ? 'http://bioinfo.hpc.cam.ac.uk/cellbase' : window.CELLBASE_HOST,
    version: (typeof window.CELLBASE_VERSION === 'undefined') ? 'v3' : window.CELLBASE_VERSION,
    get: function(args) {
        var success = args.success;
        var error = args.error;
        var async = (args.async == false) ? false: true;

        // remove XMLHttpRequest keys
        var ignoreKeys = ['success', 'error', 'async'];
        var urlConfig = {};
        for (var prop in args) {
            if (hasOwnProperty.call(args, prop) && args[prop] != null && ignoreKeys.indexOf(prop) == -1) {
                urlConfig[prop] = args[prop];
            }
        }

        var url = CellBaseManager.url(urlConfig);
        if (typeof url === 'undefined') {
            return;
        }

        if (window.CELLBASE_LOG != null && CELLBASE_LOG === true) {
            console.log(url);
        }

        var d;
        var request = new XMLHttpRequest();
        request.onload = function() {
            var contentType = this.getResponseHeader('Content-Type');
            if (contentType === 'application/json') {
                var parsedResponse = JSON.parse(this.response);
                if (typeof success === "function") success(parsedResponse);
                d = parsedResponse;
            } else {
                console.log('Cellbase returned a non json object or list, please check the url.');
                console.log(url);
                console.log(this.response)
            }
        };
        request.onerror = function() {
            console.log("CellBaseManager: Ajax call returned " + this.statusText);
            if (typeof error === "function") error(this);
        };
        request.open("GET", url, async);
        request.send();
        return d;

    },
    url: function(args) {
        if (args == null) {
            args = {};
        }
        if (args.params == null) {
            args.params = {};
        }

        var version = this.version;
        if (args.version != null) {
            version = args.version
        }

        var host = this.host;
        if (args.host != null) {
            host = args.host;
        }

        delete args.host;
        delete args.version;

        var config = {
            host: host,
            version: version
        };

        for (var prop in args) {
            if (hasOwnProperty.call(args, prop) && args[prop] != null) {
                config[prop] = args[prop];
            }
        }

        var query = '';
        if (config.query != null) {
            query = '/' + config.query.toString();
        }

        //species can be the species code(String) or an object with text attribute
        if (config.species && config.species.id != null) {
            if (config.species.assembly != null) {
                config.params["assembly"] = config.species.assembly.name;
            }
            // TODO Remove temporary fix
            if (config.subCategory === 'chromosome') {
                delete config.params["assembly"]
            }
            config.species = Utils.getSpeciesCode(config.species.scientificName);
        }

        var url;
        if (config.category === 'meta') {
            url = config.host + '/webservices/rest/' + config.version + '/' + config.category + '/' + config.subCategory;
        } else {
            url = config.host + '/webservices/rest/' + config.version + '/' + config.species + '/' + config.category + '/' + config.subCategory + query + '/' + config.resource;
        }


        url = Utils.addQueryParamtersToUrl(config.params, url);
        return url;
    }
};
</script>
<script>var SteviaManager = {
    host: (typeof window.STEVIA_SERVER_HOST === 'undefined') ? 'http://localhost:5555' : window.STEVIA_SERVER_HOST,
    version: (typeof window.STEVIA_SERVER_VERSION === 'undefined') ? 'v1' : window.STEVIA_SERVER_VERSION,

    users: {
        login: function (args) {
            return SteviaManager._doRequest(args, 'users', 'login');
        },
        logout: function (args) {
            return SteviaManager._doRequest(args, 'users', 'logout');
        },
        read: function (args) {
            return SteviaManager._doRequest(args, 'users', 'info');
        },
        update: function (args) {
            return SteviaManager._doRequest(args, 'users', 'update');
        },
        updateEmail: function (args) {
            return SteviaManager._doRequest(args, 'users', 'change-email');
        },
        updatePassword: function (args) {
            return SteviaManager._doRequest(args, 'users', 'change-password');
        },
        updateNotifications: function (args) {
            return SteviaManager._doRequest(args, 'users', 'change-notifications');
        },
        resetPassword: function (args) {
            return SteviaManager._doRequest(args, 'users', 'reset-password');
        },
        create: function (args) {
            return SteviaManager._doRequest(args, 'users', 'create');
        },
        delete: function (args) {
            return SteviaManager._doRequest(args, 'users', 'delete');
        },
        feedback: function (args) {
            return SteviaManager._doRequest(args, 'users', 'feedback');
        },
    },

    jobs: {
        create: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'create');
        },
        run: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'run');
        },
        delete: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'delete');
        },
        download: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'download');
        },
        info: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'info');
        },
        reportError: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'report-error');
        },
        example: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'example');
        }
    },
    util: {
        proxy: function (args) {
            return SteviaManager._doRequest(args, 'util', 'proxy');
        }
    },
    tools: {
        search: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'search');
        },
        info: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'info');
        },
        help: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'help');
        },
        update: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'update');
        },
        delete: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'delete');
        }
    },

    files: {
        list: function (args) {
            return SteviaManager._doRequest(args, 'files', 'list');
        },
        saveAttrFile: function (args) {
            return SteviaManager._doRequest(args, 'files', 'save-attr-file');
        },
        read: function (args) {
            return SteviaManager._doRequest(args, 'files', 'info');
        },
        info: function (args) {
            return SteviaManager._doRequest(args, 'files', 'info');
        },
        path: function (args) {
            return SteviaManager._doRequest(args, 'files', 'path');
        },
        delete: function (args) {
            return SteviaManager._doRequest(args, 'files', 'delete');
        },
        search: function (args) {
            return SteviaManager._doRequest(args, 'files', 'search');
        },
        filesByFolder: function (args) {
            return SteviaManager._doRequest(args, 'files', 'files');
        },
        content: function (args) {
            return SteviaManager._doRequest(args, 'files', 'content');
        },
        contentExample: function (args) {
            return SteviaManager._doRequest(args, 'files', 'content-example');
        },
        grep: function (args) {
            return SteviaManager._doRequest(args, 'files', 'grep');
        },
        createFolder: function (args) {
            return SteviaManager._doRequest(args, 'files', 'create-folder');
        },
        // setHeader: function (args) {
        //     return SteviaManager._doRequest(args, 'files', 'set-header');
        // },
        downloadExample: function (args) {
            return SteviaManager._doRequest(args, 'files', 'download-example');
        },
        addAttribute: function (args) {
            return SteviaManager._doRequest(args, 'files', 'add-attribute');
        },
        download: function (args) {
            return SteviaManager._doRequest(args, 'files', 'download');
        },
        move: function (args) {
            return SteviaManager._doRequest(args, 'files', 'move');
        },
        write: function (args) {
            return SteviaManager._doRequest(args, 'files', 'write');
        },
        upload: function (args) {
            var url = SteviaManager._url({
                query: {
                    name: args.name,
                    parentId: args.parentId
                },
                request: {}
            }, 'files', 'upload');
            args.url = url;
            SteviaManager._uploadFile(args);
        }
    },
    _url: function (args, api, action) {
        var host = SteviaManager.host;
        if (typeof args.request.host !== 'undefined' && args.request.host != null) {
            host = args.request.host;
        }
        var version = SteviaManager.version;
        if (typeof args.request.version !== 'undefined' && args.request.version != null) {
            version = args.request.version;
        }
        var id = '';
        if (typeof args.id !== 'undefined' && args.id != null) {
            id = '/' + args.id;
        }

        // var url = host + '/' + version + '/' + api + id + '/' + action;
        var url = host + '/' + api + id + '/' + action;
        url = this._addQueryParamtersToUrl(args.query, url);
        return url;
    },

    _doRequest: function (args, api, action) {
        var url = SteviaManager._url(args, api, action);
        if (args.request.url === true) {
            return url;
        } else {
            var method = 'GET';
            if (typeof args.request.method !== 'undefined' && args.request.method != null) {
                method = args.request.method;
            }
            var async = true;
            if (typeof args.request.async !== 'undefined' && args.request.async != null) {
                async = args.request.async;
            }
            var request = new XMLHttpRequest();
            request.onload = function () {
                var contentType = this.getResponseHeader('Content-Type');
                if (contentType.indexOf('application/json') != -1) {
                    var json = JSON.parse(this.response);
                    if (json.error == null) {
                        args.request.success(json, this);
                    } else {
                        if (window.STEVIA_MANAGER_LOG === true) {
                            console.log('! ----    SteviaManager -------');
                            console.log(json.error);
                            console.log(json);
                            console.log('! ----    SteviaManager -------');
                        }
                        args.request.error(json, this);
                    }
                } else {
                    args.request.success(this.response, this);
                }
            };
            request.onerror = function (e) {
                args.request.error({
                    error: 'Request error.',
                    errorEvent: e
                }, this);
            };
            request.open(method, url, async);
            if (args.request.headers != null) {
                for (var header in args.request.headers) {
                    request.setRequestHeader(header, args.request.headers[header]);
                }
            }

            var stv_app = (window.STV_APP != undefined) ? window.STV_APP : "-";
            request.setRequestHeader("x-stv-app", stv_app);

            var stv_user = (Cookies("bioinfo_user") != undefined) ? Cookies("bioinfo_user") : "-";
            request.setRequestHeader("x-stv-user", stv_user);

            request.setRequestHeader("x-stv-api", api);
            request.setRequestHeader("x-stv-action", action);

            if (args.sid == null) {
                args.sid = Cookies("bioinfo_sid");
            }
            if (args.sid != null) {
                request.setRequestHeader("Authorization", "sid " + args.sid);
                request.withCredentials = true;
            }
            var body = null;
            if (args.request.body != null) {
                body = args.request.body;
            }
            if (args.request.responseType != null) {
                request.responseType = args.request.responseType;
            }
            request.send(body);
            return url;
        }
    },
    _uploadFile: function (args) {
        var url = args.url;
        var blob = args.file;
        var name = args.name;
        var parentId = args.parentId;
        var userId = args.userId;
        var format = args.format;
        var bioFormat = args.bioFormat;
        var callbackProgress = args.callbackProgress;
        var callbackExists = args.callbackExists;

        /**/
        var resume = true;
        var resumeInfo = {};
        var chunkMap = {};
        var chunkId = 0;
        var BYTES_PER_CHUNK = 4 * 1024 * 1024;
        // var BYTES_PER_CHUNK = 10 * 1024 * 1024;
        var SIZE = blob.size;
        var NUM_CHUNKS = Math.max(Math.ceil(SIZE / BYTES_PER_CHUNK), 1);
        var start;
        var end;

        /**/
        var resumeResponse;
        /**/

        var getResumeInfo = function (formData, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, true); //false = sync call
            xhr.setRequestHeader("Authorization", "sid " + Cookies("bioinfo_sid"));
            xhr.withCredentials = true;
            xhr.onload = function (e) {
                console.log(xhr.responseText);
                callback(JSON.parse(xhr.responseText));
            };
            xhr.send(formData);
        };
        var uploadChunk = function (formData, chunk, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, true);
            xhr.setRequestHeader("Authorization", "sid " + Cookies("bioinfo_sid"));
            xhr.withCredentials = true;
            xhr.onload = function (e) {
                chunk.done = true;
                console.log('chunk ' + chunk.id + ' done');
                callback(JSON.parse(xhr.responseText));
            };
            xhr.send(formData);
        };
        var checkChunk = function (id, size) {
            if (typeof resumeInfo[id] === 'undefined') {
                return false;
            } else if (resumeInfo[id].size != size /*|| resumeInfo[id].hash != hash*/ ) {
                return false;
            }
            return true;
        };
        var processChunk = function (c) {
            var chunkBlob = blob.slice(c.start, c.end);

            console.log(c);
            if (checkChunk(c.id, chunkBlob.size) == false) {
                console.log('chunk ' + c.id + ' not uploaded');
                var formData = new FormData();
                formData.append('chunk_id', c.id);
                formData.append('chunk_size', chunkBlob.size);
                /*formData.append('chunk_hash', hash);*/
                formData.append("name", name);
                formData.append('userId', userId);
                formData.append('parentId', parentId);
                /*formData.append('chunk_gzip', );*/
                if (c.last) {
                    formData.append("last_chunk", true);
                    formData.append("total_size", SIZE);
                    formData.append("format", format);
                    formData.append("bioFormat", bioFormat);
                }
                formData.append('chunk_content', chunkBlob);

                uploadChunk(formData, c, function (chunkResponse) {
                    callbackProgress(c, NUM_CHUNKS, chunkResponse);
                    if (!c.last) {
                        processChunk(chunkMap[(c.id + 1)]);
                    } else {

                    }
                });
            } else {
                console.log('chunk ' + c.id + ' already uploaded');
                callbackProgress(c, NUM_CHUNKS, resumeResponse);
                if (!c.last) {
                    processChunk(chunkMap[(c.id + 1)]);
                } else {

                }
            }

        };

        /**/
        /**/

        start = 0;
        end = BYTES_PER_CHUNK;
        while (start < SIZE) {
            var last = false;
            if (chunkId == (NUM_CHUNKS - 1)) {
                last = true;
            }
            chunkMap[chunkId] = {
                id: chunkId,
                start: start,
                end: end,
                size: end - start,
                done: false,
                last: last
            };
            start = end;
            end = start + BYTES_PER_CHUNK;
            if (end > SIZE) {
                end = SIZE;
            }
            chunkId++;
        }
        if (resume) {
            var resumeFormData = new FormData();
            resumeFormData.append('resume_upload', resume);
            resumeFormData.append('chunk_map', JSON.stringify(chunkMap));
            resumeFormData.append('name', name);
            resumeFormData.append('userId', userId);
            resumeFormData.append('parentId', parentId);
            getResumeInfo(resumeFormData, function (response) {
                if (response.error == null) {
                    resumeInfo = response.resumeInfo;
                    resumeResponse = response;
                    if (response.exists) {
                        callbackExists(response.file);
                    } else {
                        setTimeout(function () {
                            processChunk(chunkMap[0]);
                        }, 50);
                    }
                } else {
                    console.log('Upload error: ' + response.error);
                }
            });
        }
    },
    _addQueryParamtersToUrl: function (paramsWS, url) {
        var chr = "?";
        if (url.indexOf("?") != -1) {
            chr = "&";
        }
        var query = this._queryString(paramsWS);
        if (query != "")
            query = chr + query;
        return url + query;
    },
    _queryString: function (obj) {
        var items = [];
        for (var key in obj) {
            if (obj[key] != null && obj[key] != undefined) {
                items.push(key + '=' + obj[key]);
            }
        }
        return items.join('&');
    },

    /*HELP METHODS*/
    getFileContent: function (fileId, cb) {
        SteviaManager.files.download({
            id: fileId,
            request: {
                async: true,
                success: function (response, req) {
                    cb(response, req);
                },
                error: function (response) {

                }
            }
        });
    },
    getFileExampleContent: function (fileName, tool, start, limit, cb) {
        SteviaManager.files.contentExample({
            query: {
                tool: tool,
                file: fileName,
                start: start,
                limit: limit
            },
            request: {
                async: true,
                success: function (response) {
                    cb(response);
                },
                error: function (response) {
                    cb(null);
                }
            }
        });

    },

    getFile: function (fileId, cb) {
        SteviaManager.files.info({
            id: fileId,
            request: {
                async: true,
                success: function (response) {
                    cb(response.response[0].results[0]);
                },
                error: function (response) {

                }
            }
        });
    },
    getJob: function (jobId, cb) {
        SteviaManager.jobs.info({
            id: jobId,
            request: {
                async: true,
                success: function (response) {
                    cb(response.response[0].results[0]);
                },
                error: function (response) {

                }
            }
        });
    },
    getFileByPath: function (path, cb) {
        SteviaManager.files.path({
            query: {
                path: path
            },
            request: {
                async: true,
                success: function (response) {
                    cb(response.response[0].results[0]);
                },
                error: function (response) {

                }
            }
        });
    },
    getPlainFolderFiles: function (fileId, cb) {
        SteviaManager.files.filesByFolder({
            id: fileId,
            request: {
                async: true,
                success: function (response) {
                    cb(response.response[0].results);
                },
                error: function (response) {

                }
            }
        });
    },
    updateFileAttributes: function (fileId, attributes, cb) {
        SteviaManager.files.addAttribute({
            id: fileId,
            request: {
                method: 'POST',
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(attributes),
                success: function (response) {
                    cb(response.response[0].results);
                },
                error: function (response) {

                }
            }
        });
    },
    updateUserNotifications: function (user, notifications, cb) {
        SteviaManager.users.updateNotifications({
            id: user,
            request: {
                method: 'POST',
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(notifications),
                success: function (response) {
                    cb(response.response[0].results[0]);
                },
                error: function (response) {

                }
            }
        });
    },
    getFileURL: function (fileId) {
        return SteviaManager.files.download({
            id: fileId,
            query: {
                sid: Cookies("bioinfo_sid")
            },
            request: {
                url: true
            }
        });
    },
    getExampleFileURL: function (tool, file) {
        return SteviaManager.files.downloadExample({
            query: {
                sid: Cookies("bioinfo_sid"),
                tool: tool,
                file: file
            },
            request: {
                url: true
            }
        });
    },

    //Download the file given a file Id.
    downloadFile: function (fileId, getContent) {
        var url = this.getFileURL(fileId);
        var link = document.createElement('a');
        link.href = url;
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        link.dispatchEvent(event);
    },

    downloadExampleFile: function (tool, filename) {
        var url = this.getExampleFileURL(tool, filename);
        var link = document.createElement('a');
        link.href = url;
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        link.dispatchEvent(event);
    },
};
</script>
<script>var BiodbManager = {
    // host: (typeof window.BioDB_HOST === 'undefined') ? 'http://localhost:5555' : window.BioDB_HOST,
    // version: (typeof window.BioDB_VERSION === 'undefined') ? 'v1' : window.BioDB_VERSION,
    host: 'http://test.babelomics.org/biodb/rest',
    version: 'v1',

    go: {
        info: function (args) {
            return BiodbManager._doRequest(args, 'go', 'info');
        },
        fetch: function (args) {
            return BiodbManager._doRequest(args, 'go', 'fetch');
        },
        genes: function (args) {
            return BiodbManager._doRequest(args, 'go', 'genes');
        }

    },
    hpo: {
        info: function (args) {
            return BiodbManager._doRequest(args, 'hpo', 'info');
        },
        fetch: function (args) {
            return BiodbManager._doRequest(args, 'hpo', 'fetch');
        },

    },
    clinical: {
      fetch: function(args){
        return BiodbManager._doRequest(args, 'clinical', 'fetch');
      }
    },
    tissue: {
      fetch: function(args){
        return BiodbManager._doRequest(args, 'tissue', 'fetch');
      }
    },
    _url: function (args, api, action) {
        var host = BiodbManager.host;
        if (typeof args.request.host !== 'undefined' && args.request.host != null) {
            host = args.request.host;
        }
        var version = BiodbManager.version;
        if (typeof args.request.version !== 'undefined' && args.request.version != null) {
            version = args.request.version;
        }
        var id = '';
        if (typeof args.id !== 'undefined' && args.id != null) {
            id = '/' + args.id;
        }

        // var url = host + '/' + version + '/' + api + id + '/' + action;
        var url = host + '/' + api + id + '/' + action;
        url = this._addQueryParamtersToUrl(args.query, url);
        return url;
    },

    _doRequest: function (args, api, action) {
        var url = BiodbManager._url(args, api, action);
        if (args.request.url === true) {
            return url;
        } else {
            var method = 'GET';
            if (typeof args.request.method !== 'undefined' && args.request.method != null) {
                method = args.request.method;
            }
            var async = true;
            if (typeof args.request.async !== 'undefined' && args.request.async != null) {
                async = args.request.async;
            }
            var request = new XMLHttpRequest();
            request.onload = function () {
                var contentType = this.getResponseHeader('Content-Type');
                if (contentType.indexOf('application/json') != -1) {
                    var json = JSON.parse(this.response);
                    if (json.error == null || json.error.msg == "") {
                        args.request.success(json, this);
                    } else {
                        // if (window.BIODB_LOG === true) {
                        console.log('! ----    BioDB -------');
                        console.log(json.error);
                        console.log(json);
                        console.log('! ----    BioDB -------');
                        // }
                        args.request.error(json, this);
                    }
                } else {
                    args.request.success(this.response, this);
                }
            };
            request.onerror = function (e) {
                args.request.error({
                    error: 'Request error.',
                    errorEvent: e
                }, this);
            };
            request.open(method, url, async);
            if (args.request.headers != null) {
                for (var header in args.request.headers) {
                    request.setRequestHeader(header, args.request.headers[header]);
                }
            }

            var body = null;
            if (args.request.body != null) {
                body = args.request.body;
            }
            if (args.request.responseType != null) {
                request.responseType = args.request.responseType;
            }
            request.send(body);
            return url;
        }
    },

    _addQueryParamtersToUrl: function (paramsWS, url) {
        var chr = "?";
        if (url.indexOf("?") != -1) {
            chr = "&";
        }
        var query = this._queryString(paramsWS);
        if (query != "")
            query = chr + query;
        return url + query;
    },
    _queryString: function (obj) {
        var items = [];
        for (var key in obj) {
            if (obj[key] != null && obj[key] != undefined) {
                items.push(key + '=' + obj[key]);
            }
        }
        return items.join('&');
    },
};
</script>












</head><body><div hidden="" by-vulcanize=""><script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());window.Polymer = {
Settings: function () {
var settings = window.Polymer || {};
if (!settings.noUrlSettings) {
var parts = location.search.slice(1).split('&');
for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
o = o.split('=');
o[0] && (settings[o[0]] = o[1] || true);
}
}
settings.wantShadow = settings.dom === 'shadow';
settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
settings.useShadow = settings.wantShadow && settings.hasShadow;
settings.hasNativeImports = Boolean('import' in document.createElement('link'));
settings.useNativeImports = settings.hasNativeImports;
settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
settings.hasNativeCSSProperties = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');
settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
return settings;
}()
};(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
var factory = desugar(prototype);
prototype = factory.prototype;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
document.registerElement(prototype.is, options);
return factory;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype.constructor;
};
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = desugar;
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript).ownerDocument;
}
});Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
for (var i = 0; i < this._callbacks.length; i++) {
this._callbacks[i]();
}
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
},
_afterNextRenderQueue: [],
_waitingNextRender: false,
afterNextRender: function (element, fn, args) {
this._watchNextRender();
this._afterNextRenderQueue.push([
element,
fn,
args
]);
},
hasRendered: function () {
return this._ready;
},
_watchNextRender: function () {
if (!this._waitingNextRender) {
this._waitingNextRender = true;
var fn = function () {
Polymer.RenderStatus._flushNextRender();
};
if (!this._ready) {
this.whenReady(fn);
} else {
requestAnimationFrame(fn);
}
}
},
_flushNextRender: function () {
var self = this;
setTimeout(function () {
self._flushRenderCallbacks(self._afterNextRenderQueue);
self._afterNextRenderQueue = [];
self._waitingNextRender = false;
});
},
_flushRenderCallbacks: function (callbacks) {
for (var i = 0, h; i < callbacks.length; i++) {
h = callbacks[i];
h[1].apply(h[0], h[2] || Polymer.nar);
}
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;(function () {
'use strict';
var settings = Polymer.Settings;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.extend(this, feature);
},
registerCallback: function () {
if (settings.lazyRegister === 'max') {
if (this.beforeRegister) {
this.beforeRegister();
}
} else {
this._desugarBehaviors();
this._doBehavior('beforeRegister');
}
this._registerFeatures();
if (!settings.lazyRegister) {
this.ensureRegisterFinished();
}
},
createdCallback: function () {
if (!this.__hasRegisterFinished) {
this._ensureRegisterFinished(this.__proto__);
}
Polymer.telemetry.instanceCount++;
this.root = this;
this._doBehavior('created');
this._initFeatures();
},
ensureRegisterFinished: function () {
this._ensureRegisterFinished(this);
},
_ensureRegisterFinished: function (proto) {
if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
if (settings.lazyRegister === 'max') {
proto._desugarBehaviors();
proto._doBehaviorOnly('beforeRegister');
}
proto.__hasRegisterFinished = proto.is;
if (proto._finishRegisterFeatures) {
proto._finishRegisterFeatures();
}
proto._doBehavior('registered');
if (settings.usePolyfillProto && proto !== this) {
proto.extend(this, proto);
}
}
},
attachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = true;
self._doBehavior('attached');
});
},
detachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = false;
self._doBehavior('detached');
});
},
attributeChangedCallback: function (name, oldValue, newValue) {
this._attributeChangedImpl(name);
this._doBehavior('attributeChanged', [
name,
oldValue,
newValue
]);
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (target, source) {
if (target && source) {
var n$ = Object.getOwnPropertyNames(source);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
this.copyOwnProperty(n, source, target);
}
}
return target || source;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_logger: function (level, args) {
if (args.length === 1 && Array.isArray(args[0])) {
args = args[0];
}
switch (level) {
case 'log':
case 'warn':
case 'error':
console[level].apply(console, args);
break;
}
},
_log: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('log', args);
},
_warn: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('warn', args);
},
_error: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('error', args);
},
_logf: function () {
return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
}());(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.extend(DomModule.prototype, {
constructor: DomModule,
createdCallback: function () {
this.register();
},
register: function (id) {
id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDomModulesUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDomModulesUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument || document;
var modules = doc.querySelectorAll('dom-module');
for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
if (m.__upgraded__) {
return;
} else {
CustomElements.upgrade(m);
}
}
}
}
}());Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
var behaviorSet = [];
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
var b = behaviors[i];
if (behaviorSet.indexOf(b) === -1) {
this._mixinBehavior(b);
behaviorSet.unshift(b);
}
}
return behaviorSet;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
for (var i = 0; i < behaviors.length; i++) {
var b = behaviors[i];
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}
return flat;
},
_mixinBehavior: function (b) {
var n$ = Object.getOwnPropertyNames(b);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
this.copyOwnProperty(n, b, this);
}
}
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_doBehavior: function (name, args) {
for (var i = 0; i < this.behaviors.length; i++) {
this._invokeBehavior(this.behaviors[i], name, args);
}
this._invokeBehavior(this, name, args);
},
_doBehaviorOnly: function (name, args) {
for (var i = 0; i < this.behaviors.length; i++) {
this._invokeBehavior(this.behaviors[i], name, args);
}
},
_invokeBehavior: function (b, name, args) {
var fn = b[name];
if (fn) {
fn.apply(this, args || Polymer.nar);
}
},
_marshalBehaviors: function () {
for (var i = 0; i < this.behaviors.length; i++) {
this._marshalBehavior(this.behaviors[i]);
}
this._marshalBehavior(this);
}
});
Polymer.Base._behaviorProperties = {
hostAttributes: true,
beforeRegister: true,
registered: true,
properties: true,
observers: true,
listeners: true,
created: true,
attached: true,
detached: true,
attributeChanged: true,
ready: true
};Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
var np = this.getNativePrototype(tag);
p = this.extend(Object.create(np), Polymer.Base);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
properties: {},
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
for (var i = 0; i < this.behaviors.length; i++) {
info = this._getPropertyInfo(property, this.behaviors[i].properties);
if (info) {
return info;
}
}
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
},
_prepPropertyInfo: function () {
this._propertyInfo = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
}
this._addPropertyInfo(this._propertyInfo, this.properties);
this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
},
_addPropertyInfo: function (target, source) {
if (source) {
var t, s;
for (var i in source) {
t = target[i];
s = source[i];
if (i[0] === '_' && !s.readOnly) {
continue;
}
if (!target[i]) {
target[i] = {
type: typeof s === 'function' ? s : s.type,
readOnly: s.readOnly,
attribute: Polymer.CaseMap.camelToDashCase(i)
};
} else {
if (!t.type) {
t.type = s.type;
}
if (!t.readOnly) {
t.readOnly = s.readOnly;
}
}
}
}
}
});Polymer.CaseMap = {
_caseMap: {},
_rx: {
dashToCamel: /-[a-z]/g,
camelToDash: /([A-Z])/g
},
dashToCamelCase: function (dash) {
return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel, function (m) {
return m[1].toUpperCase();
}));
},
camelToDashCase: function (camel) {
return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase());
}
};Polymer.Base._addFeature({
_addHostAttributes: function (attributes) {
if (!this._aggregatedAttributes) {
this._aggregatedAttributes = {};
}
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
if (this._aggregatedAttributes) {
this._applyAttributes(this, this._aggregatedAttributes);
}
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
var v = attr$[n];
this.serializeValueToAttribute(v, n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
if (this.hasAttributes()) {
for (var i in this._propertyInfo) {
var info = this._propertyInfo[i];
if (this.hasAttribute(info.attribute)) {
this._setAttributeToProperty(model, info.attribute, i, info);
}
}
}
},
_setAttributeToProperty: function (model, attribute, property, info) {
if (!this._serializing) {
property = property || Polymer.CaseMap.dashToCamelCase(attribute);
info = info || this._propertyInfo && this._propertyInfo[property];
if (info && !info.readOnly) {
var v = this.getAttribute(attribute);
model[property] = this.deserialize(v, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (property, attribute, value) {
this._serializing = true;
value = value === undefined ? this[property] : value;
this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
node = node || this;
if (str === undefined) {
node.removeAttribute(attribute);
} else {
node.setAttribute(attribute, str);
}
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value != null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value.toString();
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});Polymer.version = "1.7.0";Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._marshalBehaviors();
}
});</script>













<script>Polymer.Base._addFeature({
_prepTemplate: function () {
if (this._template === undefined) {
this._template = Polymer.DomModule.import(this.is, 'template');
}
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
HTMLTemplateElement.decorate(this._template);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_registerHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._clients = null;
this._clientsReadied = false;
},
_beginHosting: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_endHosting: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
this._readied = false;
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
if (this._template) {
this._setupRoot();
this._readyClients();
}
this._clientsReadied = true;
this._clients = null;
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
if (c$) {
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
}
this._finishDistribute();
},
_readySelf: function () {
this._doBehavior('ready');
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
}
});
}());Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (i = 1; i < rowCount; i++) {
for (j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();(function () {
'use strict';
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeAppendChild = Element.prototype.appendChild;
var nativeRemoveChild = Element.prototype.removeChild;
Polymer.TreeApi = {
arrayCopyChildNodes: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstChild; n; n = n.nextSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopyChildren: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopy: function (a$) {
var l = a$.length;
var copy = new Array(l);
for (var i = 0; i < l; i++) {
copy[i] = a$[i];
}
return copy;
}
};
Polymer.TreeApi.Logical = {
hasParentNode: function (node) {
return Boolean(node.__dom && node.__dom.parentNode);
},
hasChildNodes: function (node) {
return Boolean(node.__dom && node.__dom.childNodes !== undefined);
},
getChildNodes: function (node) {
return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
},
_getChildNodes: function (node) {
if (!node.__dom.childNodes) {
node.__dom.childNodes = [];
for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
node.__dom.childNodes.push(n);
}
}
return node.__dom.childNodes;
},
getParentNode: function (node) {
return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
},
getFirstChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
},
getLastChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
},
getNextSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
},
getPreviousSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
},
getFirstElementChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
},
_getFirstElementChild: function (node) {
var n = node.__dom.firstChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getLastElementChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
},
_getLastElementChild: function (node) {
var n = node.__dom.lastChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
getNextElementSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
},
_getNextElementSibling: function (node) {
var n = node.__dom.nextSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getPreviousElementSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
},
_getPreviousElementSibling: function (node) {
var n = node.__dom.previousSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
saveChildNodes: function (node) {
if (!this.hasChildNodes(node)) {
node.__dom = node.__dom || {};
node.__dom.firstChild = node.firstChild;
node.__dom.lastChild = node.lastChild;
node.__dom.childNodes = [];
for (var n = node.firstChild; n; n = n.nextSibling) {
n.__dom = n.__dom || {};
n.__dom.parentNode = node;
node.__dom.childNodes.push(n);
n.__dom.nextSibling = n.nextSibling;
n.__dom.previousSibling = n.previousSibling;
}
}
},
recordInsertBefore: function (node, container, ref_node) {
container.__dom.childNodes = null;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
for (var n = node.firstChild; n; n = n.nextSibling) {
this._linkNode(n, container, ref_node);
}
} else {
this._linkNode(node, container, ref_node);
}
},
_linkNode: function (node, container, ref_node) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (ref_node) {
ref_node.__dom = ref_node.__dom || {};
}
node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
if (node.__dom.previousSibling) {
node.__dom.previousSibling.__dom.nextSibling = node;
}
node.__dom.nextSibling = ref_node || null;
if (node.__dom.nextSibling) {
node.__dom.nextSibling.__dom.previousSibling = node;
}
node.__dom.parentNode = container;
if (ref_node) {
if (ref_node === container.__dom.firstChild) {
container.__dom.firstChild = node;
}
} else {
container.__dom.lastChild = node;
if (!container.__dom.firstChild) {
container.__dom.firstChild = node;
}
}
container.__dom.childNodes = null;
},
recordRemoveChild: function (node, container) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (node === container.__dom.firstChild) {
container.__dom.firstChild = node.__dom.nextSibling;
}
if (node === container.__dom.lastChild) {
container.__dom.lastChild = node.__dom.previousSibling;
}
var p = node.__dom.previousSibling;
var n = node.__dom.nextSibling;
if (p) {
p.__dom.nextSibling = n;
}
if (n) {
n.__dom.previousSibling = p;
}
node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
container.__dom.childNodes = null;
}
};
Polymer.TreeApi.Composed = {
getChildNodes: function (node) {
return Polymer.TreeApi.arrayCopyChildNodes(node);
},
getParentNode: function (node) {
return node.parentNode;
},
clearChildNodes: function (node) {
node.textContent = '';
},
insertBefore: function (parentNode, newChild, refChild) {
return nativeInsertBefore.call(parentNode, newChild, refChild || null);
},
appendChild: function (parentNode, newChild) {
return nativeAppendChild.call(parentNode, newChild);
},
removeChild: function (parentNode, node) {
return nativeRemoveChild.call(parentNode, node);
}
};
}());Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = function (node) {
this.node = needsToWrap ? DomApi.wrap(node) : node;
};
var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
DomApi.wrap = window.wrap ? window.wrap : function (node) {
return node;
};
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
deepContains: function (node) {
if (this.node.contains(node)) {
return true;
}
var n = node;
var doc = node.ownerDocument;
while (n && n !== doc && n !== this.node) {
n = Polymer.dom(n).parentNode || n.host;
}
return n === this.node;
},
queryDistributedElements: function (selector) {
var c$ = this.getEffectiveChildNodes();
var list = [];
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
list.push(c);
}
}
return list;
},
getEffectiveChildNodes: function () {
var list = [];
var c$ = this.childNodes;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
var d$ = dom(c).getDistributedNodes();
for (var j = 0; j < d$.length; j++) {
list.push(d$[j]);
}
} else {
list.push(c);
}
}
return list;
},
observeNodes: function (callback) {
if (callback) {
if (!this.observer) {
this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
}
return this.observer.addListener(callback);
}
},
unobserveNodes: function (handle) {
if (this.observer) {
this.observer.removeListener(handle);
}
},
notifyObserver: function () {
if (this.observer) {
this.observer.notify();
}
},
_query: function (matcher, node, halter) {
node = node || this.node;
var list = [];
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
return list;
},
_queryElements: function (elements, matcher, halter, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
if (this._queryElement(c, matcher, halter, list)) {
return true;
}
}
}
},
_queryElement: function (node, matcher, halter, list) {
var result = matcher(node);
if (result) {
list.push(node);
}
if (halter && halter(result)) {
return result;
}
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
}
};
var CONTENT = DomApi.CONTENT = 'content';
var dom = DomApi.factory = function (node) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi.ctor(node);
}
return node.__domApi;
};
DomApi.hasApi = function (node) {
return Boolean(node.__domApi);
};
DomApi.ctor = DomApi;
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return DomApi.factory(obj, patch);
}
};
var p = Element.prototype;
DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return DomApi;
}();(function () {
'use strict';
var Settings = Polymer.Settings;
var DomApi = Polymer.DomApi;
var dom = DomApi.factory;
var TreeApi = Polymer.TreeApi;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var CONTENT = DomApi.CONTENT;
if (Settings.useShadow) {
return;
}
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
Polymer.Base.extend(DomApi.prototype, {
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this.insertBefore(node);
},
insertBefore: function (node, ref_node) {
if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
if (DomApi.hasApi(parent)) {
dom(parent).notifyObserver();
}
this._removeNode(node);
} else {
this._removeOwnerShadyRoot(node);
}
}
if (!this._addNode(node, ref_node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (ref_node) {
TreeApi.Composed.insertBefore(container, node, ref_node);
} else {
TreeApi.Composed.appendChild(container, node);
}
}
this.notifyObserver();
return node;
},
_addNode: function (node, ref_node) {
var root = this.getOwnerRoot();
if (root) {
var ipAdded = this._maybeAddInsertionPoint(node, this.node);
if (!root._invalidInsertionPoints) {
root._invalidInsertionPoints = ipAdded;
}
this._addNodeToHost(root.host, node);
}
if (TreeApi.Logical.hasChildNodes(this.node)) {
TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
}
var handled = this._maybeDistribute(node) || this.node.shadyRoot;
if (handled) {
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
while (node.firstChild) {
TreeApi.Composed.removeChild(node, node.firstChild);
}
} else {
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
return handled;
},
removeChild: function (node) {
if (TreeApi.Logical.getParentNode(node) !== this.node) {
throw Error('The node to be removed is not a child of this node: ' + node);
}
if (!this._removeNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
var parent = TreeApi.Composed.getParentNode(node);
if (container === parent) {
TreeApi.Composed.removeChild(container, node);
}
}
this.notifyObserver();
return node;
},
_removeNode: function (node) {
var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
var distributed;
var root = this._ownerShadyRootForNode(node);
if (logicalParent) {
distributed = dom(node)._maybeDistributeParent();
TreeApi.Logical.recordRemoveChild(node, logicalParent);
if (root && this._removeDistributedChildren(root, node)) {
root._invalidInsertionPoints = true;
this._lazyDistribute(root.host);
}
}
this._removeOwnerShadyRoot(node);
if (root) {
this._removeNodeFromHost(root.host, node);
}
return distributed;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
var root = node._ownerShadyRoot;
if (root === undefined) {
if (node._isShadyRoot) {
root = node;
} else {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
if (root || document.documentElement.contains(node)) {
node._ownerShadyRoot = root;
}
}
return root;
},
_maybeDistribute: function (node) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this.getOwnerRoot();
if (root) {
this._lazyDistribute(root.host);
}
}
var needsDist = this._nodeNeedsDistribution(this.node);
if (needsDist) {
this._lazyDistribute(this.node);
}
return needsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = dom(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = TreeApi.Logical.getParentNode(n);
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
TreeApi.Logical.saveChildNodes(parent);
TreeApi.Logical.saveChildNodes(node);
added = true;
}
return added;
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
}
},
_nodeNeedsDistribution: function (node) {
return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
},
_addNodeToHost: function (host, node) {
if (host._elementAdd) {
host._elementAdd(node);
}
},
_removeNodeFromHost: function (host, node) {
if (host._elementRemove) {
host._elementRemove(node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = dom(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = TreeApi.Logical.getParentNode(node);
}
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = TreeApi.Logical.getChildNodes(node);
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = dom(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = dom(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
var result = this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node, function (n) {
return Boolean(n);
})[0];
return result || null;
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._maybeDistributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._maybeDistributeParent();
},
_maybeDistributeParent: function () {
if (this._nodeNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
return true;
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = TreeApi.Logical.getChildNodes(externalNode);
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
},
_getComposedInnerHTML: function () {
return getInnerHTML(this.node, true);
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var active = document.activeElement;
if (!active) {
return null;
}
var isShadyRoot = !!this.node._isShadyRoot;
if (this.node !== document) {
if (!isShadyRoot) {
return null;
}
if (this.node.host === active || !this.node.host.contains(active)) {
return null;
}
}
var activeRoot = dom(active).getOwnerRoot();
while (activeRoot && activeRoot !== this.node) {
active = activeRoot.host;
activeRoot = dom(active).getOwnerRoot();
}
if (this.node === document) {
return activeRoot ? null : active;
} else {
return activeRoot === this.node ? active : null;
}
},
configurable: true
},
childNodes: {
get: function () {
var c$ = TreeApi.Logical.getChildNodes(this.node);
return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
if (TreeApi.Logical.hasChildNodes(this.node)) {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
} else {
return TreeApi.arrayCopyChildren(this.node);
}
},
configurable: true
},
parentNode: {
get: function () {
return TreeApi.Logical.getParentNode(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return TreeApi.Logical.getFirstChild(this.node);
},
configurable: true
},
lastChild: {
get: function () {
return TreeApi.Logical.getLastChild(this.node);
},
configurable: true
},
nextSibling: {
get: function () {
return TreeApi.Logical.getNextSibling(this.node);
},
configurable: true
},
previousSibling: {
get: function () {
return TreeApi.Logical.getPreviousSibling(this.node);
},
configurable: true
},
firstElementChild: {
get: function () {
return TreeApi.Logical.getFirstElementChild(this.node);
},
configurable: true
},
lastElementChild: {
get: function () {
return TreeApi.Logical.getLastElementChild(this.node);
},
configurable: true
},
nextElementSibling: {
get: function () {
return TreeApi.Logical.getNextElementSibling(this.node);
},
configurable: true
},
previousElementSibling: {
get: function () {
return TreeApi.Logical.getPreviousElementSibling(this.node);
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = TreeApi.arrayCopyChildNodes(d);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.hasInsertionPoint = function (root) {
return Boolean(root && root._insertionPoints.length);
};
}());(function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = Polymer.DomApi;
if (!Settings.useShadow) {
return;
}
Polymer.Base.extend(DomApi.prototype, {
querySelectorAll: function (selector) {
return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
},
getOwnerRoot: function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
},
getDestinationInsertionPoints: function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? TreeApi.arrayCopy(n$) : [];
},
getDistributedNodes: function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? TreeApi.arrayCopy(n$) : [];
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var node = DomApi.wrap(this.node);
var activeElement = node.activeElement;
return node.contains(activeElement) ? activeElement : null;
},
configurable: true
},
childNodes: {
get: function () {
return TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
return TreeApi.arrayCopyChildren(this.node);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardMethods = function (m$) {
for (var i = 0; i < m$.length; i++) {
forwardMethod(m$[i]);
}
};
var forwardMethod = function (method) {
DomApi.prototype[method] = function () {
return this.node[method].apply(this.node, arguments);
};
};
forwardMethods([
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild',
'setAttribute',
'removeAttribute',
'querySelector'
]);
var forwardProperties = function (f$) {
for (var i = 0; i < f$.length; i++) {
forwardProperty(f$[i]);
}
};
var forwardProperty = function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
};
forwardProperties([
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
]);
}());Polymer.Base.extend(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_staticFlushList: [],
_finishDebouncer: null,
flush: function () {
this._flushGuard = 0;
this._prepareFlush();
while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
while (this._debouncers.length) {
this._debouncers.shift().complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._prepareFlush();
this._flushGuard++;
}
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
},
_prepareFlush: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
for (var i = 0; i < this._staticFlushList.length; i++) {
this._staticFlushList[i]();
}
},
addStaticFlush: function (fn) {
this._staticFlushList.push(fn);
},
removeStaticFlush: function (fn) {
var i = this._staticFlushList.indexOf(fn);
if (i >= 0) {
this._staticFlushList.splice(i, 1);
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});Polymer.EventApi = function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.Event = function (event) {
this.event = event;
};
if (Settings.useShadow) {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
var path = this.event.path;
if (!Array.isArray(path)) {
path = Array.prototype.slice.call(path);
}
return path;
}
};
} else {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var current = this.rootTarget;
while (current) {
path.push(current);
var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
if (insertionPoints.length) {
for (var i = 0; i < insertionPoints.length - 1; i++) {
path.push(insertionPoints[i]);
}
current = insertionPoints[insertionPoints.length - 1];
} else {
current = Polymer.dom(current).parentNode || current.host;
}
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new DomApi.Event(event);
}
return event.__eventApi;
};
return { factory: factory };
}();(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var useShadow = Polymer.Settings.useShadow;
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this._distributeParent();
},
_distributeParent: function () {
if (!useShadow) {
this.domApi._maybeDistributeParent();
}
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.EffectiveNodesObserver = function (domApi) {
this.domApi = domApi;
this.node = this.domApi.node;
this._listeners = [];
};
DomApi.EffectiveNodesObserver.prototype = {
addListener: function (callback) {
if (!this._isSetup) {
this._setup();
this._isSetup = true;
}
var listener = {
fn: callback,
_nodes: []
};
this._listeners.push(listener);
this._scheduleNotify();
return listener;
},
removeListener: function (handle) {
var i = this._listeners.indexOf(handle);
if (i >= 0) {
this._listeners.splice(i, 1);
handle._nodes = [];
}
if (!this._hasListeners()) {
this._cleanup();
this._isSetup = false;
}
},
_setup: function () {
this._observeContentElements(this.domApi.childNodes);
},
_cleanup: function () {
this._unobserveContentElements(this.domApi.childNodes);
},
_hasListeners: function () {
return Boolean(this._listeners.length);
},
_scheduleNotify: function () {
if (this._debouncer) {
this._debouncer.stop();
}
this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
this._debouncer.context = this;
Polymer.dom.addDebouncer(this._debouncer);
},
notify: function () {
if (this._hasListeners()) {
this._scheduleNotify();
}
},
_notify: function () {
this._beforeCallListeners();
this._callListeners();
},
_beforeCallListeners: function () {
this._updateContentElements();
},
_updateContentElements: function () {
this._observeContentElements(this.domApi.childNodes);
},
_observeContentElements: function (elements) {
for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
if (!n.__observeNodesMap.has(this)) {
n.__observeNodesMap.set(this, this._observeContent(n));
}
}
}
},
_observeContent: function (content) {
var self = this;
var h = Polymer.dom(content).observeNodes(function () {
self._scheduleNotify();
});
h._avoidChangeCalculation = true;
return h;
},
_unobserveContentElements: function (elements) {
for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
h = n.__observeNodesMap.get(this);
if (h) {
Polymer.dom(n).unobserveNodes(h);
n.__observeNodesMap.delete(this);
}
}
}
},
_isContent: function (node) {
return node.localName === 'content';
},
_callListeners: function () {
var o$ = this._listeners;
var nodes = this._getEffectiveNodes();
for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
var info = this._generateListenerInfo(o, nodes);
if (info || o._alwaysNotify) {
this._callListener(o, info);
}
}
},
_getEffectiveNodes: function () {
return this.domApi.getEffectiveChildNodes();
},
_generateListenerInfo: function (listener, newNodes) {
if (listener._avoidChangeCalculation) {
return true;
}
var oldNodes = listener._nodes;
var info = {
target: this.node,
addedNodes: [],
removedNodes: []
};
var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
info.removedNodes.push(n);
}
}
for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (j = s.index; j < s.index + s.addedCount; j++) {
info.addedNodes.push(newNodes[j]);
}
}
listener._nodes = newNodes;
if (info.addedNodes.length || info.removedNodes.length) {
return info;
}
},
_callListener: function (listener, info) {
return listener.fn.call(this.node, info);
},
enableShadowAttributeTracking: function () {
}
};
if (Settings.useShadow) {
var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
Polymer.Base.extend(DomApi.EffectiveNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var self = this;
this._mutationHandler = function (mxns) {
if (mxns && mxns.length) {
self._scheduleNotify();
}
};
this._observer = new MutationObserver(this._mutationHandler);
this._boundFlush = function () {
self._flush();
};
Polymer.dom.addStaticFlush(this._boundFlush);
this._observer.observe(this.node, { childList: true });
}
baseSetup.call(this);
},
_cleanup: function () {
this._observer.disconnect();
this._observer = null;
this._mutationHandler = null;
Polymer.dom.removeStaticFlush(this._boundFlush);
baseCleanup.call(this);
},
_flush: function () {
if (this._observer) {
this._mutationHandler(this._observer.takeRecords());
}
},
enableShadowAttributeTracking: function () {
if (this._observer) {
this._makeContentListenersAlwaysNotify();
this._observer.disconnect();
this._observer.observe(this.node, {
childList: true,
attributes: true,
subtree: true
});
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host && Polymer.dom(host).observer) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
},
_makeContentListenersAlwaysNotify: function () {
for (var i = 0, h; i < this._listeners.length; i++) {
h = this._listeners[i];
h._alwaysNotify = h._isContentListener;
}
}
});
}
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.DistributedNodesObserver = function (domApi) {
DomApi.EffectiveNodesObserver.call(this, domApi);
};
DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
},
_cleanup: function () {
},
_beforeCallListeners: function () {
},
_getEffectiveNodes: function () {
return this.domApi.getDistributedNodes();
}
});
if (Settings.useShadow) {
Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
var self = this;
this._observer = Polymer.dom(host).observeNodes(function () {
self._scheduleNotify();
});
this._observer._isContentListener = true;
if (this._hasAttrSelect()) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
}
},
_hasAttrSelect: function () {
var select = this.node.getAttribute('select');
return select && select.match(/[[.]+/);
},
_cleanup: function () {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
Polymer.dom(host).unobserveNodes(this._observer);
}
this._observer = null;
}
});
}
}());(function () {
var DomApi = Polymer.DomApi;
var TreeApi = Polymer.TreeApi;
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_setupShady: function () {
this.shadyRoot = null;
if (!this.__domApi) {
this.__domApi = null;
}
if (!this.__dom) {
this.__dom = null;
}
if (!this._ownerShadyRoot) {
this._ownerShadyRoot = undefined;
}
},
_poolContent: function () {
if (this._useContent) {
TreeApi.Logical.saveChildNodes(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._hasDistributed = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
TreeApi.Logical.saveChildNodes(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(c.parentNode);
}
this.shadyRoot.host = this;
},
get domHost() {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
var host = getTopDistributingHost(this);
Polymer.dom(this)._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
if (this.shadyRoot._invalidInsertionPoints) {
Polymer.dom(this)._updateInsertionPoints(this);
this.shadyRoot._invalidInsertionPoints = false;
}
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (DomApi.hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
notifyContentObservers(this.shadyRoot);
} else {
if (!this.shadyRoot._hasDistributed) {
TreeApi.Composed.clearChildNodes(this);
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
if (!this.shadyRoot._hasDistributed) {
notifyInitialDistribution(this);
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return DomApi.matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = TreeApi.Logical.getChildNodes(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = TreeApi.Logical.getParentNode(p);
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = TreeApi.Composed.getChildNodes(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (TreeApi.Composed.getParentNode(n) === container) {
TreeApi.Composed.removeChild(container, n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
TreeApi.Composed.insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = TreeApi.Logical.getParentNode(content);
if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = TreeApi.Logical.getChildNodes(host);
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName && c.localName === 'content') {
return host.domHost;
}
}
}
function notifyContentObservers(root) {
for (var i = 0, c; i < root._insertionPoints.length; i++) {
c = root._insertionPoints[i];
if (DomApi.hasApi(c)) {
Polymer.dom(c).notifyObserver();
}
}
}
function notifyInitialDistribution(host) {
if (DomApi.hasApi(host)) {
Polymer.dom(host).notifyObserver();
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLogicalChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new window.MutationObserver(function () {
Polymer.Async._atEndOfMicrotask();
}).observe(Polymer.Async._twiddle, { characterData: true });Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
var self = this;
this.boundComplete = function () {
self.complete();
};
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
this.callback = null;
}
},
complete: function () {
if (this.finish) {
var callback = this.callback;
this.stop();
callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return !!(debouncer && debouncer.finish);
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._registerHost();
if (this._template) {
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
}
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script>














<script>Polymer.nar = [];
Polymer.Annotations = {
parseAnnotations: function (template) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list, template.hasAttribute('strip-whitespace'));
return list;
},
_parseNodeAnnotations: function (node, list, stripWhiteSpace) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
},
_bindingRegex: function () {
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?';
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
return new RegExp(EXPRESSION, 'g');
}(),
_parseBindings: function (text) {
var re = this._bindingRegex;
var parts = [];
var lastIndex = 0;
var m;
while ((m = re.exec(text)) !== null) {
if (m.index > lastIndex) {
parts.push({ literal: text.slice(lastIndex, m.index) });
}
var mode = m[1][0];
var negate = Boolean(m[2]);
var value = m[3].trim();
var customEvent, notifyEvent, colon;
if (mode == '{' && (colon = value.indexOf('::')) > 0) {
notifyEvent = value.substring(colon + 2);
value = value.substring(0, colon);
customEvent = true;
}
parts.push({
compoundIndex: parts.length,
value: value,
mode: mode,
negate: negate,
event: notifyEvent,
customEvent: customEvent
});
lastIndex = re.lastIndex;
}
if (lastIndex && lastIndex < text.length) {
var literal = text.substring(lastIndex);
if (literal) {
parts.push({ literal: literal });
}
}
if (parts.length) {
return parts;
}
},
_literalFromParts: function (parts) {
var s = '';
for (var i = 0; i < parts.length; i++) {
var literal = parts[i].literal;
s += literal || '';
}
return s;
},
_parseTextNodeAnnotation: function (node, list) {
var parts = this._parseBindings(node.textContent);
if (parts) {
node.textContent = this._literalFromParts(parts) || ' ';
var annote = {
bindings: [{
kind: 'text',
name: 'textContent',
parts: parts,
isCompound: parts.length !== 1
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list, stripWhiteSpace) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, stripWhiteSpace) {
if (root.firstChild) {
var node = root.firstChild;
var i = 0;
while (node) {
var next = node.nextSibling;
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote);
}
if (node.localName == 'slot') {
node = this._replaceSlotWithContent(node);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = next;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
next = n.nextSibling;
root.removeChild(n);
n = next;
}
if (stripWhiteSpace && !node.textContent.trim()) {
root.removeChild(node);
i--;
}
}
if (node.parentNode) {
var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
node = next;
i++;
}
}
},
_replaceSlotWithContent: function (slot) {
var content = slot.ownerDocument.createElement('content');
while (slot.firstChild) {
content.appendChild(slot.firstChild);
}
var attrs = slot.attributes;
for (var i = 0; i < attrs.length; i++) {
var attr = attrs[i];
content.setAttribute(attr.name, attr.value);
}
var name = slot.getAttribute('name');
var select = name ? '[slot=\'' + name + '\']' : ':not([slot])';
content.setAttribute('select', select);
slot.parentNode.replaceChild(content, slot);
return content;
},
_parseTemplate: function (node, index, list, parent) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
var attrs = Array.prototype.slice.call(node.attributes);
for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
var n = a.name;
var v = a.value;
var b;
if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
annotation.bindings.push(b);
} else if (n === 'id') {
annotation.id = v;
}
}
},
_parseNodeAttributeAnnotation: function (node, name, value) {
var parts = this._parseBindings(value);
if (parts) {
var origName = name;
var kind = 'property';
if (name[name.length - 1] == '$') {
name = name.slice(0, -1);
kind = 'attribute';
}
var literal = this._literalFromParts(parts);
if (literal && kind == 'attribute') {
node.setAttribute(name, literal);
}
if (node.localName === 'input' && origName === 'value') {
node.setAttribute(origName, '');
}
node.removeAttribute(origName);
var propertyName = Polymer.CaseMap.dashToCamelCase(name);
if (kind === 'property') {
name = propertyName;
}
return {
kind: kind,
name: name,
propertyName: propertyName,
parts: parts,
literal: literal,
isCompound: parts.length !== 1
};
}
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
if (parent) {
for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
if (annote.index === i++) {
return n;
}
}
} else {
return root;
}
}
};(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && ABS_URL.test(url)) {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl
};
}());Polymer.Path = {
root: function (path) {
var dotIndex = path.indexOf('.');
if (dotIndex === -1) {
return path;
}
return path.slice(0, dotIndex);
},
isDeep: function (path) {
return path.indexOf('.') !== -1;
},
isAncestor: function (base, path) {
return base.indexOf(path + '.') === 0;
},
isDescendant: function (base, path) {
return path.indexOf(base + '.') === 0;
},
translate: function (base, newBase, path) {
return newBase + path.slice(base.length);
},
matches: function (base, wildcard, path) {
return base === path || this.isAncestor(base, path) || Boolean(wildcard) && this.isDescendant(base, path);
}
};Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
var self = this;
Polymer.Annotations.prepElement = function (element) {
self._prepElement(element);
};
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
}
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
for (var k = 0; k < b.parts.length; k++) {
var p = b.parts[k];
if (!p.literal) {
var signature = this._parseMethod(p.value);
if (signature) {
p.signature = signature;
} else {
p.model = Polymer.Path.root(p.value);
}
}
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
var name = '_parent_' + prop;
bindings.push({
index: note.index,
kind: 'property',
name: name,
propertyName: name,
parts: [{
mode: '{',
model: prop,
value: prop
}]
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
if (p.signature) {
var args = p.signature.args;
for (var kk = 0; kk < args.length; kk++) {
var model = args[kk].model;
if (model) {
pp[model] = true;
}
}
if (p.signature.dynamicFn) {
pp[p.signature.method] = true;
}
} else {
if (p.model) {
pp[p.model] = true;
}
}
}
}
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
}
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
var notes = this._notes;
var nodes = this._nodes;
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
var node = nodes[i];
this._configureTemplateContent(note, node);
this._configureCompoundBindings(note, node);
}
},
_configureTemplateContent: function (note, node) {
if (note.templateContent) {
node._content = note.templateContent;
}
},
_configureCompoundBindings: function (note, node) {
var bindings = note.bindings;
for (var i = 0; i < bindings.length; i++) {
var binding = bindings[i];
if (binding.isCompound) {
var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
var parts = binding.parts;
var literals = new Array(parts.length);
for (var j = 0; j < parts.length; j++) {
literals[j] = parts[j].literal;
}
var name = binding.name;
storage[name] = literals;
if (binding.literal && binding.kind == 'property') {
if (node._configValue) {
node._configValue(name, binding.literal);
} else {
node[name] = binding.literal;
}
}
}
}
},
_marshalIdNodes: function () {
this.$ = {};
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}
},
_marshalAnnotatedNodes: function () {
if (this._notes && this._notes.length) {
var r = new Array(this._notes.length);
for (var i = 0; i < this._notes.length; i++) {
r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
}
this._nodes = r;
}
},
_marshalAnnotatedListeners: function () {
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
this.listen(node, e.name, e.value);
}
}
}
}
});Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, eventName;
for (eventName in listeners) {
if (eventName.indexOf('.') < 0) {
node = this;
name = eventName;
} else {
name = eventName.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[eventName]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
hbl.set(target, bl);
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});(function () {
'use strict';
var wrap = Polymer.DomApi.wrap;
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
var sc = mouseEvent.sourceCapabilities;
if (sc && !sc.firesTouchEvents) {
return;
}
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
for (var i = 0, en; i < events.length; i++) {
en = events[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse() {
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (MOUSE_EVENTS.indexOf(type) === -1) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
stateObj.movefn = null;
stateObj.upfn = null;
}
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = wrap(ev.currentTarget);
var gobj = node[GESTURE_KEY];
if (!gobj) {
return;
}
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
if (type === 'touchend') {
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
ignoreMouse();
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
r.reset();
}
}
}
for (i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var preventer = detail.preventer || detail.sourceEvent;
if (preventer && preventer.preventDefault) {
preventer.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
},
resetMouseCanceller: function () {
if (POINTERSTATE.mouse.mouseIgnoreJob) {
POINTERSTATE.mouse.mouseIgnoreJob.complete();
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: null,
upfn: null
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
fire: function (type, target, event, preventer) {
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
preventer: preventer,
prevent: function (e) {
return Gestures.prevent(e);
}
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: null,
upfn: null,
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
if (self.info.state === 'start') {
Gestures.prevent('tap');
}
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
if (this.info.state === 'start') {
Gestures.prevent('tap');
}
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct, e);
}
},
fire: function (target, touch, preventer) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
preventer: preventer,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0], e);
},
touchend: function (e) {
this.forward(e.changedTouches[0], e);
},
forward: function (e, preventer) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e,
preventer: preventer
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_setupGestures: function () {
this.__polymerGestures = null;
},
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());(function () {
'use strict';
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getEffectiveChildNodes: function () {
return Polymer.dom(this).getEffectiveChildNodes();
},
getEffectiveChildren: function () {
var list = Polymer.dom(this).getEffectiveChildNodes();
return list.filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
getEffectiveTextContent: function () {
var cn = this.getEffectiveChildNodes();
var tc = [];
for (var i = 0, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(Polymer.dom(c).textContent);
}
}
return tc.join('');
},
queryEffectiveChildren: function (slctr) {
var e$ = Polymer.dom(this).queryDistributedElements(slctr);
return e$ && e$[0];
},
queryAllEffectiveChildren: function (slctr) {
return Polymer.dom(this).queryDistributedElements(slctr);
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
detail = detail === null || detail === undefined ? {} : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var useCache = options._useCache;
var event = this._getEvent(type, bubbles, cancelable, useCache);
event.detail = detail;
if (useCache) {
this.__eventCache[type] = null;
}
node.dispatchEvent(event);
if (useCache) {
this.__eventCache[type] = event;
}
return event;
},
__eventCache: {},
_getEvent: function (type, bubbles, cancelable, useCache) {
var event = useCache && this.__eventCache[type];
if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {
event = new Event(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable
});
}
return event;
},
async: function (callback, waitTime) {
var self = this;
return Polymer.Async.run(function () {
callback.call(self);
}, waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this._get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror, optAsync) {
var link = document.createElement('link');
link.rel = 'import';
link.href = href;
var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
var cached = list[link.href];
var imprt = cached || link;
var self = this;
if (onload) {
var loadListener = function (e) {
e.target.__firedLoad = true;
e.target.removeEventListener('load', loadListener);
return onload.call(self, e);
};
imprt.addEventListener('load', loadListener);
}
if (onerror) {
var errorListener = function (e) {
e.target.__firedError = true;
e.target.removeEventListener('error', errorListener);
return onerror.call(self, e);
};
imprt.addEventListener('error', errorListener);
}
if (cached) {
if (cached.__firedLoad) {
cached.dispatchEvent(new Event('load'));
}
if (cached.__firedError) {
cached.dispatchEvent(new Event('error'));
}
} else {
list[link.href] = link;
optAsync = Boolean(optAsync);
if (optAsync) {
link.setAttribute('async', '');
}
document.head.appendChild(link);
}
return imprt;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
if (!Polymer.Settings.useNativeCustomElements) {
var importHref = Polymer.Base.importHref;
Polymer.Base.importHref = function (href, onload, onerror, optAsync) {
CustomElements.ready = false;
var loadFn = function (e) {
CustomElements.upgradeDocumentTree(document);
CustomElements.ready = true;
if (onload) {
return onload.call(this, e);
}
};
return importHref.call(this, href, loadFn, onerror, optAsync);
};
}
}());Polymer.Bind = {
prepareModel: function (model) {
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (source, event, value) {
value = value === undefined ? this[source] : value;
event = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';
this.fire(event, { value: value }, {
bubbles: false,
cancelable: false,
_useCache: true
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else if (node[property] !== value) {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
fx.fn.call(this, property, this[property], fx.effect, old, fromAbove);
}
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (Polymer.Path.isDescendant(path, prop)) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
if (!model._propertyEffects) {
model._propertyEffects = {};
}
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
var propEffect = {
kind: kind,
effect: effect,
fn: Polymer.Bind['_' + kind + 'Effect']
};
fx.push(propEffect);
return propEffect;
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'annotatedComputation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event, negated) {
if (!model._bindListeners) {
model._bindListeners = [];
}
var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, negated) {
return function (target, value, targetPath) {
if (targetPath) {
var newPath = Polymer.Path.translate(property, path, targetPath);
this._notifyPath(newPath, value);
} else {
value = target[property];
if (negated) {
value = !value;
}
if (!isStructured) {
this[path] = value;
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
var b$ = inst._bindListeners;
for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
var node = inst._nodes[info.index];
this._addNotifyListener(node, inst, info.event, info.changedFn);
}
},
_addNotifyListener: function (element, context, event, changedFn) {
element.addEventListener(event, function (e) {
return context._notifyListener(changedFn, e);
});
}
};Polymer.Base.extend(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this._get(effect.value);
this.__data__[effect.value] = value;
}
this._applyEffectValue(effect, value);
},
_reflectEffect: function (source, value, effect) {
this.reflectPropertyToAttribute(source, effect.attribute, value);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source, effect.event, value);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(this, args);
this.__setProperty(effect.name, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
this._applyEffectValue(effect, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
var bailoutEarly = args.length > 1 || effect.dynamicFn;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (path === name) {
v = value;
} else {
v = model[name];
if (v === undefined && arg.structured) {
v = Polymer.Base._get(name, model);
}
}
if (bailoutEarly && v === undefined) {
return;
}
if (arg.wildcard) {
var matches = Polymer.Path.isAncestor(path, name);
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
prop.pathFn = this['_' + prop.kind + 'PathEffect'];
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });
}
if (prop.reflectToAttribute) {
var attr = Polymer.CaseMap.camelToDashCase(p);
if (attr[0] === '-') {
this._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
} else {
this._addPropertyEffect(p, 'reflect', { attribute: attr });
}
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
name: name,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'compute', {
method: sig.method,
args: sig.args,
trigger: null,
name: name,
dynamicFn: dynamicFn
});
}
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
this._addComplexObserverEffect(o);
}
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
if (!sig) {
throw new Error('Malformed observer expression \'' + observer + '\'');
}
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: null,
dynamicFn: dynamicFn
});
}
},
_addAnnotationEffects: function (notes) {
for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
var b$ = note.bindings;
for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
this._addAnnotationEffect(binding, i);
}
}
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
}
for (var i = 0; i < note.parts.length; i++) {
var part = note.parts[i];
if (part.signature) {
this._addAnnotatedComputationEffect(note, part, index);
} else if (!part.literal) {
if (note.kind === 'attribute' && note.name[0] === '-') {
this._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because "-" is not a valid attribute starting character'));
} else {
this._addPropertyEffect(part.model, 'annotation', {
kind: note.kind,
index: index,
name: note.name,
propertyName: note.propertyName,
value: part.value,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
event: part.event,
customEvent: part.customEvent,
negate: part.negate
});
}
}
}
},
_addAnnotatedComputationEffect: function (note, part, index) {
var sig = part.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
} else {
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
}
}
if (sig.dynamicFn) {
this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
}
}
},
__addAnnotatedComputationEffect: function (property, index, note, part, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
kind: note.kind,
name: note.name,
negate: part.negate,
method: part.signature.method,
args: part.signature.args,
trigger: trigger,
dynamicFn: part.signature.dynamicFn
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
sig.static = false;
sig.dynamicFn = true;
}
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = { name: arg };
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.model = Polymer.Path.root(arg);
a.structured = Polymer.Path.isDeep(arg);
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
if (this._bindListeners) {
Polymer.Bind.setupBindListeners(this);
}
},
_applyEffectValue: function (info, value) {
var node = this._nodes[info.index];
var property = info.name;
value = this._computeFinalAnnotationValue(node, property, value, info);
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
var pinfo = node._propertyInfo && node._propertyInfo[property];
if (pinfo && pinfo.readOnly) {
return;
}
this.__setProperty(property, value, false, node);
}
},
_computeFinalAnnotationValue: function (node, property, value, info) {
if (info.negate) {
value = !value;
}
if (info.isCompound) {
var storage = node.__compoundStorage__[property];
storage[info.compoundIndex] = value;
value = storage.join('');
}
if (info.kind !== 'attribute') {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
}
return value;
},
_executeStaticEffects: function () {
if (this._propertyEffects && this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});(function () {
var usePolyfillProto = Polymer.Settings.usePolyfillProto;
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
this._handlers = [];
this._aboveConfig = null;
if (initialConfig) {
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
var info = this._propertyInfo[name];
if (!info || !info.readOnly) {
this._config[name] = value;
}
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._configureInstanceProperties();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._configureProperties(this.behaviors[i].properties, config);
}
this._configureProperties(this.properties, config);
this.mixin(config, this._aboveConfig);
this._config = config;
if (this._clients && this._clients.length) {
this._distributeConfig(this._config);
}
},
_configureInstanceProperties: function () {
for (var i in this._propertyEffects) {
if (!usePolyfillProto && this.hasOwnProperty(i)) {
this._configValue(i, this[i]);
delete this[i];
}
}
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
var name = x.effect.propertyName;
var isAttr = x.effect.kind == 'attribute';
var hasEffect = node._propertyEffects && node._propertyEffects[name];
if (node._configValue && (hasEffect || !isAttr)) {
var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
value = this._computeFinalAnnotationValue(node, name, value, x.effect);
if (isAttr) {
value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
}
node._configValue(name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!Polymer.Bind._isEventBogus(e, e.target)) {
var value, path;
if (e.detail) {
value = e.detail.value;
path = e.detail.path;
}
if (!this._clientsReadied) {
this._queueHandler([
fn,
e.target,
value,
path
]);
} else {
return fn.call(this, e.target, value, path);
}
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2], h[3]);
}
this._handlers = [];
}
});
}());(function () {
'use strict';
var Path = Polymer.Path;
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var info = {};
var v = this._get(path, this, info);
if (arguments.length === 1) {
value = v;
}
if (info.path) {
this._notifyPath(info.path, value, fromAbove);
}
},
_notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPathUp(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old, key;
if (last[0] == '#') {
key = last;
old = coll.getItem(key);
last = array.indexOf(old);
coll.setItem(key, value);
} else if (parseInt(last, 10) == last) {
old = prop[last];
key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this._notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
return this._get(path, root);
},
_get: function (path, root, info) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
for (var i = 0; i < parts.length; i++) {
if (!prop) {
return;
}
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (info && array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
array = Array.isArray(prop) ? prop : null;
}
if (info) {
info.path = parts.join('.');
}
return prop;
},
_pathEffector: function (path, value) {
var model = Path.root(path);
var fx$ = this._propertyEffects && this._propertyEffects[model];
if (fx$) {
for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
var fxFn = fx.pathFn;
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (Path.matches(effect.value, false, path)) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (!effect.negate && Path.isDescendant(effect.value, path)) {
var node = this._nodes[effect.index];
if (node && node._notifyPath) {
var newPath = Path.translate(effect.value, effect.name, path);
node._notifyPath(newPath, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (Path.isDescendant(a, path)) {
this._notifyPath(Path.translate(a, b, path), value);
} else if (Path.isDescendant(b, path)) {
this._notifyPath(Path.translate(b, a, path), value);
}
}
},
_notifyPathUp: function (path, value) {
var rootName = Path.root(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, {
bubbles: false,
_useCache: true
});
},
_EVENT_CHANGED: '-changed',
notifySplices: function (path, splices) {
var info = {};
var array = this._get(path, this, info);
this._notifySplices(array, info.path, splices);
},
_notifySplices: function (array, path, splices) {
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
var splicesPath = path + '.splices';
this._notifyPath(splicesPath, change);
this._notifyPath(path + '.length', array.length);
this.__data__[splicesPath] = {
keySplices: null,
indexSplices: null
};
},
_notifySplice: function (array, path, index, added, removed) {
this._notifySplices(array, path, [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}]);
},
push: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start) {
var info = {};
var array = this._get(path, this, info);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, info.path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
_getEvent: Polymer.Base._getEvent,
__eventCache: Polymer.Base.__eventCache,
notifyPath: Polymer.Base.notifyPath,
_get: Polymer.Base._get,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_notifyPathUp: Polymer.Base._notifyPathUp,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths,
_getPathParts: Polymer.Base._getPathParts
});
}
});
}());Polymer.Base._addFeature({
resolveUrl: function (url) {
var module = Polymer.DomModule.import(this.is);
var root = '';
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
}
return Polymer.ResolveUrl.resolveUrl(url, root);
}
});Polymer.CssParse = function () {
return {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = this._expandUnicodeEscapes(t);
t = t.replace(this._rx.multipleSpaces, ' ');
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
_expandUnicodeEscapes: function (s) {
return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
var code = arguments[1], repeat = 6 - code.length;
while (repeat--) {
code = '0' + code;
}
return '\\' + code;
});
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && !this._hasMixinRules(r$)) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) === 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/,
multipleSpaces: /\s+/g
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
}();Polymer.StyleUtil = function () {
var settings = Polymer.Settings;
return {
NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachRule(rules, callback);
}
return this.parser.stringify(rules, this.NATIVE_VARIABLES);
},
forRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback);
}
}
},
forActiveRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
isKeyframesSelector: function (rule) {
return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
},
forEachRuleInStyle: function (style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
var rules = this.rulesForStyle(style);
var styleCallback, keyframeCallback;
if (styleRuleCallback) {
styleCallback = function (rule) {
styleRuleCallback(rule, style);
};
}
if (keyframesRuleCallback) {
keyframeCallback = function (rule) {
keyframesRuleCallback(rule, style);
};
}
this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules);
},
forEachRule: function (node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
if (!node) {
return;
}
var skipRules = false;
if (onlyActiveRules) {
if (node.type === this.ruleTypes.MEDIA_RULE) {
var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
if (matchMedia) {
if (!window.matchMedia(matchMedia[1]).matches) {
skipRules = true;
}
}
}
}
if (node.type === this.ruleTypes.STYLE_RULE) {
styleRuleCallback(node);
} else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
keyframesRuleCallback(node);
} else if (node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
}
}
},
applyCss: function (cssText, moniker, target, contextNode) {
var style = this.createScopeStyle(cssText, moniker);
return this.applyStyle(style, target, contextNode);
},
applyStyle: function (style, target, contextNode) {
target = target || document.head;
var after = contextNode && contextNode.nextSibling || target.firstChild;
this.__lastHeadApplyNode = style;
return target.insertBefore(style, after);
},
createScopeStyle: function (cssText, moniker) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
return style;
},
__lastHeadApplyNode: null,
applyStylePlaceHolder: function (moniker) {
var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
var scope = document.head;
scope.insertBefore(placeHolder, after || scope.firstChild);
this.__lastHeadApplyNode = placeHolder;
return placeHolder;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(' ');
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this.cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
if (!e.hasAttribute('preserve-content')) {
cssText += this.cssFromElement(e);
}
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
cssText += this.resolveCss(e.textContent, element.ownerDocument);
} else if (e.import && e.import.body) {
cssText += this.resolveCss(e.import.body.textContent, e.import);
}
}
}
return cssText;
},
isTargetedBuild: function (buildType) {
return settings.useNativeShadow ? buildType === 'shadow' : buildType === 'shady';
},
cssBuildTypeForModule: function (module) {
var dm = Polymer.DomModule.import(module);
if (dm) {
return this.getCssBuildType(dm);
}
},
getCssBuildType: function (element) {
return element.getAttribute('css-build');
},
_findMatchingParen: function (text, start) {
var level = 0;
for (var i = start, l = text.length; i < l; i++) {
switch (text[i]) {
case '(':
level++;
break;
case ')':
if (--level === 0) {
return i;
}
break;
}
}
return -1;
},
processVariableAndFallback: function (str, callback) {
var start = str.indexOf('var(');
if (start === -1) {
return callback(str, '', '', '');
}
var end = this._findMatchingParen(str, start + 3);
var inner = str.substring(start + 4, end);
var prefix = str.substring(0, start);
var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
var comma = inner.indexOf(',');
if (comma === -1) {
return callback(prefix, inner.trim(), '', suffix);
}
var value = inner.substring(0, comma).trim();
var fallback = inner.substring(comma + 1).trim();
return callback(prefix, value, fallback, suffix);
},
rx: {
VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();Polymer.StyleTransformer = function () {
var styleUtil = Polymer.StyleUtil;
var settings = Polymer.Settings;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
var cssBuildType = element.__cssBuild;
var passthrough = settings.useNativeShadow || cssBuildType === 'shady';
var cb;
if (passthrough) {
var self = this;
cb = function (rule) {
rule.selector = self._slottedToContent(rule.selector);
rule.selector = rule.selector.replace(ROOT, ':host > *');
if (callback) {
callback(rule);
}
};
}
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
},
_transformRuleCss: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
if (!styleUtil.isKeyframesSelector(rule)) {
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
}
return p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.trim();
selector = this._slottedToContent(selector);
selector = selector.replace(ROOT, ':host > *');
selector = selector.replace(CONTENT_START, HOST + ' $1');
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = this._transformHostSelector(selector, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
_transformHostSelector: function (selector, hostScope) {
var m = selector.match(HOST_PAREN);
var paren = m && m[2].trim() || '';
if (paren) {
if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
if (typeSelector === hostScope) {
return paren;
} else {
return SELECTOR_NO_MATCH;
}
} else {
return selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
}
} else {
return selector.replace(HOST, hostScope);
}
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!settings.useNativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
rule.selector = rule.selector.replace(ROOT, 'html');
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
_slottedToContent: function (cssText) {
return cssText.replace(SLOTTED_PAREN, CONTENT + '> $1');
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /::content|::shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
var CONTENT_START = new RegExp('^(' + CONTENT + ')');
var SELECTOR_NO_MATCH = 'should_not_match';
var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
return api;
}();Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachRule(rules, function (rule) {
self._mapRuleOntoParent(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRuleOntoParent: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || [];
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();Polymer.ApplyShim = function () {
'use strict';
var styleUtil = Polymer.StyleUtil;
var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
var MIXIN_VAR_SEP = '_-_';
var mixinMap = {};
function mapSet(name, props) {
name = name.trim();
mixinMap[name] = {
properties: props,
dependants: {}
};
}
function mapGet(name) {
name = name.trim();
return mixinMap[name];
}
function replaceInitialOrInherit(property, value) {
var match = INITIAL_INHERIT.exec(value);
if (match) {
if (match[1]) {
value = ApplyShim._getInitialValueForProperty(property);
} else {
value = 'apply-shim-inherit';
}
}
return value;
}
function cssTextToMap(text) {
var props = text.split(';');
var property, value;
var out = {};
for (var i = 0, p, sp; i < props.length; i++) {
p = props[i];
if (p) {
sp = p.split(':');
if (sp.length > 1) {
property = sp[0].trim();
value = replaceInitialOrInherit(property, sp.slice(1).join(':'));
out[property] = value;
}
}
}
return out;
}
function invalidateMixinEntry(mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
var currentElementName = currentProto && currentProto.is;
for (var elementName in mixinEntry.dependants) {
if (elementName !== currentElementName) {
mixinEntry.dependants[elementName].__applyShimInvalid = true;
}
}
}
function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
if (valueProperty) {
styleUtil.processVariableAndFallback(valueProperty, function (prefix, value) {
if (value && mapGet(value)) {
valueMixin = '@apply ' + value + ';';
}
});
}
if (!valueMixin) {
return matchText;
}
var mixinAsProperties = consumeCssProperties(valueMixin);
var prefix = matchText.slice(0, matchText.indexOf('--'));
var mixinValues = cssTextToMap(mixinAsProperties);
var combinedProps = mixinValues;
var mixinEntry = mapGet(propertyName);
var oldProps = mixinEntry && mixinEntry.properties;
if (oldProps) {
combinedProps = Object.create(oldProps);
combinedProps = Polymer.Base.mixin(combinedProps, mixinValues);
} else {
mapSet(propertyName, combinedProps);
}
var out = [];
var p, v;
var needToInvalidate = false;
for (p in combinedProps) {
v = mixinValues[p];
if (v === undefined) {
v = 'initial';
}
if (oldProps && !(p in oldProps)) {
needToInvalidate = true;
}
out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
}
if (needToInvalidate) {
invalidateMixinEntry(mixinEntry);
}
if (mixinEntry) {
mixinEntry.properties = combinedProps;
}
if (valueProperty) {
prefix = matchText + ';' + prefix;
}
return prefix + out.join('; ') + ';';
}
function fixVars(matchText, varA, varB) {
return 'var(' + varA + ',' + 'var(' + varB + '))';
}
function atApplyToCssProperties(mixinName, fallbacks) {
mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
var vars = [];
var mixinEntry = mapGet(mixinName);
if (!mixinEntry) {
mapSet(mixinName, {});
mixinEntry = mapGet(mixinName);
}
if (mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
if (currentProto) {
mixinEntry.dependants[currentProto.is] = currentProto;
}
var p, parts, f;
for (p in mixinEntry.properties) {
f = fallbacks && fallbacks[p];
parts = [
p,
': var(',
mixinName,
MIXIN_VAR_SEP,
p
];
if (f) {
parts.push(',', f);
}
parts.push(')');
vars.push(parts.join(''));
}
}
return vars.join('; ');
}
function consumeCssProperties(text) {
var m;
while (m = MIXIN_MATCH.exec(text)) {
var matchText = m[0];
var mixinName = m[1];
var idx = m.index;
var applyPos = idx + matchText.indexOf('@apply');
var afterApplyPos = idx + matchText.length;
var textBeforeApply = text.slice(0, applyPos);
var textAfterApply = text.slice(afterApplyPos);
var defaults = cssTextToMap(textBeforeApply);
var replacement = atApplyToCssProperties(mixinName, defaults);
text = [
textBeforeApply,
replacement,
textAfterApply
].join('');
MIXIN_MATCH.lastIndex = idx + replacement.length;
}
return text;
}
var ApplyShim = {
_measureElement: null,
_map: mixinMap,
_separator: MIXIN_VAR_SEP,
transform: function (styles, elementProto) {
this.__currentElementProto = elementProto;
styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
styleUtil.forRulesInStyles(styles, this._boundFindApplications);
if (elementProto) {
elementProto.__applyShimInvalid = false;
}
this.__currentElementProto = null;
},
_findDefinitions: function (rule) {
var cssText = rule.parsedCssText;
cssText = cssText.replace(BAD_VAR, fixVars);
cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
rule.cssText = cssText;
if (rule.selector === ':root') {
rule.selector = ':host > *';
}
},
_findApplications: function (rule) {
rule.cssText = consumeCssProperties(rule.cssText);
},
transformRule: function (rule) {
this._findDefinitions(rule);
this._findApplications(rule);
},
_getInitialValueForProperty: function (property) {
if (!this._measureElement) {
this._measureElement = document.createElement('meta');
this._measureElement.style.all = 'initial';
document.head.appendChild(this._measureElement);
}
return window.getComputedStyle(this._measureElement).getPropertyValue(property);
}
};
ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
return ApplyShim;
}();(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
var applyShim = Polymer.ApplyShim;
var settings = Polymer.Settings;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle && this.__cssBuild !== 'shady') {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow;
}
if (!nativeShadow) {
this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
}
this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is);
},
_prepShimStyles: function () {
if (this._template) {
var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
if (settings.useNativeCSSProperties && this.__cssBuild === 'shadow' && hasTargetedCssBuild) {
return;
}
this._styles = this._styles || this._collectStyles();
if (settings.useNativeCSSProperties && !this.__cssBuild) {
applyShim.transform(this._styles, this);
}
var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
this._prepStyleProperties();
if (!this._needsStyleProperties() && cssText) {
styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
}
} else {
this._styles = [];
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
var p = this._template && this._template.parentNode;
if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
cssText += styleUtil.cssFromElement(this._template);
}
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
var className = node.getAttribute('class');
node.setAttribute('class', self._scopeElementClass(node, className));
var n$ = node.querySelectorAll('*');
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
className = n.getAttribute('class');
n.setAttribute('class', self._scopeElementClass(n, className));
}
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
if (m.addedNodes) {
for (var j = 0; j < m.addedNodes.length; j++) {
scopify(m.addedNodes[j]);
}
}
}
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());Polymer.StyleProperties = function () {
'use strict';
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var IS_IE = navigator.userAgent.match('Trident');
var settings = Polymer.Settings;
return {
decorateStyles: function (styles, scope) {
var self = this, props = {}, keyframes = [], ruleIndex = 0;
var scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);
styleUtil.forRulesInStyles(styles, function (rule, style) {
self.decorateRule(rule);
rule.index = ruleIndex++;
self.whenHostOrRootRule(scope, rule, style, function (info) {
if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {
scope.__notStyleScopeCacheable = true;
}
if (info.isHost) {
var hostContextOrFunction = info.selector.split(' ').some(function (s) {
return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length;
});
scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction;
}
});
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
}, function onKeyframesRule(rule) {
keyframes.push(rule);
});
styles._keyframes = keyframes;
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var value;
var any;
while (m = rx.exec(cssText)) {
value = (m[2] || m[3]).trim();
if (value !== 'inherit') {
properties[m[1].trim()] = value;
}
any = true;
}
return any;
}
},
collectCssText: function (rule) {
return this.collectConsumingCssText(rule.parsedCssText);
},
collectConsumingCssText: function (cssText) {
return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
var name = m[1];
if (m[2] !== ':') {
props[name] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (prefix, value, fallback, suffix) {
var propertyValue = self.valueForProperty(props[value], props);
if (!propertyValue || propertyValue === 'initial') {
propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
} else if (propertyValue === 'apply-shim-inherit') {
propertyValue = 'inherit';
}
return prefix + (propertyValue || '') + suffix;
};
property = styleUtil.processVariableAndFallback(property, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
this.rx.MIXIN_MATCH.lastIndex = 0;
m = this.rx.MIXIN_MATCH.exec(p);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var colon = p.indexOf(':');
if (colon !== -1) {
var pp = p.substring(colon);
pp = pp.trim();
pp = this.valueForProperty(pp, props) || pp;
p = p.substring(0, colon) + pp;
}
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
applyKeyframeTransforms: function (rule, keyframeTransforms) {
var input = rule.cssText;
var output = rule.cssText;
if (rule.hasAnimations == null) {
rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
}
if (rule.hasAnimations) {
var transform;
if (rule.keyframeNamesToTransform == null) {
rule.keyframeNamesToTransform = [];
for (var keyframe in keyframeTransforms) {
transform = keyframeTransforms[keyframe];
output = transform(input);
if (input !== output) {
input = output;
rule.keyframeNamesToTransform.push(keyframe);
}
}
} else {
for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
input = transform(input);
}
output = input;
}
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [];
styleUtil.forActiveRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
if (element && rule.propertyInfo.properties && selectorToMatch) {
if (matchesSelector.call(element, selectorToMatch)) {
self.collectProperties(rule, props);
addToBitMask(rule.index, o);
}
}
});
return {
properties: props,
key: o
};
},
_rootSelector: /:root|:host\s*>\s*\*/,
_checkRoot: function (hostScope, selector) {
return Boolean(selector.match(this._rootSelector)) || hostScope === 'html' && selector.indexOf('html') > -1;
},
whenHostOrRootRule: function (scope, rule, style, callback) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (!rule.propertyInfo.properties) {
return;
}
var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : 'html';
var parsedSelector = rule.parsedSelector;
var isRoot = this._checkRoot(hostScope, parsedSelector);
var isHost = !isRoot && parsedSelector.indexOf(':host') === 0;
var cssBuild = scope.__cssBuild || style.__cssBuild;
if (cssBuild === 'shady') {
isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') > -1;
isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
}
if (!isRoot && !isHost) {
return;
}
var selectorToMatch = hostScope;
if (isHost) {
if (settings.useNativeShadow && !rule.transformedSelector) {
rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);
}
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
if (isRoot && hostScope === 'html') {
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
callback({
selector: selectorToMatch,
isHost: isHost,
isRoot: isRoot
});
},
hostAndRootPropertiesForScope: function (scope) {
var hostProps = {}, rootProps = {}, self = this;
styleUtil.forActiveRulesInStyles(scope._styles, function (rule, style) {
self.whenHostOrRootRule(scope, rule, style, function (info) {
var element = scope._element || scope;
if (matchesSelector.call(element, info.selector)) {
if (info.isHost) {
self.collectProperties(rule, hostProps);
} else {
self.collectProperties(rule, rootProps);
}
}
});
});
return {
rootProps: rootProps,
hostProps: hostProps
};
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
self.applyKeyframeTransforms(rule, keyframeTransforms);
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_elementKeyframeTransforms: function (element, scopeSelector) {
var keyframesRules = element._styles._keyframes;
var keyframeTransforms = {};
if (!settings.useNativeShadow && keyframesRules) {
for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
this._scopeKeyframes(keyframesRule, scopeSelector);
keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
}
}
return keyframeTransforms;
},
_keyframesRuleTransformer: function (keyframesRule) {
return function (cssText) {
return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
};
},
_scopeKeyframes: function (rule, scopeId) {
rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
rule.transformedSelector = rule.transformedSelector || rule.selector;
rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.setAttribute('class', v);
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !settings.useNativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (settings.useNativeShadow) {
if (element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle);
}
} else {
if (!style) {
if (cssText) {
style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle);
}
} else if (!style.parentNode) {
if (IS_IE && cssText.indexOf('@media') > -1) {
style.textContent = cssText;
}
styleUtil.applyStyle(style, null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
updateNativeStyleProperties: function (element, properties) {
var oldPropertyNames = element.__customStyleProperties;
if (oldPropertyNames) {
for (var i = 0; i < oldPropertyNames.length; i++) {
element.style.removeProperty(oldPropertyNames[i]);
}
}
var propertyNames = [];
for (var p in properties) {
if (properties[p] !== null) {
element.style.setProperty(p, properties[p]);
propertyNames.push(p);
}
}
element.__customStyleProperties = propertyNames;
},
rx: styleUtil.rx,
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var StyleCache = Polymer.StyleCache;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
_element: Polymer.DomApi.wrap(document.documentElement),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles, this);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
hasStyleProperties: function () {
return Boolean(this._properties);
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
if (nativeVariables) {
styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle);
}
}
};
return api;
}();(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
if (!nativeVariables) {
this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null;
}
},
customStyle: null,
getComputedStyleValue: function (property) {
return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
},
_setupStyleProperties: function () {
this.customStyle = {};
this._styleCache = null;
this._styleProperties = null;
this._scopeSelector = null;
this._ownStyleProperties = null;
this._customStyle = null;
},
_needsStyleProperties: function () {
return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_validateApplyShim: function () {
if (this.__applyShimInvalid) {
Polymer.ApplyShim.transform(this._styles, this.__proto__);
var cssText = styleTransformer.elementStyles(this);
if (nativeShadow) {
var templateStyle = this._template.content.querySelector('style');
if (templateStyle) {
templateStyle.textContent = cssText;
}
} else {
var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
if (shadyStyle) {
shadyStyle.textContent = cssText;
}
}
}
},
_beforeAttached: function () {
if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
this.__stylePropertiesInvalid = false;
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
var scopeCacheable = !this.__notStyleScopeCacheable;
if (scopeCacheable) {
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
}
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
if (scopeCacheable) {
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
}
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
this.mixin(props, hostAndRootProps.hostProps);
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, hostAndRootProps.rootProps);
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (nativeVariables) {
propertyUtils.updateNativeStyleProperties(this, this.customStyle);
} else {
if (this.isAttached) {
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
} else {
this.__stylePropertiesInvalid = true;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepConstructor();
this._prepStyles();
},
_finishRegisterFeatures: function () {
this._prepTemplate();
this._prepShimStyles();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepPropertyInfo();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._setupGestures();
this._setupConfigure();
this._setupStyleProperties();
this._setupDebouncers();
this._setupShady();
this._registerHost();
if (this._template) {
this._validateApplyShim();
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
this._marshalAnnotationReferences();
}
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalHostAttributes();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
if (b.listeners) {
this._listenListeners(b.listeners);
}
}
});(function () {
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
var applyShim = Polymer.ApplyShim;
var debounce = Polymer.Debounce;
var settings = Polymer.Settings;
var updateDebouncer;
Polymer({
is: 'custom-style',
extends: 'style',
_template: null,
properties: { include: String },
ready: function () {
this.__appliedElement = this.__appliedElement || this;
this.__cssBuild = styleUtil.getCssBuildType(this);
if (this.__appliedElement !== this) {
this.__appliedElement.__cssBuild = this.__cssBuild;
}
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement;
if (!settings.useNativeCSSProperties) {
this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
styleDefaults.addStyle(e);
}
if (e.textContent || this.include) {
this._apply(true);
} else {
var self = this;
var observer = new MutationObserver(function () {
observer.disconnect();
self._apply(true);
});
observer.observe(e, { childList: true });
}
}
}
},
_updateStyles: function () {
Polymer.updateStyles();
},
_apply: function (initialApply) {
var e = this.__appliedElement;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (!e.textContent) {
return;
}
var buildType = this.__cssBuild;
var targetedBuild = styleUtil.isTargetedBuild(buildType);
if (settings.useNativeCSSProperties && targetedBuild) {
return;
}
var styleRules = styleUtil.rulesForStyle(e);
if (!targetedBuild) {
styleUtil.forEachRule(styleRules, function (rule) {
styleTransformer.documentRule(rule);
});
if (settings.useNativeCSSProperties && !buildType) {
applyShim.transform([e]);
}
}
if (settings.useNativeCSSProperties) {
e.textContent = styleUtil.toCssText(styleRules);
} else {
var self = this;
var fn = function fn() {
self._flushCustomProperties();
};
if (initialApply) {
Polymer.RenderStatus.whenReady(fn);
} else {
fn();
}
}
},
_flushCustomProperties: function () {
if (this.__needsUpdateStyles) {
this.__needsUpdateStyles = false;
updateDebouncer = debounce(updateDebouncer, this._updateStyles);
} else {
this._applyCustomProperties();
}
},
_applyCustomProperties: function () {
var element = this.__appliedElement;
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
if (!rules) {
return;
}
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepPropertyInfo();
archetype._prepBindings();
archetype._notifyPathUp = this._notifyPathUpImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
archetype.__setPropertyOrig = this.__setProperty;
archetype.__setProperty = this.__setPropertyImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
__setPropertyImpl: function (property, value, fromAbove, node) {
if (node && node.__hideTemplateChildren__ && property == 'textContent') {
property = '__polymerTextContent__';
}
this.__setPropertyOrig(property, value, fromAbove, node);
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function () {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = function () {
rootDataHost._prepElement();
};
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop),
fn: Polymer.Bind._functionEffect
},
{
kind: 'notify',
fn: Polymer.Bind._notifyEffect,
effect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }
}
];
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
var self = this;
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = function (source, value) {
self._forwardParentProp(source, value);
};
}
this._extendTemplate(template, proto);
template._pathEffector = function (path, value, fromAbove) {
return self._pathEffectorImpl(path, value, fromAbove);
};
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
var n$ = Object.getOwnPropertyNames(proto);
if (proto._propertySetter) {
template._propertySetter = proto._propertySetter;
}
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
var val = template[n];
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
}
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathUpImpl: function (path, value) {
var dataHost = this.dataHost;
var root = Polymer.Path.root(path);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
var model = Polymer.Path.root(subPath);
if (model in this._parentProps) {
this._forwardParentPath(subPath, value);
}
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._registerHost(host);
this._beginHosting();
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._endHosting();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
return value;
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
if (model[prop] === undefined) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};Polymer({
is: 'dom-template',
extends: 'template',
_template: null,
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return '#' + key;
},
removeKey: function (key) {
if (key = this._parseKey(key)) {
this._removeFromMap(this.store[key]);
delete this.store[key];
}
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
var key;
if (item && typeof item == 'object') {
key = this.omap.get(item);
} else {
key = this.pmap[item];
}
if (key != undefined) {
return '#' + key;
}
},
getKeys: function () {
return Object.keys(this.store).map(function (key) {
return '#' + key;
});
},
_parseKey: function (key) {
if (key && key[0] == '#') {
return key.slice(1);
}
},
setItem: function (key, item) {
if (key = this._parseKey(key)) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
}
},
getItem: function (key) {
if (key = this._parseKey(key)) {
return this.store[key];
}
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
s.addedKeys = [];
for (var j = 0; j < s.removed.length; j++) {
key = this.getKey(s.removed[j]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.addedCount; j++) {
var item = this.userArray[s.index + j];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}
var removed = [];
var added = [];
for (key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};Polymer({
is: 'dom-repeat',
extends: 'template',
_template: null,
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number,
renderedItemCount: {
type: Number,
notify: true,
readOnly: true
},
initialCount: {
type: Number,
observer: '_initializeChunking'
},
targetFramerate: {
type: Number,
value: 20
},
_targetFrameTime: {
type: Number,
computed: '_computeFrameTime(targetFramerate)'
}
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
this._pool = [];
this._limit = Infinity;
var self = this;
this._boundRenderChunk = function () {
self._renderChunk();
};
},
detached: function () {
this.__isDetached = true;
for (var i = 0; i < this._instances.length; i++) {
this._detachInstance(i);
}
},
attached: function () {
if (this.__isDetached) {
this.__isDetached = false;
var parent = Polymer.dom(Polymer.dom(this).parentNode);
for (var i = 0; i < this._instances.length; i++) {
this._attachInstance(i, parent);
}
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function (sort) {
var dataHost = this._getRootDataHost();
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function (filter) {
var dataHost = this._getRootDataHost();
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_computeFrameTime: function (rate) {
return Math.ceil(1000 / rate);
},
_initializeChunking: function () {
if (this.initialCount) {
this._limit = this.initialCount;
this._chunkCount = this.initialCount;
this._lastChunkTime = performance.now();
}
},
_tryRenderChunk: function () {
if (this.items && this._limit < this.items.length) {
this.debounce('renderChunk', this._requestRenderChunk);
}
},
_requestRenderChunk: function () {
requestAnimationFrame(this._boundRenderChunk);
},
_renderChunk: function () {
var currChunkTime = performance.now();
var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
this._limit += this._chunkCount;
this._lastChunkTime = currChunkTime;
this._debounceTemplate(this._render);
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._initializeChunking();
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else if (this._keySplices.length) {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
} else {
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder && i < this._limit) {
inst = this._insertInstance(i, inst.__key__);
} else if (!inst.isPlaceholder && i >= this._limit) {
inst = this._downgradeInstance(i, inst.__key__);
}
keyToIdx[inst.__key__] = i;
if (!inst.isPlaceholder) {
inst.__setProperty(this.indexAs, i, true);
}
}
this._pool.length = 0;
this._setRenderedItemCount(this._instances.length);
this.fire('dom-change');
this._tryRenderChunk();
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
var self = this;
if (this._filterFn) {
keys = keys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
if (this._sortFn) {
keys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
}
for (i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__key__ = key;
if (!inst.isPlaceholder && i < this._limit) {
inst.__setProperty(this.as, c.getItem(key), true);
}
} else if (i < this._limit) {
this._insertInstance(i, key);
} else {
this._insertPlaceholder(i, key);
}
}
for (var j = this._instances.length - 1; j >= i; j--) {
this._detachAndRemoveInstance(j);
}
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var keyMap = {};
var key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
key = s.removed[j];
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.added.length; j++) {
key = s.added[j];
keyMap[key] = keyMap[key] ? null : 1;
}
}
var removedIdxs = [];
var addedKeys = [];
for (key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
this._detachAndRemoveInstance(idx);
}
}
}
var self = this;
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
addedKeys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
var start = 0;
for (i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i]);
}
}
},
_insertRowUserSort: function (start, key) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = this._sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._insertPlaceholder(idx, key);
return idx;
},
_applySplicesArrayOrder: function (splices) {
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
this._detachAndRemoveInstance(s.index);
}
for (j = 0; j < s.addedKeys.length; j++) {
this._insertPlaceholder(s.index + j, s.addedKeys[j]);
}
}
},
_detachInstance: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
return inst;
}
},
_attachInstance: function (idx, parent) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
parent.insertBefore(inst.root, this);
}
},
_detachAndRemoveInstance: function (idx) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
this._instances.splice(idx, 1);
},
_insertPlaceholder: function (idx, key) {
this._instances.splice(idx, 0, {
isPlaceholder: true,
__key__: key
});
},
_stampInstance: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
return this.stamp(model);
},
_insertInstance: function (idx, key) {
var inst = this._pool.pop();
if (inst) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._stampInstance(idx, key);
}
var beforeRow = this._instances[idx + 1];
var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
this._instances[idx] = inst;
return inst;
},
_downgradeInstance: function (idx, key) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
inst = {
isPlaceholder: true,
__key__: key
};
this._instances[idx] = inst;
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst.__setProperty(prop, value, true);
}
}
},
_forwardParentPath: function (path, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst._notifyPath(path, value, true);
}
}
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst && !inst.isPlaceholder) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst._notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});Polymer({
is: 'array-selector',
_template: null,
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});Polymer({
is: 'dom-if',
extends: 'template',
_template: null,
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
}
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(this.parentNode instanceof ShadowRoot))) {
this._teardownInstance();
}
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
this.fire('dom-change');
this._lastIf = this.if;
}
},
_ensureInstance: function () {
var parentNode = Polymer.dom(this).parentNode;
if (parentNode) {
var parent = Polymer.dom(parentNode);
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
parent.insertBefore(root, this);
} else {
var c$ = this._instance._children;
if (c$ && c$.length) {
var lastChild = Polymer.dom(this).previousSibling;
if (lastChild !== c$[c$.length - 1]) {
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.insertBefore(n, this);
}
}
}
}
}
},
_teardownInstance: function () {
if (this._instance) {
var c$ = this._instance._children;
if (c$ && c$.length) {
var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.removeChild(n);
}
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance.__setProperty(prop, value, true);
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance._notifyPath(path, value, true);
}
}
});Polymer({
is: 'dom-bind',
extends: 'template',
_template: null,
created: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
if (document.readyState == 'loading') {
document.addEventListener('DOMContentLoaded', function () {
self._markImportsReady();
});
} else {
self._markImportsReady();
}
});
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
parentDom.insertBefore(this.root, this);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_configureInstanceProperties: function () {
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
var setupConfigure = this._setupConfigure;
this._setupConfigure = function () {
setupConfigure.call(this, config);
};
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
this._prepPropertyInfo();
Polymer.Base._initFeatures.call(this);
this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
}
this._insertChildren();
this.fire('dom-change');
}
});</script>
































<dom-module id="iron-flex" assetpath="bower_components/iron-flex-layout/">
  <template>
    <style>
      .layout.horizontal,
      .layout.vertical {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
      }

      .layout.inline {
        display: -ms-inline-flexbox;
        display: -webkit-inline-flex;
        display: inline-flex;
      }

      .layout.horizontal {
        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
      }

      .layout.vertical {
        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
      }

      .layout.wrap {
        -ms-flex-wrap: wrap;
        -webkit-flex-wrap: wrap;
        flex-wrap: wrap;
      }

      .layout.center,
      .layout.center-center {
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
      }

      .layout.center-justified,
      .layout.center-center {
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
      }

      .flex {
        -ms-flex: 1 1 0.000000001px;
        -webkit-flex: 1;
        flex: 1;
        -webkit-flex-basis: 0.000000001px;
        flex-basis: 0.000000001px;
      }

      .flex-auto {
        -ms-flex: 1 1 auto;
        -webkit-flex: 1 1 auto;
        flex: 1 1 auto;
      }

      .flex-none {
        -ms-flex: none;
        -webkit-flex: none;
        flex: none;
      }
    </style>
  </template>
</dom-module>


<dom-module id="iron-flex-reverse" assetpath="bower_components/iron-flex-layout/">
  <template>
    <style>
      .layout.horizontal-reverse,
      .layout.vertical-reverse {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
      }

      .layout.horizontal-reverse {
        -ms-flex-direction: row-reverse;
        -webkit-flex-direction: row-reverse;
        flex-direction: row-reverse;
      }

      .layout.vertical-reverse {
        -ms-flex-direction: column-reverse;
        -webkit-flex-direction: column-reverse;
        flex-direction: column-reverse;
      }

      .layout.wrap-reverse {
        -ms-flex-wrap: wrap-reverse;
        -webkit-flex-wrap: wrap-reverse;
        flex-wrap: wrap-reverse;
      }
    </style>
  </template>
</dom-module>


<dom-module id="iron-flex-alignment" assetpath="bower_components/iron-flex-layout/">
  <template>
    <style>
      /**
       * Alignment in cross axis.
       */
      .layout.start {
        -ms-flex-align: start;
        -webkit-align-items: flex-start;
        align-items: flex-start;
      }

      .layout.center,
      .layout.center-center {
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
      }

      .layout.end {
        -ms-flex-align: end;
        -webkit-align-items: flex-end;
        align-items: flex-end;
      }

      .layout.baseline {
        -ms-flex-align: baseline;
        -webkit-align-items: baseline;
        align-items: baseline;
      }

      /**
       * Alignment in main axis.
       */
      .layout.start-justified {
        -ms-flex-pack: start;
        -webkit-justify-content: flex-start;
        justify-content: flex-start;
      }

      .layout.center-justified,
      .layout.center-center {
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
      }

      .layout.end-justified {
        -ms-flex-pack: end;
        -webkit-justify-content: flex-end;
        justify-content: flex-end;
      }

      .layout.around-justified {
        -ms-flex-pack: distribute;
        -webkit-justify-content: space-around;
        justify-content: space-around;
      }

      .layout.justified {
        -ms-flex-pack: justify;
        -webkit-justify-content: space-between;
        justify-content: space-between;
      }

      /**
       * Self alignment.
       */
      .self-start {
        -ms-align-self: flex-start;
        -webkit-align-self: flex-start;
        align-self: flex-start;
      }

      .self-center {
        -ms-align-self: center;
        -webkit-align-self: center;
        align-self: center;
      }

      .self-end {
        -ms-align-self: flex-end;
        -webkit-align-self: flex-end;
        align-self: flex-end;
      }

      .self-stretch {
        -ms-align-self: stretch;
        -webkit-align-self: stretch;
        align-self: stretch;
      }

      .self-baseline {
        -ms-align-self: baseline;
        -webkit-align-self: baseline;
        align-self: baseline;
      };

      /**
       * multi-line alignment in main axis.
       */
      .layout.start-aligned {
        -ms-flex-line-pack: start;  /* IE10 */
        -ms-align-content: flex-start;
        -webkit-align-content: flex-start;
        align-content: flex-start;
      }

      .layout.end-aligned {
        -ms-flex-line-pack: end;  /* IE10 */
        -ms-align-content: flex-end;
        -webkit-align-content: flex-end;
        align-content: flex-end;
      }

      .layout.center-aligned {
        -ms-flex-line-pack: center;  /* IE10 */
        -ms-align-content: center;
        -webkit-align-content: center;
        align-content: center;
      }

      .layout.between-aligned {
        -ms-flex-line-pack: justify;  /* IE10 */
        -ms-align-content: space-between;
        -webkit-align-content: space-between;
        align-content: space-between;
      }

      .layout.around-aligned {
        -ms-flex-line-pack: distribute;  /* IE10 */
        -ms-align-content: space-around;
        -webkit-align-content: space-around;
        align-content: space-around;
      }
    </style>
  </template>
</dom-module>

<dom-module id="iron-flex-factors" assetpath="bower_components/iron-flex-layout/">
  <template>
    <style>
      .flex,
      .flex-1 {
        -ms-flex: 1 1 0.000000001px;
        -webkit-flex: 1;
        flex: 1;
        -webkit-flex-basis: 0.000000001px;
        flex-basis: 0.000000001px;
      }

      .flex-2 {
        -ms-flex: 2;
        -webkit-flex: 2;
        flex: 2;
      }

      .flex-3 {
        -ms-flex: 3;
        -webkit-flex: 3;
        flex: 3;
      }

      .flex-4 {
        -ms-flex: 4;
        -webkit-flex: 4;
        flex: 4;
      }

      .flex-5 {
        -ms-flex: 5;
        -webkit-flex: 5;
        flex: 5;
      }

      .flex-6 {
        -ms-flex: 6;
        -webkit-flex: 6;
        flex: 6;
      }

      .flex-7 {
        -ms-flex: 7;
        -webkit-flex: 7;
        flex: 7;
      }

      .flex-8 {
        -ms-flex: 8;
        -webkit-flex: 8;
        flex: 8;
      }

      .flex-9 {
        -ms-flex: 9;
        -webkit-flex: 9;
        flex: 9;
      }

      .flex-10 {
        -ms-flex: 10;
        -webkit-flex: 10;
        flex: 10;
      }

      .flex-11 {
        -ms-flex: 11;
        -webkit-flex: 11;
        flex: 11;
      }

      .flex-12 {
        -ms-flex: 12;
        -webkit-flex: 12;
        flex: 12;
      }
    </style>
  </template>
</dom-module>


<dom-module id="iron-positioning" assetpath="bower_components/iron-flex-layout/">
  <template>
    <style>
      .block {
        display: block;
      }

      /* IE 10 support for HTML5 hidden attr */
      [hidden] {
        display: none !important;
      }

      .invisible {
        visibility: hidden !important;
      }

      .relative {
        position: relative;
      }

      .fit {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }

      body.fullbleed {
        margin: 0;
        height: 100vh;
      }

      .scroll {
        -webkit-overflow-scrolling: touch;
        overflow: auto;
      }

      /* fixed position */
      .fixed-bottom,
      .fixed-left,
      .fixed-right,
      .fixed-top {
        position: fixed;
      }

      .fixed-top {
        top: 0;
        left: 0;
        right: 0;
      }

      .fixed-right {
        top: 0;
        right: 0;
        bottom: 0;
      }

      .fixed-bottom {
        right: 0;
        bottom: 0;
        left: 0;
      }

      .fixed-left {
        top: 0;
        bottom: 0;
        left: 0;
      }
    </style>
  </template>
</dom-module>
<script>(function(g,f){"use strict";var h=function(e){if("object"!==typeof e.document)throw Error("Cookies.js requires a `window` with a `document` object");var b=function(a,d,c){return 1===arguments.length?b.get(a):b.set(a,d,c)};b._document=e.document;b._cacheKeyPrefix="cookey.";b.defaults={path:"/",secure:!1};b.get=function(a){b._cachedDocumentCookie!==b._document.cookie&&b._renewCache();return b._cache[b._cacheKeyPrefix+a]};b.set=function(a,d,c){c=b._getExtendedOptions(c);c.expires=b._getExpiresDate(d===f?-1:c.expires); b._document.cookie=b._generateCookieString(a,d,c);return b};b.expire=function(a,d){return b.set(a,f,d)};b._getExtendedOptions=function(a){return{path:a&&a.path||b.defaults.path,domain:a&&a.domain||b.defaults.domain,expires:a&&a.expires||b.defaults.expires,secure:a&&a.secure!==f?a.secure:b.defaults.secure}};b._isValidDate=function(a){return"[object Date]"===Object.prototype.toString.call(a)&&!isNaN(a.getTime())};b._getExpiresDate=function(a,d){d=d||new Date;switch(typeof a){case "number":a=new Date(d.getTime()+ 1E3*a);break;case "string":a=new Date(a)}if(a&&!b._isValidDate(a))throw Error("`expires` parameter cannot be converted to a valid Date instance");return a};b._generateCookieString=function(a,b,c){a=a.replace(/[^#$&+\^`|]/g,encodeURIComponent);a=a.replace(/\(/g,"%28").replace(/\)/g,"%29");b=(b+"").replace(/[^!#$&-+\--:<-\[\]-~]/g,encodeURIComponent);c=c||{};a=a+"="+b+(c.path?";path="+c.path:"");a+=c.domain?";domain="+c.domain:"";a+=c.expires?";expires="+c.expires.toUTCString():"";return a+=c.secure? ";secure":""};b._getCacheFromString=function(a){var d={};a=a?a.split("; "):[];for(var c=0;c<a.length;c++){var e=b._getKeyValuePairFromCookieString(a[c]);d[b._cacheKeyPrefix+e.key]===f&&(d[b._cacheKeyPrefix+e.key]=e.value)}return d};b._getKeyValuePairFromCookieString=function(a){var b=a.indexOf("="),b=0>b?a.length:b;return{key:decodeURIComponent(a.substr(0,b)),value:decodeURIComponent(a.substr(b+1))}};b._renewCache=function(){b._cache=b._getCacheFromString(b._document.cookie);b._cachedDocumentCookie= b._document.cookie};b._areEnabled=function(){var a="1"===b.set("cookies.js",1).get("cookies.js");b.expire("cookies.js");return a};b.enabled=b._areEnabled();return b},e="object"===typeof g.document?h(g):h;"function"===typeof define&&define.amd?define(function(){return e}):"object"===typeof exports?("object"===typeof module&&"object"===typeof module.exports&&(exports=module.exports=e),exports.Cookies=e):g.Cookies=e})("undefined"===typeof window?this:window);</script><script>;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {
	        function F() {}

	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                F.prototype = this;
	                var subtype = new F();

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init')) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));</script><script>;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));</script><script>!function(){function n(){}function t(n){return n}function e(n){return!!n}function r(n){return!n}function u(n){return function(){if(null===n)throw new Error("Callback was already called.");n.apply(this,arguments),n=null}}function i(n){return function(){null!==n&&(n.apply(this,arguments),n=null)}}function o(n){return M(n)||"number"==typeof n.length&&n.length>=0&&n.length%1===0}function c(n,t){for(var e=-1,r=n.length;++e<r;)t(n[e],e,n)}function a(n,t){for(var e=-1,r=n.length,u=Array(r);++e<r;)u[e]=t(n[e],e,n);return u}function f(n){return a(Array(n),function(n,t){return t})}function l(n,t,e){return c(n,function(n,r,u){e=t(e,n,r,u)}),e}function s(n,t){c(W(n),function(e){t(n[e],e)})}function p(n,t){for(var e=0;e<n.length;e++)if(n[e]===t)return e;return-1}function h(n){var t,e,r=-1;return o(n)?(t=n.length,function(){return r++,t>r?r:null}):(e=W(n),t=e.length,function(){return r++,t>r?e[r]:null})}function m(n,t){return t=null==t?n.length-1:+t,function(){for(var e=Math.max(arguments.length-t,0),r=Array(e),u=0;e>u;u++)r[u]=arguments[u+t];switch(t){case 0:return n.call(this,r);case 1:return n.call(this,arguments[0],r)}}}function y(n){return function(t,e,r){return n(t,r)}}function v(t){return function(e,r,o){o=i(o||n),e=e||[];var c=h(e);if(0>=t)return o(null);var a=!1,f=0,l=!1;!function s(){if(a&&0>=f)return o(null);for(;t>f&&!l;){var n=c();if(null===n)return a=!0,void(0>=f&&o(null));f+=1,r(e[n],n,u(function(n){f-=1,n?(o(n),l=!0):s()}))}}()}}function d(n){return function(t,e,r){return n(P.eachOf,t,e,r)}}function g(n){return function(t,e,r,u){return n(v(e),t,r,u)}}function k(n){return function(t,e,r){return n(P.eachOfSeries,t,e,r)}}function b(t,e,r,u){u=i(u||n),e=e||[];var c=o(e)?[]:{};t(e,function(n,t,e){r(n,function(n,r){c[t]=r,e(n)})},function(n){u(n,c)})}function w(n,t,e,r){var u=[];n(t,function(n,t,r){e(n,function(e){e&&u.push({index:t,value:n}),r()})},function(){r(a(u.sort(function(n,t){return n.index-t.index}),function(n){return n.value}))})}function O(n,t,e,r){w(n,t,function(n,t){e(n,function(n){t(!n)})},r)}function S(n,t,e){return function(r,u,i,o){function c(){o&&o(e(!1,void 0))}function a(n,r,u){return o?void i(n,function(r){o&&t(r)&&(o(e(!0,n)),o=i=!1),u()}):u()}arguments.length>3?n(r,u,a,c):(o=i,i=u,n(r,a,c))}}function E(n,t){return t}function L(t,e,r){r=r||n;var u=o(e)?[]:{};t(e,function(n,t,e){n(m(function(n,r){r.length<=1&&(r=r[0]),u[t]=r,e(n)}))},function(n){r(n,u)})}function j(n,t,e,r){var u=[];n(t,function(n,t,r){e(n,function(n,t){u=u.concat(t||[]),r(n)})},function(n){r(n,u)})}function I(t,e,r){function i(t,e,r,u){if(null!=u&&"function"!=typeof u)throw new Error("task callback must be a function");return t.started=!0,M(e)||(e=[e]),0===e.length&&t.idle()?P.setImmediate(function(){t.drain()}):(c(e,function(e){var i={data:e,callback:u||n};r?t.tasks.unshift(i):t.tasks.push(i),t.tasks.length===t.concurrency&&t.saturated()}),void P.setImmediate(t.process))}function o(n,t){return function(){f-=1;var e=!1,r=arguments;c(t,function(n){c(l,function(t,r){t!==n||e||(l.splice(r,1),e=!0)}),n.callback.apply(n,r)}),n.tasks.length+f===0&&n.drain(),n.process()}}if(null==e)e=1;else if(0===e)throw new Error("Concurrency must not be zero");var f=0,l=[],s={tasks:[],concurrency:e,payload:r,saturated:n,empty:n,drain:n,started:!1,paused:!1,push:function(n,t){i(s,n,!1,t)},kill:function(){s.drain=n,s.tasks=[]},unshift:function(n,t){i(s,n,!0,t)},process:function(){for(;!s.paused&&f<s.concurrency&&s.tasks.length;){var n=s.payload?s.tasks.splice(0,s.payload):s.tasks.splice(0,s.tasks.length),e=a(n,function(n){return n.data});0===s.tasks.length&&s.empty(),f+=1,l.push(n[0]);var r=u(o(s,n));t(e,r)}},length:function(){return s.tasks.length},running:function(){return f},workersList:function(){return l},idle:function(){return s.tasks.length+f===0},pause:function(){s.paused=!0},resume:function(){if(s.paused!==!1){s.paused=!1;for(var n=Math.min(s.concurrency,s.tasks.length),t=1;n>=t;t++)P.setImmediate(s.process)}}};return s}function x(n){return m(function(t,e){t.apply(null,e.concat([m(function(t,e){"object"==typeof console&&(t?console.error&&console.error(t):console[n]&&c(e,function(t){console[n](t)}))})]))})}function A(n){return function(t,e,r){n(f(t),e,r)}}function T(n){return m(function(t,e){var r=m(function(e){var r=this,u=e.pop();return n(t,function(n,t,u){n.apply(r,e.concat([u]))},u)});return e.length?r.apply(this,e):r})}function z(n){return m(function(t){var e=t.pop();t.push(function(){var n=arguments;r?P.setImmediate(function(){e.apply(null,n)}):e.apply(null,n)});var r=!0;n.apply(this,t),r=!1})}var q,P={},C="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||this;null!=C&&(q=C.async),P.noConflict=function(){return C.async=q,P};var H=Object.prototype.toString,M=Array.isArray||function(n){return"[object Array]"===H.call(n)},U=function(n){var t=typeof n;return"function"===t||"object"===t&&!!n},W=Object.keys||function(n){var t=[];for(var e in n)n.hasOwnProperty(e)&&t.push(e);return t},B="function"==typeof setImmediate&&setImmediate,D=B?function(n){B(n)}:function(n){setTimeout(n,0)};"object"==typeof process&&"function"==typeof process.nextTick?P.nextTick=process.nextTick:P.nextTick=D,P.setImmediate=B?D:P.nextTick,P.forEach=P.each=function(n,t,e){return P.eachOf(n,y(t),e)},P.forEachSeries=P.eachSeries=function(n,t,e){return P.eachOfSeries(n,y(t),e)},P.forEachLimit=P.eachLimit=function(n,t,e,r){return v(t)(n,y(e),r)},P.forEachOf=P.eachOf=function(t,e,r){function o(n){f--,n?r(n):null===c&&0>=f&&r(null)}r=i(r||n),t=t||[];for(var c,a=h(t),f=0;null!=(c=a());)f+=1,e(t[c],c,u(o));0===f&&r(null)},P.forEachOfSeries=P.eachOfSeries=function(t,e,r){function o(){var n=!0;return null===a?r(null):(e(t[a],a,u(function(t){if(t)r(t);else{if(a=c(),null===a)return r(null);n?P.setImmediate(o):o()}})),void(n=!1))}r=i(r||n),t=t||[];var c=h(t),a=c();o()},P.forEachOfLimit=P.eachOfLimit=function(n,t,e,r){v(t)(n,e,r)},P.map=d(b),P.mapSeries=k(b),P.mapLimit=g(b),P.inject=P.foldl=P.reduce=function(n,t,e,r){P.eachOfSeries(n,function(n,r,u){e(t,n,function(n,e){t=e,u(n)})},function(n){r(n,t)})},P.foldr=P.reduceRight=function(n,e,r,u){var i=a(n,t).reverse();P.reduce(i,e,r,u)},P.transform=function(n,t,e,r){3===arguments.length&&(r=e,e=t,t=M(n)?[]:{}),P.eachOf(n,function(n,r,u){e(t,n,r,u)},function(n){r(n,t)})},P.select=P.filter=d(w),P.selectLimit=P.filterLimit=g(w),P.selectSeries=P.filterSeries=k(w),P.reject=d(O),P.rejectLimit=g(O),P.rejectSeries=k(O),P.any=P.some=S(P.eachOf,e,t),P.someLimit=S(P.eachOfLimit,e,t),P.all=P.every=S(P.eachOf,r,r),P.everyLimit=S(P.eachOfLimit,r,r),P.detect=S(P.eachOf,t,E),P.detectSeries=S(P.eachOfSeries,t,E),P.detectLimit=S(P.eachOfLimit,t,E),P.sortBy=function(n,t,e){function r(n,t){var e=n.criteria,r=t.criteria;return r>e?-1:e>r?1:0}P.map(n,function(n,e){t(n,function(t,r){t?e(t):e(null,{value:n,criteria:r})})},function(n,t){return n?e(n):void e(null,a(t.sort(r),function(n){return n.value}))})},P.auto=function(t,e,r){function u(n){g.unshift(n)}function o(n){var t=p(g,n);t>=0&&g.splice(t,1)}function a(){h--,c(g.slice(0),function(n){n()})}"function"==typeof arguments[1]&&(r=e,e=null),r=i(r||n);var f=W(t),h=f.length;if(!h)return r(null);e||(e=h);var y={},v=0,d=!1,g=[];u(function(){h||r(null,y)}),c(f,function(n){function i(){return e>v&&l(k,function(n,t){return n&&y.hasOwnProperty(t)},!0)&&!y.hasOwnProperty(n)}function c(){i()&&(v++,o(c),h[h.length-1](g,y))}if(!d){for(var f,h=M(t[n])?t[n]:[t[n]],g=m(function(t,e){if(v--,e.length<=1&&(e=e[0]),t){var u={};s(y,function(n,t){u[t]=n}),u[n]=e,d=!0,r(t,u)}else y[n]=e,P.setImmediate(a)}),k=h.slice(0,h.length-1),b=k.length;b--;){if(!(f=t[k[b]]))throw new Error("Has nonexistent dependency in "+k.join(", "));if(M(f)&&p(f,n)>=0)throw new Error("Has cyclic dependencies")}i()?(v++,h[h.length-1](g,y)):u(c)}})},P.retry=function(n,t,e){function r(n,t){if("number"==typeof t)n.times=parseInt(t,10)||i;else{if("object"!=typeof t)throw new Error("Unsupported argument type for 'times': "+typeof t);n.times=parseInt(t.times,10)||i,n.interval=parseInt(t.interval,10)||o}}function u(n,t){function e(n,e){return function(r){n(function(n,t){r(!n||e,{err:n,result:t})},t)}}function r(n){return function(t){setTimeout(function(){t(null)},n)}}for(;a.times;){var u=!(a.times-=1);c.push(e(a.task,u)),!u&&a.interval>0&&c.push(r(a.interval))}P.series(c,function(t,e){e=e[e.length-1],(n||a.callback)(e.err,e.result)})}var i=5,o=0,c=[],a={times:i,interval:o},f=arguments.length;if(1>f||f>3)throw new Error("Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)");return 2>=f&&"function"==typeof n&&(e=t,t=n),"function"!=typeof n&&r(a,n),a.callback=e,a.task=t,a.callback?u():u},P.waterfall=function(t,e){function r(n){return m(function(t,u){if(t)e.apply(null,[t].concat(u));else{var i=n.next();i?u.push(r(i)):u.push(e),z(n).apply(null,u)}})}if(e=i(e||n),!M(t)){var u=new Error("First argument to waterfall must be an array of functions");return e(u)}return t.length?void r(P.iterator(t))():e()},P.parallel=function(n,t){L(P.eachOf,n,t)},P.parallelLimit=function(n,t,e){L(v(t),n,e)},P.series=function(n,t){L(P.eachOfSeries,n,t)},P.iterator=function(n){function t(e){function r(){return n.length&&n[e].apply(null,arguments),r.next()}return r.next=function(){return e<n.length-1?t(e+1):null},r}return t(0)},P.apply=m(function(n,t){return m(function(e){return n.apply(null,t.concat(e))})}),P.concat=d(j),P.concatSeries=k(j),P.whilst=function(t,e,r){if(r=r||n,t()){var u=m(function(n,i){n?r(n):t.apply(this,i)?e(u):r.apply(null,[null].concat(i))});e(u)}else r(null)},P.doWhilst=function(n,t,e){var r=0;return P.whilst(function(){return++r<=1||t.apply(this,arguments)},n,e)},P.until=function(n,t,e){return P.whilst(function(){return!n.apply(this,arguments)},t,e)},P.doUntil=function(n,t,e){return P.doWhilst(n,function(){return!t.apply(this,arguments)},e)},P.during=function(t,e,r){r=r||n;var u=m(function(n,e){n?r(n):(e.push(i),t.apply(this,e))}),i=function(n,t){n?r(n):t?e(u):r(null)};t(i)},P.doDuring=function(n,t,e){var r=0;P.during(function(n){r++<1?n(null,!0):t.apply(this,arguments)},n,e)},P.queue=function(n,t){var e=I(function(t,e){n(t[0],e)},t,1);return e},P.priorityQueue=function(t,e){function r(n,t){return n.priority-t.priority}function u(n,t,e){for(var r=-1,u=n.length-1;u>r;){var i=r+(u-r+1>>>1);e(t,n[i])>=0?r=i:u=i-1}return r}function i(t,e,i,o){if(null!=o&&"function"!=typeof o)throw new Error("task callback must be a function");return t.started=!0,M(e)||(e=[e]),0===e.length?P.setImmediate(function(){t.drain()}):void c(e,function(e){var c={data:e,priority:i,callback:"function"==typeof o?o:n};t.tasks.splice(u(t.tasks,c,r)+1,0,c),t.tasks.length===t.concurrency&&t.saturated(),P.setImmediate(t.process)})}var o=P.queue(t,e);return o.push=function(n,t,e){i(o,n,t,e)},delete o.unshift,o},P.cargo=function(n,t){return I(n,1,t)},P.log=x("log"),P.dir=x("dir"),P.memoize=function(n,e){var r={},u={},i=Object.prototype.hasOwnProperty;e=e||t;var o=m(function(t){var o=t.pop(),c=e.apply(null,t);i.call(r,c)?P.setImmediate(function(){o.apply(null,r[c])}):i.call(u,c)?u[c].push(o):(u[c]=[o],n.apply(null,t.concat([m(function(n){r[c]=n;var t=u[c];delete u[c];for(var e=0,i=t.length;i>e;e++)t[e].apply(null,n)})])))});return o.memo=r,o.unmemoized=n,o},P.unmemoize=function(n){return function(){return(n.unmemoized||n).apply(null,arguments)}},P.times=A(P.map),P.timesSeries=A(P.mapSeries),P.timesLimit=function(n,t,e,r){return P.mapLimit(f(n),t,e,r)},P.seq=function(){var t=arguments;return m(function(e){var r=this,u=e[e.length-1];"function"==typeof u?e.pop():u=n,P.reduce(t,e,function(n,t,e){t.apply(r,n.concat([m(function(n,t){e(n,t)})]))},function(n,t){u.apply(r,[n].concat(t))})})},P.compose=function(){return P.seq.apply(null,Array.prototype.reverse.call(arguments))},P.applyEach=T(P.eachOf),P.applyEachSeries=T(P.eachOfSeries),P.forever=function(t,e){function r(n){return n?i(n):void o(r)}var i=u(e||n),o=z(t);r()},P.ensureAsync=z,P.constant=m(function(n){var t=[null].concat(n);return function(n){return n.apply(this,t)}}),P.wrapSync=P.asyncify=function(n){return m(function(t){var e,r=t.pop();try{e=n.apply(this,t)}catch(u){return r(u)}U(e)&&"function"==typeof e.then?e.then(function(n){r(null,n)})["catch"](function(n){r(n.message?n:new Error(n))}):r(null,e)})},"object"==typeof module&&module.exports?module.exports=P:"function"==typeof define&&define.amd?define([],function(){return P}):C.async=P}();
//# sourceMappingURL=dist/async.min.map</script><script>/*
 * Copyright (c) 2016 Francisco Salavert (Computational Genomics - CIPF)
 * Copyright (c) 2016 Ruben Sanchez (Computational Genomics - CIPF)
 */

var SVG = {

	create : function (elementName, attributes){
		var el = document.createElementNS('http://www.w3.org/2000/svg', elementName);
		for ( var key in attributes){
			el.setAttribute(key, attributes[key]);
		}
		return el;
	},

	addChild : function (parent, elementName, attributes, index){
		var el = document.createElementNS('http://www.w3.org/2000/svg', elementName);
		for ( var key in attributes){
			el.setAttribute(key, attributes[key]);
		}
		return this._insert(parent, el, index);
	},

	addChildImage : function (parent, attributes, index){
		var el = document.createElementNS('http://www.w3.org/2000/svg', "image");
		for ( var key in attributes){
			if(key == "xlink:href"){
				el.setAttributeNS('http://www.w3.org/1999/xlink','href',attributes[key]);
			}else{
			    el.setAttribute(key, attributes[key]);
            }
		}
		return this._insert(parent, el, index);
	},

	_insert : function (parent, el, index){
		// insert child at requested index, or as last child if index is too high or no index is specified
	    if ( null == index ) {
	    	parent.appendChild( el );
	    }
	    else {
	      var targetIndex = index + 1;
	      if ( 0 == index ) {
	        targetIndex = 0;
	      }
	      var targetEl = parent.childNodes[ targetIndex ];
	      if ( targetEl ) {
	    	  parent.insertBefore( el, targetEl );
	      }
	      else {
	    	  parent.appendChild( el );
	      }
	    }
	    return el;
	},

	init : function (parent, attributes){
		return this.addChild(parent, "svg", attributes);
	},



    //
    /* Functions to generate arcs with PATH element  */
    //

    _polarToCartesian : function (centerX, centerY, radius, angleInDegrees) {
        var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;

        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY + (radius * Math.sin(angleInRadians))
        };
    },

    describeArc : function (x, y, radius, startAngle, endAngle) {

        var start = this._polarToCartesian(x, y, radius, endAngle);
        var end = this._polarToCartesian(x, y, radius, startAngle);

        var arcSweep = endAngle - startAngle <= 180 ? "0" : "1";
        var d = [
            "M", start.x, start.y,
            "A", radius, radius, 0, arcSweep, 0, end.x, end.y
        ].join(" ");

        return d;
    }
};
</script><script>!function(){function n(n){return n&&(n.ownerDocument||n.document||n).documentElement}function t(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}function e(n,t){return t>n?-1:n>t?1:n>=t?0:NaN}function r(n){return null===n?NaN:+n}function i(n){return!isNaN(n)}function u(n){return{left:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)<0?r=u+1:i=u}return r},right:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)>0?i=u:r=u+1}return r}}}function o(n){return n.length}function a(n){for(var t=1;n*t%1;)t*=10;return t}function l(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function c(){this._=Object.create(null)}function f(n){return(n+="")===bo||n[0]===_o?_o+n:n}function s(n){return(n+="")[0]===_o?n.slice(1):n}function h(n){return f(n)in this._}function p(n){return(n=f(n))in this._&&delete this._[n]}function g(){var n=[];for(var t in this._)n.push(s(t));return n}function v(){var n=0;for(var t in this._)++n;return n}function d(){for(var n in this._)return!1;return!0}function y(){this._=Object.create(null)}function m(n){return n}function M(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function x(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=wo.length;r>e;++e){var i=wo[e]+t;if(i in n)return i}}function b(){}function _(){}function w(n){function t(){for(var t,r=e,i=-1,u=r.length;++i<u;)(t=r[i].on)&&t.apply(this,arguments);return n}var e=[],r=new c;return t.on=function(t,i){var u,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,u=e.indexOf(o)).concat(e.slice(u+1)),r.remove(t)),i&&e.push(r.set(t,{on:i})),n)},t}function S(){ao.event.preventDefault()}function k(){for(var n,t=ao.event;n=t.sourceEvent;)t=n;return t}function N(n){for(var t=new _,e=0,r=arguments.length;++e<r;)t[arguments[e]]=w(t);return t.of=function(e,r){return function(i){try{var u=i.sourceEvent=ao.event;i.target=n,ao.event=i,t[i.type].apply(e,r)}finally{ao.event=u}}},t}function E(n){return ko(n,Co),n}function A(n){return"function"==typeof n?n:function(){return No(n,this)}}function C(n){return"function"==typeof n?n:function(){return Eo(n,this)}}function z(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function i(){this.setAttribute(n,t)}function u(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ao.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?u:i}function L(n){return n.trim().replace(/\s+/g," ")}function q(n){return new RegExp("(?:^|\\s+)"+ao.requote(n)+"(?:\\s+|$)","g")}function T(n){return(n+"").trim().split(/^|\s+/)}function R(n,t){function e(){for(var e=-1;++e<i;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<i;)n[e](this,r)}n=T(n).map(D);var i=n.length;return"function"==typeof t?r:e}function D(n){var t=q(n);return function(e,r){if(i=e.classList)return r?i.add(n):i.remove(n);var i=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(i)||e.setAttribute("class",L(i+" "+n))):e.setAttribute("class",L(i.replace(t," ")))}}function P(n,t,e){function r(){this.style.removeProperty(n)}function i(){this.style.setProperty(n,t,e)}function u(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?u:i}function U(n,t){function e(){delete this[n]}function r(){this[n]=t}function i(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?i:r}function j(n){function t(){var t=this.ownerDocument,e=this.namespaceURI;return e===zo&&t.documentElement.namespaceURI===zo?t.createElement(n):t.createElementNS(e,n)}function e(){return this.ownerDocument.createElementNS(n.space,n.local)}return"function"==typeof n?n:(n=ao.ns.qualify(n)).local?e:t}function F(){var n=this.parentNode;n&&n.removeChild(this)}function H(n){return{__data__:n}}function O(n){return function(){return Ao(this,n)}}function I(n){return arguments.length||(n=e),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function Y(n,t){for(var e=0,r=n.length;r>e;e++)for(var i,u=n[e],o=0,a=u.length;a>o;o++)(i=u[o])&&t(i,o,e);return n}function Z(n){return ko(n,qo),n}function V(n){var t,e;return function(r,i,u){var o,a=n[u].update,l=a.length;for(u!=e&&(e=u,t=0),i>=t&&(t=i+1);!(o=a[t])&&++t<l;);return o}}function X(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function i(){var i=l(t,co(arguments));r.call(this),this.addEventListener(n,this[o]=i,i.$=e),i._=t}function u(){var t,e=new RegExp("^__on([^.]+)"+ao.requote(n)+"$");for(var r in this)if(t=r.match(e)){var i=this[r];this.removeEventListener(t[1],i,i.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),l=$;a>0&&(n=n.slice(0,a));var c=To.get(n);return c&&(n=c,l=B),a?t?i:r:t?b:u}function $(n,t){return function(e){var r=ao.event;ao.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ao.event=r}}}function B(n,t){var e=$(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function W(e){var r=".dragsuppress-"+ ++Do,i="click"+r,u=ao.select(t(e)).on("touchmove"+r,S).on("dragstart"+r,S).on("selectstart"+r,S);if(null==Ro&&(Ro="onselectstart"in e?!1:x(e.style,"userSelect")),Ro){var o=n(e).style,a=o[Ro];o[Ro]="none"}return function(n){if(u.on(r,null),Ro&&(o[Ro]=a),n){var t=function(){u.on(i,null)};u.on(i,function(){S(),t()},!0),setTimeout(t,0)}}}function J(n,e){e.changedTouches&&(e=e.changedTouches[0]);var r=n.ownerSVGElement||n;if(r.createSVGPoint){var i=r.createSVGPoint();if(0>Po){var u=t(n);if(u.scrollX||u.scrollY){r=ao.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var o=r[0][0].getScreenCTM();Po=!(o.f||o.e),r.remove()}}return Po?(i.x=e.pageX,i.y=e.pageY):(i.x=e.clientX,i.y=e.clientY),i=i.matrixTransform(n.getScreenCTM().inverse()),[i.x,i.y]}var a=n.getBoundingClientRect();return[e.clientX-a.left-n.clientLeft,e.clientY-a.top-n.clientTop]}function G(){return ao.event.changedTouches[0].identifier}function K(n){return n>0?1:0>n?-1:0}function Q(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function nn(n){return n>1?0:-1>n?Fo:Math.acos(n)}function tn(n){return n>1?Io:-1>n?-Io:Math.asin(n)}function en(n){return((n=Math.exp(n))-1/n)/2}function rn(n){return((n=Math.exp(n))+1/n)/2}function un(n){return((n=Math.exp(2*n))-1)/(n+1)}function on(n){return(n=Math.sin(n/2))*n}function an(){}function ln(n,t,e){return this instanceof ln?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof ln?new ln(n.h,n.s,n.l):_n(""+n,wn,ln):new ln(n,t,e)}function cn(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?u+(o-u)*n/60:180>n?o:240>n?u+(o-u)*(240-n)/60:u}function i(n){return Math.round(255*r(n))}var u,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,u=2*e-o,new mn(i(n+120),i(n),i(n-120))}function fn(n,t,e){return this instanceof fn?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof fn?new fn(n.h,n.c,n.l):n instanceof hn?gn(n.l,n.a,n.b):gn((n=Sn((n=ao.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new fn(n,t,e)}function sn(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new hn(e,Math.cos(n*=Yo)*t,Math.sin(n)*t)}function hn(n,t,e){return this instanceof hn?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof hn?new hn(n.l,n.a,n.b):n instanceof fn?sn(n.h,n.c,n.l):Sn((n=mn(n)).r,n.g,n.b):new hn(n,t,e)}function pn(n,t,e){var r=(n+16)/116,i=r+t/500,u=r-e/200;return i=vn(i)*na,r=vn(r)*ta,u=vn(u)*ea,new mn(yn(3.2404542*i-1.5371385*r-.4985314*u),yn(-.969266*i+1.8760108*r+.041556*u),yn(.0556434*i-.2040259*r+1.0572252*u))}function gn(n,t,e){return n>0?new fn(Math.atan2(e,t)*Zo,Math.sqrt(t*t+e*e),n):new fn(NaN,NaN,n)}function vn(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function dn(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function yn(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function mn(n,t,e){return this instanceof mn?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof mn?new mn(n.r,n.g,n.b):_n(""+n,mn,cn):new mn(n,t,e)}function Mn(n){return new mn(n>>16,n>>8&255,255&n)}function xn(n){return Mn(n)+""}function bn(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function _n(n,t,e){var r,i,u,o=0,a=0,l=0;if(r=/([a-z]+)\((.*)\)/.exec(n=n.toLowerCase()))switch(i=r[2].split(","),r[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Nn(i[0]),Nn(i[1]),Nn(i[2]))}return(u=ua.get(n))?t(u.r,u.g,u.b):(null==n||"#"!==n.charAt(0)||isNaN(u=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&u)>>4,o=o>>4|o,a=240&u,a=a>>4|a,l=15&u,l=l<<4|l):7===n.length&&(o=(16711680&u)>>16,a=(65280&u)>>8,l=255&u)),t(o,a,l))}function wn(n,t,e){var r,i,u=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-u,l=(o+u)/2;return a?(i=.5>l?a/(o+u):a/(2-o-u),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=NaN,i=l>0&&1>l?0:r),new ln(r,i,l)}function Sn(n,t,e){n=kn(n),t=kn(t),e=kn(e);var r=dn((.4124564*n+.3575761*t+.1804375*e)/na),i=dn((.2126729*n+.7151522*t+.072175*e)/ta),u=dn((.0193339*n+.119192*t+.9503041*e)/ea);return hn(116*i-16,500*(r-i),200*(i-u))}function kn(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Nn(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function En(n){return"function"==typeof n?n:function(){return n}}function An(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Cn(t,e,n,r)}}function Cn(n,t,e,r){function i(){var n,t=l.status;if(!t&&Ln(l)||t>=200&&300>t||304===t){try{n=e.call(u,l)}catch(r){return void o.error.call(u,r)}o.load.call(u,n)}else o.error.call(u,l)}var u={},o=ao.dispatch("beforesend","progress","load","error"),a={},l=new XMLHttpRequest,c=null;return!this.XDomainRequest||"withCredentials"in l||!/^(http(s)?:)?\/\//.test(n)||(l=new XDomainRequest),"onload"in l?l.onload=l.onerror=i:l.onreadystatechange=function(){l.readyState>3&&i()},l.onprogress=function(n){var t=ao.event;ao.event=n;try{o.progress.call(u,l)}finally{ao.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.responseType=function(n){return arguments.length?(c=n,u):c},u.response=function(n){return e=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(co(arguments)))}}),u.send=function(e,r,i){if(2===arguments.length&&"function"==typeof r&&(i=r,r=null),l.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),l.setRequestHeader)for(var f in a)l.setRequestHeader(f,a[f]);return null!=t&&l.overrideMimeType&&l.overrideMimeType(t),null!=c&&(l.responseType=c),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),o.beforesend.call(u,l),l.send(null==r?null:r),u},u.abort=function(){return l.abort(),u},ao.rebind(u,o,"on"),null==r?u:u.get(zn(r))}function zn(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Ln(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qn(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var i=e+t,u={c:n,t:i,n:null};return aa?aa.n=u:oa=u,aa=u,la||(ca=clearTimeout(ca),la=1,fa(Tn)),u}function Tn(){var n=Rn(),t=Dn()-n;t>24?(isFinite(t)&&(clearTimeout(ca),ca=setTimeout(Tn,t)),la=0):(la=1,fa(Tn))}function Rn(){for(var n=Date.now(),t=oa;t;)n>=t.t&&t.c(n-t.t)&&(t.c=null),t=t.n;return n}function Dn(){for(var n,t=oa,e=1/0;t;)t.c?(t.t<e&&(e=t.t),t=(n=t).n):t=n?n.n=t.n:oa=t.n;return aa=n,e}function Pn(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Un(n,t){var e=Math.pow(10,3*xo(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function jn(n){var t=n.decimal,e=n.thousands,r=n.grouping,i=n.currency,u=r&&e?function(n,t){for(var i=n.length,u=[],o=0,a=r[0],l=0;i>0&&a>0&&(l+a+1>t&&(a=Math.max(1,t-l)),u.push(n.substring(i-=a,i+a)),!((l+=a+1)>t));)a=r[o=(o+1)%r.length];return u.reverse().join(e)}:m;return function(n){var e=ha.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",l=e[4]||"",c=e[5],f=+e[6],s=e[7],h=e[8],p=e[9],g=1,v="",d="",y=!1,m=!0;switch(h&&(h=+h.substring(1)),(c||"0"===r&&"="===o)&&(c=r="0",o="="),p){case"n":s=!0,p="g";break;case"%":g=100,d="%",p="f";break;case"p":g=100,d="%",p="r";break;case"b":case"o":case"x":case"X":"#"===l&&(v="0"+p.toLowerCase());case"c":m=!1;case"d":y=!0,h=0;break;case"s":g=-1,p="r"}"$"===l&&(v=i[0],d=i[1]),"r"!=p||h||(p="g"),null!=h&&("g"==p?h=Math.max(1,Math.min(21,h)):"e"!=p&&"f"!=p||(h=Math.max(0,Math.min(20,h)))),p=pa.get(p)||Fn;var M=c&&s;return function(n){var e=d;if(y&&n%1)return"";var i=0>n||0===n&&0>1/n?(n=-n,"-"):"-"===a?"":a;if(0>g){var l=ao.formatPrefix(n,h);n=l.scale(n),e=l.symbol+d}else n*=g;n=p(n,h);var x,b,_=n.lastIndexOf(".");if(0>_){var w=m?n.lastIndexOf("e"):-1;0>w?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!c&&s&&(x=u(x,1/0));var S=v.length+x.length+b.length+(M?0:i.length),k=f>S?new Array(S=f-S+1).join(r):"";return M&&(x=u(k+x,k.length?f-b.length:1/0)),i+=v,n=x+b,("<"===o?i+n+k:">"===o?k+i+n:"^"===o?k.substring(0,S>>=1)+i+n+k.substring(S):i+(M?n:k+n))+e}}}function Fn(n){return n+""}function Hn(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function On(n,t,e){function r(t){var e=n(t),r=u(e,1);return r-t>t-e?e:r}function i(e){return t(e=n(new va(e-1)),1),e}function u(n,e){return t(n=new va(+n),e),n}function o(n,r,u){var o=i(n),a=[];if(u>1)for(;r>o;)e(o)%u||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{va=Hn;var r=new Hn;return r._=n,o(r,t,e)}finally{va=Date}}n.floor=n,n.round=r,n.ceil=i,n.offset=u,n.range=o;var l=n.utc=In(n);return l.floor=l,l.round=In(r),l.ceil=In(i),l.offset=In(u),l.range=a,n}function In(n){return function(t,e){try{va=Hn;var r=new Hn;return r._=t,n(r,e)._}finally{va=Date}}}function Yn(n){function t(n){function t(t){for(var e,i,u,o=[],a=-1,l=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(l,a)),null!=(i=ya[e=n.charAt(++a)])&&(e=n.charAt(++a)),(u=A[e])&&(e=u(t,null==i?"e"===e?" ":"0":i)),o.push(e),l=a+1);return o.push(n.slice(l,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},i=e(r,n,t,0);if(i!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var u=null!=r.Z&&va!==Hn,o=new(u?Hn:va);return"j"in r?o.setFullYear(r.y,0,r.j):"W"in r||"U"in r?("w"in r||(r.w="W"in r?1:0),o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),u?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var i,u,o,a=0,l=t.length,c=e.length;l>a;){if(r>=c)return-1;if(i=t.charCodeAt(a++),37===i){if(o=t.charAt(a++),u=C[o in ya?t.charAt(a++):o],!u||(r=u(n,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){N.lastIndex=0;var r=N.exec(t.slice(e));return r?(n.m=E.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,A.c.toString(),t,r)}function l(n,t,r){return e(n,A.x.toString(),t,r)}function c(n,t,r){return e(n,A.X.toString(),t,r)}function f(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var s=n.dateTime,h=n.date,p=n.time,g=n.periods,v=n.days,d=n.shortDays,y=n.months,m=n.shortMonths;t.utc=function(n){function e(n){try{va=Hn;var t=new va;return t._=n,r(t)}finally{va=Date}}var r=t(n);return e.parse=function(n){try{va=Hn;var t=r.parse(n);return t&&t._}finally{va=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ct;var M=ao.map(),x=Vn(v),b=Xn(v),_=Vn(d),w=Xn(d),S=Vn(y),k=Xn(y),N=Vn(m),E=Xn(m);g.forEach(function(n,t){M.set(n.toLowerCase(),t)});var A={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return m[n.getMonth()]},B:function(n){return y[n.getMonth()]},c:t(s),d:function(n,t){return Zn(n.getDate(),t,2)},e:function(n,t){return Zn(n.getDate(),t,2)},H:function(n,t){return Zn(n.getHours(),t,2)},I:function(n,t){return Zn(n.getHours()%12||12,t,2)},j:function(n,t){return Zn(1+ga.dayOfYear(n),t,3)},L:function(n,t){return Zn(n.getMilliseconds(),t,3)},m:function(n,t){return Zn(n.getMonth()+1,t,2)},M:function(n,t){return Zn(n.getMinutes(),t,2)},p:function(n){return g[+(n.getHours()>=12)]},S:function(n,t){return Zn(n.getSeconds(),t,2)},U:function(n,t){return Zn(ga.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Zn(ga.mondayOfYear(n),t,2)},x:t(h),X:t(p),y:function(n,t){return Zn(n.getFullYear()%100,t,2)},Y:function(n,t){return Zn(n.getFullYear()%1e4,t,4)},Z:at,"%":function(){return"%"}},C={a:r,A:i,b:u,B:o,c:a,d:tt,e:tt,H:rt,I:rt,j:et,L:ot,m:nt,M:it,p:f,S:ut,U:Bn,w:$n,W:Wn,x:l,X:c,y:Gn,Y:Jn,Z:Kn,"%":lt};return t}function Zn(n,t,e){var r=0>n?"-":"",i=(r?-n:n)+"",u=i.length;return r+(e>u?new Array(e-u+1).join(t)+i:i)}function Vn(n){return new RegExp("^(?:"+n.map(ao.requote).join("|")+")","i")}function Xn(n){for(var t=new c,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function $n(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Bn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function Wn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Jn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Gn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.y=Qn(+r[0]),e+r[0].length):-1}function Kn(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Qn(n){return n+(n>68?1900:2e3)}function nt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function tt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function et(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function rt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function it(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function ut(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ot(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function at(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=xo(t)/60|0,i=xo(t)%60;return e+Zn(r,"0",2)+Zn(i,"0",2)}function lt(n,t,e){Ma.lastIndex=0;var r=Ma.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ct(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ft(){}function st(n,t,e){var r=e.s=n+t,i=r-n,u=r-i;e.t=n-u+(t-i)}function ht(n,t){n&&wa.hasOwnProperty(n.type)&&wa[n.type](n,t)}function pt(n,t,e){var r,i=-1,u=n.length-e;for(t.lineStart();++i<u;)r=n[i],t.point(r[0],r[1],r[2]);t.lineEnd()}function gt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)pt(n[e],t,1);t.polygonEnd()}function vt(){function n(n,t){n*=Yo,t=t*Yo/2+Fo/4;var e=n-r,o=e>=0?1:-1,a=o*e,l=Math.cos(t),c=Math.sin(t),f=u*c,s=i*l+f*Math.cos(a),h=f*o*Math.sin(a);ka.add(Math.atan2(h,s)),r=n,i=l,u=c}var t,e,r,i,u;Na.point=function(o,a){Na.point=n,r=(t=o)*Yo,i=Math.cos(a=(e=a)*Yo/2+Fo/4),u=Math.sin(a)},Na.lineEnd=function(){n(t,e)}}function dt(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function yt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function mt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Mt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function xt(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function bt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function _t(n){return[Math.atan2(n[1],n[0]),tn(n[2])]}function wt(n,t){return xo(n[0]-t[0])<Uo&&xo(n[1]-t[1])<Uo}function St(n,t){n*=Yo;var e=Math.cos(t*=Yo);kt(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function kt(n,t,e){++Ea,Ca+=(n-Ca)/Ea,za+=(t-za)/Ea,La+=(e-La)/Ea}function Nt(){function n(n,i){n*=Yo;var u=Math.cos(i*=Yo),o=u*Math.cos(n),a=u*Math.sin(n),l=Math.sin(i),c=Math.atan2(Math.sqrt((c=e*l-r*a)*c+(c=r*o-t*l)*c+(c=t*a-e*o)*c),t*o+e*a+r*l);Aa+=c,qa+=c*(t+(t=o)),Ta+=c*(e+(e=a)),Ra+=c*(r+(r=l)),kt(t,e,r)}var t,e,r;ja.point=function(i,u){i*=Yo;var o=Math.cos(u*=Yo);t=o*Math.cos(i),e=o*Math.sin(i),r=Math.sin(u),ja.point=n,kt(t,e,r)}}function Et(){ja.point=St}function At(){function n(n,t){n*=Yo;var e=Math.cos(t*=Yo),o=e*Math.cos(n),a=e*Math.sin(n),l=Math.sin(t),c=i*l-u*a,f=u*o-r*l,s=r*a-i*o,h=Math.sqrt(c*c+f*f+s*s),p=r*o+i*a+u*l,g=h&&-nn(p)/h,v=Math.atan2(h,p);Da+=g*c,Pa+=g*f,Ua+=g*s,Aa+=v,qa+=v*(r+(r=o)),Ta+=v*(i+(i=a)),Ra+=v*(u+(u=l)),kt(r,i,u)}var t,e,r,i,u;ja.point=function(o,a){t=o,e=a,ja.point=n,o*=Yo;var l=Math.cos(a*=Yo);r=l*Math.cos(o),i=l*Math.sin(o),u=Math.sin(a),kt(r,i,u)},ja.lineEnd=function(){n(t,e),ja.lineEnd=Et,ja.point=St}}function Ct(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function zt(){return!0}function Lt(n,t,e,r,i){var u=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(wt(e,r)){i.lineStart();for(var a=0;t>a;++a)i.point((e=n[a])[0],e[1]);return void i.lineEnd()}var l=new Tt(e,n,null,!0),c=new Tt(e,null,l,!1);l.o=c,u.push(l),o.push(c),l=new Tt(r,n,null,!1),c=new Tt(r,null,l,!0),l.o=c,u.push(l),o.push(c)}}),o.sort(t),qt(u),qt(o),u.length){for(var a=0,l=e,c=o.length;c>a;++a)o[a].e=l=!l;for(var f,s,h=u[0];;){for(var p=h,g=!0;p.v;)if((p=p.n)===h)return;f=p.z,i.lineStart();do{if(p.v=p.o.v=!0,p.e){if(g)for(var a=0,c=f.length;c>a;++a)i.point((s=f[a])[0],s[1]);else r(p.x,p.n.x,1,i);p=p.n}else{if(g){f=p.p.z;for(var a=f.length-1;a>=0;--a)i.point((s=f[a])[0],s[1])}else r(p.x,p.p.x,-1,i);p=p.p}p=p.o,f=p.z,g=!g}while(!p.v);i.lineEnd()}}}function qt(n){if(t=n.length){for(var t,e,r=0,i=n[0];++r<t;)i.n=e=n[r],e.p=i,i=e;i.n=e=n[0],e.p=i}}function Tt(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Rt(n,t,e,r){return function(i,u){function o(t,e){var r=i(t,e);n(t=r[0],e=r[1])&&u.point(t,e)}function a(n,t){var e=i(n,t);d.point(e[0],e[1])}function l(){m.point=a,d.lineStart()}function c(){m.point=o,d.lineEnd()}function f(n,t){v.push([n,t]);var e=i(n,t);x.point(e[0],e[1])}function s(){x.lineStart(),v=[]}function h(){f(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),g.push(v),v=null,r)if(1&t){n=e[0];var i,r=n.length-1,o=-1;if(r>0){for(b||(u.polygonStart(),b=!0),u.lineStart();++o<r;)u.point((i=n[o])[0],i[1]);u.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),p.push(e.filter(Dt))}var p,g,v,d=t(u),y=i.invert(r[0],r[1]),m={point:o,lineStart:l,lineEnd:c,polygonStart:function(){m.point=f,m.lineStart=s,m.lineEnd=h,p=[],g=[]},polygonEnd:function(){m.point=o,m.lineStart=l,m.lineEnd=c,p=ao.merge(p);var n=Ot(y,g);p.length?(b||(u.polygonStart(),b=!0),Lt(p,Ut,n,e,u)):n&&(b||(u.polygonStart(),b=!0),u.lineStart(),e(null,null,1,u),u.lineEnd()),b&&(u.polygonEnd(),b=!1),p=g=null},sphere:function(){u.polygonStart(),u.lineStart(),e(null,null,1,u),u.lineEnd(),u.polygonEnd()}},M=Pt(),x=t(M),b=!1;return m}}function Dt(n){return n.length>1}function Pt(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:b,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ut(n,t){return((n=n.x)[0]<0?n[1]-Io-Uo:Io-n[1])-((t=t.x)[0]<0?t[1]-Io-Uo:Io-t[1])}function jt(n){var t,e=NaN,r=NaN,i=NaN;return{lineStart:function(){n.lineStart(),t=1},point:function(u,o){var a=u>0?Fo:-Fo,l=xo(u-e);xo(l-Fo)<Uo?(n.point(e,r=(r+o)/2>0?Io:-Io),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(u,r),t=0):i!==a&&l>=Fo&&(xo(e-i)<Uo&&(e-=i*Uo),xo(u-a)<Uo&&(u-=a*Uo),r=Ft(e,r,u,o),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=u,r=o),i=a},lineEnd:function(){n.lineEnd(),e=r=NaN},clean:function(){return 2-t}}}function Ft(n,t,e,r){var i,u,o=Math.sin(n-e);return xo(o)>Uo?Math.atan((Math.sin(t)*(u=Math.cos(r))*Math.sin(e)-Math.sin(r)*(i=Math.cos(t))*Math.sin(n))/(i*u*o)):(t+r)/2}function Ht(n,t,e,r){var i;if(null==n)i=e*Io,r.point(-Fo,i),r.point(0,i),r.point(Fo,i),r.point(Fo,0),r.point(Fo,-i),r.point(0,-i),r.point(-Fo,-i),r.point(-Fo,0),r.point(-Fo,i);else if(xo(n[0]-t[0])>Uo){var u=n[0]<t[0]?Fo:-Fo;i=e*u/2,r.point(-u,i),r.point(0,i),r.point(u,i)}else r.point(t[0],t[1])}function Ot(n,t){var e=n[0],r=n[1],i=[Math.sin(e),-Math.cos(e),0],u=0,o=0;ka.reset();for(var a=0,l=t.length;l>a;++a){var c=t[a],f=c.length;if(f)for(var s=c[0],h=s[0],p=s[1]/2+Fo/4,g=Math.sin(p),v=Math.cos(p),d=1;;){d===f&&(d=0),n=c[d];var y=n[0],m=n[1]/2+Fo/4,M=Math.sin(m),x=Math.cos(m),b=y-h,_=b>=0?1:-1,w=_*b,S=w>Fo,k=g*M;if(ka.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),u+=S?b+_*Ho:b,S^h>=e^y>=e){var N=mt(dt(s),dt(n));bt(N);var E=mt(i,N);bt(E);var A=(S^b>=0?-1:1)*tn(E[2]);(r>A||r===A&&(N[0]||N[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=y,g=M,v=x,s=n}}return(-Uo>u||Uo>u&&-Uo>ka)^1&o}function It(n){function t(n,t){return Math.cos(n)*Math.cos(t)>u}function e(n){var e,u,l,c,f;return{lineStart:function(){c=l=!1,f=1},point:function(s,h){var p,g=[s,h],v=t(s,h),d=o?v?0:i(s,h):v?i(s+(0>s?Fo:-Fo),h):0;if(!e&&(c=l=v)&&n.lineStart(),v!==l&&(p=r(e,g),(wt(e,p)||wt(g,p))&&(g[0]+=Uo,g[1]+=Uo,v=t(g[0],g[1]))),v!==l)f=0,v?(n.lineStart(),p=r(g,e),n.point(p[0],p[1])):(p=r(e,g),n.point(p[0],p[1]),n.lineEnd()),e=p;else if(a&&e&&o^v){var y;d&u||!(y=r(g,e,!0))||(f=0,o?(n.lineStart(),n.point(y[0][0],y[0][1]),n.point(y[1][0],y[1][1]),n.lineEnd()):(n.point(y[1][0],y[1][1]),n.lineEnd(),n.lineStart(),n.point(y[0][0],y[0][1])))}!v||e&&wt(e,g)||n.point(g[0],g[1]),e=g,l=v,u=d},lineEnd:function(){l&&n.lineEnd(),e=null},clean:function(){return f|(c&&l)<<1}}}function r(n,t,e){var r=dt(n),i=dt(t),o=[1,0,0],a=mt(r,i),l=yt(a,a),c=a[0],f=l-c*c;if(!f)return!e&&n;var s=u*l/f,h=-u*c/f,p=mt(o,a),g=xt(o,s),v=xt(a,h);Mt(g,v);var d=p,y=yt(g,d),m=yt(d,d),M=y*y-m*(yt(g,g)-1);if(!(0>M)){var x=Math.sqrt(M),b=xt(d,(-y-x)/m);if(Mt(b,g),b=_t(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],N=t[1];w>S&&(_=w,w=S,S=_);var E=S-w,A=xo(E-Fo)<Uo,C=A||Uo>E;if(!A&&k>N&&(_=k,k=N,N=_),C?A?k+N>0^b[1]<(xo(b[0]-w)<Uo?k:N):k<=b[1]&&b[1]<=N:E>Fo^(w<=b[0]&&b[0]<=S)){var z=xt(d,(-y+x)/m);return Mt(z,g),[b,_t(z)]}}}function i(t,e){var r=o?n:Fo-n,i=0;return-r>t?i|=1:t>r&&(i|=2),-r>e?i|=4:e>r&&(i|=8),i}var u=Math.cos(n),o=u>0,a=xo(u)>Uo,l=ve(n,6*Yo);return Rt(t,e,l,o?[0,-n]:[-Fo,n-Fo])}function Yt(n,t,e,r){return function(i){var u,o=i.a,a=i.b,l=o.x,c=o.y,f=a.x,s=a.y,h=0,p=1,g=f-l,v=s-c;if(u=n-l,g||!(u>0)){if(u/=g,0>g){if(h>u)return;p>u&&(p=u)}else if(g>0){if(u>p)return;u>h&&(h=u)}if(u=e-l,g||!(0>u)){if(u/=g,0>g){if(u>p)return;u>h&&(h=u)}else if(g>0){if(h>u)return;p>u&&(p=u)}if(u=t-c,v||!(u>0)){if(u/=v,0>v){if(h>u)return;p>u&&(p=u)}else if(v>0){if(u>p)return;u>h&&(h=u)}if(u=r-c,v||!(0>u)){if(u/=v,0>v){if(u>p)return;u>h&&(h=u)}else if(v>0){if(h>u)return;p>u&&(p=u)}return h>0&&(i.a={x:l+h*g,y:c+h*v}),1>p&&(i.b={x:l+p*g,y:c+p*v}),i}}}}}}function Zt(n,t,e,r){function i(r,i){return xo(r[0]-n)<Uo?i>0?0:3:xo(r[0]-e)<Uo?i>0?2:1:xo(r[1]-t)<Uo?i>0?1:0:i>0?3:2}function u(n,t){return o(n.x,t.x)}function o(n,t){var e=i(n,1),r=i(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function l(n){for(var t=0,e=d.length,r=n[1],i=0;e>i;++i)for(var u,o=1,a=d[i],l=a.length,c=a[0];l>o;++o)u=a[o],c[1]<=r?u[1]>r&&Q(c,u,n)>0&&++t:u[1]<=r&&Q(c,u,n)<0&&--t,c=u;return 0!==t}function c(u,a,l,c){var f=0,s=0;if(null==u||(f=i(u,l))!==(s=i(a,l))||o(u,a)<0^l>0){do c.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+l+4)%4)!==s)}else c.point(a[0],a[1])}function f(i,u){return i>=n&&e>=i&&u>=t&&r>=u}function s(n,t){f(n,t)&&a.point(n,t)}function h(){C.point=g,d&&d.push(y=[]),S=!0,w=!1,b=_=NaN}function p(){v&&(g(m,M),x&&w&&E.rejoin(),v.push(E.buffer())),C.point=s,w&&a.lineEnd()}function g(n,t){n=Math.max(-Ha,Math.min(Ha,n)),t=Math.max(-Ha,Math.min(Ha,t));var e=f(n,t);if(d&&y.push([n,t]),S)m=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};A(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,y,m,M,x,b,_,w,S,k,N=a,E=Pt(),A=Yt(n,t,e,r),C={point:s,lineStart:h,lineEnd:p,polygonStart:function(){a=E,v=[],d=[],k=!0},polygonEnd:function(){a=N,v=ao.merge(v);var t=l([n,r]),e=k&&t,i=v.length;(e||i)&&(a.polygonStart(),e&&(a.lineStart(),c(null,null,1,a),a.lineEnd()),i&&Lt(v,u,t,c,a),a.polygonEnd()),v=d=y=null}};return C}}function Vt(n){var t=0,e=Fo/3,r=ae(n),i=r(t,e);return i.parallels=function(n){return arguments.length?r(t=n[0]*Fo/180,e=n[1]*Fo/180):[t/Fo*180,e/Fo*180]},i}function Xt(n,t){function e(n,t){var e=Math.sqrt(u-2*i*Math.sin(t))/i;return[e*Math.sin(n*=i),o-e*Math.cos(n)]}var r=Math.sin(n),i=(r+Math.sin(t))/2,u=1+r*(2*i-r),o=Math.sqrt(u)/i;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/i,tn((u-(n*n+e*e)*i*i)/(2*i))]},e}function $t(){function n(n,t){Ia+=i*n-r*t,r=n,i=t}var t,e,r,i;$a.point=function(u,o){$a.point=n,t=r=u,e=i=o},$a.lineEnd=function(){n(t,e)}}function Bt(n,t){Ya>n&&(Ya=n),n>Va&&(Va=n),Za>t&&(Za=t),t>Xa&&(Xa=t)}function Wt(){function n(n,t){o.push("M",n,",",t,u)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function i(){o.push("Z")}var u=Jt(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return u=Jt(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Jt(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Gt(n,t){Ca+=n,za+=t,++La}function Kt(){function n(n,r){var i=n-t,u=r-e,o=Math.sqrt(i*i+u*u);qa+=o*(t+n)/2,Ta+=o*(e+r)/2,Ra+=o,Gt(t=n,e=r)}var t,e;Wa.point=function(r,i){Wa.point=n,Gt(t=r,e=i)}}function Qt(){Wa.point=Gt}function ne(){function n(n,t){var e=n-r,u=t-i,o=Math.sqrt(e*e+u*u);qa+=o*(r+n)/2,Ta+=o*(i+t)/2,Ra+=o,o=i*n-r*t,Da+=o*(r+n),Pa+=o*(i+t),Ua+=3*o,Gt(r=n,i=t)}var t,e,r,i;Wa.point=function(u,o){Wa.point=n,Gt(t=r=u,e=i=o)},Wa.lineEnd=function(){n(t,e)}}function te(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,Ho)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function i(){a.point=t}function u(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:i,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=i,a.point=t},pointRadius:function(n){return o=n,a},result:b};return a}function ee(n){function t(n){return(a?r:e)(n)}function e(t){return ue(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=NaN,S.point=u,t.lineStart()}function u(e,r){var u=dt([e,r]),o=n(e,r);i(M,x,m,b,_,w,M=o[0],x=o[1],m=e,b=u[0],_=u[1],w=u[2],a,t),t.point(M,x)}function o(){S.point=e,t.lineEnd()}function l(){
r(),S.point=c,S.lineEnd=f}function c(n,t){u(s=n,h=t),p=M,g=x,v=b,d=_,y=w,S.point=u}function f(){i(M,x,m,b,_,w,p,g,s,v,d,y,a,t),S.lineEnd=o,o()}var s,h,p,g,v,d,y,m,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=l},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function i(t,e,r,a,l,c,f,s,h,p,g,v,d,y){var m=f-t,M=s-e,x=m*m+M*M;if(x>4*u&&d--){var b=a+p,_=l+g,w=c+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),N=xo(xo(w)-1)<Uo||xo(r-h)<Uo?(r+h)/2:Math.atan2(_,b),E=n(N,k),A=E[0],C=E[1],z=A-t,L=C-e,q=M*z-m*L;(q*q/x>u||xo((m*z+M*L)/x-.5)>.3||o>a*p+l*g+c*v)&&(i(t,e,r,a,l,c,A,C,N,b/=S,_/=S,w,d,y),y.point(A,C),i(A,C,N,b,_,w,f,s,h,p,g,v,d,y))}}var u=.5,o=Math.cos(30*Yo),a=16;return t.precision=function(n){return arguments.length?(a=(u=n*n)>0&&16,t):Math.sqrt(u)},t}function re(n){var t=ee(function(t,e){return n([t*Zo,e*Zo])});return function(n){return le(t(n))}}function ie(n){this.stream=n}function ue(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function oe(n){return ae(function(){return n})()}function ae(n){function t(n){return n=a(n[0]*Yo,n[1]*Yo),[n[0]*h+l,c-n[1]*h]}function e(n){return n=a.invert((n[0]-l)/h,(c-n[1])/h),n&&[n[0]*Zo,n[1]*Zo]}function r(){a=Ct(o=se(y,M,x),u);var n=u(v,d);return l=p-n[0]*h,c=g+n[1]*h,i()}function i(){return f&&(f.valid=!1,f=null),t}var u,o,a,l,c,f,s=ee(function(n,t){return n=u(n,t),[n[0]*h+l,c-n[1]*h]}),h=150,p=480,g=250,v=0,d=0,y=0,M=0,x=0,b=Fa,_=m,w=null,S=null;return t.stream=function(n){return f&&(f.valid=!1),f=le(b(o,s(_(n)))),f.valid=!0,f},t.clipAngle=function(n){return arguments.length?(b=null==n?(w=n,Fa):It((w=+n)*Yo),i()):w},t.clipExtent=function(n){return arguments.length?(S=n,_=n?Zt(n[0][0],n[0][1],n[1][0],n[1][1]):m,i()):S},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(p=+n[0],g=+n[1],r()):[p,g]},t.center=function(n){return arguments.length?(v=n[0]%360*Yo,d=n[1]%360*Yo,r()):[v*Zo,d*Zo]},t.rotate=function(n){return arguments.length?(y=n[0]%360*Yo,M=n[1]%360*Yo,x=n.length>2?n[2]%360*Yo:0,r()):[y*Zo,M*Zo,x*Zo]},ao.rebind(t,s,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function le(n){return ue(n,function(t,e){n.point(t*Yo,e*Yo)})}function ce(n,t){return[n,t]}function fe(n,t){return[n>Fo?n-Ho:-Fo>n?n+Ho:n,t]}function se(n,t,e){return n?t||e?Ct(pe(n),ge(t,e)):pe(n):t||e?ge(t,e):fe}function he(n){return function(t,e){return t+=n,[t>Fo?t-Ho:-Fo>t?t+Ho:t,e]}}function pe(n){var t=he(n);return t.invert=he(-n),t}function ge(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*r+a*i;return[Math.atan2(l*u-f*o,a*r-c*i),tn(f*u+l*o)]}var r=Math.cos(n),i=Math.sin(n),u=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*u-l*o;return[Math.atan2(l*u+c*o,a*r+f*i),tn(f*r-a*i)]},e}function ve(n,t){var e=Math.cos(n),r=Math.sin(n);return function(i,u,o,a){var l=o*t;null!=i?(i=de(e,i),u=de(e,u),(o>0?u>i:i>u)&&(i+=o*Ho)):(i=n+o*Ho,u=n-.5*l);for(var c,f=i;o>0?f>u:u>f;f-=l)a.point((c=_t([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function de(n,t){var e=dt(t);e[0]-=n,bt(e);var r=nn(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Uo)%(2*Math.PI)}function ye(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function me(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function Me(n){return n.source}function xe(n){return n.target}function be(n,t,e,r){var i=Math.cos(t),u=Math.sin(t),o=Math.cos(r),a=Math.sin(r),l=i*Math.cos(n),c=i*Math.sin(n),f=o*Math.cos(e),s=o*Math.sin(e),h=2*Math.asin(Math.sqrt(on(r-t)+i*o*on(e-n))),p=1/Math.sin(h),g=h?function(n){var t=Math.sin(n*=h)*p,e=Math.sin(h-n)*p,r=e*l+t*f,i=e*c+t*s,o=e*u+t*a;return[Math.atan2(i,r)*Zo,Math.atan2(o,Math.sqrt(r*r+i*i))*Zo]}:function(){return[n*Zo,t*Zo]};return g.distance=h,g}function _e(){function n(n,i){var u=Math.sin(i*=Yo),o=Math.cos(i),a=xo((n*=Yo)-t),l=Math.cos(a);Ja+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*u-e*o*l)*a),e*u+r*o*l),t=n,e=u,r=o}var t,e,r;Ga.point=function(i,u){t=i*Yo,e=Math.sin(u*=Yo),r=Math.cos(u),Ga.point=n},Ga.lineEnd=function(){Ga.point=Ga.lineEnd=b}}function we(n,t){function e(t,e){var r=Math.cos(t),i=Math.cos(e),u=n(r*i);return[u*i*Math.sin(t),u*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),i=t(r),u=Math.sin(i),o=Math.cos(i);return[Math.atan2(n*u,r*o),Math.asin(r&&e*u/r)]},e}function Se(n,t){function e(n,t){o>0?-Io+Uo>t&&(t=-Io+Uo):t>Io-Uo&&(t=Io-Uo);var e=o/Math.pow(i(t),u);return[e*Math.sin(u*n),o-e*Math.cos(u*n)]}var r=Math.cos(n),i=function(n){return Math.tan(Fo/4+n/2)},u=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(i(t)/i(n)),o=r*Math.pow(i(n),u)/u;return u?(e.invert=function(n,t){var e=o-t,r=K(u)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/u,2*Math.atan(Math.pow(o/r,1/u))-Io]},e):Ne}function ke(n,t){function e(n,t){var e=u-t;return[e*Math.sin(i*n),u-e*Math.cos(i*n)]}var r=Math.cos(n),i=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),u=r/i+n;return xo(i)<Uo?ce:(e.invert=function(n,t){var e=u-t;return[Math.atan2(n,e)/i,u-K(i)*Math.sqrt(n*n+e*e)]},e)}function Ne(n,t){return[n,Math.log(Math.tan(Fo/4+t/2))]}function Ee(n){var t,e=oe(n),r=e.scale,i=e.translate,u=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=i.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=u.apply(e,arguments);if(o===e){if(t=null==n){var a=Fo*r(),l=i();u([[l[0]-a,l[1]-a],[l[0]+a,l[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Ae(n,t){return[Math.log(Math.tan(Fo/4+t/2)),-n]}function Ce(n){return n[0]}function ze(n){return n[1]}function Le(n){for(var t=n.length,e=[0,1],r=2,i=2;t>i;i++){for(;r>1&&Q(n[e[r-2]],n[e[r-1]],n[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function qe(n,t){return n[0]-t[0]||n[1]-t[1]}function Te(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Re(n,t,e,r){var i=n[0],u=e[0],o=t[0]-i,a=r[0]-u,l=n[1],c=e[1],f=t[1]-l,s=r[1]-c,h=(a*(l-c)-s*(i-u))/(s*o-a*f);return[i+h*o,l+h*f]}function De(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Pe(){rr(this),this.edge=this.site=this.circle=null}function Ue(n){var t=cl.pop()||new Pe;return t.site=n,t}function je(n){Be(n),ol.remove(n),cl.push(n),rr(n)}function Fe(n){var t=n.circle,e=t.x,r=t.cy,i={x:e,y:r},u=n.P,o=n.N,a=[n];je(n);for(var l=u;l.circle&&xo(e-l.circle.x)<Uo&&xo(r-l.circle.cy)<Uo;)u=l.P,a.unshift(l),je(l),l=u;a.unshift(l),Be(l);for(var c=o;c.circle&&xo(e-c.circle.x)<Uo&&xo(r-c.circle.cy)<Uo;)o=c.N,a.push(c),je(c),c=o;a.push(c),Be(c);var f,s=a.length;for(f=1;s>f;++f)c=a[f],l=a[f-1],nr(c.edge,l.site,c.site,i);l=a[0],c=a[s-1],c.edge=Ke(l.site,c.site,null,i),$e(l),$e(c)}function He(n){for(var t,e,r,i,u=n.x,o=n.y,a=ol._;a;)if(r=Oe(a,o)-u,r>Uo)a=a.L;else{if(i=u-Ie(a,o),!(i>Uo)){r>-Uo?(t=a.P,e=a):i>-Uo?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var l=Ue(n);if(ol.insert(t,l),t||e){if(t===e)return Be(t),e=Ue(t.site),ol.insert(l,e),l.edge=e.edge=Ke(t.site,l.site),$e(t),void $e(e);if(!e)return void(l.edge=Ke(t.site,l.site));Be(t),Be(e);var c=t.site,f=c.x,s=c.y,h=n.x-f,p=n.y-s,g=e.site,v=g.x-f,d=g.y-s,y=2*(h*d-p*v),m=h*h+p*p,M=v*v+d*d,x={x:(d*m-p*M)/y+f,y:(h*M-v*m)/y+s};nr(e.edge,c,g,x),l.edge=Ke(c,n,null,x),e.edge=Ke(n,g,null,x),$e(t),$e(e)}}function Oe(n,t){var e=n.site,r=e.x,i=e.y,u=i-t;if(!u)return r;var o=n.P;if(!o)return-(1/0);e=o.site;var a=e.x,l=e.y,c=l-t;if(!c)return a;var f=a-r,s=1/u-1/c,h=f/c;return s?(-h+Math.sqrt(h*h-2*s*(f*f/(-2*c)-l+c/2+i-u/2)))/s+r:(r+a)/2}function Ie(n,t){var e=n.N;if(e)return Oe(e,t);var r=n.site;return r.y===t?r.x:1/0}function Ye(n){this.site=n,this.edges=[]}function Ze(n){for(var t,e,r,i,u,o,a,l,c,f,s=n[0][0],h=n[1][0],p=n[0][1],g=n[1][1],v=ul,d=v.length;d--;)if(u=v[d],u&&u.prepare())for(a=u.edges,l=a.length,o=0;l>o;)f=a[o].end(),r=f.x,i=f.y,c=a[++o%l].start(),t=c.x,e=c.y,(xo(r-t)>Uo||xo(i-e)>Uo)&&(a.splice(o,0,new tr(Qe(u.site,f,xo(r-s)<Uo&&g-i>Uo?{x:s,y:xo(t-s)<Uo?e:g}:xo(i-g)<Uo&&h-r>Uo?{x:xo(e-g)<Uo?t:h,y:g}:xo(r-h)<Uo&&i-p>Uo?{x:h,y:xo(t-h)<Uo?e:p}:xo(i-p)<Uo&&r-s>Uo?{x:xo(e-p)<Uo?t:s,y:p}:null),u.site,null)),++l)}function Ve(n,t){return t.angle-n.angle}function Xe(){rr(this),this.x=this.y=this.arc=this.site=this.cy=null}function $e(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,u=e.site;if(r!==u){var o=i.x,a=i.y,l=r.x-o,c=r.y-a,f=u.x-o,s=u.y-a,h=2*(l*s-c*f);if(!(h>=-jo)){var p=l*l+c*c,g=f*f+s*s,v=(s*p-c*g)/h,d=(l*g-f*p)/h,s=d+a,y=fl.pop()||new Xe;y.arc=n,y.site=i,y.x=v+o,y.y=s+Math.sqrt(v*v+d*d),y.cy=s,n.circle=y;for(var m=null,M=ll._;M;)if(y.y<M.y||y.y===M.y&&y.x<=M.x){if(!M.L){m=M.P;break}M=M.L}else{if(!M.R){m=M;break}M=M.R}ll.insert(m,y),m||(al=y)}}}}function Be(n){var t=n.circle;t&&(t.P||(al=t.N),ll.remove(t),fl.push(t),rr(t),n.circle=null)}function We(n){for(var t,e=il,r=Yt(n[0][0],n[0][1],n[1][0],n[1][1]),i=e.length;i--;)t=e[i],(!Je(t,n)||!r(t)||xo(t.a.x-t.b.x)<Uo&&xo(t.a.y-t.b.y)<Uo)&&(t.a=t.b=null,e.splice(i,1))}function Je(n,t){var e=n.b;if(e)return!0;var r,i,u=n.a,o=t[0][0],a=t[1][0],l=t[0][1],c=t[1][1],f=n.l,s=n.r,h=f.x,p=f.y,g=s.x,v=s.y,d=(h+g)/2,y=(p+v)/2;if(v===p){if(o>d||d>=a)return;if(h>g){if(u){if(u.y>=c)return}else u={x:d,y:l};e={x:d,y:c}}else{if(u){if(u.y<l)return}else u={x:d,y:c};e={x:d,y:l}}}else if(r=(h-g)/(v-p),i=y-r*d,-1>r||r>1)if(h>g){if(u){if(u.y>=c)return}else u={x:(l-i)/r,y:l};e={x:(c-i)/r,y:c}}else{if(u){if(u.y<l)return}else u={x:(c-i)/r,y:c};e={x:(l-i)/r,y:l}}else if(v>p){if(u){if(u.x>=a)return}else u={x:o,y:r*o+i};e={x:a,y:r*a+i}}else{if(u){if(u.x<o)return}else u={x:a,y:r*a+i};e={x:o,y:r*o+i}}return n.a=u,n.b=e,!0}function Ge(n,t){this.l=n,this.r=t,this.a=this.b=null}function Ke(n,t,e,r){var i=new Ge(n,t);return il.push(i),e&&nr(i,n,t,e),r&&nr(i,t,n,r),ul[n.i].edges.push(new tr(i,n,t)),ul[t.i].edges.push(new tr(i,t,n)),i}function Qe(n,t,e){var r=new Ge(n,null);return r.a=t,r.b=e,il.push(r),r}function nr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function tr(n,t,e){var r=n.a,i=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(i.x-r.x,r.y-i.y):Math.atan2(r.x-i.x,i.y-r.y)}function er(){this._=null}function rr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function ir(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ur(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function or(n){for(;n.L;)n=n.L;return n}function ar(n,t){var e,r,i,u=n.sort(lr).pop();for(il=[],ul=new Array(n.length),ol=new er,ll=new er;;)if(i=al,u&&(!i||u.y<i.y||u.y===i.y&&u.x<i.x))u.x===e&&u.y===r||(ul[u.i]=new Ye(u),He(u),e=u.x,r=u.y),u=n.pop();else{if(!i)break;Fe(i.arc)}t&&(We(t),Ze(t));var o={cells:ul,edges:il};return ol=ll=il=ul=null,o}function lr(n,t){return t.y-n.y||t.x-n.x}function cr(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function fr(n){return n.x}function sr(n){return n.y}function hr(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function pr(n,t,e,r,i,u){if(!n(t,e,r,i,u)){var o=.5*(e+i),a=.5*(r+u),l=t.nodes;l[0]&&pr(n,l[0],e,r,o,a),l[1]&&pr(n,l[1],o,r,i,a),l[2]&&pr(n,l[2],e,a,o,u),l[3]&&pr(n,l[3],o,a,i,u)}}function gr(n,t,e,r,i,u,o){var a,l=1/0;return function c(n,f,s,h,p){if(!(f>u||s>o||r>h||i>p)){if(g=n.point){var g,v=t-n.x,d=e-n.y,y=v*v+d*d;if(l>y){var m=Math.sqrt(l=y);r=t-m,i=e-m,u=t+m,o=e+m,a=g}}for(var M=n.nodes,x=.5*(f+h),b=.5*(s+p),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;k>S;++S)if(n=M[3&S])switch(3&S){case 0:c(n,f,s,x,b);break;case 1:c(n,x,s,h,b);break;case 2:c(n,f,b,x,p);break;case 3:c(n,x,b,h,p)}}}(n,r,i,u,o),a}function vr(n,t){n=ao.rgb(n),t=ao.rgb(t);var e=n.r,r=n.g,i=n.b,u=t.r-e,o=t.g-r,a=t.b-i;return function(n){return"#"+bn(Math.round(e+u*n))+bn(Math.round(r+o*n))+bn(Math.round(i+a*n))}}function dr(n,t){var e,r={},i={};for(e in n)e in t?r[e]=Mr(n[e],t[e]):i[e]=n[e];for(e in t)e in n||(i[e]=t[e]);return function(n){for(e in r)i[e]=r[e](n);return i}}function yr(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function mr(n,t){var e,r,i,u=hl.lastIndex=pl.lastIndex=0,o=-1,a=[],l=[];for(n+="",t+="";(e=hl.exec(n))&&(r=pl.exec(t));)(i=r.index)>u&&(i=t.slice(u,i),a[o]?a[o]+=i:a[++o]=i),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,l.push({i:o,x:yr(e,r)})),u=pl.lastIndex;return u<t.length&&(i=t.slice(u),a[o]?a[o]+=i:a[++o]=i),a.length<2?l[0]?(t=l[0].x,function(n){return t(n)+""}):function(){return t}:(t=l.length,function(n){for(var e,r=0;t>r;++r)a[(e=l[r]).i]=e.x(n);return a.join("")})}function Mr(n,t){for(var e,r=ao.interpolators.length;--r>=0&&!(e=ao.interpolators[r](n,t)););return e}function xr(n,t){var e,r=[],i=[],u=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(Mr(n[e],t[e]));for(;u>e;++e)i[e]=n[e];for(;o>e;++e)i[e]=t[e];return function(n){for(e=0;a>e;++e)i[e]=r[e](n);return i}}function br(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function _r(n){return function(t){return 1-n(1-t)}}function wr(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function Sr(n){return n*n}function kr(n){return n*n*n}function Nr(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function Ar(n){return 1-Math.cos(n*Io)}function Cr(n){return Math.pow(2,10*(n-1))}function zr(n){return 1-Math.sqrt(1-n*n)}function Lr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/Ho*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Ho/t)}}function qr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Tr(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Rr(n,t){n=ao.hcl(n),t=ao.hcl(t);var e=n.h,r=n.c,i=n.l,u=t.h-e,o=t.c-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return sn(e+u*n,r+o*n,i+a*n)+""}}function Dr(n,t){n=ao.hsl(n),t=ao.hsl(t);var e=n.h,r=n.s,i=n.l,u=t.h-e,o=t.s-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return cn(e+u*n,r+o*n,i+a*n)+""}}function Pr(n,t){n=ao.lab(n),t=ao.lab(t);var e=n.l,r=n.a,i=n.b,u=t.l-e,o=t.a-r,a=t.b-i;return function(n){return pn(e+u*n,r+o*n,i+a*n)+""}}function Ur(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function jr(n){var t=[n.a,n.b],e=[n.c,n.d],r=Hr(t),i=Fr(t,e),u=Hr(Or(e,t,-i))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,i*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Zo,this.translate=[n.e,n.f],this.scale=[r,u],this.skew=u?Math.atan2(i,u)*Zo:0}function Fr(n,t){return n[0]*t[0]+n[1]*t[1]}function Hr(n){var t=Math.sqrt(Fr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Or(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ir(n){return n.length?n.pop()+",":""}function Yr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push("translate(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else(t[0]||t[1])&&e.push("translate("+t+")")}function Zr(n,t,e,r){n!==t?(n-t>180?t+=360:t-n>180&&(n+=360),r.push({i:e.push(Ir(e)+"rotate(",null,")")-2,x:yr(n,t)})):t&&e.push(Ir(e)+"rotate("+t+")")}function Vr(n,t,e,r){n!==t?r.push({i:e.push(Ir(e)+"skewX(",null,")")-2,x:yr(n,t)}):t&&e.push(Ir(e)+"skewX("+t+")")}function Xr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push(Ir(e)+"scale(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else 1===t[0]&&1===t[1]||e.push(Ir(e)+"scale("+t+")")}function $r(n,t){var e=[],r=[];return n=ao.transform(n),t=ao.transform(t),Yr(n.translate,t.translate,e,r),Zr(n.rotate,t.rotate,e,r),Vr(n.skew,t.skew,e,r),Xr(n.scale,t.scale,e,r),n=t=null,function(n){for(var t,i=-1,u=r.length;++i<u;)e[(t=r[i]).i]=t.x(n);return e.join("")}}function Br(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Wr(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Jr(n){for(var t=n.source,e=n.target,r=Kr(t,e),i=[t];t!==r;)t=t.parent,i.push(t);for(var u=i.length;e!==r;)i.splice(u,0,e),e=e.parent;return i}function Gr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Kr(n,t){if(n===t)return n;for(var e=Gr(n),r=Gr(t),i=e.pop(),u=r.pop(),o=null;i===u;)o=i,i=e.pop(),u=r.pop();return o}function Qr(n){n.fixed|=2}function ni(n){n.fixed&=-7}function ti(n){n.fixed|=4,n.px=n.x,n.py=n.y}function ei(n){n.fixed&=-5}function ri(n,t,e){var r=0,i=0;if(n.charge=0,!n.leaf)for(var u,o=n.nodes,a=o.length,l=-1;++l<a;)u=o[l],null!=u&&(ri(u,t,e),n.charge+=u.charge,r+=u.charge*u.cx,i+=u.charge*u.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var c=t*e[n.point.index];n.charge+=n.pointCharge=c,r+=c*n.point.x,i+=c*n.point.y}n.cx=r/n.charge,n.cy=i/n.charge}function ii(n,t){return ao.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=fi,n}function ui(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(i=n.children)&&(r=i.length))for(var r,i;--r>=0;)e.push(i[r])}function oi(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(u=n.children)&&(i=u.length))for(var i,u,o=-1;++o<i;)e.push(u[o]);for(;null!=(n=r.pop());)t(n)}function ai(n){return n.children}function li(n){return n.value}function ci(n,t){return t.value-n.value}function fi(n){return ao.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function si(n){return n.x}function hi(n){return n.y}function pi(n,t,e){n.y0=t,n.y=e}function gi(n){return ao.range(n.length)}function vi(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function di(n){for(var t,e=1,r=0,i=n[0][1],u=n.length;u>e;++e)(t=n[e][1])>i&&(r=e,i=t);return r}function yi(n){return n.reduce(mi,0)}function mi(n,t){return n+t[1]}function Mi(n,t){return xi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function xi(n,t){for(var e=-1,r=+n[0],i=(n[1]-r)/t,u=[];++e<=t;)u[e]=i*e+r;return u}function bi(n){return[ao.min(n),ao.max(n)]}function _i(n,t){return n.value-t.value}function wi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Si(n,t){n._pack_next=t,t._pack_prev=n}function ki(n,t){var e=t.x-n.x,r=t.y-n.y,i=n.r+t.r;return.999*i*i>e*e+r*r}function Ni(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),p=Math.max(n.y+n.r,p)}if((e=n.children)&&(c=e.length)){var e,r,i,u,o,a,l,c,f=1/0,s=-(1/0),h=1/0,p=-(1/0);if(e.forEach(Ei),r=e[0],r.x=-r.r,r.y=0,t(r),c>1&&(i=e[1],i.x=i.r,i.y=0,t(i),c>2))for(u=e[2],zi(r,i,u),t(u),wi(r,u),r._pack_prev=u,wi(u,i),i=r._pack_next,o=3;c>o;o++){zi(r,i,u=e[o]);var g=0,v=1,d=1;for(a=i._pack_next;a!==i;a=a._pack_next,v++)if(ki(a,u)){g=1;break}if(1==g)for(l=r._pack_prev;l!==a._pack_prev&&!ki(l,u);l=l._pack_prev,d++);g?(d>v||v==d&&i.r<r.r?Si(r,i=a):Si(r=l,i),o--):(wi(r,u),i=u,t(u))}var y=(f+s)/2,m=(h+p)/2,M=0;for(o=0;c>o;o++)u=e[o],u.x-=y,u.y-=m,M=Math.max(M,u.r+Math.sqrt(u.x*u.x+u.y*u.y));n.r=M,e.forEach(Ai)}}function Ei(n){n._pack_next=n._pack_prev=n}function Ai(n){delete n._pack_next,delete n._pack_prev}function Ci(n,t,e,r){var i=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,i)for(var u=-1,o=i.length;++u<o;)Ci(i[u],t,e,r)}function zi(n,t,e){var r=n.r+e.r,i=t.x-n.x,u=t.y-n.y;if(r&&(i||u)){var o=t.r+e.r,a=i*i+u*u;o*=o,r*=r;var l=.5+(r-o)/(2*a),c=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+l*i+c*u,e.y=n.y+l*u-c*i}else e.x=n.x+r,e.y=n.y}function Li(n,t){return n.parent==t.parent?1:2}function qi(n){var t=n.children;return t.length?t[0]:n.t}function Ti(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ri(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Di(n){for(var t,e=0,r=0,i=n.children,u=i.length;--u>=0;)t=i[u],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Pi(n,t,e){return n.a.parent===t.parent?n.a:e}function Ui(n){return 1+ao.max(n,function(n){return n.y})}function ji(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Fi(n){var t=n.children;return t&&t.length?Fi(t[0]):n}function Hi(n){var t,e=n.children;return e&&(t=e.length)?Hi(e[t-1]):n}function Oi(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Ii(n,t){var e=n.x+t[3],r=n.y+t[0],i=n.dx-t[1]-t[3],u=n.dy-t[0]-t[2];return 0>i&&(e+=i/2,i=0),0>u&&(r+=u/2,u=0),{x:e,y:r,dx:i,dy:u}}function Yi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Zi(n){return n.rangeExtent?n.rangeExtent():Yi(n.range())}function Vi(n,t,e,r){var i=e(n[0],n[1]),u=r(t[0],t[1]);return function(n){return u(i(n))}}function Xi(n,t){var e,r=0,i=n.length-1,u=n[r],o=n[i];return u>o&&(e=r,r=i,i=e,e=u,u=o,o=e),n[r]=t.floor(u),n[i]=t.ceil(o),n}function $i(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:Sl}function Bi(n,t,e,r){var i=[],u=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)i.push(e(n[o-1],n[o])),u.push(r(t[o-1],t[o]));return function(t){var e=ao.bisect(n,t,1,a)-1;return u[e](i[e](t))}}function Wi(n,t,e,r){function i(){var i=Math.min(n.length,t.length)>2?Bi:Vi,l=r?Wr:Br;return o=i(n,t,l,e),a=i(t,n,l,Mr),u}function u(n){return o(n)}var o,a;return u.invert=function(n){return a(n)},u.domain=function(t){return arguments.length?(n=t.map(Number),i()):n},u.range=function(n){return arguments.length?(t=n,i()):t},u.rangeRound=function(n){return u.range(n).interpolate(Ur)},u.clamp=function(n){return arguments.length?(r=n,i()):r},u.interpolate=function(n){return arguments.length?(e=n,i()):e},u.ticks=function(t){return Qi(n,t)},u.tickFormat=function(t,e){return nu(n,t,e)},u.nice=function(t){return Gi(n,t),i()},u.copy=function(){return Wi(n,t,e,r)},i()}function Ji(n,t){return ao.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Gi(n,t){return Xi(n,$i(Ki(n,t)[2])),Xi(n,$i(Ki(n,t)[2])),n}function Ki(n,t){null==t&&(t=10);var e=Yi(n),r=e[1]-e[0],i=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),u=t/r*i;return.15>=u?i*=10:.35>=u?i*=5:.75>=u&&(i*=2),e[0]=Math.ceil(e[0]/i)*i,e[1]=Math.floor(e[1]/i)*i+.5*i,e[2]=i,e}function Qi(n,t){return ao.range.apply(ao,Ki(n,t))}function nu(n,t,e){var r=Ki(n,t);if(e){var i=ha.exec(e);if(i.shift(),"s"===i[8]){var u=ao.formatPrefix(Math.max(xo(r[0]),xo(r[1])));return i[7]||(i[7]="."+tu(u.scale(r[2]))),i[8]="f",e=ao.format(i.join("")),function(n){return e(u.scale(n))+u.symbol}}i[7]||(i[7]="."+eu(i[8],r)),e=i.join("")}else e=",."+tu(r[2])+"f";return ao.format(e)}function tu(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function eu(n,t){var e=tu(t[2]);return n in kl?Math.abs(e-tu(Math.max(xo(t[0]),xo(t[1]))))+ +("e"!==n):e-2*("%"===n)}function ru(n,t,e,r){function i(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function u(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(i(t))}return o.invert=function(t){return u(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(i)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(i)),o):t},o.nice=function(){var t=Xi(r.map(i),e?Math:El);return n.domain(t),r=t.map(u),o},o.ticks=function(){var n=Yi(r),o=[],a=n[0],l=n[1],c=Math.floor(i(a)),f=Math.ceil(i(l)),s=t%1?2:t;if(isFinite(f-c)){if(e){for(;f>c;c++)for(var h=1;s>h;h++)o.push(u(c)*h);o.push(u(c))}else for(o.push(u(c));c++<f;)for(var h=s-1;h>0;h--)o.push(u(c)*h);for(c=0;o[c]<a;c++);for(f=o.length;o[f-1]>l;f--);o=o.slice(c,f)}return o},o.tickFormat=function(n,e){if(!arguments.length)return Nl;arguments.length<2?e=Nl:"function"!=typeof e&&(e=ao.format(e));var r=Math.max(1,t*n/o.ticks().length);return function(n){var o=n/u(Math.round(i(n)));return t-.5>o*t&&(o*=t),r>=o?e(n):""}},o.copy=function(){return ru(n.copy(),t,e,r)},Ji(o,n)}function iu(n,t,e){function r(t){return n(i(t))}var i=uu(t),u=uu(1/t);return r.invert=function(t){return u(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(i)),r):e},r.ticks=function(n){return Qi(e,n)},r.tickFormat=function(n,t){return nu(e,n,t)},r.nice=function(n){return r.domain(Gi(e,n))},r.exponent=function(o){return arguments.length?(i=uu(t=o),u=uu(1/t),n.domain(e.map(i)),r):t},r.copy=function(){return iu(n.copy(),t,e)},Ji(r,n)}function uu(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function ou(n,t){function e(e){return u[((i.get(e)||("range"===t.t?i.set(e,n.push(e)):NaN))-1)%u.length]}function r(t,e){return ao.range(n.length).map(function(n){return t+e*n})}var i,u,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new c;for(var u,o=-1,a=r.length;++o<a;)i.has(u=r[o])||i.set(u,n.push(u));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(u=n,o=0,t={t:"range",a:arguments},e):u},e.rangePoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=(l+c)/2,0):(c-l)/(n.length-1+a);return u=r(l+f*a/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=c=Math.round((l+c)/2),0):(c-l)/(n.length-1+a)|0;return u=r(l+Math.round(f*a/2+(c-l-(n.length-1+a)*f)/2),f),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=(s-f)/(n.length-a+2*l);return u=r(f+h*l,h),c&&u.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=Math.floor((s-f)/(n.length-a+2*l));return u=r(f+Math.round((s-f-(n.length-a)*h)/2),h),c&&u.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Yi(t.a[0])},e.copy=function(){return ou(n,t)},e.domain(n)}function au(n,t){function u(){var e=0,r=t.length;for(a=[];++e<r;)a[e-1]=ao.quantile(n,e/r);return o}function o(n){return isNaN(n=+n)?void 0:t[ao.bisect(a,n)]}var a;return o.domain=function(t){return arguments.length?(n=t.map(r).filter(i).sort(e),u()):n},o.range=function(n){return arguments.length?(t=n,u()):t},o.quantiles=function(){return a},o.invertExtent=function(e){return e=t.indexOf(e),0>e?[NaN,NaN]:[e>0?a[e-1]:n[0],e<a.length?a[e]:n[n.length-1]]},o.copy=function(){return au(n,t)},u()}function lu(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(u*(t-n))))]}function i(){return u=e.length/(t-n),o=e.length-1,r}var u,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],i()):[n,t]},r.range=function(n){return arguments.length?(e=n,i()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?NaN:t/u+n,[t,t+1/u]},r.copy=function(){return lu(n,t,e)},i()}function cu(n,t){function e(e){return e>=e?t[ao.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return cu(n,t)},e}function fu(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Qi(n,t)},t.tickFormat=function(t,e){return nu(n,t,e)},t.copy=function(){return fu(n)},t}function su(){return 0}function hu(n){return n.innerRadius}function pu(n){return n.outerRadius}function gu(n){return n.startAngle}function vu(n){return n.endAngle}function du(n){return n&&n.padAngle}function yu(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function mu(n,t,e,r,i){var u=n[0]-t[0],o=n[1]-t[1],a=(i?r:-r)/Math.sqrt(u*u+o*o),l=a*o,c=-a*u,f=n[0]+l,s=n[1]+c,h=t[0]+l,p=t[1]+c,g=(f+h)/2,v=(s+p)/2,d=h-f,y=p-s,m=d*d+y*y,M=e-r,x=f*p-h*s,b=(0>y?-1:1)*Math.sqrt(Math.max(0,M*M*m-x*x)),_=(x*y-d*b)/m,w=(-x*d-y*b)/m,S=(x*y+d*b)/m,k=(-x*d+y*b)/m,N=_-g,E=w-v,A=S-g,C=k-v;return N*N+E*E>A*A+C*C&&(_=S,w=k),[[_-l,w-c],[_*e/M,w*e/M]]}function Mu(n){function t(t){function o(){c.push("M",u(n(f),a))}for(var l,c=[],f=[],s=-1,h=t.length,p=En(e),g=En(r);++s<h;)i.call(this,l=t[s],s)?f.push([+p.call(this,l,s),+g.call(this,l,s)]):f.length&&(o(),f=[]);return f.length&&o(),c.length?c.join(""):null}var e=Ce,r=ze,i=zt,u=xu,o=u.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(i=n,t):i},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?u=n:(u=Tl.get(n)||xu).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function xu(n){return n.length>1?n.join("L"):n+"Z"}function bu(n){return n.join("L")+"Z"}function _u(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&i.push("H",r[0]),i.join("")}function wu(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("V",(r=n[t])[1],"H",r[0]);return i.join("")}function Su(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r=n[t])[0],"V",r[1]);return i.join("")}function ku(n,t){return n.length<4?xu(n):n[1]+Au(n.slice(1,-1),Cu(n,t))}function Nu(n,t){return n.length<3?bu(n):n[0]+Au((n.push(n[0]),n),Cu([n[n.length-2]].concat(n,[n[1]]),t))}function Eu(n,t){return n.length<3?xu(n):n[0]+Au(n,Cu(n,t))}function Au(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return xu(n);var e=n.length!=t.length,r="",i=n[0],u=n[1],o=t[0],a=o,l=1;if(e&&(r+="Q"+(u[0]-2*o[0]/3)+","+(u[1]-2*o[1]/3)+","+u[0]+","+u[1],i=n[1],l=2),t.length>1){a=t[1],u=n[l],l++,r+="C"+(i[0]+o[0])+","+(i[1]+o[1])+","+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1];for(var c=2;c<t.length;c++,l++)u=n[l],a=t[c],r+="S"+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1]}if(e){var f=n[l];r+="Q"+(u[0]+2*a[0]/3)+","+(u[1]+2*a[1]/3)+","+f[0]+","+f[1]}return r}function Cu(n,t){for(var e,r=[],i=(1-t)/2,u=n[0],o=n[1],a=1,l=n.length;++a<l;)e=u,u=o,o=n[a],r.push([i*(o[0]-e[0]),i*(o[1]-e[1])]);return r}function zu(n){if(n.length<3)return xu(n);var t=1,e=n.length,r=n[0],i=r[0],u=r[1],o=[i,i,i,(r=n[1])[0]],a=[u,u,u,r[1]],l=[i,",",u,"L",Ru(Pl,o),",",Ru(Pl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Du(l,o,a);return n.pop(),l.push("L",r),l.join("")}function Lu(n){if(n.length<4)return xu(n);for(var t,e=[],r=-1,i=n.length,u=[0],o=[0];++r<3;)t=n[r],u.push(t[0]),o.push(t[1]);for(e.push(Ru(Pl,u)+","+Ru(Pl,o)),--r;++r<i;)t=n[r],u.shift(),u.push(t[0]),o.shift(),o.push(t[1]),Du(e,u,o);return e.join("")}function qu(n){for(var t,e,r=-1,i=n.length,u=i+4,o=[],a=[];++r<4;)e=n[r%i],o.push(e[0]),a.push(e[1]);for(t=[Ru(Pl,o),",",Ru(Pl,a)],--r;++r<u;)e=n[r%i],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Du(t,o,a);return t.join("")}function Tu(n,t){var e=n.length-1;if(e)for(var r,i,u=n[0][0],o=n[0][1],a=n[e][0]-u,l=n[e][1]-o,c=-1;++c<=e;)r=n[c],i=c/e,r[0]=t*r[0]+(1-t)*(u+i*a),r[1]=t*r[1]+(1-t)*(o+i*l);return zu(n)}function Ru(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Du(n,t,e){n.push("C",Ru(Rl,t),",",Ru(Rl,e),",",Ru(Dl,t),",",Ru(Dl,e),",",Ru(Pl,t),",",Ru(Pl,e))}function Pu(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Uu(n){for(var t=0,e=n.length-1,r=[],i=n[0],u=n[1],o=r[0]=Pu(i,u);++t<e;)r[t]=(o+(o=Pu(i=u,u=n[t+1])))/2;return r[t]=o,r}function ju(n){for(var t,e,r,i,u=[],o=Uu(n),a=-1,l=n.length-1;++a<l;)t=Pu(n[a],n[a+1]),xo(t)<Uo?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,i=e*e+r*r,i>9&&(i=3*t/Math.sqrt(i),o[a]=i*e,o[a+1]=i*r));for(a=-1;++a<=l;)i=(n[Math.min(l,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),u.push([i||0,o[a]*i||0]);return u}function Fu(n){return n.length<3?xu(n):n[0]+Au(n,ju(n))}function Hu(n){for(var t,e,r,i=-1,u=n.length;++i<u;)t=n[i],e=t[0],r=t[1]-Io,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Ou(n){function t(t){function l(){v.push("M",a(n(y),s),f,c(n(d.reverse()),s),"Z")}for(var h,p,g,v=[],d=[],y=[],m=-1,M=t.length,x=En(e),b=En(i),_=e===r?function(){
return p}:En(r),w=i===u?function(){return g}:En(u);++m<M;)o.call(this,h=t[m],m)?(d.push([p=+x.call(this,h,m),g=+b.call(this,h,m)]),y.push([+_.call(this,h,m),+w.call(this,h,m)])):d.length&&(l(),d=[],y=[]);return d.length&&l(),v.length?v.join(""):null}var e=Ce,r=Ce,i=0,u=ze,o=zt,a=xu,l=a.key,c=a,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(i=u=n,t):u},t.y0=function(n){return arguments.length?(i=n,t):i},t.y1=function(n){return arguments.length?(u=n,t):u},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(l="function"==typeof n?a=n:(a=Tl.get(n)||xu).key,c=a.reverse||a,f=a.closed?"M":"L",t):l},t.tension=function(n){return arguments.length?(s=n,t):s},t}function Iu(n){return n.radius}function Yu(n){return[n.x,n.y]}function Zu(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-Io;return[e*Math.cos(r),e*Math.sin(r)]}}function Vu(){return 64}function Xu(){return"circle"}function $u(n){var t=Math.sqrt(n/Fo);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Bu(n){return function(){var t,e,r;(t=this[n])&&(r=t[e=t.active])&&(r.timer.c=null,r.timer.t=NaN,--t.count?delete t[e]:delete this[n],t.active+=.5,r.event&&r.event.interrupt.call(this,this.__data__,r.index))}}function Wu(n,t,e){return ko(n,Yl),n.namespace=t,n.id=e,n}function Ju(n,t,e,r){var i=n.id,u=n.namespace;return Y(n,"function"==typeof e?function(n,o,a){n[u][i].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[u][i].tween.set(t,e)}))}function Gu(n){return null==n&&(n=""),function(){this.textContent=n}}function Ku(n){return null==n?"__transition__":"__transition_"+n+"__"}function Qu(n,t,e,r,i){function u(n){var t=v.delay;return f.t=t+l,n>=t?o(n-t):void(f.c=o)}function o(e){var i=g.active,u=g[i];u&&(u.timer.c=null,u.timer.t=NaN,--g.count,delete g[i],u.event&&u.event.interrupt.call(n,n.__data__,u.index));for(var o in g)if(r>+o){var c=g[o];c.timer.c=null,c.timer.t=NaN,--g.count,delete g[o]}f.c=a,qn(function(){return f.c&&a(e||1)&&(f.c=null,f.t=NaN),1},0,l),g.active=r,v.event&&v.event.start.call(n,n.__data__,t),p=[],v.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&p.push(r)}),h=v.ease,s=v.duration}function a(i){for(var u=i/s,o=h(u),a=p.length;a>0;)p[--a].call(n,o);return u>=1?(v.event&&v.event.end.call(n,n.__data__,t),--g.count?delete g[r]:delete n[e],1):void 0}var l,f,s,h,p,g=n[e]||(n[e]={active:0,count:0}),v=g[r];v||(l=i.time,f=qn(u,0,l),v=g[r]={tween:new c,time:l,timer:f,delay:i.delay,duration:i.duration,ease:i.ease,index:t},i=null,++g.count)}function no(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function to(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function eo(n){return n.toISOString()}function ro(n,t,e){function r(t){return n(t)}function i(n,e){var r=n[1]-n[0],i=r/e,u=ao.bisect(Kl,i);return u==Kl.length?[t.year,Ki(n.map(function(n){return n/31536e6}),e)[2]]:u?t[i/Kl[u-1]<Kl[u]/i?u-1:u]:[tc,Ki(n,e)[2]]}return r.invert=function(t){return io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,io(+e+1),t).length}var u=r.domain(),o=Yi(u),a=null==n?i(o,10):"number"==typeof n&&i(o,n);return a&&(n=a[0],t=a[1]),r.domain(Xi(u,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Yi(r.domain()),u=null==n?i(e,10):"number"==typeof n?i(e,n):!n.range&&[{range:n},t];return u&&(n=u[0],t=u[1]),n.range(e[0],io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return ro(n.copy(),t,e)},Ji(r,n)}function io(n){return new Date(n)}function uo(n){return JSON.parse(n.responseText)}function oo(n){var t=fo.createRange();return t.selectNode(fo.body),t.createContextualFragment(n.responseText)}var ao={version:"3.5.17"},lo=[].slice,co=function(n){return lo.call(n)},fo=this.document;if(fo)try{co(fo.documentElement.childNodes)[0].nodeType}catch(so){co=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),fo)try{fo.createElement("DIV").style.setProperty("opacity",0,"")}catch(ho){var po=this.Element.prototype,go=po.setAttribute,vo=po.setAttributeNS,yo=this.CSSStyleDeclaration.prototype,mo=yo.setProperty;po.setAttribute=function(n,t){go.call(this,n,t+"")},po.setAttributeNS=function(n,t,e){vo.call(this,n,t,e+"")},yo.setProperty=function(n,t,e){mo.call(this,n,t+"",e)}}ao.ascending=e,ao.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:NaN},ao.min=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&e>r&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&e>r&&(e=r)}return e},ao.max=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&r>e&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&r>e&&(e=r)}return e},ao.extent=function(n,t){var e,r,i,u=-1,o=n.length;if(1===arguments.length){for(;++u<o;)if(null!=(r=n[u])&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=n[u])&&(e>r&&(e=r),r>i&&(i=r))}else{for(;++u<o;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=t.call(n,n[u],u))&&(e>r&&(e=r),r>i&&(i=r))}return[e,i]},ao.sum=function(n,t){var e,r=0,u=n.length,o=-1;if(1===arguments.length)for(;++o<u;)i(e=+n[o])&&(r+=e);else for(;++o<u;)i(e=+t.call(n,n[o],o))&&(r+=e);return r},ao.mean=function(n,t){var e,u=0,o=n.length,a=-1,l=o;if(1===arguments.length)for(;++a<o;)i(e=r(n[a]))?u+=e:--l;else for(;++a<o;)i(e=r(t.call(n,n[a],a)))?u+=e:--l;return l?u/l:void 0},ao.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),i=+n[r-1],u=e-r;return u?i+u*(n[r]-i):i},ao.median=function(n,t){var u,o=[],a=n.length,l=-1;if(1===arguments.length)for(;++l<a;)i(u=r(n[l]))&&o.push(u);else for(;++l<a;)i(u=r(t.call(n,n[l],l)))&&o.push(u);return o.length?ao.quantile(o.sort(e),.5):void 0},ao.variance=function(n,t){var e,u,o=n.length,a=0,l=0,c=-1,f=0;if(1===arguments.length)for(;++c<o;)i(e=r(n[c]))&&(u=e-a,a+=u/++f,l+=u*(e-a));else for(;++c<o;)i(e=r(t.call(n,n[c],c)))&&(u=e-a,a+=u/++f,l+=u*(e-a));return f>1?l/(f-1):void 0},ao.deviation=function(){var n=ao.variance.apply(this,arguments);return n?Math.sqrt(n):n};var Mo=u(e);ao.bisectLeft=Mo.left,ao.bisect=ao.bisectRight=Mo.right,ao.bisector=function(n){return u(1===n.length?function(t,r){return e(n(t),r)}:n)},ao.shuffle=function(n,t,e){(u=arguments.length)<3&&(e=n.length,2>u&&(t=0));for(var r,i,u=e-t;u;)i=Math.random()*u--|0,r=n[u+t],n[u+t]=n[i+t],n[i+t]=r;return n},ao.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ao.pairs=function(n){for(var t,e=0,r=n.length-1,i=n[0],u=new Array(0>r?0:r);r>e;)u[e]=[t=i,i=n[++e]];return u},ao.transpose=function(n){if(!(i=n.length))return[];for(var t=-1,e=ao.min(n,o),r=new Array(e);++t<e;)for(var i,u=-1,a=r[t]=new Array(i);++u<i;)a[u]=n[u][t];return r},ao.zip=function(){return ao.transpose(arguments)},ao.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ao.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ao.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ao.merge=function(n){for(var t,e,r,i=n.length,u=-1,o=0;++u<i;)o+=n[u].length;for(e=new Array(o);--i>=0;)for(r=n[i],t=r.length;--t>=0;)e[--o]=r[t];return e};var xo=Math.abs;ao.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e===1/0)throw new Error("infinite range");var r,i=[],u=a(xo(e)),o=-1;if(n*=u,t*=u,e*=u,0>e)for(;(r=n+e*++o)>t;)i.push(r/u);else for(;(r=n+e*++o)<t;)i.push(r/u);return i},ao.map=function(n,t){var e=new c;if(n instanceof c)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,i=-1,u=n.length;if(1===arguments.length)for(;++i<u;)e.set(i,n[i]);else for(;++i<u;)e.set(t.call(n,r=n[i],i),r)}else for(var o in n)e.set(o,n[o]);return e};var bo="__proto__",_o="\x00";l(c,{has:h,get:function(n){return this._[f(n)]},set:function(n,t){return this._[f(n)]=t},remove:p,keys:g,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:s(t),value:this._[t]});return n},size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t),this._[t])}}),ao.nest=function(){function n(t,o,a){if(a>=u.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,p=-1,g=o.length,v=u[a++],d=new c;++p<g;)(h=d.get(l=v(f=o[p])))?h.push(f):d.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,a))}):(f={},s=function(e,r){f[e]=n(t,r,a)}),d.forEach(s),f}function t(n,e){if(e>=u.length)return n;var r=[],i=o[e++];return n.forEach(function(n,i){r.push({key:n,values:t(i,e)})}),i?r.sort(function(n,t){return i(n.key,t.key)}):r}var e,r,i={},u=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(ao.map,e,0),0)},i.key=function(n){return u.push(n),i},i.sortKeys=function(n){return o[u.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},ao.set=function(n){var t=new y;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},l(y,{has:h,add:function(n){return this._[f(n+="")]=!0,n},remove:p,values:g,size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t))}}),ao.behavior={},ao.rebind=function(n,t){for(var e,r=1,i=arguments.length;++r<i;)n[e=arguments[r]]=M(n,t,t[e]);return n};var wo=["webkit","ms","moz","Moz","o","O"];ao.dispatch=function(){for(var n=new _,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=w(n);return n},_.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ao.event=null,ao.requote=function(n){return n.replace(So,"\\$&")};var So=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,ko={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},No=function(n,t){return t.querySelector(n)},Eo=function(n,t){return t.querySelectorAll(n)},Ao=function(n,t){var e=n.matches||n[x(n,"matchesSelector")];return(Ao=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(No=function(n,t){return Sizzle(n,t)[0]||null},Eo=Sizzle,Ao=Sizzle.matchesSelector),ao.selection=function(){return ao.select(fo.documentElement)};var Co=ao.selection.prototype=[];Co.select=function(n){var t,e,r,i,u=[];n=A(n);for(var o=-1,a=this.length;++o<a;){u.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var l=-1,c=r.length;++l<c;)(i=r[l])?(t.push(e=n.call(i,i.__data__,l,o)),e&&"__data__"in i&&(e.__data__=i.__data__)):t.push(null)}return E(u)},Co.selectAll=function(n){var t,e,r=[];n=C(n);for(var i=-1,u=this.length;++i<u;)for(var o=this[i],a=-1,l=o.length;++a<l;)(e=o[a])&&(r.push(t=co(n.call(e,e.__data__,a,i))),t.parentNode=e);return E(r)};var zo="http://www.w3.org/1999/xhtml",Lo={svg:"http://www.w3.org/2000/svg",xhtml:zo,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ao.ns={prefix:Lo,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),Lo.hasOwnProperty(e)?{space:Lo[e],local:n}:n}},Co.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ao.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(z(t,n[t]));return this}return this.each(z(n,t))},Co.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=T(n)).length,i=-1;if(t=e.classList){for(;++i<r;)if(!t.contains(n[i]))return!1}else for(t=e.getAttribute("class");++i<r;)if(!q(n[i]).test(t))return!1;return!0}for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},Co.style=function(n,e,r){var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(e="");for(r in n)this.each(P(r,n[r],e));return this}if(2>i){var u=this.node();return t(u).getComputedStyle(u,null).getPropertyValue(n)}r=""}return this.each(P(n,e,r))},Co.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(U(t,n[t]));return this}return this.each(U(n,t))},Co.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Co.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Co.append=function(n){return n=j(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},Co.insert=function(n,t){return n=j(n),t=A(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},Co.remove=function(){return this.each(F)},Co.data=function(n,t){function e(n,e){var r,i,u,o=n.length,s=e.length,h=Math.min(o,s),p=new Array(s),g=new Array(s),v=new Array(o);if(t){var d,y=new c,m=new Array(o);for(r=-1;++r<o;)(i=n[r])&&(y.has(d=t.call(i,i.__data__,r))?v[r]=i:y.set(d,i),m[r]=d);for(r=-1;++r<s;)(i=y.get(d=t.call(e,u=e[r],r)))?i!==!0&&(p[r]=i,i.__data__=u):g[r]=H(u),y.set(d,!0);for(r=-1;++r<o;)r in m&&y.get(m[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],u=e[r],i?(i.__data__=u,p[r]=i):g[r]=H(u);for(;s>r;++r)g[r]=H(e[r]);for(;o>r;++r)v[r]=n[r]}g.update=p,g.parentNode=p.parentNode=v.parentNode=n.parentNode,a.push(g),l.push(p),f.push(v)}var r,i,u=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++u<o;)(i=r[u])&&(n[u]=i.__data__);return n}var a=Z([]),l=E([]),f=E([]);if("function"==typeof n)for(;++u<o;)e(r=this[u],n.call(r,r.parentNode.__data__,u));else for(;++u<o;)e(r=this[u],n);return l.enter=function(){return a},l.exit=function(){return f},l},Co.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Co.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]),t.parentNode=(e=this[u]).parentNode;for(var a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return E(i)},Co.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],i=r.length-1,u=r[i];--i>=0;)(e=r[i])&&(u&&u!==e.nextSibling&&u.parentNode.insertBefore(e,u),u=e);return this},Co.sort=function(n){n=I.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Co.each=function(n){return Y(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Co.call=function(n){var t=co(arguments);return n.apply(t[0]=this,t),this},Co.empty=function(){return!this.node()},Co.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,i=e.length;i>r;r++){var u=e[r];if(u)return u}return null},Co.size=function(){var n=0;return Y(this,function(){++n}),n};var qo=[];ao.selection.enter=Z,ao.selection.enter.prototype=qo,qo.append=Co.append,qo.empty=Co.empty,qo.node=Co.node,qo.call=Co.call,qo.size=Co.size,qo.select=function(n){for(var t,e,r,i,u,o=[],a=-1,l=this.length;++a<l;){r=(i=this[a]).update,o.push(t=[]),t.parentNode=i.parentNode;for(var c=-1,f=i.length;++c<f;)(u=i[c])?(t.push(r[c]=e=n.call(i.parentNode,u.__data__,c,a)),e.__data__=u.__data__):t.push(null)}return E(o)},qo.insert=function(n,t){return arguments.length<2&&(t=V(this)),Co.insert.call(this,n,t)},ao.select=function(t){var e;return"string"==typeof t?(e=[No(t,fo)],e.parentNode=fo.documentElement):(e=[t],e.parentNode=n(t)),E([e])},ao.selectAll=function(n){var t;return"string"==typeof n?(t=co(Eo(n,fo)),t.parentNode=fo.documentElement):(t=co(n),t.parentNode=null),E([t])},Co.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(X(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(X(n,t,e))};var To=ao.map({mouseenter:"mouseover",mouseleave:"mouseout"});fo&&To.forEach(function(n){"on"+n in fo&&To.remove(n)});var Ro,Do=0;ao.mouse=function(n){return J(n,k())};var Po=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;ao.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=k().changedTouches),t)for(var r,i=0,u=t.length;u>i;++i)if((r=t[i]).identifier===e)return J(n,r)},ao.behavior.drag=function(){function n(){this.on("mousedown.drag",u).on("touchstart.drag",o)}function e(n,t,e,u,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],g|=n|e,M=r,p({type:"drag",x:r[0]+c[0],y:r[1]+c[1],dx:n,dy:e}))}function l(){t(h,v)&&(y.on(u+d,null).on(o+d,null),m(g),p({type:"dragend"}))}var c,f=this,s=ao.event.target.correspondingElement||ao.event.target,h=f.parentNode,p=r.of(f,arguments),g=0,v=n(),d=".drag"+(null==v?"":"-"+v),y=ao.select(e(s)).on(u+d,a).on(o+d,l),m=W(s),M=t(h,v);i?(c=i.apply(f,arguments),c=[c.x-M[0],c.y-M[1]]):c=[0,0],p({type:"dragstart"})}}var r=N(n,"drag","dragstart","dragend"),i=null,u=e(b,ao.mouse,t,"mousemove","mouseup"),o=e(G,ao.touch,m,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},ao.rebind(n,r,"on")},ao.touches=function(n,t){return arguments.length<2&&(t=k().touches),t?co(t).map(function(t){var e=J(n,t);return e.identifier=t.identifier,e}):[]};var Uo=1e-6,jo=Uo*Uo,Fo=Math.PI,Ho=2*Fo,Oo=Ho-Uo,Io=Fo/2,Yo=Fo/180,Zo=180/Fo,Vo=Math.SQRT2,Xo=2,$o=4;ao.interpolateZoom=function(n,t){var e,r,i=n[0],u=n[1],o=n[2],a=t[0],l=t[1],c=t[2],f=a-i,s=l-u,h=f*f+s*s;if(jo>h)r=Math.log(c/o)/Vo,e=function(n){return[i+n*f,u+n*s,o*Math.exp(Vo*n*r)]};else{var p=Math.sqrt(h),g=(c*c-o*o+$o*h)/(2*o*Xo*p),v=(c*c-o*o-$o*h)/(2*c*Xo*p),d=Math.log(Math.sqrt(g*g+1)-g),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-d)/Vo,e=function(n){var t=n*r,e=rn(d),a=o/(Xo*p)*(e*un(Vo*t+d)-en(d));return[i+a*f,u+a*s,o*e/rn(Vo*t+d)]}}return e.duration=1e3*r,e},ao.behavior.zoom=function(){function n(n){n.on(L,s).on(Wo+".zoom",p).on("dblclick.zoom",g).on(R,h)}function e(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function r(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function i(n){k.k=Math.max(A[0],Math.min(A[1],n))}function u(n,t){t=r(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function o(t,e,r,o){t.__chart__={x:k.x,y:k.y,k:k.k},i(Math.pow(2,o)),u(d=e,r),t=ao.select(t),C>0&&(t=t.transition().duration(C)),t.call(n.event)}function a(){b&&b.domain(x.range().map(function(n){return(n-k.x)/k.k}).map(x.invert)),w&&w.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function l(n){z++||n({type:"zoomstart"})}function c(n){a(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function f(n){--z||(n({type:"zoomend"}),d=null)}function s(){function n(){a=1,u(ao.mouse(i),h),c(o)}function r(){s.on(q,null).on(T,null),p(a),f(o)}var i=this,o=D.of(i,arguments),a=0,s=ao.select(t(i)).on(q,n).on(T,r),h=e(ao.mouse(i)),p=W(i);Il.call(i),l(o)}function h(){function n(){var n=ao.touches(g);return p=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=e(n))}),n}function t(){var t=ao.event.target;ao.select(t).on(x,r).on(b,a),_.push(t);for(var e=ao.event.changedTouches,i=0,u=e.length;u>i;++i)d[e[i].identifier]=null;var l=n(),c=Date.now();if(1===l.length){if(500>c-M){var f=l[0];o(g,f,d[f.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),S()}M=c}else if(l.length>1){var f=l[0],s=l[1],h=f[0]-s[0],p=f[1]-s[1];y=h*h+p*p}}function r(){var n,t,e,r,o=ao.touches(g);Il.call(g);for(var a=0,l=o.length;l>a;++a,r=null)if(e=o[a],r=d[e.identifier]){if(t)break;n=e,t=r}if(r){var f=(f=e[0]-n[0])*f+(f=e[1]-n[1])*f,s=y&&Math.sqrt(f/y);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+r[0])/2,(t[1]+r[1])/2],i(s*p)}M=null,u(n,t),c(v)}function a(){if(ao.event.touches.length){for(var t=ao.event.changedTouches,e=0,r=t.length;r>e;++e)delete d[t[e].identifier];for(var i in d)return void n()}ao.selectAll(_).on(m,null),w.on(L,s).on(R,h),N(),f(v)}var p,g=this,v=D.of(g,arguments),d={},y=0,m=".zoom-"+ao.event.changedTouches[0].identifier,x="touchmove"+m,b="touchend"+m,_=[],w=ao.select(g),N=W(g);t(),l(v),w.on(L,null).on(R,t)}function p(){var n=D.of(this,arguments);m?clearTimeout(m):(Il.call(this),v=e(d=y||ao.mouse(this)),l(n)),m=setTimeout(function(){m=null,f(n)},50),S(),i(Math.pow(2,.002*Bo())*k.k),u(d,v),c(n)}function g(){var n=ao.mouse(this),t=Math.log(k.k)/Math.LN2;o(this,n,e(n),ao.event.shiftKey?Math.ceil(t)-1:Math.floor(t)+1)}var v,d,y,m,M,x,b,_,w,k={x:0,y:0,k:1},E=[960,500],A=Jo,C=250,z=0,L="mousedown.zoom",q="mousemove.zoom",T="mouseup.zoom",R="touchstart.zoom",D=N(n,"zoomstart","zoom","zoomend");return Wo||(Wo="onwheel"in fo?(Bo=function(){return-ao.event.deltaY*(ao.event.deltaMode?120:1)},"wheel"):"onmousewheel"in fo?(Bo=function(){return ao.event.wheelDelta},"mousewheel"):(Bo=function(){return-ao.event.detail},"MozMousePixelScroll")),n.event=function(n){n.each(function(){var n=D.of(this,arguments),t=k;Hl?ao.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},l(n)}).tween("zoom:zoom",function(){var e=E[0],r=E[1],i=d?d[0]:e/2,u=d?d[1]:r/2,o=ao.interpolateZoom([(i-k.x)/k.k,(u-k.y)/k.k,e/k.k],[(i-t.x)/t.k,(u-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:i-r[0]*a,y:u-r[1]*a,k:a},c(n)}}).each("interrupt.zoom",function(){f(n)}).each("end.zoom",function(){f(n)}):(this.__chart__=k,l(n),c(n),f(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},a(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:null},i(+t),a(),n):k.k},n.scaleExtent=function(t){return arguments.length?(A=null==t?Jo:[+t[0],+t[1]],n):A},n.center=function(t){return arguments.length?(y=t&&[+t[0],+t[1]],n):y},n.size=function(t){return arguments.length?(E=t&&[+t[0],+t[1]],n):E},n.duration=function(t){return arguments.length?(C=+t,n):C},n.x=function(t){return arguments.length?(b=t,x=t.copy(),k={x:0,y:0,k:1},n):b},n.y=function(t){return arguments.length?(w=t,_=t.copy(),k={x:0,y:0,k:1},n):w},ao.rebind(n,D,"on")};var Bo,Wo,Jo=[0,1/0];ao.color=an,an.prototype.toString=function(){return this.rgb()+""},ao.hsl=ln;var Go=ln.prototype=new an;Go.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,this.l/n)},Go.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,n*this.l)},Go.rgb=function(){return cn(this.h,this.s,this.l)},ao.hcl=fn;var Ko=fn.prototype=new an;Ko.brighter=function(n){return new fn(this.h,this.c,Math.min(100,this.l+Qo*(arguments.length?n:1)))},Ko.darker=function(n){return new fn(this.h,this.c,Math.max(0,this.l-Qo*(arguments.length?n:1)))},Ko.rgb=function(){return sn(this.h,this.c,this.l).rgb()},ao.lab=hn;var Qo=18,na=.95047,ta=1,ea=1.08883,ra=hn.prototype=new an;ra.brighter=function(n){return new hn(Math.min(100,this.l+Qo*(arguments.length?n:1)),this.a,this.b)},ra.darker=function(n){return new hn(Math.max(0,this.l-Qo*(arguments.length?n:1)),this.a,this.b)},ra.rgb=function(){return pn(this.l,this.a,this.b)},ao.rgb=mn;var ia=mn.prototype=new an;ia.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,i=30;return t||e||r?(t&&i>t&&(t=i),e&&i>e&&(e=i),r&&i>r&&(r=i),new mn(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new mn(i,i,i)},ia.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new mn(n*this.r,n*this.g,n*this.b)},ia.hsl=function(){return wn(this.r,this.g,this.b)},ia.toString=function(){return"#"+bn(this.r)+bn(this.g)+bn(this.b)};var ua=ao.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});ua.forEach(function(n,t){ua.set(n,Mn(t))}),ao.functor=En,ao.xhr=An(m),ao.dsv=function(n,t){function e(n,e,u){arguments.length<3&&(u=e,e=null);var o=Cn(n,t,null==e?r:i(e),u);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:i(n)):e},o}function r(n){return e.parse(n.responseText)}function i(n){return function(t){return e.parse(t.responseText,n)}}function u(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var i=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(i(n),e)}:i})},e.parseRows=function(n,t){function e(){if(f>=c)return o;if(i)return i=!1,u;var t=f;if(34===n.charCodeAt(t)){for(var e=t;e++<c;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(i=!0,10===n.charCodeAt(e+2)&&++f):10===r&&(i=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;c>f;){var r=n.charCodeAt(f++),a=1;if(10===r)i=!0;else if(13===r)i=!0,10===n.charCodeAt(f)&&(++f,++a);else if(r!==l)continue;return n.slice(t,f-a)}return n.slice(t)}for(var r,i,u={},o={},a=[],c=n.length,f=0,s=0;(r=e())!==o;){for(var h=[];r!==u&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,s++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new y,i=[];return t.forEach(function(n){for(var t in n)r.has(t)||i.push(r.add(t))}),[i.map(o).join(n)].concat(t.map(function(t){return i.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(u).join("\n")},e},ao.csv=ao.dsv(",","text/csv"),ao.tsv=ao.dsv("	","text/tab-separated-values");var oa,aa,la,ca,fa=this[x(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ao.timer=function(){qn.apply(this,arguments)},ao.timer.flush=function(){Rn(),Dn()},ao.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var sa=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Un);ao.formatPrefix=function(n,t){var e=0;return(n=+n)&&(0>n&&(n*=-1),t&&(n=ao.round(n,Pn(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),sa[8+e/3]};var ha=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,pa=ao.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ao.round(n,Pn(n,t))).toFixed(Math.max(0,Math.min(20,Pn(n*(1+1e-15),t))))}}),ga=ao.time={},va=Date;Hn.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){da.setUTCDate.apply(this._,arguments)},setDay:function(){da.setUTCDay.apply(this._,arguments)},setFullYear:function(){da.setUTCFullYear.apply(this._,arguments)},setHours:function(){da.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){da.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){da.setUTCMinutes.apply(this._,arguments)},setMonth:function(){da.setUTCMonth.apply(this._,arguments)},setSeconds:function(){da.setUTCSeconds.apply(this._,arguments)},setTime:function(){da.setTime.apply(this._,arguments)}};var da=Date.prototype;ga.year=On(function(n){return n=ga.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),ga.years=ga.year.range,ga.years.utc=ga.year.utc.range,ga.day=On(function(n){var t=new va(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),ga.days=ga.day.range,ga.days.utc=ga.day.utc.range,ga.dayOfYear=function(n){var t=ga.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=ga[n]=On(function(n){return(n=ga.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});ga[n+"s"]=e.range,ga[n+"s"].utc=e.utc.range,ga[n+"OfYear"]=function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)}}),ga.week=ga.sunday,ga.weeks=ga.sunday.range,ga.weeks.utc=ga.sunday.utc.range,ga.weekOfYear=ga.sundayOfYear;var ya={"-":"",_:" ",0:"0"},ma=/^\s*\d+/,Ma=/^%/;ao.locale=function(n){return{numberFormat:jn(n),timeFormat:Yn(n)}};var xa=ao.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ao.format=xa.numberFormat,ao.geo={},ft.prototype={s:0,t:0,add:function(n){st(n,this.t,ba),st(ba.s,this.s,this),this.s?this.t+=ba.t:this.s=ba.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var ba=new ft;ao.geo.stream=function(n,t){n&&_a.hasOwnProperty(n.type)?_a[n.type](n,t):ht(n,t)};var _a={Feature:function(n,t){ht(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,i=e.length;++r<i;)ht(e[r].geometry,t)}},wa={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){pt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)pt(e[r],t,0)},Polygon:function(n,t){gt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)gt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,i=e.length;++r<i;)ht(e[r],t)}};ao.geo.area=function(n){return Sa=0,ao.geo.stream(n,Na),Sa};var Sa,ka=new ft,Na={sphere:function(){Sa+=4*Fo},point:b,lineStart:b,lineEnd:b,polygonStart:function(){ka.reset(),Na.lineStart=vt},polygonEnd:function(){var n=2*ka;Sa+=0>n?4*Fo+n:n,Na.lineStart=Na.lineEnd=Na.point=b}};ao.geo.bounds=function(){function n(n,t){M.push(x=[f=n,h=n]),s>t&&(s=t),t>p&&(p=t)}function t(t,e){var r=dt([t*Yo,e*Yo]);if(y){var i=mt(y,r),u=[i[1],-i[0],0],o=mt(u,i);bt(o),o=_t(o);var l=t-g,c=l>0?1:-1,v=o[0]*Zo*c,d=xo(l)>180;if(d^(v>c*g&&c*t>v)){var m=o[1]*Zo;m>p&&(p=m)}else if(v=(v+360)%360-180,d^(v>c*g&&c*t>v)){var m=-o[1]*Zo;s>m&&(s=m)}else s>e&&(s=e),e>p&&(p=e);d?g>t?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t):h>=f?(f>t&&(f=t),t>h&&(h=t)):t>g?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t)}else n(t,e);y=r,g=t}function e(){b.point=t}function r(){x[0]=f,x[1]=h,b.point=n,y=null}function i(n,e){if(y){var r=n-g;m+=xo(r)>180?r+(r>0?360:-360):r}else v=n,d=e;Na.point(n,e),t(n,e)}function u(){Na.lineStart()}function o(){i(v,d),Na.lineEnd(),xo(m)>Uo&&(f=-(h=180)),x[0]=f,x[1]=h,y=null}function a(n,t){return(t-=n)<0?t+360:t}function l(n,t){return n[0]-t[0]}function c(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var f,s,h,p,g,v,d,y,m,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=i,b.lineStart=u,b.lineEnd=o,m=0,Na.polygonStart()},polygonEnd:function(){Na.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,0>ka?(f=-(h=180),s=-(p=90)):m>Uo?p=90:-Uo>m&&(s=-90),x[0]=f,x[1]=h}};return function(n){p=h=-(f=s=1/0),M=[],ao.geo.stream(n,b);var t=M.length;if(t){M.sort(l);for(var e,r=1,i=M[0],u=[i];t>r;++r)e=M[r],c(e[0],i)||c(e[1],i)?(a(i[0],e[1])>a(i[0],i[1])&&(i[1]=e[1]),a(e[0],i[1])>a(i[0],i[1])&&(i[0]=e[0])):u.push(i=e);for(var o,e,g=-(1/0),t=u.length-1,r=0,i=u[t];t>=r;i=e,++r)e=u[r],(o=a(i[1],e[0]))>g&&(g=o,f=e[0],h=i[1])}return M=x=null,f===1/0||s===1/0?[[NaN,NaN],[NaN,NaN]]:[[f,s],[h,p]]}}(),ao.geo.centroid=function(n){Ea=Aa=Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,ja);var t=Da,e=Pa,r=Ua,i=t*t+e*e+r*r;return jo>i&&(t=qa,e=Ta,r=Ra,Uo>Aa&&(t=Ca,e=za,r=La),i=t*t+e*e+r*r,jo>i)?[NaN,NaN]:[Math.atan2(e,t)*Zo,tn(r/Math.sqrt(i))*Zo]};var Ea,Aa,Ca,za,La,qa,Ta,Ra,Da,Pa,Ua,ja={sphere:b,point:St,lineStart:Nt,lineEnd:Et,polygonStart:function(){ja.lineStart=At},polygonEnd:function(){ja.lineStart=Nt}},Fa=Rt(zt,jt,Ht,[-Fo,-Fo/2]),Ha=1e9;ao.geo.clipExtent=function(){var n,t,e,r,i,u,o={stream:function(n){return i&&(i.valid=!1),i=u(n),i.valid=!0,i},extent:function(a){return arguments.length?(u=Zt(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),i&&(i.valid=!1,i=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ao.geo.conicEqualArea=function(){return Vt(Xt)}).raw=Xt,ao.geo.albers=function(){return ao.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ao.geo.albersUsa=function(){function n(n){var u=n[0],o=n[1];return t=null,e(u,o),t||(r(u,o),t)||i(u,o),t}var t,e,r,i,u=ao.geo.albers(),o=ao.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ao.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=u.scale(),e=u.translate(),r=(n[0]-e[0])/t,i=(n[1]-e[1])/t;return(i>=.12&&.234>i&&r>=-.425&&-.214>r?o:i>=.166&&.234>i&&r>=-.214&&-.115>r?a:u).invert(n)},n.stream=function(n){var t=u.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,i){t.point(n,i),e.point(n,i),r.point(n,i)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(u.precision(t),o.precision(t),a.precision(t),n):u.precision()},n.scale=function(t){return arguments.length?(u.scale(t),o.scale(.35*t),a.scale(t),n.translate(u.translate())):u.scale()},n.translate=function(t){if(!arguments.length)return u.translate();var c=u.scale(),f=+t[0],s=+t[1];return e=u.translate(t).clipExtent([[f-.455*c,s-.238*c],[f+.455*c,s+.238*c]]).stream(l).point,r=o.translate([f-.307*c,s+.201*c]).clipExtent([[f-.425*c+Uo,s+.12*c+Uo],[f-.214*c-Uo,s+.234*c-Uo]]).stream(l).point,i=a.translate([f-.205*c,s+.212*c]).clipExtent([[f-.214*c+Uo,s+.166*c+Uo],[f-.115*c-Uo,s+.234*c-Uo]]).stream(l).point,n},n.scale(1070)};var Oa,Ia,Ya,Za,Va,Xa,$a={point:b,lineStart:b,lineEnd:b,polygonStart:function(){Ia=0,$a.lineStart=$t},polygonEnd:function(){$a.lineStart=$a.lineEnd=$a.point=b,Oa+=xo(Ia/2)}},Ba={point:Bt,lineStart:b,lineEnd:b,polygonStart:b,polygonEnd:b},Wa={point:Gt,lineStart:Kt,lineEnd:Qt,polygonStart:function(){Wa.lineStart=ne},polygonEnd:function(){Wa.point=Gt,Wa.lineStart=Kt,Wa.lineEnd=Qt}};ao.geo.path=function(){function n(n){return n&&("function"==typeof a&&u.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=i(u)),ao.geo.stream(n,o)),u.result()}function t(){return o=null,n}var e,r,i,u,o,a=4.5;return n.area=function(n){return Oa=0,ao.geo.stream(n,i($a)),Oa},n.centroid=function(n){return Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,i(Wa)),Ua?[Da/Ua,Pa/Ua]:Ra?[qa/Ra,Ta/Ra]:La?[Ca/La,za/La]:[NaN,NaN]},n.bounds=function(n){return Va=Xa=-(Ya=Za=1/0),ao.geo.stream(n,i(Ba)),[[Ya,Za],[Va,Xa]]},n.projection=function(n){return arguments.length?(i=(e=n)?n.stream||re(n):m,t()):e},n.context=function(n){return arguments.length?(u=null==(r=n)?new Wt:new te(n),"function"!=typeof a&&u.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(u.pointRadius(+t),+t),n):a},n.projection(ao.geo.albersUsa()).context(null)},ao.geo.transform=function(n){return{stream:function(t){var e=new ie(t);for(var r in n)e[r]=n[r];return e}}},ie.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ao.geo.projection=oe,ao.geo.projectionMutator=ae,(ao.geo.equirectangular=function(){return oe(ce)}).raw=ce.invert=ce,ao.geo.rotation=function(n){function t(t){return t=n(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t}return n=se(n[0]%360*Yo,n[1]*Yo,n.length>2?n[2]*Yo:0),t.invert=function(t){return t=n.invert(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t},t},fe.invert=ce,ao.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=se(-n[0]*Yo,-n[1]*Yo,0).invert,i=[];return e(null,null,1,{point:function(n,e){i.push(n=t(n,e)),n[0]*=Zo,n[1]*=Zo}}),{type:"Polygon",coordinates:[i]}}var t,e,r=[0,0],i=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ve((t=+r)*Yo,i*Yo),n):t},n.precision=function(r){return arguments.length?(e=ve(t*Yo,(i=+r)*Yo),n):i},n.angle(90)},ao.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Yo,i=n[1]*Yo,u=t[1]*Yo,o=Math.sin(r),a=Math.cos(r),l=Math.sin(i),c=Math.cos(i),f=Math.sin(u),s=Math.cos(u);return Math.atan2(Math.sqrt((e=s*o)*e+(e=c*f-l*s*a)*e),l*f+c*s*a)},ao.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ao.range(Math.ceil(u/d)*d,i,d).map(h).concat(ao.range(Math.ceil(c/y)*y,l,y).map(p)).concat(ao.range(Math.ceil(r/g)*g,e,g).filter(function(n){return xo(n%d)>Uo}).map(f)).concat(ao.range(Math.ceil(a/v)*v,o,v).filter(function(n){return xo(n%y)>Uo}).map(s))}var e,r,i,u,o,a,l,c,f,s,h,p,g=10,v=g,d=90,y=360,m=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(u).concat(p(l).slice(1),h(i).reverse().slice(1),p(c).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(u=+t[0][0],i=+t[1][0],c=+t[0][1],l=+t[1][1],u>i&&(t=u,u=i,i=t),c>l&&(t=c,c=l,l=t),n.precision(m)):[[u,c],[i,l]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(m)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],y=+t[1],n):[d,y]},n.minorStep=function(t){return arguments.length?(g=+t[0],v=+t[1],n):[g,v]},n.precision=function(t){return arguments.length?(m=+t,f=ye(a,o,90),s=me(r,e,m),h=ye(c,l,90),p=me(u,i,m),n):m},n.majorExtent([[-180,-90+Uo],[180,90-Uo]]).minorExtent([[-180,-80-Uo],[180,80+Uo]])},ao.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||i.apply(this,arguments)]}}var t,e,r=Me,i=xe;return n.distance=function(){return ao.geo.distance(t||r.apply(this,arguments),e||i.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(i=t,e="function"==typeof t?null:t,n):i},n.precision=function(){return arguments.length?n:0},n},ao.geo.interpolate=function(n,t){return be(n[0]*Yo,n[1]*Yo,t[0]*Yo,t[1]*Yo)},ao.geo.length=function(n){return Ja=0,ao.geo.stream(n,Ga),Ja};var Ja,Ga={sphere:b,point:b,lineStart:_e,lineEnd:b,polygonStart:b,polygonEnd:b},Ka=we(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ao.geo.azimuthalEqualArea=function(){return oe(Ka)}).raw=Ka;var Qa=we(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},m);(ao.geo.azimuthalEquidistant=function(){return oe(Qa)}).raw=Qa,(ao.geo.conicConformal=function(){return Vt(Se)}).raw=Se,(ao.geo.conicEquidistant=function(){return Vt(ke)}).raw=ke;var nl=we(function(n){return 1/n},Math.atan);(ao.geo.gnomonic=function(){return oe(nl)}).raw=nl,Ne.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Io]},(ao.geo.mercator=function(){return Ee(Ne)}).raw=Ne;var tl=we(function(){return 1},Math.asin);(ao.geo.orthographic=function(){return oe(tl)}).raw=tl;var el=we(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ao.geo.stereographic=function(){return oe(el)}).raw=el,Ae.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Io]},(ao.geo.transverseMercator=function(){var n=Ee(Ae),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Ae,ao.geom={},ao.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,i=En(e),u=En(r),o=n.length,a=[],l=[];for(t=0;o>t;t++)a.push([+i.call(this,n[t],t),+u.call(this,n[t],t),t]);for(a.sort(qe),t=0;o>t;t++)l.push([a[t][0],-a[t][1]]);var c=Le(a),f=Le(l),s=f[0]===c[0],h=f[f.length-1]===c[c.length-1],p=[];for(t=c.length-1;t>=0;--t)p.push(n[a[c[t]][2]]);for(t=+s;t<f.length-h;++t)p.push(n[a[f[t]][2]]);return p}var e=Ce,r=ze;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ao.geom.polygon=function(n){return ko(n,rl),n};var rl=ao.geom.polygon.prototype=[];rl.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],i=0;++t<e;)n=r,r=this[t],i+=n[1]*r[0]-n[0]*r[1];return.5*i},rl.centroid=function(n){var t,e,r=-1,i=this.length,u=0,o=0,a=this[i-1];for(arguments.length||(n=-1/(6*this.area()));++r<i;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],u+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[u*n,o*n]},rl.clip=function(n){for(var t,e,r,i,u,o,a=De(n),l=-1,c=this.length-De(this),f=this[c-1];++l<c;){for(t=n.slice(),n.length=0,i=this[l],u=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Te(o,f,i)?(Te(u,f,i)||n.push(Re(u,o,f,i)),n.push(o)):Te(u,f,i)&&n.push(Re(u,o,f,i)),u=o;a&&n.push(n[0]),f=i}return n};var il,ul,ol,al,ll,cl=[],fl=[];Ye.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Ve),t.length},tr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},er.prototype={insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=or(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(i=r.R,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(ir(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ur(this,r))):(i=r.L,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(ur(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ir(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,i=n.U,u=n.L,o=n.R;if(e=u?o?or(o):u:o,i?i.L===n?i.L=e:i.R=e:this._=e,u&&o?(r=e.C,e.C=n.C,e.L=u,u.U=e,e!==o?(i=e.U,e.U=n.U,n=e.R,i.L=n,e.R=o,o.U=e):(e.U=i,i=e,n=e.R)):(r=n.C,n=e),n&&(n.U=i),!r){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===i.L){if(t=i.R,t.C&&(t.C=!1,i.C=!0,ir(this,i),t=i.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ur(this,t),t=i.R),t.C=i.C,i.C=t.R.C=!1,ir(this,i),n=this._;break}}else if(t=i.L,t.C&&(t.C=!1,i.C=!0,ur(this,i),t=i.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,ir(this,t),t=i.L),t.C=i.C,i.C=t.L.C=!1,ur(this,i),n=this._;break}t.C=!0,n=i,i=i.U}while(!n.C);n&&(n.C=!1)}}},ao.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],i=a[0][1],u=a[1][0],o=a[1][1];return ar(e(n),a).cells.forEach(function(e,a){var l=e.edges,c=e.site,f=t[a]=l.length?l.map(function(n){var t=n.start();return[t.x,t.y]}):c.x>=r&&c.x<=u&&c.y>=i&&c.y<=o?[[r,o],[u,o],[u,i],[r,i]]:[];f.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(u(n,t)/Uo)*Uo,y:Math.round(o(n,t)/Uo)*Uo,i:t}})}var r=Ce,i=ze,u=r,o=i,a=sl;return n?t(n):(t.links=function(n){return ar(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return ar(e(n)).cells.forEach(function(e,r){for(var i,u,o=e.site,a=e.edges.sort(Ve),l=-1,c=a.length,f=a[c-1].edge,s=f.l===o?f.r:f.l;++l<c;)i=f,u=s,f=a[l].edge,s=f.l===o?f.r:f.l,r<u.i&&r<s.i&&cr(o,u,s)<0&&t.push([n[r],n[u.i],n[s.i]])}),t},t.x=function(n){return arguments.length?(u=En(r=n),t):r},t.y=function(n){return arguments.length?(o=En(i=n),t):i},t.clipExtent=function(n){return arguments.length?(a=null==n?sl:n,t):a===sl?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===sl?null:a&&a[1]},t)};var sl=[[-1e6,-1e6],[1e6,1e6]];ao.geom.delaunay=function(n){return ao.geom.voronoi().triangles(n)},ao.geom.quadtree=function(n,t,e,r,i){function u(n){function u(n,t,e,r,i,u,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var l=n.x,f=n.y;if(null!=l)if(xo(l-e)+xo(f-r)<.01)c(n,t,e,r,i,u,o,a);else{var s=n.point;n.x=n.y=n.point=null,c(n,s,l,f,i,u,o,a),c(n,t,e,r,i,u,o,a)}else n.x=e,n.y=r,n.point=t}else c(n,t,e,r,i,u,o,a)}function c(n,t,e,r,i,o,a,l){var c=.5*(i+a),f=.5*(o+l),s=e>=c,h=r>=f,p=h<<1|s;n.leaf=!1,n=n.nodes[p]||(n.nodes[p]=hr()),s?i=c:a=c,h?o=f:l=f,u(n,t,e,r,i,o,a,l)}var f,s,h,p,g,v,d,y,m,M=En(a),x=En(l);if(null!=t)v=t,d=e,y=r,m=i;else if(y=m=-(v=d=1/0),s=[],h=[],g=n.length,o)for(p=0;g>p;++p)f=n[p],f.x<v&&(v=f.x),f.y<d&&(d=f.y),f.x>y&&(y=f.x),f.y>m&&(m=f.y),s.push(f.x),h.push(f.y);else for(p=0;g>p;++p){var b=+M(f=n[p],p),_=+x(f,p);v>b&&(v=b),d>_&&(d=_),b>y&&(y=b),_>m&&(m=_),s.push(b),h.push(_)}var w=y-v,S=m-d;w>S?m=d+w:y=v+S;var k=hr();if(k.add=function(n){u(k,n,+M(n,++p),+x(n,p),v,d,y,m)},k.visit=function(n){pr(n,k,v,d,y,m)},k.find=function(n){return gr(k,n[0],n[1],v,d,y,m)},p=-1,null==t){for(;++p<g;)u(k,n[p],s[p],h[p],v,d,y,m);--p}else n.forEach(k.add);return s=h=n=f=null,k}var o,a=Ce,l=ze;return(o=arguments.length)?(a=fr,l=sr,3===o&&(i=e,r=t,e=t=0),u(n)):(u.x=function(n){return arguments.length?(a=n,u):a},u.y=function(n){return arguments.length?(l=n,u):l},u.extent=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],i=+n[1][1]),u):null==t?null:[[t,e],[r,i]]},u.size=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=e=0,r=+n[0],i=+n[1]),u):null==t?null:[r-t,i-e]},u)},ao.interpolateRgb=vr,ao.interpolateObject=dr,ao.interpolateNumber=yr,ao.interpolateString=mr;var hl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,pl=new RegExp(hl.source,"g");ao.interpolate=Mr,ao.interpolators=[function(n,t){var e=typeof t;return("string"===e?ua.has(t.toLowerCase())||/^(#|rgb\(|hsl\()/i.test(t)?vr:mr:t instanceof an?vr:Array.isArray(t)?xr:"object"===e&&isNaN(t)?dr:yr)(n,t)}],ao.interpolateArray=xr;var gl=function(){return m},vl=ao.map({linear:gl,poly:Er,quad:function(){return Sr},cubic:function(){return kr},sin:function(){return Ar},exp:function(){return Cr},circle:function(){return zr},elastic:Lr,back:qr,bounce:function(){return Tr}}),dl=ao.map({"in":m,out:_r,"in-out":wr,"out-in":function(n){return wr(_r(n))}});ao.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=vl.get(e)||gl,r=dl.get(r)||m,br(r(e.apply(null,lo.call(arguments,1))))},ao.interpolateHcl=Rr,ao.interpolateHsl=Dr,ao.interpolateLab=Pr,ao.interpolateRound=Ur,ao.transform=function(n){var t=fo.createElementNS(ao.ns.prefix.svg,"g");return(ao.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new jr(e?e.matrix:yl)})(n)},jr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var yl={a:1,b:0,c:0,d:1,e:0,f:0};ao.interpolateTransform=$r,ao.layout={},ao.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Jr(n[e]));return t}},ao.layout.chord=function(){function n(){var n,c,s,h,p,g={},v=[],d=ao.range(u),y=[];for(e=[],r=[],n=0,h=-1;++h<u;){for(c=0,p=-1;++p<u;)c+=i[h][p];v.push(c),y.push(ao.range(u)),n+=c}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&y.forEach(function(n,t){n.sort(function(n,e){return a(i[t][n],i[t][e])})}),n=(Ho-f*u)/n,c=0,h=-1;++h<u;){for(s=c,p=-1;++p<u;){var m=d[h],M=y[m][p],x=i[m][M],b=c,_=c+=x*n;g[m+"-"+M]={index:m,subindex:M,startAngle:b,endAngle:_,value:x}}r[m]={index:m,startAngle:s,endAngle:c,value:v[m]},c+=f}for(h=-1;++h<u;)for(p=h-1;++p<u;){var w=g[h+"-"+p],S=g[p+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}l&&t()}function t(){e.sort(function(n,t){return l((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,i,u,o,a,l,c={},f=0;return c.matrix=function(n){return arguments.length?(u=(i=n)&&i.length,e=r=null,c):i},c.padding=function(n){return arguments.length?(f=n,e=r=null,c):f},c.sortGroups=function(n){return arguments.length?(o=n,e=r=null,c):o},c.sortSubgroups=function(n){return arguments.length?(a=n,e=null,c):a},c.sortChords=function(n){return arguments.length?(l=n,e&&t(),c):l},c.chords=function(){return e||n(),e},c.groups=function(){return r||n(),r},c},ao.layout.force=function(){function n(n){return function(t,e,r,i){if(t.point!==n){var u=t.cx-n.x,o=t.cy-n.y,a=i-e,l=u*u+o*o;if(l>a*a/y){if(v>l){var c=t.charge/l;n.px-=u*c,n.py-=o*c}return!0}if(t.point&&l&&v>l){var c=t.pointCharge/l;n.px-=u*c,n.py-=o*c}}return!t.charge}}function t(n){n.px=ao.event.x,n.py=ao.event.y,l.resume()}var e,r,i,u,o,a,l={},c=ao.dispatch("start","tick","end"),f=[1,1],s=.9,h=ml,p=Ml,g=-30,v=xl,d=.1,y=.64,M=[],x=[];return l.tick=function(){if((i*=.99)<.005)return e=null,c.end({type:"end",alpha:i=0}),!0;var t,r,l,h,p,v,y,m,b,_=M.length,w=x.length;for(r=0;w>r;++r)l=x[r],h=l.source,p=l.target,m=p.x-h.x,b=p.y-h.y,(v=m*m+b*b)&&(v=i*o[r]*((v=Math.sqrt(v))-u[r])/v,m*=v,b*=v,p.x-=m*(y=h.weight+p.weight?h.weight/(h.weight+p.weight):.5),p.y-=b*y,h.x+=m*(y=1-y),h.y+=b*y);if((y=i*d)&&(m=f[0]/2,b=f[1]/2,r=-1,y))for(;++r<_;)l=M[r],l.x+=(m-l.x)*y,l.y+=(b-l.y)*y;if(g)for(ri(t=ao.geom.quadtree(M),i,a),r=-1;++r<_;)(l=M[r]).fixed||t.visit(n(l));for(r=-1;++r<_;)l=M[r],l.fixed?(l.x=l.px,l.y=l.py):(l.x-=(l.px-(l.px=l.x))*s,l.y-=(l.py-(l.py=l.y))*s);c.tick({type:"tick",alpha:i})},l.nodes=function(n){return arguments.length?(M=n,l):M},l.links=function(n){return arguments.length?(x=n,l):x},l.size=function(n){return arguments.length?(f=n,l):f},l.linkDistance=function(n){return arguments.length?(h="function"==typeof n?n:+n,l):h},l.distance=l.linkDistance,l.linkStrength=function(n){return arguments.length?(p="function"==typeof n?n:+n,l):p},l.friction=function(n){return arguments.length?(s=+n,l):s},l.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,l):g},l.chargeDistance=function(n){return arguments.length?(v=n*n,l):Math.sqrt(v)},l.gravity=function(n){return arguments.length?(d=+n,l):d},l.theta=function(n){return arguments.length?(y=n*n,l):Math.sqrt(y)},l.alpha=function(n){return arguments.length?(n=+n,i?n>0?i=n:(e.c=null,e.t=NaN,e=null,c.end({type:"end",alpha:i=0})):n>0&&(c.start({type:"start",alpha:i=n}),e=qn(l.tick)),l):i},l.start=function(){function n(n,r){if(!e){for(e=new Array(i),l=0;i>l;++l)e[l]=[];for(l=0;c>l;++l){var u=x[l];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var o,a=e[t],l=-1,f=a.length;++l<f;)if(!isNaN(o=a[l][n]))return o;return Math.random()*r}var t,e,r,i=M.length,c=x.length,s=f[0],v=f[1];for(t=0;i>t;++t)(r=M[t]).index=t,r.weight=0;for(t=0;c>t;++t)r=x[t],"number"==typeof r.source&&(r.source=M[r.source]),"number"==typeof r.target&&(r.target=M[r.target]),++r.source.weight,++r.target.weight;for(t=0;i>t;++t)r=M[t],isNaN(r.x)&&(r.x=n("x",s)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof h)for(t=0;c>t;++t)u[t]=+h.call(this,x[t],t);else for(t=0;c>t;++t)u[t]=h;if(o=[],"function"==typeof p)for(t=0;c>t;++t)o[t]=+p.call(this,x[t],t);else for(t=0;c>t;++t)o[t]=p;if(a=[],"function"==typeof g)for(t=0;i>t;++t)a[t]=+g.call(this,M[t],t);else for(t=0;i>t;++t)a[t]=g;return l.resume()},l.resume=function(){return l.alpha(.1)},l.stop=function(){return l.alpha(0)},l.drag=function(){return r||(r=ao.behavior.drag().origin(m).on("dragstart.force",Qr).on("drag.force",t).on("dragend.force",ni)),arguments.length?void this.on("mouseover.force",ti).on("mouseout.force",ei).call(r):r},ao.rebind(l,c,"on")};var ml=20,Ml=1,xl=1/0;ao.layout.hierarchy=function(){function n(i){var u,o=[i],a=[];for(i.depth=0;null!=(u=o.pop());)if(a.push(u),(c=e.call(n,u,u.depth))&&(l=c.length)){for(var l,c,f;--l>=0;)o.push(f=c[l]),f.parent=u,f.depth=u.depth+1;r&&(u.value=0),u.children=c}else r&&(u.value=+r.call(n,u,u.depth)||0),delete u.children;return oi(i,function(n){var e,i;t&&(e=n.children)&&e.sort(t),r&&(i=n.parent)&&(i.value+=n.value)}),a}var t=ci,e=ai,r=li;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(ui(t,function(n){n.children&&(n.value=0)}),oi(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ao.layout.partition=function(){function n(t,e,r,i){var u=t.children;if(t.x=e,t.y=t.depth*i,t.dx=r,t.dy=i,u&&(o=u.length)){var o,a,l,c=-1;for(r=t.value?r/t.value:0;++c<o;)n(a=u[c],e,l=a.value*r,i),e+=l}}function t(n){var e=n.children,r=0;if(e&&(i=e.length))for(var i,u=-1;++u<i;)r=Math.max(r,t(e[u]));return 1+r}function e(e,u){var o=r.call(this,e,u);return n(o[0],0,i[0],i[1]/t(o[0])),o}var r=ao.layout.hierarchy(),i=[1,1];return e.size=function(n){return arguments.length?(i=n,e):i},ii(e,r)},ao.layout.pie=function(){function n(o){var a,l=o.length,c=o.map(function(e,r){return+t.call(n,e,r)}),f=+("function"==typeof r?r.apply(this,arguments):r),s=("function"==typeof i?i.apply(this,arguments):i)-f,h=Math.min(Math.abs(s)/l,+("function"==typeof u?u.apply(this,arguments):u)),p=h*(0>s?-1:1),g=ao.sum(c),v=g?(s-l*p)/g:0,d=ao.range(l),y=[];return null!=e&&d.sort(e===bl?function(n,t){return c[t]-c[n]}:function(n,t){return e(o[n],o[t])}),d.forEach(function(n){y[n]={data:o[n],value:a=c[n],startAngle:f,endAngle:f+=a*v+p,padAngle:h}}),y}var t=Number,e=bl,r=0,i=Ho,u=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(i=t,n):i},n.padAngle=function(t){return arguments.length?(u=t,n):u},n};var bl={};ao.layout.stack=function(){function n(a,l){if(!(h=a.length))return a;var c=a.map(function(e,r){return t.call(n,e,r)}),f=c.map(function(t){return t.map(function(t,e){return[u.call(n,t,e),o.call(n,t,e)]})}),s=e.call(n,f,l);c=ao.permute(c,s),f=ao.permute(f,s);var h,p,g,v,d=r.call(n,f,l),y=c[0].length;for(g=0;y>g;++g)for(i.call(n,c[0][g],v=d[g],f[0][g][1]),p=1;h>p;++p)i.call(n,c[p][g],v+=f[p-1][g][1],f[p][g][1]);return a}var t=m,e=gi,r=vi,i=pi,u=si,o=hi;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:_l.get(t)||gi,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:wl.get(t)||vi,n):r},n.x=function(t){return arguments.length?(u=t,n):u},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(i=t,n):i},n};var _l=ao.map({"inside-out":function(n){var t,e,r=n.length,i=n.map(di),u=n.map(yi),o=ao.range(r).sort(function(n,t){return i[n]-i[t]}),a=0,l=0,c=[],f=[];for(t=0;r>t;++t)e=o[t],l>a?(a+=u[e],c.push(e)):(l+=u[e],f.push(e));return f.reverse().concat(c)},reverse:function(n){return ao.range(n.length).reverse()},"default":gi}),wl=ao.map({silhouette:function(n){var t,e,r,i=n.length,u=n[0].length,o=[],a=0,l=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;u>e;++e)l[e]=(a-o[e])/2;return l},wiggle:function(n){var t,e,r,i,u,o,a,l,c,f=n.length,s=n[0],h=s.length,p=[];for(p[0]=l=c=0,e=1;h>e;++e){for(t=0,i=0;f>t;++t)i+=n[t][e][1];for(t=0,u=0,a=s[e][0]-s[e-1][0];f>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;u+=o*n[t][e][1]}p[e]=l-=i?u/i*a:0,c>l&&(c=l)}for(e=0;h>e;++e)p[e]-=c;return p},expand:function(n){var t,e,r,i=n.length,u=n[0].length,o=1/i,a=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];if(r)for(t=0;i>t;t++)n[t][e][1]/=r;else for(t=0;i>t;t++)n[t][e][1]=o}for(e=0;u>e;++e)a[e]=0;return a},zero:vi});ao.layout.histogram=function(){function n(n,u){for(var o,a,l=[],c=n.map(e,this),f=r.call(this,c,u),s=i.call(this,f,c,u),u=-1,h=c.length,p=s.length-1,g=t?1:1/h;++u<p;)o=l[u]=[],o.dx=s[u+1]-(o.x=s[u]),o.y=0;if(p>0)for(u=-1;++u<h;)a=c[u],a>=f[0]&&a<=f[1]&&(o=l[ao.bisect(s,a,1,p)-1],o.y+=g,o.push(n[u]));return l}var t=!0,e=Number,r=bi,i=Mi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=En(t),n):r},n.bins=function(t){return arguments.length?(i="number"==typeof t?function(n){return xi(n,t)}:En(t),n):i},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ao.layout.pack=function(){function n(n,u){var o=e.call(this,n,u),a=o[0],l=i[0],c=i[1],f=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,oi(a,function(n){n.r=+f(n.value)}),oi(a,Ni),r){var s=r*(t?1:Math.max(2*a.r/l,2*a.r/c))/2;oi(a,function(n){n.r+=s}),oi(a,Ni),oi(a,function(n){n.r-=s})}return Ci(a,l/2,c/2,t?1:1/Math.max(2*a.r/l,2*a.r/c)),o}var t,e=ao.layout.hierarchy().sort(_i),r=0,i=[1,1];return n.size=function(t){return arguments.length?(i=t,n):i},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},ii(n,e)},ao.layout.tree=function(){function n(n,i){var f=o.call(this,n,i),s=f[0],h=t(s);if(oi(h,e),h.parent.m=-h.z,ui(h,r),c)ui(s,u);else{var p=s,g=s,v=s;ui(s,function(n){n.x<p.x&&(p=n),n.x>g.x&&(g=n),n.depth>v.depth&&(v=n)});var d=a(p,g)/2-p.x,y=l[0]/(g.x+a(g,p)/2+d),m=l[1]/(v.depth||1);ui(s,function(n){n.x=(n.x+d)*y,n.y=n.depth*m})}return f}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var i,u=t.children,o=0,a=u.length;a>o;++o)r.push((u[o]=i={_:u[o],parent:t,children:(i=u[o].children)&&i.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=i);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Di(n);var u=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-u):n.z=u}else r&&(n.z=r.z+a(n._,r._));n.parent.A=i(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function i(n,t,e){if(t){for(var r,i=n,u=n,o=t,l=i.parent.children[0],c=i.m,f=u.m,s=o.m,h=l.m;o=Ti(o),i=qi(i),o&&i;)l=qi(l),u=Ti(u),u.a=n,r=o.z+s-i.z-c+a(o._,i._),r>0&&(Ri(Pi(o,n,e),n,r),c+=r,f+=r),s+=o.m,c+=i.m,h+=l.m,f+=u.m;o&&!Ti(u)&&(u.t=o,u.m+=s-f),i&&!qi(l)&&(l.t=i,l.m+=c-h,e=n)}return e}function u(n){n.x*=l[0],n.y=n.depth*l[1]}var o=ao.layout.hierarchy().sort(null).value(null),a=Li,l=[1,1],c=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(c=null==(l=t)?u:null,n):c?null:l},n.nodeSize=function(t){return arguments.length?(c=null==(l=t)?null:u,n):c?l:null},ii(n,o)},ao.layout.cluster=function(){function n(n,u){var o,a=t.call(this,n,u),l=a[0],c=0;oi(l,function(n){var t=n.children;t&&t.length?(n.x=ji(t),n.y=Ui(t)):(n.x=o?c+=e(n,o):0,n.y=0,o=n)});var f=Fi(l),s=Hi(l),h=f.x-e(f,s)/2,p=s.x+e(s,f)/2;return oi(l,i?function(n){n.x=(n.x-l.x)*r[0],n.y=(l.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(p-h)*r[0],n.y=(1-(l.y?n.y/l.y:1))*r[1]}),a}var t=ao.layout.hierarchy().sort(null).value(null),e=Li,r=[1,1],i=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(i=null==(r=t),n):i?null:r},n.nodeSize=function(t){return arguments.length?(i=null!=(r=t),n):i?r:null},ii(n,t)},ao.layout.treemap=function(){function n(n,t){for(var e,r,i=-1,u=n.length;++i<u;)r=(e=n[i]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var u=e.children;if(u&&u.length){var o,a,l,c=s(e),f=[],h=u.slice(),g=1/0,v="slice"===p?c.dx:"dice"===p?c.dy:"slice-dice"===p?1&e.depth?c.dy:c.dx:Math.min(c.dx,c.dy);for(n(h,c.dx*c.dy/e.value),f.area=0;(l=h.length)>0;)f.push(o=h[l-1]),f.area+=o.area,"squarify"!==p||(a=r(f,v))<=g?(h.pop(),g=a):(f.area-=f.pop().area,i(f,v,c,!1),v=Math.min(c.dx,c.dy),f.length=f.area=0,g=1/0);f.length&&(i(f,v,c,!0),f.length=f.area=0),u.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var u,o=s(t),a=r.slice(),l=[];for(n(a,o.dx*o.dy/t.value),l.area=0;u=a.pop();)l.push(u),l.area+=u.area,null!=u.z&&(i(l,u.z?o.dx:o.dy,o,!a.length),l.length=l.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,i=0,u=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(u>e&&(u=e),e>i&&(i=e));return r*=r,t*=t,r?Math.max(t*i*g/r,r/(t*u*g)):1/0}function i(n,t,e,r){var i,u=-1,o=n.length,a=e.x,c=e.y,f=t?l(n.area/t):0;
if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++u<o;)i=n[u],i.x=a,i.y=c,i.dy=f,a+=i.dx=Math.min(e.x+e.dx-a,f?l(i.area/f):0);i.z=!0,i.dx+=e.x+e.dx-a,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++u<o;)i=n[u],i.x=a,i.y=c,i.dx=f,c+=i.dy=Math.min(e.y+e.dy-c,f?l(i.area/f):0);i.z=!1,i.dy+=e.y+e.dy-c,e.x+=f,e.dx-=f}}function u(r){var i=o||a(r),u=i[0];return u.x=u.y=0,u.value?(u.dx=c[0],u.dy=c[1]):u.dx=u.dy=0,o&&a.revalue(u),n([u],u.dx*u.dy/u.value),(o?e:t)(u),h&&(o=i),i}var o,a=ao.layout.hierarchy(),l=Math.round,c=[1,1],f=null,s=Oi,h=!1,p="squarify",g=.5*(1+Math.sqrt(5));return u.size=function(n){return arguments.length?(c=n,u):c},u.padding=function(n){function t(t){var e=n.call(u,t,t.depth);return null==e?Oi(t):Ii(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Ii(t,n)}if(!arguments.length)return f;var r;return s=null==(f=n)?Oi:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,u},u.round=function(n){return arguments.length?(l=n?Math.round:Number,u):l!=Number},u.sticky=function(n){return arguments.length?(h=n,o=null,u):h},u.ratio=function(n){return arguments.length?(g=n,u):g},u.mode=function(n){return arguments.length?(p=n+"",u):p},ii(u,a)},ao.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,i;do e=2*Math.random()-1,r=2*Math.random()-1,i=e*e+r*r;while(!i||i>1);return n+t*e*Math.sqrt(-2*Math.log(i)/i)}},logNormal:function(){var n=ao.random.normal.apply(ao,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ao.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},ao.scale={};var Sl={floor:m,ceil:m};ao.scale.linear=function(){return Wi([0,1],[0,1],Mr,!1)};var kl={s:1,g:1,p:1,r:1,e:1};ao.scale.log=function(){return ru(ao.scale.linear().domain([0,1]),10,!0,[1,10])};var Nl=ao.format(".0e"),El={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ao.scale.pow=function(){return iu(ao.scale.linear(),1,[0,1])},ao.scale.sqrt=function(){return ao.scale.pow().exponent(.5)},ao.scale.ordinal=function(){return ou([],{t:"range",a:[[]]})},ao.scale.category10=function(){return ao.scale.ordinal().range(Al)},ao.scale.category20=function(){return ao.scale.ordinal().range(Cl)},ao.scale.category20b=function(){return ao.scale.ordinal().range(zl)},ao.scale.category20c=function(){return ao.scale.ordinal().range(Ll)};var Al=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(xn),Cl=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(xn),zl=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(xn),Ll=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(xn);ao.scale.quantile=function(){return au([],[])},ao.scale.quantize=function(){return lu(0,1,[0,1])},ao.scale.threshold=function(){return cu([.5],[0,1])},ao.scale.identity=function(){return fu([0,1])},ao.svg={},ao.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),c=Math.max(0,+r.apply(this,arguments)),f=o.apply(this,arguments)-Io,s=a.apply(this,arguments)-Io,h=Math.abs(s-f),p=f>s?0:1;if(n>c&&(g=c,c=n,n=g),h>=Oo)return t(c,p)+(n?t(n,1-p):"")+"Z";var g,v,d,y,m,M,x,b,_,w,S,k,N=0,E=0,A=[];if((y=(+l.apply(this,arguments)||0)/2)&&(d=u===ql?Math.sqrt(n*n+c*c):+u.apply(this,arguments),p||(E*=-1),c&&(E=tn(d/c*Math.sin(y))),n&&(N=tn(d/n*Math.sin(y)))),c){m=c*Math.cos(f+E),M=c*Math.sin(f+E),x=c*Math.cos(s-E),b=c*Math.sin(s-E);var C=Math.abs(s-f-2*E)<=Fo?0:1;if(E&&yu(m,M,x,b)===p^C){var z=(f+s)/2;m=c*Math.cos(z),M=c*Math.sin(z),x=b=null}}else m=M=0;if(n){_=n*Math.cos(s-N),w=n*Math.sin(s-N),S=n*Math.cos(f+N),k=n*Math.sin(f+N);var L=Math.abs(f-s+2*N)<=Fo?0:1;if(N&&yu(_,w,S,k)===1-p^L){var q=(f+s)/2;_=n*Math.cos(q),w=n*Math.sin(q),S=k=null}}else _=w=0;if(h>Uo&&(g=Math.min(Math.abs(c-n)/2,+i.apply(this,arguments)))>.001){v=c>n^p?0:1;var T=g,R=g;if(Fo>h){var D=null==S?[_,w]:null==x?[m,M]:Re([m,M],[S,k],[x,b],[_,w]),P=m-D[0],U=M-D[1],j=x-D[0],F=b-D[1],H=1/Math.sin(Math.acos((P*j+U*F)/(Math.sqrt(P*P+U*U)*Math.sqrt(j*j+F*F)))/2),O=Math.sqrt(D[0]*D[0]+D[1]*D[1]);R=Math.min(g,(n-O)/(H-1)),T=Math.min(g,(c-O)/(H+1))}if(null!=x){var I=mu(null==S?[_,w]:[S,k],[m,M],c,T,p),Y=mu([x,b],[_,w],c,T,p);g===T?A.push("M",I[0],"A",T,",",T," 0 0,",v," ",I[1],"A",c,",",c," 0 ",1-p^yu(I[1][0],I[1][1],Y[1][0],Y[1][1]),",",p," ",Y[1],"A",T,",",T," 0 0,",v," ",Y[0]):A.push("M",I[0],"A",T,",",T," 0 1,",v," ",Y[0])}else A.push("M",m,",",M);if(null!=S){var Z=mu([m,M],[S,k],n,-R,p),V=mu([_,w],null==x?[m,M]:[x,b],n,-R,p);g===R?A.push("L",V[0],"A",R,",",R," 0 0,",v," ",V[1],"A",n,",",n," 0 ",p^yu(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-p," ",Z[1],"A",R,",",R," 0 0,",v," ",Z[0]):A.push("L",V[0],"A",R,",",R," 0 0,",v," ",Z[0])}else A.push("L",_,",",w)}else A.push("M",m,",",M),null!=x&&A.push("A",c,",",c," 0 ",C,",",p," ",x,",",b),A.push("L",_,",",w),null!=S&&A.push("A",n,",",n," 0 ",L,",",1-p," ",S,",",k);return A.push("Z"),A.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=hu,r=pu,i=su,u=ql,o=gu,a=vu,l=du;return n.innerRadius=function(t){return arguments.length?(e=En(t),n):e},n.outerRadius=function(t){return arguments.length?(r=En(t),n):r},n.cornerRadius=function(t){return arguments.length?(i=En(t),n):i},n.padRadius=function(t){return arguments.length?(u=t==ql?ql:En(t),n):u},n.startAngle=function(t){return arguments.length?(o=En(t),n):o},n.endAngle=function(t){return arguments.length?(a=En(t),n):a},n.padAngle=function(t){return arguments.length?(l=En(t),n):l},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-Io;return[Math.cos(t)*n,Math.sin(t)*n]},n};var ql="auto";ao.svg.line=function(){return Mu(m)};var Tl=ao.map({linear:xu,"linear-closed":bu,step:_u,"step-before":wu,"step-after":Su,basis:zu,"basis-open":Lu,"basis-closed":qu,bundle:Tu,cardinal:Eu,"cardinal-open":ku,"cardinal-closed":Nu,monotone:Fu});Tl.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Rl=[0,2/3,1/3,0],Dl=[0,1/3,2/3,0],Pl=[0,1/6,2/3,1/6];ao.svg.line.radial=function(){var n=Mu(Hu);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},wu.reverse=Su,Su.reverse=wu,ao.svg.area=function(){return Ou(m)},ao.svg.area.radial=function(){var n=Ou(Hu);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ao.svg.chord=function(){function n(n,a){var l=t(this,u,n,a),c=t(this,o,n,a);return"M"+l.p0+r(l.r,l.p1,l.a1-l.a0)+(e(l,c)?i(l.r,l.p1,l.r,l.p0):i(l.r,l.p1,c.r,c.p0)+r(c.r,c.p1,c.a1-c.a0)+i(c.r,c.p1,l.r,l.p0))+"Z"}function t(n,t,e,r){var i=t.call(n,e,r),u=a.call(n,i,r),o=l.call(n,i,r)-Io,f=c.call(n,i,r)-Io;return{r:u,a0:o,a1:f,p0:[u*Math.cos(o),u*Math.sin(o)],p1:[u*Math.cos(f),u*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Fo)+",1 "+t}function i(n,t,e,r){return"Q 0,0 "+r}var u=Me,o=xe,a=Iu,l=gu,c=vu;return n.radius=function(t){return arguments.length?(a=En(t),n):a},n.source=function(t){return arguments.length?(u=En(t),n):u},n.target=function(t){return arguments.length?(o=En(t),n):o},n.startAngle=function(t){return arguments.length?(l=En(t),n):l},n.endAngle=function(t){return arguments.length?(c=En(t),n):c},n},ao.svg.diagonal=function(){function n(n,i){var u=t.call(this,n,i),o=e.call(this,n,i),a=(u.y+o.y)/2,l=[u,{x:u.x,y:a},{x:o.x,y:a},o];return l=l.map(r),"M"+l[0]+"C"+l[1]+" "+l[2]+" "+l[3]}var t=Me,e=xe,r=Yu;return n.source=function(e){return arguments.length?(t=En(e),n):t},n.target=function(t){return arguments.length?(e=En(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ao.svg.diagonal.radial=function(){var n=ao.svg.diagonal(),t=Yu,e=n.projection;return n.projection=function(n){return arguments.length?e(Zu(t=n)):t},n},ao.svg.symbol=function(){function n(n,r){return(Ul.get(t.call(this,n,r))||$u)(e.call(this,n,r))}var t=Xu,e=Vu;return n.type=function(e){return arguments.length?(t=En(e),n):t},n.size=function(t){return arguments.length?(e=En(t),n):e},n};var Ul=ao.map({circle:$u,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Fl)),e=t*Fl;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ao.svg.symbolTypes=Ul.keys();var jl=Math.sqrt(3),Fl=Math.tan(30*Yo);Co.transition=function(n){for(var t,e,r=Hl||++Zl,i=Ku(n),u=[],o=Ol||{time:Date.now(),ease:Nr,delay:0,duration:250},a=-1,l=this.length;++a<l;){u.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(e=c[f])&&Qu(e,f,i,r,o),t.push(e)}return Wu(u,i,r)},Co.interrupt=function(n){return this.each(null==n?Il:Bu(Ku(n)))};var Hl,Ol,Il=Bu(Ku()),Yl=[],Zl=0;Yl.call=Co.call,Yl.empty=Co.empty,Yl.node=Co.node,Yl.size=Co.size,ao.transition=function(n,t){return n&&n.transition?Hl?n.transition(t):n:ao.selection().transition(n)},ao.transition.prototype=Yl,Yl.select=function(n){var t,e,r,i=this.id,u=this.namespace,o=[];n=A(n);for(var a=-1,l=this.length;++a<l;){o.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(r=c[f])&&(e=n.call(r,r.__data__,f,a))?("__data__"in r&&(e.__data__=r.__data__),Qu(e,f,u,i,r[u][i]),t.push(e)):t.push(null)}return Wu(o,u,i)},Yl.selectAll=function(n){var t,e,r,i,u,o=this.id,a=this.namespace,l=[];n=C(n);for(var c=-1,f=this.length;++c<f;)for(var s=this[c],h=-1,p=s.length;++h<p;)if(r=s[h]){u=r[a][o],e=n.call(r,r.__data__,h,c),l.push(t=[]);for(var g=-1,v=e.length;++g<v;)(i=e[g])&&Qu(i,g,a,o,u),t.push(i)}return Wu(l,a,o)},Yl.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]);for(var e=this[u],a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return Wu(i,this.namespace,this.id)},Yl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):Y(this,null==t?function(t){t[r][e].tween.remove(n)}:function(i){i[r][e].tween.set(n,t)})},Yl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function i(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function u(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?$r:Mr,a=ao.ns.qualify(n);return Ju(this,"attr."+n,t,a.local?u:i)},Yl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(i));return r&&function(n){this.setAttribute(i,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(i.space,i.local));return r&&function(n){this.setAttributeNS(i.space,i.local,r(n))}}var i=ao.ns.qualify(n);return this.tween("attr."+n,i.local?r:e)},Yl.style=function(n,e,r){function i(){this.style.removeProperty(n)}function u(e){return null==e?i:(e+="",function(){var i,u=t(this).getComputedStyle(this,null).getPropertyValue(n);return u!==e&&(i=Mr(u,e),function(t){this.style.setProperty(n,i(t),r)})})}var o=arguments.length;if(3>o){if("string"!=typeof n){2>o&&(e="");for(r in n)this.style(r,n[r],e);return this}r=""}return Ju(this,"style."+n,e,u)},Yl.styleTween=function(n,e,r){function i(i,u){var o=e.call(this,i,u,t(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),r)}}return arguments.length<3&&(r=""),this.tween("style."+n,i)},Yl.text=function(n){return Ju(this,"text",n,Gu)},Yl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Yl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ao.ease.apply(ao,arguments)),Y(this,function(r){r[e][t].ease=n}))},Yl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:Y(this,"function"==typeof n?function(r,i,u){r[e][t].delay=+n.call(r,r.__data__,i,u)}:(n=+n,function(r){r[e][t].delay=n}))},Yl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:Y(this,"function"==typeof n?function(r,i,u){r[e][t].duration=Math.max(1,n.call(r,r.__data__,i,u))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Yl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var i=Ol,u=Hl;try{Hl=e,Y(this,function(t,i,u){Ol=t[r][e],n.call(t,t.__data__,i,u)})}finally{Ol=i,Hl=u}}else Y(this,function(i){var u=i[r][e];(u.event||(u.event=ao.dispatch("start","end","interrupt"))).on(n,t)});return this},Yl.transition=function(){for(var n,t,e,r,i=this.id,u=++Zl,o=this.namespace,a=[],l=0,c=this.length;c>l;l++){a.push(n=[]);for(var t=this[l],f=0,s=t.length;s>f;f++)(e=t[f])&&(r=e[o][i],Qu(e,f,o,u,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Wu(a,o,u)},ao.svg.axis=function(){function n(n){n.each(function(){var n,c=ao.select(this),f=this.__chart__||e,s=this.__chart__=e.copy(),h=null==l?s.ticks?s.ticks.apply(s,a):s.domain():l,p=null==t?s.tickFormat?s.tickFormat.apply(s,a):m:t,g=c.selectAll(".tick").data(h,s),v=g.enter().insert("g",".domain").attr("class","tick").style("opacity",Uo),d=ao.transition(g.exit()).style("opacity",Uo).remove(),y=ao.transition(g.order()).style("opacity",1),M=Math.max(i,0)+o,x=Zi(s),b=c.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),ao.transition(b));v.append("line"),v.append("text");var w,S,k,N,E=v.select("line"),A=y.select("line"),C=g.select("text").text(p),z=v.select("text"),L=y.select("text"),q="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=no,w="x",k="y",S="x2",N="y2",C.attr("dy",0>q?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+q*u+"V0H"+x[1]+"V"+q*u)):(n=to,w="y",k="x",S="y2",N="x2",C.attr("dy",".32em").style("text-anchor",0>q?"end":"start"),_.attr("d","M"+q*u+","+x[0]+"H0V"+x[1]+"H"+q*u)),E.attr(N,q*i),z.attr(k,q*M),A.attr(S,0).attr(N,q*i),L.attr(w,0).attr(k,q*M),s.rangeBand){var T=s,R=T.rangeBand()/2;f=s=function(n){return T(n)+R}}else f.rangeBand?f=s:d.call(n,s,f);v.call(n,f,s),y.call(n,s,s)})}var t,e=ao.scale.linear(),r=Vl,i=6,u=6,o=3,a=[10],l=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Xl?t+"":Vl,n):r},n.ticks=function(){return arguments.length?(a=co(arguments),n):a},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(i=+t,u=+arguments[e-1],n):i},n.innerTickSize=function(t){return arguments.length?(i=+t,n):i},n.outerTickSize=function(t){return arguments.length?(u=+t,n):u},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Vl="bottom",Xl={top:1,right:1,bottom:1,left:1};ao.svg.brush=function(){function n(t){t.each(function(){var t=ao.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=t.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=t.selectAll(".resize").data(v,m);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return $l[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,s=ao.transition(t),h=ao.transition(o);c&&(l=Zi(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),r(s)),f&&(l=Zi(f),h.attr("y",l[0]).attr("height",l[1]-l[0]),i(s)),e(s)})}function e(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+s[+/e$/.test(n)]+","+h[+/^s/.test(n)]+")"})}function r(n){n.select(".extent").attr("x",s[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",s[1]-s[0])}function i(n){n.select(".extent").attr("y",h[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1]-h[0])}function u(){function u(){32==ao.event.keyCode&&(C||(M=null,L[0]-=s[1],L[1]-=h[1],C=2),S())}function v(){32==ao.event.keyCode&&2==C&&(L[0]+=s[1],L[1]+=h[1],C=0,S())}function d(){var n=ao.mouse(b),t=!1;x&&(n[0]+=x[0],n[1]+=x[1]),C||(ao.event.altKey?(M||(M=[(s[0]+s[1])/2,(h[0]+h[1])/2]),L[0]=s[+(n[0]<M[0])],L[1]=h[+(n[1]<M[1])]):M=null),E&&y(n,c,0)&&(r(k),t=!0),A&&y(n,f,1)&&(i(k),t=!0),t&&(e(k),w({type:"brush",mode:C?"move":"resize"}))}function y(n,t,e){var r,i,u=Zi(t),l=u[0],c=u[1],f=L[e],v=e?h:s,d=v[1]-v[0];return C&&(l-=f,c-=d+f),r=(e?g:p)?Math.max(l,Math.min(c,n[e])):n[e],C?i=(r+=f)+d:(M&&(f=Math.max(l,Math.min(c,2*M[e]-r))),r>f?(i=r,r=f):i=f),v[0]!=r||v[1]!=i?(e?a=null:o=null,v[0]=r,v[1]=i,!0):void 0}function m(){d(),k.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ao.select("body").style("cursor",null),q.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),z(),w({type:"brushend"})}var M,x,b=this,_=ao.select(ao.event.target),w=l.of(b,arguments),k=ao.select(b),N=_.datum(),E=!/^(n|s)$/.test(N)&&c,A=!/^(e|w)$/.test(N)&&f,C=_.classed("extent"),z=W(b),L=ao.mouse(b),q=ao.select(t(b)).on("keydown.brush",u).on("keyup.brush",v);if(ao.event.changedTouches?q.on("touchmove.brush",d).on("touchend.brush",m):q.on("mousemove.brush",d).on("mouseup.brush",m),k.interrupt().selectAll("*").interrupt(),C)L[0]=s[0]-L[0],L[1]=h[0]-L[1];else if(N){var T=+/w$/.test(N),R=+/^n/.test(N);x=[s[1-T]-L[0],h[1-R]-L[1]],L[0]=s[T],L[1]=h[R]}else ao.event.altKey&&(M=L.slice());k.style("pointer-events","none").selectAll(".resize").style("display",null),ao.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),d()}var o,a,l=N(n,"brushstart","brush","brushend"),c=null,f=null,s=[0,0],h=[0,0],p=!0,g=!0,v=Bl[0];return n.event=function(n){n.each(function(){var n=l.of(this,arguments),t={x:s,y:h,i:o,j:a},e=this.__chart__||t;this.__chart__=t,Hl?ao.select(this).transition().each("start.brush",function(){o=e.i,a=e.j,s=e.x,h=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=xr(s,t.x),r=xr(h,t.y);return o=a=null,function(i){s=t.x=e(i),h=t.y=r(i),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){o=t.i,a=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,v=Bl[!c<<1|!f],n):c},n.y=function(t){return arguments.length?(f=t,v=Bl[!c<<1|!f],n):f},n.clamp=function(t){return arguments.length?(c&&f?(p=!!t[0],g=!!t[1]):c?p=!!t:f&&(g=!!t),n):c&&f?[p,g]:c?p:f?g:null},n.extent=function(t){var e,r,i,u,l;return arguments.length?(c&&(e=t[0],r=t[1],f&&(e=e[0],r=r[0]),o=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(l=e,e=r,r=l),e==s[0]&&r==s[1]||(s=[e,r])),f&&(i=t[0],u=t[1],c&&(i=i[1],u=u[1]),a=[i,u],f.invert&&(i=f(i),u=f(u)),i>u&&(l=i,i=u,u=l),i==h[0]&&u==h[1]||(h=[i,u])),n):(c&&(o?(e=o[0],r=o[1]):(e=s[0],r=s[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(l=e,e=r,r=l))),f&&(a?(i=a[0],u=a[1]):(i=h[0],u=h[1],f.invert&&(i=f.invert(i),u=f.invert(u)),i>u&&(l=i,i=u,u=l))),c&&f?[[e,i],[r,u]]:c?[e,r]:f&&[i,u])},n.clear=function(){return n.empty()||(s=[0,0],h=[0,0],o=a=null),n},n.empty=function(){return!!c&&s[0]==s[1]||!!f&&h[0]==h[1]},ao.rebind(n,l,"on")};var $l={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Bl=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Wl=ga.format=xa.timeFormat,Jl=Wl.utc,Gl=Jl("%Y-%m-%dT%H:%M:%S.%LZ");Wl.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?eo:Gl,eo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},eo.toString=Gl.toString,ga.second=On(function(n){return new va(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),ga.seconds=ga.second.range,ga.seconds.utc=ga.second.utc.range,ga.minute=On(function(n){return new va(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),ga.minutes=ga.minute.range,ga.minutes.utc=ga.minute.utc.range,ga.hour=On(function(n){var t=n.getTimezoneOffset()/60;return new va(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),ga.hours=ga.hour.range,ga.hours.utc=ga.hour.utc.range,ga.month=On(function(n){return n=ga.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),ga.months=ga.month.range,ga.months.utc=ga.month.utc.range;var Kl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Ql=[[ga.second,1],[ga.second,5],[ga.second,15],[ga.second,30],[ga.minute,1],[ga.minute,5],[ga.minute,15],[ga.minute,30],[ga.hour,1],[ga.hour,3],[ga.hour,6],[ga.hour,12],[ga.day,1],[ga.day,2],[ga.week,1],[ga.month,1],[ga.month,3],[ga.year,1]],nc=Wl.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",zt]]),tc={range:function(n,t,e){return ao.range(Math.ceil(n/e)*e,+t,e).map(io)},floor:m,ceil:m};Ql.year=ga.year,ga.scale=function(){return ro(ao.scale.linear(),Ql,nc)};var ec=Ql.map(function(n){return[n[0].utc,n[1]]}),rc=Jl.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",zt]]);ec.year=ga.year.utc,ga.scale.utc=function(){return ro(ao.scale.linear(),ec,rc)},ao.text=An(function(n){return n.responseText}),ao.json=function(n,t){return Cn(n,"application/json",uo,t)},ao.html=function(n,t){return Cn(n,"text/html",oo,t)},ao.xml=An(function(n){return n.responseXML}),"function"==typeof define&&define.amd?(this.d3=ao,define(ao)):"object"==typeof module&&module.exports?module.exports=ao:this.d3=ao}();</script><script>function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var _createClass=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}();!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.dTree=t()}(this,function(){"use strict";var e=function(){function e(t,n,r){_classCallCheck(this,e),e.DEBUG_LEVEL=r.debug?1:0,this.root=t,this.siblings=n,this.opts=r,this.allNodes=this._flatten(this.root);var a=_.filter(this.allNodes,function(e){return!e.hidden});this.nodeSize=r.callbacks.nodeSize(a,r.nodeWidth,r.callbacks.textRenderer)}return _createClass(e,[{key:"create",value:function(){var e=this.opts,t=(this.allNodes,this.nodeSize),n=e.width+e.margin.left+e.margin.right,r=e.height+e.margin.top+e.margin.bottom,a=d3.behavior.zoom().scaleExtent([.1,10]).on("zoom",_.bind(function(){i.attr("transform","translate("+d3.event.translate+") scale("+d3.event.scale+")")},this)),i=this.svg=d3.select(e.target).append("svg").attr("width",n).attr("height",r).call(a).append("g").attr("transform","translate("+n/2+","+e.margin.top+")");a.translate([n/2,e.margin.top]),this.tree=d3.layout.tree().nodeSize([2*t[0],2.5*t[1]]),this.tree.separation(function(e,t){return e.hidden||t.hidden?.3:.6}),this._update(this.root)}},{key:"_update",value:function(e){var t=this.opts,n=(this.allNodes,this.nodeSize),r=this.tree.nodes(e),a=this.tree.links(r);this.svg.selectAll(".link").data(a).enter().append("path").attr("class",t.styles.linage).attr("d",this._elbow);var r=this.svg.selectAll(".node").data(r).enter();this._linkSiblings(),this.svg.selectAll(".sibling").data(this.siblings).enter().append("path").attr("class",t.styles.marriage).attr("d",_.bind(this._siblingLine,this)),r.append("foreignObject").filter(function(e){return e.hidden?!1:!0}).attr("x",function(e){return e.x-e.cWidth/2+"px"}).attr("y",function(e){return e.y-e.cHeight/2+"px"}).attr("width",function(e){return e.cWidth+"px"}).attr("height",function(e){return e.cHeight+"px"}).attr("id",function(e){return e.id}).html(function(e){return t.callbacks.nodeRenderer(e.name,e.x,e.y,n[0],n[1],e.extra,e.id,e["class"],e.textClass,t.callbacks.textRenderer)}).on("click",function(e){e.hidden||t.callbacks.nodeClick(e.name,e.extra,e.id)})}},{key:"_flatten",value:function(e){function t(e){e.children&&e.children.forEach(t),e.id||(e.id=++r),n.push(e)}var n=[],r=0;return t(e),n}},{key:"_elbow",value:function(e,t){if(e.target.noParent)return"M0,0L0,0";var n=e.target.y+.5*(e.source.y-e.target.y),r=[{x:e.target.x,y:e.target.y},{x:e.target.x,y:n},{x:e.source.x,y:e.source.y}],a=d3.svg.line().x(function(e){return e.x}).y(function(e){return e.y}).interpolate("step-after");return a(r)}},{key:"_linkSiblings",value:function(){var e=this.allNodes;_.forEach(this.siblings,function(t){var n=e.filter(function(e){return t.source.id==e.id}),r=e.filter(function(e){return t.target.id==e.id});t.source.x=n[0].x,t.source.y=n[0].y,t.target.x=r[0].x,t.target.y=r[0].y})}},{key:"_siblingLine",value:function(e,t){var n=e.target.y+.5*(e.source.y-e.target.y),r=this.nodeSize[0],a=this.nodeSize[1];e.number>0&&(n-=8*a/10);var i=[{x:e.source.x,y:e.source.y},{x:e.source.x+6*r/10,y:e.source.y},{x:e.source.x+6*r/10,y:n},{x:e.target.x-6*r/10,y:n},{x:e.target.x-6*r/10,y:e.target.y},{x:e.target.x,y:e.target.y}],s=d3.svg.line().x(function(e){return e.x}).y(function(e){return e.y}).interpolate("linear");return s(i)}}],[{key:"_nodeSize",value:function(e,t,n){var r=0,a=document.createElement("svg");return document.body.appendChild(a),_.map(e,function(e){var i=document.createElement("div");i.setAttribute("class",e["class"]),i.style.visibility="hidden",i.style.maxWidth=t+"px";var s=n(e.name,e.extra,e.textClass);i.innerHTML=s,a.appendChild(i);var o=i.offsetHeight;a.removeChild(i),r=Math.max(r,o),e.cHeight=o,e.cWidth=t}),document.body.removeChild(a),[t,r]}},{key:"_nodeRenderer",value:function(e,t,n,r,a,i,s,o,l,d){var c="";return c+="<div ",c+='style="height:100%;width:100%;" ',c+='class="'+o+'" ',c+='id="node'+s+'">\n',c+=d(e,i,l),c+="</div>"}},{key:"_textRenderer",value:function(e,t,n){var r="";return r+="<p ",r+='align="center" ',r+='class="'+n+'">\n',r+=e,r+="</p>\n"}},{key:"_debug",value:function(t){e.DEBUG_LEVEL>0&&console.log(t)}}]),e}(),t={VERSION:"1.3.2",init:function(t){var n=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],r=_.defaultsDeep(n||{},{target:"#graph",debug:!1,width:600,height:600,callbacks:{nodeClick:function(e,t,n){},nodeRenderer:function(t,n,r,a,i,s,o,l,d,c){return e._nodeRenderer(t,n,r,a,i,s,o,l,d,c)},nodeSize:function(t,n,r){return e._nodeSize(t,n,r)},nodeSorter:function(e,t,n,r){return 0},textRenderer:function(t,n,r){return e._textRenderer(t,n,r)}},margin:{top:0,right:0,bottom:0,left:0},nodeWidth:100,styles:{node:"node",linage:"linage",marriage:"marriage",text:"nodeText"}}),t=this._preprocess(t,r),a=new e(t.root,t.siblings,r);a.create()},_preprocess:function(e,n){var r=[],a=0,i={name:"",id:a++,hidden:!0,children:[]},s=function o(e,s){var l={name:e.name,id:a++,hidden:!1,children:[],extra:e.extra,textClass:e.textClass?e.textClass:n.styles.text,"class":e["class"]?e["class"]:n.styles.node};s==i&&(l.noParent=!0);for(var d=0;d<e.depthOffset;d++){var c={name:"",id:a++,hidden:!0,children:[],noParent:l.noParent};s.children.push(c),s=c}t._sortPersons(e.children,n),_.forEach(e.children,function(e){o(e,l)}),s.children.push(l),e.marriage&&(console.log('DEPRECATED: The data attribute "marriage" is deprecated in favor of "marriages" that takes an array. It will be removed in 2.0.'),e.marriages=[e.marriage]),t._sortMarriages(e.marriages,n),_.forEach(e.marriages,function(e,i){var d={name:"",id:a++,hidden:!0,noParent:!0,children:[],extra:e.extra},c=e.spouse,u={name:c.name,id:a++,hidden:!1,noParent:!0,children:[],textClass:c.textClass?c.textClass:n.styles.text,"class":c["class"]?c["class"]:n.styles.node,extra:c.extra};s.children.push(d,u),t._sortPersons(e.children,n),_.forEach(e.children,function(e){o(e,d)}),r.push({source:{id:l.id},target:{id:u.id},number:i})})};return _.forEach(e,function(e){s(e,i)}),{root:i,siblings:r}},_sortPersons:function(e,t){return void 0!=e&&e.sort(function(e,n){return t.callbacks.nodeSorter(e.name,e.extra,n.name,n.extra)}),e},_sortMarriages:function(e,t){return void 0!=e&&Array.isArray(e)&&e.sort(function(e,n){var r=e.spouse,a=n.spouse;return t.callbacks.nodeSorter(r.name,r.extra,a.name,a.extra)}),e}};return t});
//# sourceMappingURL=dTree.min.js.map
</script><script>/**
 * @license
 * Lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 */
;(function(){function n(n,t){return n.set(t[0],t[1]),n}function t(n,t){return n.add(t),n}function r(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function e(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&false!==t(n[r],r,n););return n}function i(n,t){for(var r=null==n?0:n.length;r--&&false!==t(n[r],r,n););
return n}function o(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return false;return true}function f(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function c(n,t){return!(null==n||!n.length)&&-1<d(n,t,0)}function a(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return true;return false}function l(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function s(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];
return n}function h(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function p(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function _(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return true;return false}function v(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,false}),e}function g(n,t,r,e){var u=n.length;for(r+=e?1:-1;e?r--:++r<u;)if(t(n[r],r,n))return r;return-1}function d(n,t,r){if(t===t)n:{
--r;for(var e=n.length;++r<e;)if(n[r]===t){n=r;break n}n=-1}else n=g(n,b,r);return n}function y(n,t,r,e){--r;for(var u=n.length;++r<u;)if(e(n[r],t))return r;return-1}function b(n){return n!==n}function x(n,t){var r=null==n?0:n.length;return r?k(n,t)/r:P}function j(n){return function(t){return null==t?F:t[n]}}function w(n){return function(t){return null==n?F:n[t]}}function m(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=false,n):t(r,n,u,i)}),r}function A(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;
return n}function k(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==F&&(r=r===F?i:r+i)}return r}function E(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function O(n,t){return l(t,function(t){return[t,n[t]]})}function S(n){return function(t){return n(t)}}function I(n,t){return l(t,function(t){return n[t]})}function R(n,t){return n.has(t)}function z(n,t){for(var r=-1,e=n.length;++r<e&&-1<d(t,n[r],0););return r}function W(n,t){for(var r=n.length;r--&&-1<d(t,n[r],0););return r}function B(n){
return"\\"+Tn[n]}function L(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function U(n,t){return function(r){return n(t(r))}}function C(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&"__lodash_placeholder__"!==o||(n[r]="__lodash_placeholder__",i[u++]=r)}return i}function D(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function M(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function T(n){if(Bn.test(n)){
for(var t=zn.lastIndex=0;zn.test(n);)++t;n=t}else n=tt(n);return n}function $(n){return Bn.test(n)?n.match(zn)||[]:n.split("")}var F,N=1/0,P=NaN,Z=[["ary",128],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",32],["partialRight",64],["rearg",256]],q=/\b__p\+='';/g,V=/\b(__p\+=)''\+/g,K=/(__e\(.*?\)|\b__t\))\+'';/g,G=/&(?:amp|lt|gt|quot|#39);/g,H=/[&<>"']/g,J=RegExp(G.source),Y=RegExp(H.source),Q=/<%-([\s\S]+?)%>/g,X=/<%([\s\S]+?)%>/g,nn=/<%=([\s\S]+?)%>/g,tn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,rn=/^\w*$/,en=/^\./,un=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,on=/[\\^$.*+?()[\]{}|]/g,fn=RegExp(on.source),cn=/^\s+|\s+$/g,an=/^\s+/,ln=/\s+$/,sn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,hn=/\{\n\/\* \[wrapped with (.+)\] \*/,pn=/,? & /,_n=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,vn=/\\(\\)?/g,gn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,dn=/\w*$/,yn=/^[-+]0x[0-9a-f]+$/i,bn=/^0b[01]+$/i,xn=/^\[object .+?Constructor\]$/,jn=/^0o[0-7]+$/i,wn=/^(?:0|[1-9]\d*)$/,mn=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,An=/($^)/,kn=/['\n\r\u2028\u2029\\]/g,En="[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",On="(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])"+En,Sn="(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",In=RegExp("['\u2019]","g"),Rn=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]","g"),zn=RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|"+Sn+En,"g"),Wn=RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)|\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)|\\d+",On].join("|"),"g"),Bn=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),Ln=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Un="Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),Cn={};
Cn["[object Float32Array]"]=Cn["[object Float64Array]"]=Cn["[object Int8Array]"]=Cn["[object Int16Array]"]=Cn["[object Int32Array]"]=Cn["[object Uint8Array]"]=Cn["[object Uint8ClampedArray]"]=Cn["[object Uint16Array]"]=Cn["[object Uint32Array]"]=true,Cn["[object Arguments]"]=Cn["[object Array]"]=Cn["[object ArrayBuffer]"]=Cn["[object Boolean]"]=Cn["[object DataView]"]=Cn["[object Date]"]=Cn["[object Error]"]=Cn["[object Function]"]=Cn["[object Map]"]=Cn["[object Number]"]=Cn["[object Object]"]=Cn["[object RegExp]"]=Cn["[object Set]"]=Cn["[object String]"]=Cn["[object WeakMap]"]=false;
var Dn={};Dn["[object Arguments]"]=Dn["[object Array]"]=Dn["[object ArrayBuffer]"]=Dn["[object DataView]"]=Dn["[object Boolean]"]=Dn["[object Date]"]=Dn["[object Float32Array]"]=Dn["[object Float64Array]"]=Dn["[object Int8Array]"]=Dn["[object Int16Array]"]=Dn["[object Int32Array]"]=Dn["[object Map]"]=Dn["[object Number]"]=Dn["[object Object]"]=Dn["[object RegExp]"]=Dn["[object Set]"]=Dn["[object String]"]=Dn["[object Symbol]"]=Dn["[object Uint8Array]"]=Dn["[object Uint8ClampedArray]"]=Dn["[object Uint16Array]"]=Dn["[object Uint32Array]"]=true,
Dn["[object Error]"]=Dn["[object Function]"]=Dn["[object WeakMap]"]=false;var Mn,Tn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},$n=parseFloat,Fn=parseInt,Nn=typeof global=="object"&&global&&global.Object===Object&&global,Pn=typeof self=="object"&&self&&self.Object===Object&&self,Zn=Nn||Pn||Function("return this")(),qn=typeof exports=="object"&&exports&&!exports.nodeType&&exports,Vn=qn&&typeof module=="object"&&module&&!module.nodeType&&module,Kn=Vn&&Vn.exports===qn,Gn=Kn&&Nn.process;
n:{try{Mn=Gn&&Gn.binding&&Gn.binding("util");break n}catch(n){}Mn=void 0}var Hn=Mn&&Mn.isArrayBuffer,Jn=Mn&&Mn.isDate,Yn=Mn&&Mn.isMap,Qn=Mn&&Mn.isRegExp,Xn=Mn&&Mn.isSet,nt=Mn&&Mn.isTypedArray,tt=j("length"),rt=w({"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I",
"\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C",
"\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i",
"\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S",
"\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe",
"\u0149":"'n","\u017f":"s"}),et=w({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),ut=w({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),it=function w(En){function On(n){if(bu(n)&&!cf(n)&&!(n instanceof Mn)){if(n instanceof zn)return n;if(fi.call(n,"__wrapped__"))return Ne(n)}return new zn(n)}function Sn(){}function zn(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=F}function Mn(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,
this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Tn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Nn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Pn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function qn(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new Pn;++t<r;)this.add(n[t])}function Vn(n){
this.size=(this.__data__=new Nn(n)).size}function Gn(n,t){var r,e=cf(n),u=!e&&ff(n),i=!e&&!u&&lf(n),o=!e&&!u&&!i&&vf(n),u=(e=e||u||i||o)?E(n.length,ti):[],f=u.length;for(r in n)!t&&!fi.call(n,r)||e&&("length"==r||i&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||Se(r,f))||u.push(r);return u}function tt(n){var t=n.length;return t?n[ar(0,t-1)]:F}function ot(n,t){return Me(Tr(n),dt(t,0,n.length))}function ft(n){return Me(Tr(n))}function ct(n,t,r,e){return n===F||su(n,ui[r])&&!fi.call(e,r)?t:n;
}function at(n,t,r){(r===F||su(n[t],r))&&(r!==F||t in n)||vt(n,t,r)}function lt(n,t,r){var e=n[t];fi.call(n,t)&&su(e,r)&&(r!==F||t in n)||vt(n,t,r)}function st(n,t){for(var r=n.length;r--;)if(su(n[r][0],t))return r;return-1}function ht(n,t,r,e){return io(n,function(n,u,i){t(e,n,r(n),i)}),e}function pt(n,t){return n&&$r(t,Bu(t),n)}function _t(n,t){return n&&$r(t,Lu(t),n)}function vt(n,t,r){"__proto__"==t&&ki?ki(n,t,{configurable:true,enumerable:true,value:r,writable:true}):n[t]=r}function gt(n,t){for(var r=-1,e=t.length,u=Gu(e),i=null==n;++r<e;)u[r]=i?F:zu(n,t[r]);
return u}function dt(n,t,r){return n===n&&(r!==F&&(n=n<=r?n:r),t!==F&&(n=n>=t?n:t)),n}function yt(n,t,r,e,i,o){var f,c=1&t,a=2&t,l=4&t;if(r&&(f=i?r(n,e,i,o):r(n)),f!==F)return f;if(!yu(n))return n;if(e=cf(n)){if(f=Ae(n),!c)return Tr(n,f)}else{var s=go(n),h="[object Function]"==s||"[object GeneratorFunction]"==s;if(lf(n))return Br(n,c);if("[object Object]"==s||"[object Arguments]"==s||h&&!i){if(f=a||h?{}:ke(n),!c)return a?Nr(n,_t(f,n)):Fr(n,pt(f,n))}else{if(!Dn[s])return i?n:{};f=Ee(n,s,yt,c)}}if(o||(o=new Vn),
i=o.get(n))return i;o.set(n,f);var a=l?a?ge:ve:a?Lu:Bu,p=e?F:a(n);return u(p||n,function(e,u){p&&(u=e,e=n[u]),lt(f,u,yt(e,t,r,u,n,o))}),f}function bt(n){var t=Bu(n);return function(r){return xt(r,n,t)}}function xt(n,t,r){var e=r.length;if(null==n)return!e;for(n=Xu(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===F&&!(u in n)||!i(o))return false}return true}function jt(n,t,r){if(typeof n!="function")throw new ri("Expected a function");return xo(function(){n.apply(F,r)},t)}function wt(n,t,r,e){var u=-1,i=c,o=true,f=n.length,s=[],h=t.length;
if(!f)return s;r&&(t=l(t,S(r))),e?(i=a,o=false):200<=t.length&&(i=R,o=false,t=new qn(t));n:for(;++u<f;){var p=n[u],_=null==r?p:r(p),p=e||0!==p?p:0;if(o&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function mt(n,t){var r=true;return io(n,function(n,e,u){return r=!!t(n,e,u)}),r}function At(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===F?o===o&&!mu(o):r(o,f)))var f=o,c=i}return c}function kt(n,t){var r=[];return io(n,function(n,e,u){
t(n,e,u)&&r.push(n)}),r}function Et(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Oe),u||(u=[]);++i<o;){var f=n[i];0<t&&r(f)?1<t?Et(f,t-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function Ot(n,t){return n&&fo(n,t,Bu)}function St(n,t){return n&&co(n,t,Bu)}function It(n,t){return f(t,function(t){return vu(n[t])})}function Rt(n,t){t=zr(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[Te(t[r++])];return r&&r==e?n:F}function zt(n,t,r){return t=t(n),cf(n)?t:s(t,r(n))}function Wt(n){if(null==n)return n===F?"[object Undefined]":"[object Null]";
n=Xu(n);var t;if(Ai&&Ai in n){var r=fi.call(n,Ai),e=n[Ai];try{n[Ai]=F,t=true}catch(n){}var u=li.call(n);t&&(r?n[Ai]=e:delete n[Ai]),t=u}else t=li.call(n);return t}function Bt(n,t){return n>t}function Lt(n,t){return null!=n&&fi.call(n,t)}function Ut(n,t){return null!=n&&t in Xu(n)}function Ct(n,t,r){for(var e=r?a:c,u=n[0].length,i=n.length,o=i,f=Gu(i),s=1/0,h=[];o--;){var p=n[o];o&&t&&(p=l(p,S(t))),s=Di(p.length,s),f[o]=!r&&(t||120<=u&&120<=p.length)?new qn(o&&p):F}var p=n[0],_=-1,v=f[0];n:for(;++_<u&&h.length<s;){
var g=p[_],d=t?t(g):g,g=r||0!==g?g:0;if(v?!R(v,d):!e(h,d,r)){for(o=i;--o;){var y=f[o];if(y?!R(y,d):!e(n[o],d,r))continue n}v&&v.push(d),h.push(g)}}return h}function Dt(n,t,r){var e={};return Ot(n,function(n,u,i){t(e,r(n),u,i)}),e}function Mt(n,t,e){return t=zr(t,n),n=2>t.length?n:Rt(n,gr(t,0,-1)),t=null==n?n:n[Te(Ke(t))],null==t?F:r(t,n,e)}function Tt(n){return bu(n)&&"[object Arguments]"==Wt(n)}function $t(n){return bu(n)&&"[object ArrayBuffer]"==Wt(n)}function Ft(n){return bu(n)&&"[object Date]"==Wt(n);
}function Nt(n,t,r,e,u){if(n===t)t=true;else if(null==n||null==t||!yu(n)&&!bu(t))t=n!==n&&t!==t;else n:{var i=cf(n),o=cf(t),f="[object Array]",c="[object Array]";i||(f=go(n),f="[object Arguments]"==f?"[object Object]":f),o||(c=go(t),c="[object Arguments]"==c?"[object Object]":c);var a="[object Object]"==f,o="[object Object]"==c;if((c=f==c)&&lf(n)){if(!lf(t)){t=false;break n}i=true,a=false}if(c&&!a)u||(u=new Vn),t=i||vf(n)?he(n,t,r,e,Nt,u):pe(n,t,f,r,e,Nt,u);else{if(!(1&r)&&(i=a&&fi.call(n,"__wrapped__"),f=o&&fi.call(t,"__wrapped__"),
i||f)){n=i?n.value():n,t=f?t.value():t,u||(u=new Vn),t=Nt(n,t,r,e,u);break n}if(c)t:if(u||(u=new Vn),i=1&r,f=Bu(n),o=f.length,c=Bu(t).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in t:fi.call(t,l))){t=false;break t}}if((c=u.get(n))&&u.get(t))t=c==t;else{c=true,u.set(n,t),u.set(t,n);for(var s=i;++a<o;){var l=f[a],h=n[l],p=t[l];if(e)var _=i?e(p,h,l,t,n,u):e(h,p,l,n,t,u);if(_===F?h!==p&&!Nt(h,p,r,e,u):!_){c=false;break}s||(s="constructor"==l)}c&&!s&&(r=n.constructor,e=t.constructor,r!=e&&"constructor"in n&&"constructor"in t&&!(typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)&&(c=false)),
u.delete(n),u.delete(t),t=c}}else t=false;else t=false}}return t}function Pt(n){return bu(n)&&"[object Map]"==go(n)}function Zt(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=Xu(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return false}for(;++u<i;){var f=r[u],c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===F&&!(c in n))return false}else{if(f=new Vn,e)var s=e(a,l,c,n,t,f);if(s===F?!Nt(l,a,3,e,f):!s)return false}}return true}function qt(n){return!(!yu(n)||ai&&ai in n)&&(vu(n)?pi:xn).test($e(n))}function Vt(n){
return bu(n)&&"[object RegExp]"==Wt(n)}function Kt(n){return bu(n)&&"[object Set]"==go(n)}function Gt(n){return bu(n)&&du(n.length)&&!!Cn[Wt(n)]}function Ht(n){return typeof n=="function"?n:null==n?Fu:typeof n=="object"?cf(n)?nr(n[0],n[1]):Xt(n):qu(n)}function Jt(n){if(!We(n))return Ui(n);var t,r=[];for(t in Xu(n))fi.call(n,t)&&"constructor"!=t&&r.push(t);return r}function Yt(n,t){return n<t}function Qt(n,t){var r=-1,e=hu(n)?Gu(n.length):[];return io(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Xt(n){
var t=je(n);return 1==t.length&&t[0][2]?Be(t[0][0],t[0][1]):function(r){return r===n||Zt(r,n,t)}}function nr(n,t){return Re(n)&&t===t&&!yu(t)?Be(Te(n),t):function(r){var e=zu(r,n);return e===F&&e===t?Wu(r,n):Nt(t,e,3)}}function tr(n,t,r,e,u){n!==t&&fo(t,function(i,o){if(yu(i)){u||(u=new Vn);var f=u,c=n[o],a=t[o],l=f.get(a);if(l)at(n,o,l);else{var l=e?e(c,a,o+"",n,t,f):F,s=l===F;if(s){var h=cf(a),p=!h&&lf(a),_=!h&&!p&&vf(a),l=a;h||p||_?cf(c)?l=c:pu(c)?l=Tr(c):p?(s=false,l=Br(a,true)):_?(s=false,l=Ur(a,true)):l=[]:ju(a)||ff(a)?(l=c,
ff(c)?l=Iu(c):(!yu(c)||r&&vu(c))&&(l=ke(a))):s=false}s&&(f.set(a,l),tr(l,a,r,e,f),f.delete(a)),at(n,o,l)}}else f=e?e(n[o],i,o+"",n,t,u):F,f===F&&(f=i),at(n,o,f)},Lu)}function rr(n,t){var r=n.length;if(r)return t+=0>t?r:0,Se(t,r)?n[t]:F}function er(n,t,r){var e=-1;return t=l(t.length?t:[Fu],S(be())),n=Qt(n,function(n){return{a:l(t,function(t){return t(n)}),b:++e,c:n}}),A(n,function(n,t){var e;n:{e=-1;for(var u=n.a,i=t.a,o=u.length,f=r.length;++e<o;){var c=Cr(u[e],i[e]);if(c){e=e>=f?c:c*("desc"==r[e]?-1:1);
break n}}e=n.b-t.b}return e})}function ur(n,t){return n=Xu(n),ir(n,t,function(t,r){return Wu(n,r)})}function ir(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=Rt(n,o);r(f,o)&&_r(i,zr(o,n),f)}return i}function or(n){return function(t){return Rt(t,n)}}function fr(n,t,r,e){var u=e?y:d,i=-1,o=t.length,f=n;for(n===t&&(t=Tr(t)),r&&(f=l(n,S(r)));++i<o;)for(var c=0,a=t[i],a=r?r(a):a;-1<(c=u(f,a,c,e));)f!==n&&ji.call(f,c,1),ji.call(n,c,1);return n}function cr(n,t){for(var r=n?t.length:0,e=r-1;r--;){
var u=t[r];if(r==e||u!==i){var i=u;Se(u)?ji.call(n,u,1):Ar(n,u)}}}function ar(n,t){return n+Ri($i()*(t-n+1))}function lr(n,t){var r="";if(!n||1>t||9007199254740991<t)return r;do t%2&&(r+=n),(t=Ri(t/2))&&(n+=n);while(t);return r}function sr(n,t){return jo(Ue(n,t,Fu),n+"")}function hr(n){return tt(Cu(n))}function pr(n,t){var r=Cu(n);return Me(r,dt(t,0,r.length))}function _r(n,t,r,e){if(!yu(n))return n;t=zr(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=Te(t[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):F;
a===F&&(a=yu(l)?l:Se(t[u+1])?[]:{})}lt(f,c,a),f=f[c]}return n}function vr(n){return Me(Cu(n))}function gr(n,t,r){var e=-1,u=n.length;for(0>t&&(t=-t>u?0:u+t),r=r>u?u:r,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Gu(u);++e<u;)r[e]=n[e+t];return r}function dr(n,t){var r;return io(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function yr(n,t,r){var e=0,u=null==n?e:n.length;if(typeof t=="number"&&t===t&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!mu(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return br(n,t,Fu,r);
}function br(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,c=mu(t),a=t===F;u<i;){var l=Ri((u+i)/2),s=r(n[l]),h=s!==F,p=null===s,_=s===s,v=mu(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=t:s<t)?u=l+1:i=l}return Di(i,4294967294)}function xr(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!su(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function jr(n){return typeof n=="number"?n:mu(n)?P:+n}function wr(n){if(typeof n=="string")return n;
if(cf(n))return l(n,wr)+"";if(mu(n))return eo?eo.call(n):"";var t=n+"";return"0"==t&&1/n==-N?"-0":t}function mr(n,t,r){var e=-1,u=c,i=n.length,o=true,f=[],l=f;if(r)o=false,u=a;else if(200<=i){if(u=t?null:ho(n))return D(u);o=false,u=R,l=new qn}else l=t?[]:f;n:for(;++e<i;){var s=n[e],h=t?t(s):s,s=r||0!==s?s:0;if(o&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue n;t&&l.push(h),f.push(s)}else u(l,h,r)||(l!==f&&l.push(h),f.push(s))}return f}function Ar(n,t){return t=zr(t,n),n=2>t.length?n:Rt(n,gr(t,0,-1)),
null==n||delete n[Te(Ke(t))]}function kr(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?gr(n,e?0:i,e?i+1:u):gr(n,e?i+1:0,e?u:i)}function Er(n,t){var r=n;return r instanceof Mn&&(r=r.value()),h(t,function(n,t){return t.func.apply(t.thisArg,s([n],t.args))},r)}function Or(n,t,r){var e=n.length;if(2>e)return e?mr(n[0]):[];for(var u=-1,i=Gu(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=wt(i[u]||o,n[f],t,r));return mr(Et(i,1),t,r)}function Sr(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;)r(o,n[e],e<i?t[e]:F);
return o}function Ir(n){return pu(n)?n:[]}function Rr(n){return typeof n=="function"?n:Fu}function zr(n,t){return cf(n)?n:Re(n,t)?[n]:wo(Ru(n))}function Wr(n,t,r){var e=n.length;return r=r===F?e:r,!t&&r>=e?n:gr(n,t,r)}function Br(n,t){if(t)return n.slice();var r=n.length,r=di?di(r):new n.constructor(r);return n.copy(r),r}function Lr(n){var t=new n.constructor(n.byteLength);return new gi(t).set(new gi(n)),t}function Ur(n,t){return new n.constructor(t?Lr(n.buffer):n.buffer,n.byteOffset,n.length)}function Cr(n,t){
if(n!==t){var r=n!==F,e=null===n,u=n===n,i=mu(n),o=t!==F,f=null===t,c=t===t,a=mu(t);if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Dr(n,t,r,e){var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Ci(i-o,0),l=Gu(c+a);for(e=!e;++f<c;)l[f]=t[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l}function Mr(n,t,r,e){var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Ci(i-f,0),s=Gu(l+a);
for(e=!e;++u<l;)s[u]=n[u];for(l=u;++c<a;)s[l+c]=t[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=n[u++]);return s}function Tr(n,t){var r=-1,e=n.length;for(t||(t=Gu(e));++r<e;)t[r]=n[r];return t}function $r(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):F;c===F&&(c=n[f]),u?vt(r,f,c):lt(r,f,c)}return r}function Fr(n,t){return $r(n,_o(n),t)}function Nr(n,t){return $r(n,vo(n),t)}function Pr(n,t){return function(r,u){var i=cf(r)?e:ht,o=t?t():{};return i(r,n,be(u,2),o);
}}function Zr(n){return sr(function(t,r){var e=-1,u=r.length,i=1<u?r[u-1]:F,o=2<u?r[2]:F,i=3<n.length&&typeof i=="function"?(u--,i):F;for(o&&Ie(r[0],r[1],o)&&(i=3>u?F:i,u=1),t=Xu(t);++e<u;)(o=r[e])&&n(t,o,e,i);return t})}function qr(n,t){return function(r,e){if(null==r)return r;if(!hu(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=Xu(r);(t?i--:++i<u)&&false!==e(o[i],i,o););return r}}function Vr(n){return function(t,r,e){var u=-1,i=Xu(t);e=e(t);for(var o=e.length;o--;){var f=e[n?o:++u];if(false===r(i[f],f,i))break;
}return t}}function Kr(n,t,r){function e(){return(this&&this!==Zn&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=1&t,i=Jr(n);return e}function Gr(n){return function(t){t=Ru(t);var r=Bn.test(t)?$(t):F,e=r?r[0]:t.charAt(0);return t=r?Wr(r,1).join(""):t.slice(1),e[n]()+t}}function Hr(n){return function(t){return h(Tu(Mu(t).replace(In,"")),n,"")}}function Jr(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:
return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=uo(n.prototype),t=n.apply(r,t);return yu(t)?t:r}}function Yr(n,t,e){function u(){for(var o=arguments.length,f=Gu(o),c=o,a=ye(u);c--;)f[c]=arguments[c];return c=3>o&&f[0]!==a&&f[o-1]!==a?[]:C(f,a),o-=c.length,o<e?ce(n,t,ne,u.placeholder,F,f,c,F,F,e-o):r(this&&this!==Zn&&this instanceof u?i:n,this,f);
}var i=Jr(n);return u}function Qr(n){return function(t,r,e){var u=Xu(t);if(!hu(t)){var i=be(r,3);t=Bu(t),r=function(n){return i(u[n],n,u)}}return r=n(t,r,e),-1<r?u[i?t[r]:r]:F}}function Xr(n){return _e(function(t){var r=t.length,e=r,u=zn.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if(typeof i!="function")throw new ri("Expected a function");if(u&&!o&&"wrapper"==de(i))var o=new zn([],true)}for(e=o?e:r;++e<r;)var i=t[e],u=de(i),f="wrapper"==u?po(i):F,o=f&&ze(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[de(f[0])].apply(o,f[3]):1==i.length&&ze(i)?o[u]():o.thru(i);
return function(){var n=arguments,e=n[0];if(o&&1==n.length&&cf(e)&&200<=e.length)return o.plant(e).value();for(var u=0,n=r?t[u].apply(this,n):e;++u<r;)n=t[u].call(this,n);return n}})}function ne(n,t,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Gu(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=ye(l),b=y.length;for(x=0;b--;)y[b]===j&&++x}if(e&&(y=Dr(y,e,u,_)),i&&(y=Mr(y,i,o,_)),d-=x,_&&d<a)return j=C(y,j),ce(n,t,ne,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[n]:n,d=y.length,f){x=y.length;
for(var w=Di(f.length,x),m=Tr(y);w--;){var A=f[w];y[w]=Se(A,x)?m[A]:F}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==Zn&&this instanceof l&&(b=g||Jr(b)),b.apply(j,y)}var s=128&t,h=1&t,p=2&t,_=24&t,v=512&t,g=p?F:Jr(n);return l}function te(n,t){return function(r,e){return Dt(r,n,t(e))}}function re(n,t){return function(r,e){var u;if(r===F&&e===F)return t;if(r!==F&&(u=r),e!==F){if(u===F)return e;typeof r=="string"||typeof e=="string"?(r=wr(r),e=wr(e)):(r=jr(r),e=jr(e)),u=n(r,e)}return u;
}}function ee(n){return _e(function(t){return t=l(t,S(be())),sr(function(e){var u=this;return n(t,function(n){return r(n,u,e)})})})}function ue(n,t){t=t===F?" ":wr(t);var r=t.length;return 2>r?r?lr(t,n):t:(r=lr(t,Ii(n/T(t))),Bn.test(t)?Wr($(r),0,n).join(""):r.slice(0,n))}function ie(n,t,e,u){function i(){for(var t=-1,c=arguments.length,a=-1,l=u.length,s=Gu(l+c),h=this&&this!==Zn&&this instanceof i?f:n;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++t];return r(h,o?e:this,s)}var o=1&t,f=Jr(n);return i;
}function oe(n){return function(t,r,e){e&&typeof e!="number"&&Ie(t,r,e)&&(r=e=F),t=ku(t),r===F?(r=t,t=0):r=ku(r),e=e===F?t<r?1:-1:ku(e);var u=-1;r=Ci(Ii((r-t)/(e||1)),0);for(var i=Gu(r);r--;)i[n?r:++u]=t,t+=e;return i}}function fe(n){return function(t,r){return typeof t=="string"&&typeof r=="string"||(t=Su(t),r=Su(r)),n(t,r)}}function ce(n,t,r,e,u,i,o,f,c,a){var l=8&t,s=l?o:F;o=l?F:o;var h=l?i:F;return i=l?F:i,t=(t|(l?32:64))&~(l?64:32),4&t||(t&=-4),u=[n,t,u,h,s,i,o,f,c,a],r=r.apply(F,u),ze(n)&&bo(r,u),
r.placeholder=e,Ce(r,n,t)}function ae(n){var t=Qu[n];return function(n,r){if(n=Su(n),r=Di(Eu(r),292)){var e=(Ru(n)+"e").split("e"),e=t(e[0]+"e"+(+e[1]+r)),e=(Ru(e)+"e").split("e");return+(e[0]+"e"+(+e[1]-r))}return t(n)}}function le(n){return function(t){var r=go(t);return"[object Map]"==r?L(t):"[object Set]"==r?M(t):O(t,n(t))}}function se(n,t,r,e,u,i,o,f){var c=2&t;if(!c&&typeof n!="function")throw new ri("Expected a function");var a=e?e.length:0;if(a||(t&=-97,e=u=F),o=o===F?o:Ci(Eu(o),0),f=f===F?f:Eu(f),
a-=u?u.length:0,64&t){var l=e,s=u;e=u=F}var h=c?F:po(n);return i=[n,t,r,e,u,l,s,i,o,f],h&&(r=i[1],n=h[1],t=r|n,e=128==n&&8==r||128==n&&256==r&&i[7].length<=h[8]||384==n&&h[7].length<=h[8]&&8==r,131>t||e)&&(1&n&&(i[2]=h[2],t|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Dr(e,r,h[4]):r,i[4]=e?C(i[3],"__lodash_placeholder__"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Mr(e,r,h[6]):r,i[6]=e?C(i[5],"__lodash_placeholder__"):h[6]),(r=h[7])&&(i[7]=r),128&n&&(i[8]=null==i[8]?h[8]:Di(i[8],h[8])),null==i[9]&&(i[9]=h[9]),i[0]=h[0],
i[1]=t),n=i[0],t=i[1],r=i[2],e=i[3],u=i[4],f=i[9]=null==i[9]?c?0:n.length:Ci(i[9]-a,0),!f&&24&t&&(t&=-25),Ce((h?ao:bo)(t&&1!=t?8==t||16==t?Yr(n,t,f):32!=t&&33!=t||u.length?ne.apply(F,i):ie(n,t,r,e):Kr(n,t,r),i),n,t)}function he(n,t,r,e,u,i){var o=1&r,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(n))&&i.get(t))return c==t;var c=-1,a=true,l=2&r?new qn:F;for(i.set(n,t),i.set(t,n);++c<f;){var s=n[c],h=t[c];if(e)var p=o?e(h,s,c,t,n,i):e(s,h,c,n,t,i);if(p!==F){if(p)continue;a=false;break}if(l){
if(!_(t,function(n,t){if(!R(l,t)&&(s===n||u(s,n,r,e,i)))return l.push(t)})){a=false;break}}else if(s!==h&&!u(s,h,r,e,i)){a=false;break}}return i.delete(n),i.delete(t),a}function pe(n,t,r,e,u,i,o){switch(r){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)break;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":if(n.byteLength!=t.byteLength||!i(new gi(n),new gi(t)))break;return true;case"[object Boolean]":case"[object Date]":case"[object Number]":return su(+n,+t);case"[object Error]":
return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=L;case"[object Set]":if(f||(f=D),n.size!=t.size&&!(1&e))break;return(r=o.get(n))?r==t:(e|=2,o.set(n,t),t=he(f(n),f(t),e,u,i,o),o.delete(n),t);case"[object Symbol]":if(ro)return ro.call(n)==ro.call(t)}return false}function _e(n){return jo(Ue(n,F,qe),n+"")}function ve(n){return zt(n,Bu,_o)}function ge(n){return zt(n,Lu,vo)}function de(n){for(var t=n.name+"",r=Hi[t],e=fi.call(Hi,t)?r.length:0;e--;){
var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function ye(n){return(fi.call(On,"placeholder")?On:n).placeholder}function be(){var n=On.iteratee||Nu,n=n===Nu?Ht:n;return arguments.length?n(arguments[0],arguments[1]):n}function xe(n,t){var r=n.__data__,e=typeof t;return("string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t)?r[typeof t=="string"?"string":"hash"]:r.map}function je(n){for(var t=Bu(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,u===u&&!yu(u)]}return t;
}function we(n,t){var r=null==n?F:n[t];return qt(r)?r:F}function me(n,t,r){t=zr(t,n);for(var e=-1,u=t.length,i=false;++e<u;){var o=Te(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&du(u)&&Se(o,u)&&(cf(n)||ff(n)))}function Ae(n){var t=n.length,r=n.constructor(t);return t&&"string"==typeof n[0]&&fi.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function ke(n){return typeof n.constructor!="function"||We(n)?{}:uo(yi(n))}function Ee(r,e,u,i){var o=r.constructor;
switch(e){case"[object ArrayBuffer]":return Lr(r);case"[object Boolean]":case"[object Date]":return new o(+r);case"[object DataView]":return e=i?Lr(r.buffer):r.buffer,new r.constructor(e,r.byteOffset,r.byteLength);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":case"[object Uint16Array]":case"[object Uint32Array]":return Ur(r,i);case"[object Map]":return e=i?u(L(r),1):L(r),
h(e,n,new r.constructor);case"[object Number]":case"[object String]":return new o(r);case"[object RegExp]":return e=new r.constructor(r.source,dn.exec(r)),e.lastIndex=r.lastIndex,e;case"[object Set]":return e=i?u(D(r),1):D(r),h(e,t,new r.constructor);case"[object Symbol]":return ro?Xu(ro.call(r)):{}}}function Oe(n){return cf(n)||ff(n)||!!(wi&&n&&n[wi])}function Se(n,t){return t=null==t?9007199254740991:t,!!t&&(typeof n=="number"||wn.test(n))&&-1<n&&0==n%1&&n<t}function Ie(n,t,r){if(!yu(r))return false;
var e=typeof t;return!!("number"==e?hu(r)&&Se(t,r.length):"string"==e&&t in r)&&su(r[t],n)}function Re(n,t){if(cf(n))return false;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!mu(n))||(rn.test(n)||!tn.test(n)||null!=t&&n in Xu(t))}function ze(n){var t=de(n),r=On[t];return typeof r=="function"&&t in Mn.prototype&&(n===r||(t=po(r),!!t&&n===t[0]))}function We(n){var t=n&&n.constructor;return n===(typeof t=="function"&&t.prototype||ui)}function Be(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==F||n in Xu(r)));
}}function Le(n,t,r,e,u,i){return yu(n)&&yu(t)&&(i.set(t,n),tr(n,t,F,Le,i),i.delete(t)),n}function Ue(n,t,e){return t=Ci(t===F?n.length-1:t,0),function(){for(var u=arguments,i=-1,o=Ci(u.length-t,0),f=Gu(o);++i<o;)f[i]=u[t+i];for(i=-1,o=Gu(t+1);++i<t;)o[i]=u[i];return o[t]=e(f),r(n,this,o)}}function Ce(n,t,r){var e=t+"";t=jo;var u,i=Fe;return u=(u=e.match(hn))?u[1].split(pn):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?"& ":"")+r[u],r=r.join(2<i?", ":" "),e=e.replace(sn,"{\n/* [wrapped with "+r+"] */\n")),
t(n,e)}function De(n){var t=0,r=0;return function(){var e=Mi(),u=16-(e-r);if(r=e,0<u){if(800<=++t)return arguments[0]}else t=0;return n.apply(F,arguments)}}function Me(n,t){var r=-1,e=n.length,u=e-1;for(t=t===F?e:t;++r<t;){var e=ar(r,u),i=n[e];n[e]=n[r],n[r]=i}return n.length=t,n}function Te(n){if(typeof n=="string"||mu(n))return n;var t=n+"";return"0"==t&&1/n==-N?"-0":t}function $e(n){if(null!=n){try{return oi.call(n)}catch(n){}return n+""}return""}function Fe(n,t){return u(Z,function(r){var e="_."+r[0];
t&r[1]&&!c(n,e)&&n.push(e)}),n.sort()}function Ne(n){if(n instanceof Mn)return n.clone();var t=new zn(n.__wrapped__,n.__chain__);return t.__actions__=Tr(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function Pe(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Eu(r),0>r&&(r=Ci(e+r,0)),g(n,be(t,3),r)):-1}function Ze(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==F&&(u=Eu(r),u=0>r?Ci(e+u,0):Di(u,e-1)),g(n,be(t,3),u,true)}function qe(n){return(null==n?0:n.length)?Et(n,1):[];
}function Ve(n){return n&&n.length?n[0]:F}function Ke(n){var t=null==n?0:n.length;return t?n[t-1]:F}function Ge(n,t){return n&&n.length&&t&&t.length?fr(n,t):n}function He(n){return null==n?n:Fi.call(n)}function Je(n){if(!n||!n.length)return[];var t=0;return n=f(n,function(n){if(pu(n))return t=Ci(n.length,t),true}),E(t,function(t){return l(n,j(t))})}function Ye(n,t){if(!n||!n.length)return[];var e=Je(n);return null==t?e:l(e,function(n){return r(t,F,n)})}function Qe(n){return n=On(n),n.__chain__=true,n;
}function Xe(n,t){return t(n)}function nu(){return this}function tu(n,t){return(cf(n)?u:io)(n,be(t,3))}function ru(n,t){return(cf(n)?i:oo)(n,be(t,3))}function eu(n,t){return(cf(n)?l:Qt)(n,be(t,3))}function uu(n,t,r){return t=r?F:t,t=n&&null==t?n.length:t,se(n,128,F,F,F,F,t)}function iu(n,t){var r;if(typeof t!="function")throw new ri("Expected a function");return n=Eu(n),function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=F),r}}function ou(n,t,r){return t=r?F:t,n=se(n,8,F,F,F,F,F,t),n.placeholder=ou.placeholder,
n}function fu(n,t,r){return t=r?F:t,n=se(n,16,F,F,F,F,F,t),n.placeholder=fu.placeholder,n}function cu(n,t,r){function e(t){var r=c,e=a;return c=a=F,_=t,s=n.apply(e,r)}function u(n){var r=n-p;return n-=_,p===F||r>=t||0>r||g&&n>=l}function i(){var n=Ho();if(u(n))return o(n);var r,e=xo;r=n-_,n=t-(n-p),r=g?Di(n,l-r):n,h=e(i,r)}function o(n){return h=F,d&&c?e(n):(c=a=F,s)}function f(){var n=Ho(),r=u(n);if(c=arguments,a=this,p=n,r){if(h===F)return _=n=p,h=xo(i,t),v?e(n):s;if(g)return h=xo(i,t),e(p)}return h===F&&(h=xo(i,t)),
s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof n!="function")throw new ri("Expected a function");return t=Su(t)||0,yu(r)&&(v=!!r.leading,l=(g="maxWait"in r)?Ci(Su(r.maxWait)||0,t):l,d="trailing"in r?!!r.trailing:d),f.cancel=function(){h!==F&&so(h),_=0,c=p=a=h=F},f.flush=function(){return h===F?s:o(Ho())},f}function au(n,t){function r(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=n.apply(this,e),r.cache=i.set(u,e)||i,e)}if(typeof n!="function"||null!=t&&typeof t!="function")throw new ri("Expected a function");
return r.cache=new(au.Cache||Pn),r}function lu(n){if(typeof n!="function")throw new ri("Expected a function");return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function su(n,t){return n===t||n!==n&&t!==t}function hu(n){return null!=n&&du(n.length)&&!vu(n)}function pu(n){return bu(n)&&hu(n)}function _u(n){if(!bu(n))return false;var t=Wt(n);return"[object Error]"==t||"[object DOMException]"==t||typeof n.message=="string"&&typeof n.name=="string"&&!ju(n);
}function vu(n){return!!yu(n)&&(n=Wt(n),"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n)}function gu(n){return typeof n=="number"&&n==Eu(n)}function du(n){return typeof n=="number"&&-1<n&&0==n%1&&9007199254740991>=n}function yu(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function bu(n){return null!=n&&typeof n=="object"}function xu(n){return typeof n=="number"||bu(n)&&"[object Number]"==Wt(n)}function ju(n){return!(!bu(n)||"[object Object]"!=Wt(n))&&(n=yi(n),
null===n||(n=fi.call(n,"constructor")&&n.constructor,typeof n=="function"&&n instanceof n&&oi.call(n)==si))}function wu(n){return typeof n=="string"||!cf(n)&&bu(n)&&"[object String]"==Wt(n)}function mu(n){return typeof n=="symbol"||bu(n)&&"[object Symbol]"==Wt(n)}function Au(n){if(!n)return[];if(hu(n))return wu(n)?$(n):Tr(n);if(mi&&n[mi]){n=n[mi]();for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}return t=go(n),("[object Map]"==t?L:"[object Set]"==t?D:Cu)(n)}function ku(n){return n?(n=Su(n),
n===N||n===-N?1.7976931348623157e308*(0>n?-1:1):n===n?n:0):0===n?n:0}function Eu(n){n=ku(n);var t=n%1;return n===n?t?n-t:n:0}function Ou(n){return n?dt(Eu(n),0,4294967295):0}function Su(n){if(typeof n=="number")return n;if(mu(n))return P;if(yu(n)&&(n=typeof n.valueOf=="function"?n.valueOf():n,n=yu(n)?n+"":n),typeof n!="string")return 0===n?n:+n;n=n.replace(cn,"");var t=bn.test(n);return t||jn.test(n)?Fn(n.slice(2),t?2:8):yn.test(n)?P:+n}function Iu(n){return $r(n,Lu(n))}function Ru(n){return null==n?"":wr(n);
}function zu(n,t,r){return n=null==n?F:Rt(n,t),n===F?r:n}function Wu(n,t){return null!=n&&me(n,t,Ut)}function Bu(n){return hu(n)?Gn(n):Jt(n)}function Lu(n){if(hu(n))n=Gn(n,true);else if(yu(n)){var t,r=We(n),e=[];for(t in n)("constructor"!=t||!r&&fi.call(n,t))&&e.push(t);n=e}else{if(t=[],null!=n)for(r in Xu(n))t.push(r);n=t}return n}function Uu(n,t){if(null==n)return{};var r=l(ge(n),function(n){return[n]});return t=be(t),ir(n,r,function(n,r){return t(n,r[0])})}function Cu(n){return null==n?[]:I(n,Bu(n));
}function Du(n){return Ff(Ru(n).toLowerCase())}function Mu(n){return(n=Ru(n))&&n.replace(mn,rt).replace(Rn,"")}function Tu(n,t,r){return n=Ru(n),t=r?F:t,t===F?Ln.test(n)?n.match(Wn)||[]:n.match(_n)||[]:n.match(t)||[]}function $u(n){return function(){return n}}function Fu(n){return n}function Nu(n){return Ht(typeof n=="function"?n:yt(n,1))}function Pu(n,t,r){var e=Bu(t),i=It(t,e);null!=r||yu(t)&&(i.length||!e.length)||(r=t,t=n,n=this,i=It(t,Bu(t)));var o=!(yu(r)&&"chain"in r&&!r.chain),f=vu(n);return u(i,function(r){
var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Tr(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,s([this.value()],arguments))})}),n}function Zu(){}function qu(n){return Re(n)?j(Te(n)):or(n)}function Vu(){return[]}function Ku(){return false}En=null==En?Zn:it.defaults(Zn.Object(),En,it.pick(Zn,Un));var Gu=En.Array,Hu=En.Date,Ju=En.Error,Yu=En.Function,Qu=En.Math,Xu=En.Object,ni=En.RegExp,ti=En.String,ri=En.TypeError,ei=Gu.prototype,ui=Xu.prototype,ii=En["__core-js_shared__"],oi=Yu.prototype.toString,fi=ui.hasOwnProperty,ci=0,ai=function(){
var n=/[^.]+$/.exec(ii&&ii.keys&&ii.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),li=ui.toString,si=oi.call(Xu),hi=Zn._,pi=ni("^"+oi.call(fi).replace(on,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),_i=Kn?En.Buffer:F,vi=En.Symbol,gi=En.Uint8Array,di=_i?_i.f:F,yi=U(Xu.getPrototypeOf,Xu),bi=Xu.create,xi=ui.propertyIsEnumerable,ji=ei.splice,wi=vi?vi.isConcatSpreadable:F,mi=vi?vi.iterator:F,Ai=vi?vi.toStringTag:F,ki=function(){try{var n=we(Xu,"defineProperty");
return n({},"",{}),n}catch(n){}}(),Ei=En.clearTimeout!==Zn.clearTimeout&&En.clearTimeout,Oi=Hu&&Hu.now!==Zn.Date.now&&Hu.now,Si=En.setTimeout!==Zn.setTimeout&&En.setTimeout,Ii=Qu.ceil,Ri=Qu.floor,zi=Xu.getOwnPropertySymbols,Wi=_i?_i.isBuffer:F,Bi=En.isFinite,Li=ei.join,Ui=U(Xu.keys,Xu),Ci=Qu.max,Di=Qu.min,Mi=Hu.now,Ti=En.parseInt,$i=Qu.random,Fi=ei.reverse,Ni=we(En,"DataView"),Pi=we(En,"Map"),Zi=we(En,"Promise"),qi=we(En,"Set"),Vi=we(En,"WeakMap"),Ki=we(Xu,"create"),Gi=Vi&&new Vi,Hi={},Ji=$e(Ni),Yi=$e(Pi),Qi=$e(Zi),Xi=$e(qi),no=$e(Vi),to=vi?vi.prototype:F,ro=to?to.valueOf:F,eo=to?to.toString:F,uo=function(){
function n(){}return function(t){return yu(t)?bi?bi(t):(n.prototype=t,t=new n,n.prototype=F,t):{}}}();On.templateSettings={escape:Q,evaluate:X,interpolate:nn,variable:"",imports:{_:On}},On.prototype=Sn.prototype,On.prototype.constructor=On,zn.prototype=uo(Sn.prototype),zn.prototype.constructor=zn,Mn.prototype=uo(Sn.prototype),Mn.prototype.constructor=Mn,Tn.prototype.clear=function(){this.__data__=Ki?Ki(null):{},this.size=0},Tn.prototype.delete=function(n){return n=this.has(n)&&delete this.__data__[n],
this.size-=n?1:0,n},Tn.prototype.get=function(n){var t=this.__data__;return Ki?(n=t[n],"__lodash_hash_undefined__"===n?F:n):fi.call(t,n)?t[n]:F},Tn.prototype.has=function(n){var t=this.__data__;return Ki?t[n]!==F:fi.call(t,n)},Tn.prototype.set=function(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=Ki&&t===F?"__lodash_hash_undefined__":t,this},Nn.prototype.clear=function(){this.__data__=[],this.size=0},Nn.prototype.delete=function(n){var t=this.__data__;return n=st(t,n),!(0>n)&&(n==t.length-1?t.pop():ji.call(t,n,1),
--this.size,true)},Nn.prototype.get=function(n){var t=this.__data__;return n=st(t,n),0>n?F:t[n][1]},Nn.prototype.has=function(n){return-1<st(this.__data__,n)},Nn.prototype.set=function(n,t){var r=this.__data__,e=st(r,n);return 0>e?(++this.size,r.push([n,t])):r[e][1]=t,this},Pn.prototype.clear=function(){this.size=0,this.__data__={hash:new Tn,map:new(Pi||Nn),string:new Tn}},Pn.prototype.delete=function(n){return n=xe(this,n).delete(n),this.size-=n?1:0,n},Pn.prototype.get=function(n){return xe(this,n).get(n);
},Pn.prototype.has=function(n){return xe(this,n).has(n)},Pn.prototype.set=function(n,t){var r=xe(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this},qn.prototype.add=qn.prototype.push=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this},qn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.clear=function(){this.__data__=new Nn,this.size=0},Vn.prototype.delete=function(n){var t=this.__data__;return n=t.delete(n),this.size=t.size,n},Vn.prototype.get=function(n){
return this.__data__.get(n)},Vn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.set=function(n,t){var r=this.__data__;if(r instanceof Nn){var e=r.__data__;if(!Pi||199>e.length)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new Pn(e)}return r.set(n,t),this.size=r.size,this};var io=qr(Ot),oo=qr(St,true),fo=Vr(),co=Vr(true),ao=Gi?function(n,t){return Gi.set(n,t),n}:Fu,lo=ki?function(n,t){return ki(n,"toString",{configurable:true,enumerable:false,value:$u(t),writable:true})}:Fu,so=Ei||function(n){
return Zn.clearTimeout(n)},ho=qi&&1/D(new qi([,-0]))[1]==N?function(n){return new qi(n)}:Zu,po=Gi?function(n){return Gi.get(n)}:Zu,_o=zi?U(zi,Xu):Vu,vo=zi?function(n){for(var t=[];n;)s(t,_o(n)),n=yi(n);return t}:Vu,go=Wt;(Ni&&"[object DataView]"!=go(new Ni(new ArrayBuffer(1)))||Pi&&"[object Map]"!=go(new Pi)||Zi&&"[object Promise]"!=go(Zi.resolve())||qi&&"[object Set]"!=go(new qi)||Vi&&"[object WeakMap]"!=go(new Vi))&&(go=function(n){var t=Wt(n);if(n=(n="[object Object]"==t?n.constructor:F)?$e(n):"")switch(n){
case Ji:return"[object DataView]";case Yi:return"[object Map]";case Qi:return"[object Promise]";case Xi:return"[object Set]";case no:return"[object WeakMap]"}return t});var yo=ii?vu:Ku,bo=De(ao),xo=Si||function(n,t){return Zn.setTimeout(n,t)},jo=De(lo),wo=function(n){n=au(n,function(n){return 500===t.size&&t.clear(),n});var t=n.cache;return n}(function(n){var t=[];return en.test(n)&&t.push(""),n.replace(un,function(n,r,e,u){t.push(e?u.replace(vn,"$1"):r||n)}),t}),mo=sr(function(n,t){return pu(n)?wt(n,Et(t,1,pu,true)):[];
}),Ao=sr(function(n,t){var r=Ke(t);return pu(r)&&(r=F),pu(n)?wt(n,Et(t,1,pu,true),be(r,2)):[]}),ko=sr(function(n,t){var r=Ke(t);return pu(r)&&(r=F),pu(n)?wt(n,Et(t,1,pu,true),F,r):[]}),Eo=sr(function(n){var t=l(n,Ir);return t.length&&t[0]===n[0]?Ct(t):[]}),Oo=sr(function(n){var t=Ke(n),r=l(n,Ir);return t===Ke(r)?t=F:r.pop(),r.length&&r[0]===n[0]?Ct(r,be(t,2)):[]}),So=sr(function(n){var t=Ke(n),r=l(n,Ir);return(t=typeof t=="function"?t:F)&&r.pop(),r.length&&r[0]===n[0]?Ct(r,F,t):[]}),Io=sr(Ge),Ro=_e(function(n,t){
var r=null==n?0:n.length,e=gt(n,t);return cr(n,l(t,function(n){return Se(n,r)?+n:n}).sort(Cr)),e}),zo=sr(function(n){return mr(Et(n,1,pu,true))}),Wo=sr(function(n){var t=Ke(n);return pu(t)&&(t=F),mr(Et(n,1,pu,true),be(t,2))}),Bo=sr(function(n){var t=Ke(n),t=typeof t=="function"?t:F;return mr(Et(n,1,pu,true),F,t)}),Lo=sr(function(n,t){return pu(n)?wt(n,t):[]}),Uo=sr(function(n){return Or(f(n,pu))}),Co=sr(function(n){var t=Ke(n);return pu(t)&&(t=F),Or(f(n,pu),be(t,2))}),Do=sr(function(n){var t=Ke(n),t=typeof t=="function"?t:F;
return Or(f(n,pu),F,t)}),Mo=sr(Je),To=sr(function(n){var t=n.length,t=1<t?n[t-1]:F,t=typeof t=="function"?(n.pop(),t):F;return Ye(n,t)}),$o=_e(function(n){function t(t){return gt(t,n)}var r=n.length,e=r?n[0]:0,u=this.__wrapped__;return!(1<r||this.__actions__.length)&&u instanceof Mn&&Se(e)?(u=u.slice(e,+e+(r?1:0)),u.__actions__.push({func:Xe,args:[t],thisArg:F}),new zn(u,this.__chain__).thru(function(n){return r&&!n.length&&n.push(F),n})):this.thru(t)}),Fo=Pr(function(n,t,r){fi.call(n,r)?++n[r]:vt(n,r,1);
}),No=Qr(Pe),Po=Qr(Ze),Zo=Pr(function(n,t,r){fi.call(n,r)?n[r].push(t):vt(n,r,[t])}),qo=sr(function(n,t,e){var u=-1,i=typeof t=="function",o=hu(n)?Gu(n.length):[];return io(n,function(n){o[++u]=i?r(t,n,e):Mt(n,t,e)}),o}),Vo=Pr(function(n,t,r){vt(n,r,t)}),Ko=Pr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Go=sr(function(n,t){if(null==n)return[];var r=t.length;return 1<r&&Ie(n,t[0],t[1])?t=[]:2<r&&Ie(t[0],t[1],t[2])&&(t=[t[0]]),er(n,Et(t,1),[])}),Ho=Oi||function(){return Zn.Date.now();
},Jo=sr(function(n,t,r){var e=1;if(r.length)var u=C(r,ye(Jo)),e=32|e;return se(n,e,t,r,u)}),Yo=sr(function(n,t,r){var e=3;if(r.length)var u=C(r,ye(Yo)),e=32|e;return se(t,e,n,r,u)}),Qo=sr(function(n,t){return jt(n,1,t)}),Xo=sr(function(n,t,r){return jt(n,Su(t)||0,r)});au.Cache=Pn;var nf=sr(function(n,t){t=1==t.length&&cf(t[0])?l(t[0],S(be())):l(Et(t,1),S(be()));var e=t.length;return sr(function(u){for(var i=-1,o=Di(u.length,e);++i<o;)u[i]=t[i].call(this,u[i]);return r(n,this,u)})}),tf=sr(function(n,t){
return se(n,32,F,t,C(t,ye(tf)))}),rf=sr(function(n,t){return se(n,64,F,t,C(t,ye(rf)))}),ef=_e(function(n,t){return se(n,256,F,F,F,t)}),uf=fe(Bt),of=fe(function(n,t){return n>=t}),ff=Tt(function(){return arguments}())?Tt:function(n){return bu(n)&&fi.call(n,"callee")&&!xi.call(n,"callee")},cf=Gu.isArray,af=Hn?S(Hn):$t,lf=Wi||Ku,sf=Jn?S(Jn):Ft,hf=Yn?S(Yn):Pt,pf=Qn?S(Qn):Vt,_f=Xn?S(Xn):Kt,vf=nt?S(nt):Gt,gf=fe(Yt),df=fe(function(n,t){return n<=t}),yf=Zr(function(n,t){if(We(t)||hu(t))$r(t,Bu(t),n);else for(var r in t)fi.call(t,r)&&lt(n,r,t[r]);
}),bf=Zr(function(n,t){$r(t,Lu(t),n)}),xf=Zr(function(n,t,r,e){$r(t,Lu(t),n,e)}),jf=Zr(function(n,t,r,e){$r(t,Bu(t),n,e)}),wf=_e(gt),mf=sr(function(n){return n.push(F,ct),r(xf,F,n)}),Af=sr(function(n){return n.push(F,Le),r(If,F,n)}),kf=te(function(n,t,r){n[t]=r},$u(Fu)),Ef=te(function(n,t,r){fi.call(n,t)?n[t].push(r):n[t]=[r]},be),Of=sr(Mt),Sf=Zr(function(n,t,r){tr(n,t,r)}),If=Zr(function(n,t,r,e){tr(n,t,r,e)}),Rf=_e(function(n,t){var r={};if(null==n)return r;var e=false;t=l(t,function(t){return t=zr(t,n),
e||(e=1<t.length),t}),$r(n,ge(n),r),e&&(r=yt(r,7));for(var u=t.length;u--;)Ar(r,t[u]);return r}),zf=_e(function(n,t){return null==n?{}:ur(n,t)}),Wf=le(Bu),Bf=le(Lu),Lf=Hr(function(n,t,r){return t=t.toLowerCase(),n+(r?Du(t):t)}),Uf=Hr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Cf=Hr(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Df=Gr("toLowerCase"),Mf=Hr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Tf=Hr(function(n,t,r){return n+(r?" ":"")+Ff(t)}),$f=Hr(function(n,t,r){
return n+(r?" ":"")+t.toUpperCase()}),Ff=Gr("toUpperCase"),Nf=sr(function(n,t){try{return r(n,F,t)}catch(n){return _u(n)?n:new Ju(n)}}),Pf=_e(function(n,t){return u(t,function(t){t=Te(t),vt(n,t,Jo(n[t],n))}),n}),Zf=Xr(),qf=Xr(true),Vf=sr(function(n,t){return function(r){return Mt(r,n,t)}}),Kf=sr(function(n,t){return function(r){return Mt(n,r,t)}}),Gf=ee(l),Hf=ee(o),Jf=ee(_),Yf=oe(),Qf=oe(true),Xf=re(function(n,t){return n+t},0),nc=ae("ceil"),tc=re(function(n,t){return n/t},1),rc=ae("floor"),ec=re(function(n,t){
return n*t},1),uc=ae("round"),ic=re(function(n,t){return n-t},0);return On.after=function(n,t){if(typeof t!="function")throw new ri("Expected a function");return n=Eu(n),function(){if(1>--n)return t.apply(this,arguments)}},On.ary=uu,On.assign=yf,On.assignIn=bf,On.assignInWith=xf,On.assignWith=jf,On.at=wf,On.before=iu,On.bind=Jo,On.bindAll=Pf,On.bindKey=Yo,On.castArray=function(){if(!arguments.length)return[];var n=arguments[0];return cf(n)?n:[n]},On.chain=Qe,On.chunk=function(n,t,r){if(t=(r?Ie(n,t,r):t===F)?1:Ci(Eu(t),0),
r=null==n?0:n.length,!r||1>t)return[];for(var e=0,u=0,i=Gu(Ii(r/t));e<r;)i[u++]=gr(n,e,e+=t);return i},On.compact=function(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u},On.concat=function(){var n=arguments.length;if(!n)return[];for(var t=Gu(n-1),r=arguments[0];n--;)t[n-1]=arguments[n];return s(cf(r)?Tr(r):[r],Et(t,1))},On.cond=function(n){var t=null==n?0:n.length,e=be();return n=t?l(n,function(n){if("function"!=typeof n[1])throw new ri("Expected a function");
return[e(n[0]),n[1]]}):[],sr(function(e){for(var u=-1;++u<t;){var i=n[u];if(r(i[0],this,e))return r(i[1],this,e)}})},On.conforms=function(n){return bt(yt(n,1))},On.constant=$u,On.countBy=Fo,On.create=function(n,t){var r=uo(n);return null==t?r:pt(r,t)},On.curry=ou,On.curryRight=fu,On.debounce=cu,On.defaults=mf,On.defaultsDeep=Af,On.defer=Qo,On.delay=Xo,On.difference=mo,On.differenceBy=Ao,On.differenceWith=ko,On.drop=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Eu(t),gr(n,0>t?0:t,e)):[];
},On.dropRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Eu(t),t=e-t,gr(n,0,0>t?0:t)):[]},On.dropRightWhile=function(n,t){return n&&n.length?kr(n,be(t,3),true,true):[]},On.dropWhile=function(n,t){return n&&n.length?kr(n,be(t,3),true):[]},On.fill=function(n,t,r,e){var u=null==n?0:n.length;if(!u)return[];for(r&&typeof r!="number"&&Ie(n,t,r)&&(r=0,e=u),u=n.length,r=Eu(r),0>r&&(r=-r>u?0:u+r),e=e===F||e>u?u:Eu(e),0>e&&(e+=u),e=r>e?0:Ou(e);r<e;)n[r++]=t;return n},On.filter=function(n,t){
return(cf(n)?f:kt)(n,be(t,3))},On.flatMap=function(n,t){return Et(eu(n,t),1)},On.flatMapDeep=function(n,t){return Et(eu(n,t),N)},On.flatMapDepth=function(n,t,r){return r=r===F?1:Eu(r),Et(eu(n,t),r)},On.flatten=qe,On.flattenDeep=function(n){return(null==n?0:n.length)?Et(n,N):[]},On.flattenDepth=function(n,t){return null!=n&&n.length?(t=t===F?1:Eu(t),Et(n,t)):[]},On.flip=function(n){return se(n,512)},On.flow=Zf,On.flowRight=qf,On.fromPairs=function(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){
var u=n[t];e[u[0]]=u[1]}return e},On.functions=function(n){return null==n?[]:It(n,Bu(n))},On.functionsIn=function(n){return null==n?[]:It(n,Lu(n))},On.groupBy=Zo,On.initial=function(n){return(null==n?0:n.length)?gr(n,0,-1):[]},On.intersection=Eo,On.intersectionBy=Oo,On.intersectionWith=So,On.invert=kf,On.invertBy=Ef,On.invokeMap=qo,On.iteratee=Nu,On.keyBy=Vo,On.keys=Bu,On.keysIn=Lu,On.map=eu,On.mapKeys=function(n,t){var r={};return t=be(t,3),Ot(n,function(n,e,u){vt(r,t(n,e,u),n)}),r},On.mapValues=function(n,t){
var r={};return t=be(t,3),Ot(n,function(n,e,u){vt(r,e,t(n,e,u))}),r},On.matches=function(n){return Xt(yt(n,1))},On.matchesProperty=function(n,t){return nr(n,yt(t,1))},On.memoize=au,On.merge=Sf,On.mergeWith=If,On.method=Vf,On.methodOf=Kf,On.mixin=Pu,On.negate=lu,On.nthArg=function(n){return n=Eu(n),sr(function(t){return rr(t,n)})},On.omit=Rf,On.omitBy=function(n,t){return Uu(n,lu(be(t)))},On.once=function(n){return iu(2,n)},On.orderBy=function(n,t,r,e){return null==n?[]:(cf(t)||(t=null==t?[]:[t]),
r=e?F:r,cf(r)||(r=null==r?[]:[r]),er(n,t,r))},On.over=Gf,On.overArgs=nf,On.overEvery=Hf,On.overSome=Jf,On.partial=tf,On.partialRight=rf,On.partition=Ko,On.pick=zf,On.pickBy=Uu,On.property=qu,On.propertyOf=function(n){return function(t){return null==n?F:Rt(n,t)}},On.pull=Io,On.pullAll=Ge,On.pullAllBy=function(n,t,r){return n&&n.length&&t&&t.length?fr(n,t,be(r,2)):n},On.pullAllWith=function(n,t,r){return n&&n.length&&t&&t.length?fr(n,t,F,r):n},On.pullAt=Ro,On.range=Yf,On.rangeRight=Qf,On.rearg=ef,On.reject=function(n,t){
return(cf(n)?f:kt)(n,lu(be(t,3)))},On.remove=function(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=be(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return cr(n,u),r},On.rest=function(n,t){if(typeof n!="function")throw new ri("Expected a function");return t=t===F?t:Eu(t),sr(n,t)},On.reverse=He,On.sampleSize=function(n,t,r){return t=(r?Ie(n,t,r):t===F)?1:Eu(t),(cf(n)?ot:pr)(n,t)},On.set=function(n,t,r){return null==n?n:_r(n,t,r)},On.setWith=function(n,t,r,e){return e=typeof e=="function"?e:F,
null==n?n:_r(n,t,r,e)},On.shuffle=function(n){return(cf(n)?ft:vr)(n)},On.slice=function(n,t,r){var e=null==n?0:n.length;return e?(r&&typeof r!="number"&&Ie(n,t,r)?(t=0,r=e):(t=null==t?0:Eu(t),r=r===F?e:Eu(r)),gr(n,t,r)):[]},On.sortBy=Go,On.sortedUniq=function(n){return n&&n.length?xr(n):[]},On.sortedUniqBy=function(n,t){return n&&n.length?xr(n,be(t,2)):[]},On.split=function(n,t,r){return r&&typeof r!="number"&&Ie(n,t,r)&&(t=r=F),r=r===F?4294967295:r>>>0,r?(n=Ru(n))&&(typeof t=="string"||null!=t&&!pf(t))&&(t=wr(t),
!t&&Bn.test(n))?Wr($(n),0,r):n.split(t,r):[]},On.spread=function(n,t){if(typeof n!="function")throw new ri("Expected a function");return t=t===F?0:Ci(Eu(t),0),sr(function(e){var u=e[t];return e=Wr(e,0,t),u&&s(e,u),r(n,this,e)})},On.tail=function(n){var t=null==n?0:n.length;return t?gr(n,1,t):[]},On.take=function(n,t,r){return n&&n.length?(t=r||t===F?1:Eu(t),gr(n,0,0>t?0:t)):[]},On.takeRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Eu(t),t=e-t,gr(n,0>t?0:t,e)):[]},On.takeRightWhile=function(n,t){
return n&&n.length?kr(n,be(t,3),false,true):[]},On.takeWhile=function(n,t){return n&&n.length?kr(n,be(t,3)):[]},On.tap=function(n,t){return t(n),n},On.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new ri("Expected a function");return yu(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),cu(n,t,{leading:e,maxWait:t,trailing:u})},On.thru=Xe,On.toArray=Au,On.toPairs=Wf,On.toPairsIn=Bf,On.toPath=function(n){return cf(n)?l(n,Te):mu(n)?[n]:Tr(wo(Ru(n)))},On.toPlainObject=Iu,
On.transform=function(n,t,r){var e=cf(n),i=e||lf(n)||vf(n);if(t=be(t,4),null==r){var o=n&&n.constructor;r=i?e?new o:[]:yu(n)&&vu(o)?uo(yi(n)):{}}return(i?u:Ot)(n,function(n,e,u){return t(r,n,e,u)}),r},On.unary=function(n){return uu(n,1)},On.union=zo,On.unionBy=Wo,On.unionWith=Bo,On.uniq=function(n){return n&&n.length?mr(n):[]},On.uniqBy=function(n,t){return n&&n.length?mr(n,be(t,2)):[]},On.uniqWith=function(n,t){return t=typeof t=="function"?t:F,n&&n.length?mr(n,F,t):[]},On.unset=function(n,t){return null==n||Ar(n,t);
},On.unzip=Je,On.unzipWith=Ye,On.update=function(n,t,r){return null==n?n:_r(n,t,Rr(r)(Rt(n,t)),void 0)},On.updateWith=function(n,t,r,e){return e=typeof e=="function"?e:F,null!=n&&(n=_r(n,t,Rr(r)(Rt(n,t)),e)),n},On.values=Cu,On.valuesIn=function(n){return null==n?[]:I(n,Lu(n))},On.without=Lo,On.words=Tu,On.wrap=function(n,t){return tf(Rr(t),n)},On.xor=Uo,On.xorBy=Co,On.xorWith=Do,On.zip=Mo,On.zipObject=function(n,t){return Sr(n||[],t||[],lt)},On.zipObjectDeep=function(n,t){return Sr(n||[],t||[],_r);
},On.zipWith=To,On.entries=Wf,On.entriesIn=Bf,On.extend=bf,On.extendWith=xf,Pu(On,On),On.add=Xf,On.attempt=Nf,On.camelCase=Lf,On.capitalize=Du,On.ceil=nc,On.clamp=function(n,t,r){return r===F&&(r=t,t=F),r!==F&&(r=Su(r),r=r===r?r:0),t!==F&&(t=Su(t),t=t===t?t:0),dt(Su(n),t,r)},On.clone=function(n){return yt(n,4)},On.cloneDeep=function(n){return yt(n,5)},On.cloneDeepWith=function(n,t){return t=typeof t=="function"?t:F,yt(n,5,t)},On.cloneWith=function(n,t){return t=typeof t=="function"?t:F,yt(n,4,t)},
On.conformsTo=function(n,t){return null==t||xt(n,t,Bu(t))},On.deburr=Mu,On.defaultTo=function(n,t){return null==n||n!==n?t:n},On.divide=tc,On.endsWith=function(n,t,r){n=Ru(n),t=wr(t);var e=n.length,e=r=r===F?e:dt(Eu(r),0,e);return r-=t.length,0<=r&&n.slice(r,e)==t},On.eq=su,On.escape=function(n){return(n=Ru(n))&&Y.test(n)?n.replace(H,et):n},On.escapeRegExp=function(n){return(n=Ru(n))&&fn.test(n)?n.replace(on,"\\$&"):n},On.every=function(n,t,r){var e=cf(n)?o:mt;return r&&Ie(n,t,r)&&(t=F),e(n,be(t,3));
},On.find=No,On.findIndex=Pe,On.findKey=function(n,t){return v(n,be(t,3),Ot)},On.findLast=Po,On.findLastIndex=Ze,On.findLastKey=function(n,t){return v(n,be(t,3),St)},On.floor=rc,On.forEach=tu,On.forEachRight=ru,On.forIn=function(n,t){return null==n?n:fo(n,be(t,3),Lu)},On.forInRight=function(n,t){return null==n?n:co(n,be(t,3),Lu)},On.forOwn=function(n,t){return n&&Ot(n,be(t,3))},On.forOwnRight=function(n,t){return n&&St(n,be(t,3))},On.get=zu,On.gt=uf,On.gte=of,On.has=function(n,t){return null!=n&&me(n,t,Lt);
},On.hasIn=Wu,On.head=Ve,On.identity=Fu,On.includes=function(n,t,r,e){return n=hu(n)?n:Cu(n),r=r&&!e?Eu(r):0,e=n.length,0>r&&(r=Ci(e+r,0)),wu(n)?r<=e&&-1<n.indexOf(t,r):!!e&&-1<d(n,t,r)},On.indexOf=function(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Eu(r),0>r&&(r=Ci(e+r,0)),d(n,t,r)):-1},On.inRange=function(n,t,r){return t=ku(t),r===F?(r=t,t=0):r=ku(r),n=Su(n),n>=Di(t,r)&&n<Ci(t,r)},On.invoke=Of,On.isArguments=ff,On.isArray=cf,On.isArrayBuffer=af,On.isArrayLike=hu,On.isArrayLikeObject=pu,
On.isBoolean=function(n){return true===n||false===n||bu(n)&&"[object Boolean]"==Wt(n)},On.isBuffer=lf,On.isDate=sf,On.isElement=function(n){return bu(n)&&1===n.nodeType&&!ju(n)},On.isEmpty=function(n){if(null==n)return true;if(hu(n)&&(cf(n)||typeof n=="string"||typeof n.splice=="function"||lf(n)||vf(n)||ff(n)))return!n.length;var t=go(n);if("[object Map]"==t||"[object Set]"==t)return!n.size;if(We(n))return!Jt(n).length;for(var r in n)if(fi.call(n,r))return false;return true},On.isEqual=function(n,t){return Nt(n,t);
},On.isEqualWith=function(n,t,r){var e=(r=typeof r=="function"?r:F)?r(n,t):F;return e===F?Nt(n,t,F,r):!!e},On.isError=_u,On.isFinite=function(n){return typeof n=="number"&&Bi(n)},On.isFunction=vu,On.isInteger=gu,On.isLength=du,On.isMap=hf,On.isMatch=function(n,t){return n===t||Zt(n,t,je(t))},On.isMatchWith=function(n,t,r){return r=typeof r=="function"?r:F,Zt(n,t,je(t),r)},On.isNaN=function(n){return xu(n)&&n!=+n},On.isNative=function(n){if(yo(n))throw new Ju("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
return qt(n)},On.isNil=function(n){return null==n},On.isNull=function(n){return null===n},On.isNumber=xu,On.isObject=yu,On.isObjectLike=bu,On.isPlainObject=ju,On.isRegExp=pf,On.isSafeInteger=function(n){return gu(n)&&-9007199254740991<=n&&9007199254740991>=n},On.isSet=_f,On.isString=wu,On.isSymbol=mu,On.isTypedArray=vf,On.isUndefined=function(n){return n===F},On.isWeakMap=function(n){return bu(n)&&"[object WeakMap]"==go(n)},On.isWeakSet=function(n){return bu(n)&&"[object WeakSet]"==Wt(n)},On.join=function(n,t){
return null==n?"":Li.call(n,t)},On.kebabCase=Uf,On.last=Ke,On.lastIndexOf=function(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;if(r!==F&&(u=Eu(r),u=0>u?Ci(e+u,0):Di(u,e-1)),t===t){for(r=u+1;r--&&n[r]!==t;);n=r}else n=g(n,b,u,true);return n},On.lowerCase=Cf,On.lowerFirst=Df,On.lt=gf,On.lte=df,On.max=function(n){return n&&n.length?At(n,Fu,Bt):F},On.maxBy=function(n,t){return n&&n.length?At(n,be(t,2),Bt):F},On.mean=function(n){return x(n,Fu)},On.meanBy=function(n,t){return x(n,be(t,2))},On.min=function(n){
return n&&n.length?At(n,Fu,Yt):F},On.minBy=function(n,t){return n&&n.length?At(n,be(t,2),Yt):F},On.stubArray=Vu,On.stubFalse=Ku,On.stubObject=function(){return{}},On.stubString=function(){return""},On.stubTrue=function(){return true},On.multiply=ec,On.nth=function(n,t){return n&&n.length?rr(n,Eu(t)):F},On.noConflict=function(){return Zn._===this&&(Zn._=hi),this},On.noop=Zu,On.now=Ho,On.pad=function(n,t,r){n=Ru(n);var e=(t=Eu(t))?T(n):0;return!t||e>=t?n:(t=(t-e)/2,ue(Ri(t),r)+n+ue(Ii(t),r))},On.padEnd=function(n,t,r){
n=Ru(n);var e=(t=Eu(t))?T(n):0;return t&&e<t?n+ue(t-e,r):n},On.padStart=function(n,t,r){n=Ru(n);var e=(t=Eu(t))?T(n):0;return t&&e<t?ue(t-e,r)+n:n},On.parseInt=function(n,t,r){return r||null==t?t=0:t&&(t=+t),Ti(Ru(n).replace(an,""),t||0)},On.random=function(n,t,r){if(r&&typeof r!="boolean"&&Ie(n,t,r)&&(t=r=F),r===F&&(typeof t=="boolean"?(r=t,t=F):typeof n=="boolean"&&(r=n,n=F)),n===F&&t===F?(n=0,t=1):(n=ku(n),t===F?(t=n,n=0):t=ku(t)),n>t){var e=n;n=t,t=e}return r||n%1||t%1?(r=$i(),Di(n+r*(t-n+$n("1e-"+((r+"").length-1))),t)):ar(n,t);
},On.reduce=function(n,t,r){var e=cf(n)?h:m,u=3>arguments.length;return e(n,be(t,4),r,u,io)},On.reduceRight=function(n,t,r){var e=cf(n)?p:m,u=3>arguments.length;return e(n,be(t,4),r,u,oo)},On.repeat=function(n,t,r){return t=(r?Ie(n,t,r):t===F)?1:Eu(t),lr(Ru(n),t)},On.replace=function(){var n=arguments,t=Ru(n[0]);return 3>n.length?t:t.replace(n[1],n[2])},On.result=function(n,t,r){t=zr(t,n);var e=-1,u=t.length;for(u||(u=1,n=F);++e<u;){var i=null==n?F:n[Te(t[e])];i===F&&(e=u,i=r),n=vu(i)?i.call(n):i;
}return n},On.round=uc,On.runInContext=w,On.sample=function(n){return(cf(n)?tt:hr)(n)},On.size=function(n){if(null==n)return 0;if(hu(n))return wu(n)?T(n):n.length;var t=go(n);return"[object Map]"==t||"[object Set]"==t?n.size:Jt(n).length},On.snakeCase=Mf,On.some=function(n,t,r){var e=cf(n)?_:dr;return r&&Ie(n,t,r)&&(t=F),e(n,be(t,3))},On.sortedIndex=function(n,t){return yr(n,t)},On.sortedIndexBy=function(n,t,r){return br(n,t,be(r,2))},On.sortedIndexOf=function(n,t){var r=null==n?0:n.length;if(r){
var e=yr(n,t);if(e<r&&su(n[e],t))return e}return-1},On.sortedLastIndex=function(n,t){return yr(n,t,true)},On.sortedLastIndexBy=function(n,t,r){return br(n,t,be(r,2),true)},On.sortedLastIndexOf=function(n,t){if(null==n?0:n.length){var r=yr(n,t,true)-1;if(su(n[r],t))return r}return-1},On.startCase=Tf,On.startsWith=function(n,t,r){return n=Ru(n),r=dt(Eu(r),0,n.length),t=wr(t),n.slice(r,r+t.length)==t},On.subtract=ic,On.sum=function(n){return n&&n.length?k(n,Fu):0},On.sumBy=function(n,t){return n&&n.length?k(n,be(t,2)):0;
},On.template=function(n,t,r){var e=On.templateSettings;r&&Ie(n,t,r)&&(t=F),n=Ru(n),t=xf({},t,e,ct),r=xf({},t.imports,e.imports,ct);var u,i,o=Bu(r),f=I(r,o),c=0;r=t.interpolate||An;var a="__p+='";r=ni((t.escape||An).source+"|"+r.source+"|"+(r===nn?gn:An).source+"|"+(t.evaluate||An).source+"|$","g");var l="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,o,f,l){return e||(e=o),a+=n.slice(c,l).replace(kn,B),r&&(u=true,a+="'+__e("+r+")+'"),f&&(i=true,a+="';"+f+";\n__p+='"),
e&&(a+="'+((__t=("+e+"))==null?'':__t)+'"),c=l+t.length,t}),a+="';",(t=t.variable)||(a="with(obj){"+a+"}"),a=(i?a.replace(q,""):a).replace(V,"$1").replace(K,"$1;"),a="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(u?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+a+"return __p}",t=Nf(function(){return Yu(o,l+"return "+a).apply(F,f)}),t.source=a,_u(t))throw t;return t},On.times=function(n,t){if(n=Eu(n),1>n||9007199254740991<n)return[];
var r=4294967295,e=Di(n,4294967295);for(t=be(t),n-=4294967295,e=E(e,t);++r<n;)t(r);return e},On.toFinite=ku,On.toInteger=Eu,On.toLength=Ou,On.toLower=function(n){return Ru(n).toLowerCase()},On.toNumber=Su,On.toSafeInteger=function(n){return dt(Eu(n),-9007199254740991,9007199254740991)},On.toString=Ru,On.toUpper=function(n){return Ru(n).toUpperCase()},On.trim=function(n,t,r){return(n=Ru(n))&&(r||t===F)?n.replace(cn,""):n&&(t=wr(t))?(n=$(n),r=$(t),t=z(n,r),r=W(n,r)+1,Wr(n,t,r).join("")):n},On.trimEnd=function(n,t,r){
return(n=Ru(n))&&(r||t===F)?n.replace(ln,""):n&&(t=wr(t))?(n=$(n),t=W(n,$(t))+1,Wr(n,0,t).join("")):n},On.trimStart=function(n,t,r){return(n=Ru(n))&&(r||t===F)?n.replace(an,""):n&&(t=wr(t))?(n=$(n),t=z(n,$(t)),Wr(n,t).join("")):n},On.truncate=function(n,t){var r=30,e="...";if(yu(t))var u="separator"in t?t.separator:u,r="length"in t?Eu(t.length):r,e="omission"in t?wr(t.omission):e;n=Ru(n);var i=n.length;if(Bn.test(n))var o=$(n),i=o.length;if(r>=i)return n;if(i=r-T(e),1>i)return e;if(r=o?Wr(o,0,i).join(""):n.slice(0,i),
u===F)return r+e;if(o&&(i+=r.length-i),pf(u)){if(n.slice(i).search(u)){var f=r;for(u.global||(u=ni(u.source,Ru(dn.exec(u))+"g")),u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===F?i:c)}}else n.indexOf(wr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},On.unescape=function(n){return(n=Ru(n))&&J.test(n)?n.replace(G,ut):n},On.uniqueId=function(n){var t=++ci;return Ru(n)+t},On.upperCase=$f,On.upperFirst=Ff,On.each=tu,On.eachRight=ru,On.first=Ve,Pu(On,function(){var n={};return Ot(On,function(t,r){
fi.call(On.prototype,r)||(n[r]=t)}),n}(),{chain:false}),On.VERSION="4.17.2",u("bind bindKey curry curryRight partial partialRight".split(" "),function(n){On[n].placeholder=On}),u(["drop","take"],function(n,t){Mn.prototype[n]=function(r){var e=this.__filtered__;if(e&&!t)return new Mn(this);r=r===F?1:Ci(Eu(r),0);var u=this.clone();return e?u.__takeCount__=Di(r,u.__takeCount__):u.__views__.push({size:Di(r,4294967295),type:n+(0>u.__dir__?"Right":"")}),u},Mn.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse();
}}),u(["filter","map","takeWhile"],function(n,t){var r=t+1,e=1==r||3==r;Mn.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:be(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),u(["head","last"],function(n,t){var r="take"+(t?"Right":"");Mn.prototype[n]=function(){return this[r](1).value()[0]}}),u(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Mn.prototype[n]=function(){return this.__filtered__?new Mn(this):this[r](1)}}),Mn.prototype.compact=function(){
return this.filter(Fu)},Mn.prototype.find=function(n){return this.filter(n).head()},Mn.prototype.findLast=function(n){return this.reverse().find(n)},Mn.prototype.invokeMap=sr(function(n,t){return typeof n=="function"?new Mn(this):this.map(function(r){return Mt(r,n,t)})}),Mn.prototype.reject=function(n){return this.filter(lu(be(n)))},Mn.prototype.slice=function(n,t){n=Eu(n);var r=this;return r.__filtered__&&(0<n||0>t)?new Mn(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==F&&(t=Eu(t),r=0>t?r.dropRight(-t):r.take(t-n)),
r)},Mn.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Mn.prototype.toArray=function(){return this.take(4294967295)},Ot(Mn.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=On[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(On.prototype[t]=function(){function t(n){return n=u.apply(On,s([n],f)),e&&h?n[0]:n}var o=this.__wrapped__,f=e?[1]:arguments,c=o instanceof Mn,a=f[0],l=c||cf(o);l&&r&&typeof a=="function"&&1!=a.length&&(c=l=false);
var h=this.__chain__,p=!!this.__actions__.length,a=i&&!h,c=c&&!p;return!i&&l?(o=c?o:new Mn(this),o=n.apply(o,f),o.__actions__.push({func:Xe,args:[t],thisArg:F}),new zn(o,h)):a&&c?n.apply(this,f):(o=this.thru(t),a?e?o.value()[0]:o.value():o)})}),u("pop push shift sort splice unshift".split(" "),function(n){var t=ei[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);On.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(cf(u)?u:[],n);
}return this[r](function(r){return t.apply(cf(r)?r:[],n)})}}),Ot(Mn.prototype,function(n,t){var r=On[t];if(r){var e=r.name+"";(Hi[e]||(Hi[e]=[])).push({name:t,func:r})}}),Hi[ne(F,2).name]=[{name:"wrapper",func:F}],Mn.prototype.clone=function(){var n=new Mn(this.__wrapped__);return n.__actions__=Tr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Tr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Tr(this.__views__),n},Mn.prototype.reverse=function(){
if(this.__filtered__){var n=new Mn(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},Mn.prototype.value=function(){var n,t=this.__wrapped__.value(),r=this.__dir__,e=cf(t),u=0>r,i=e?t.length:0;n=i;for(var o=this.__views__,f=0,c=-1,a=o.length;++c<a;){var l=o[c],s=l.size;switch(l.type){case"drop":f+=s;break;case"dropRight":n-=s;break;case"take":n=Di(n,f+s);break;case"takeRight":f=Ci(f,n-s)}}if(n={start:f,end:n},o=n.start,f=n.end,n=f-o,u=u?f:o-1,o=this.__iteratees__,f=o.length,
c=0,a=Di(n,this.__takeCount__),!e||200>i||i==n&&a==n)return Er(t,this.__actions__);e=[];n:for(;n--&&c<a;){for(u+=r,i=-1,l=t[u];++i<f;){var h=o[i],s=h.type,h=(0,h.iteratee)(l);if(2==s)l=h;else if(!h){if(1==s)continue n;break n}}e[c++]=l}return e},On.prototype.at=$o,On.prototype.chain=function(){return Qe(this)},On.prototype.commit=function(){return new zn(this.value(),this.__chain__)},On.prototype.next=function(){this.__values__===F&&(this.__values__=Au(this.value()));var n=this.__index__>=this.__values__.length;
return{done:n,value:n?F:this.__values__[this.__index__++]}},On.prototype.plant=function(n){for(var t,r=this;r instanceof Sn;){var e=Ne(r);e.__index__=0,e.__values__=F,t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},On.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Mn?(this.__actions__.length&&(n=new Mn(this)),n=n.reverse(),n.__actions__.push({func:Xe,args:[He],thisArg:F}),new zn(n,this.__chain__)):this.thru(He)},On.prototype.toJSON=On.prototype.valueOf=On.prototype.value=function(){
return Er(this.__wrapped__,this.__actions__)},On.prototype.first=On.prototype.head,mi&&(On.prototype[mi]=nu),On}();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Zn._=it, define(function(){return it})):Vn?((Vn.exports=it)._=it,qn._=it):Zn._=it}).call(this);</script><dom-module id="stv-login" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: absolute;
            box-sizing: border-box;
            padding: 30px 100px;
            left: 0;
            right: 0;
            margin: 0px auto 0px auto;
            width: 500px;
            transition: all 0.2s;
            box-shadow: 0px 0px 12px 6px rgba(0, 0, 0, 0.30);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .title {
            text-align: center;
            font-size: 25px;
        }

        .icon {
            font-size: 50px;
            color: var(--dark-primary-color);
        }

        .message {
            margin: 20px 0 0 0;
            box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.3);
        }

        .shortcut {
            cursor: pointer;
        }

        .right {
            text-align: right;
        }

        .shortcut:hover {
            text-decoration: underline;
        }

        #button {
            font-weight: normal;
            height: auto;
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 3px;
            color: var(--text-primary-color);
            background-color: var(--dark-button-color);
        }

        #button:hover {
            background-color: var(--light-button-color);
        }
    </style>
    <template>
        <div class="title">
            <div>
                Login
            </div>
            <div class="icon">
                <i class="fa fa-sign-in"></i>
            </div>
        </div>
        <form id="form" on-keypress="handleFormKey">
            <label class="stv">User name:</label>
            <input class="stv" type="text" value="{{name::input}}" required="" pattern="[a-zA-Z0-9._]+">

            <div class="right">
                <span hidden$="{{hideSignup}}" class="shortcut" on-click="handleSignup">Create new user...</span>
            </div>
            <br>
            <label class="stv">Password:</label>
            <input class="stv" type="password" value="{{password::input}}" required="">

            <div class="right">
                <span hidden$="{{hideSignup}}" class="shortcut" on-click="handleRemember">Remember password...</span>
            </div>
            <br>
            <br>

            <div id="button" class="stv-btn stv-btn-shdw" on-click="handleForm">Login</div>
            <br>
            <div hidden$="{{hideAnonymous}}" class="right">
                <span class="shortcut" on-click="handleAnonymous">Login as anonymous</span>
                <br>
                <span style="color:#888">All data will be deleted on logout</span>
            </div>
        </form>
        <div hidden$="{{!message}}" class="message stv-note stv-note-warn">&nbsp;{{message}}</div>
    </template>

    <script>
        Polymer({
            is: "stv-login",
            properties: {
                name: {
                    type: String,
                    value: ''
                },
                password: {
                    type: String,
                    value: ''
                },
                message: {
                    type: String,
                    value: ''
                },
                hideSignup: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                hideAnonymous: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
            },
            clean: function() {
                this.set('name', '');
                this.set('message', '');
                this.set('password', '');
            },
            handleFormKey: function(e) {
                if (e.which == 13) {
                    this.handleForm();
                }
            },
            handleRemember: function(e) {
                this.fire("remember", {});
            },
            handleSignup: function(e) {
                this.fire("signup", {});
            },
            handleForm: function(e) {
                this.set('message', '');

                if (this.$.form.checkValidity()) {
                    this._login();
                }else{
                    this.set('message', 'Please, you should fill all the fields.');
                }
            },
            handleAnonymous: function() {
                this.clean();
                this.fire('anonymous');
            },
            _login: function() {
                var me = this;
                // console.log(this.name)
                // console.log(this.password)
                SteviaManager.users.login({
                    id: this.name,
                    sid: CryptoJS.SHA1(this.password).toString(),
                    request: {
                        success: function(response) {
                            if (response.response[0].error == null) {
                                Cookies.set('bioinfo_sid', response.response[0].results[0].id, {
                                    path: window.location.pathname
                                });
                                Cookies.set('bioinfo_user', me.name, {
                                    path: window.location.pathname
                                });
                                me.fire('login', {
                                    status: true
                                });
                                me.clean();
                            } else {
                                console.log(response.response[0].error);
                                me.message = response.response[0].error;
                            }
                            me.password = null;
                        },
                        error: function(response) {
                            //Delete all cookies
                            Cookies.expire('bioinfo_sid', {
                                path: window.location.pathname
                            });
                            Cookies.expire('bioinfo_user', {
                                path: window.location.pathname
                            });
                            me.message = response.error.split(":")[1];
                            if (response.errorEvent) {
                                me.message = 'Server error, try again later.';
                            }
                        }
                    }
                });
            }
        });
    </script>
</dom-module>
<dom-module id="stv-signup" assetpath="bower_components/stevia-elements/src/">
    <style>
        :host {
            display: block;
            position: absolute;
            box-sizing: border-box;
            padding: 30px 100px;
            left: 0;
            right: 0;
            margin: 0px auto 0px auto;
            width: 500px;
            box-shadow: 0px 0px 12px 6px rgba(0, 0, 0, 0.30);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .title {
            text-align: center;
            font-size: 25px;
        }

        .icon {
            font-size: 50px;
            color: var(--dark-primary-color);
        }

        .message {
            margin: 20px 0 0 0;
            box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.3);
        }

        #button {
            font-weight: normal;
            height: auto;
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 3px;
            color: var(--text-primary-color);
            background-color: var(--dark-button-color);
        }

        #button:hover {
            background-color: var(--light-button-color);
        }
    </style>
    <template>
        <div class="title">
            <div>
                Create a new user
            </div>
            <div class="icon">
                <i class="fa fa-pencil-square-o"></i>
            </div>
        </div>
        <form id="form" on-keypress="handleFormKey">
            <label class="stv">User name:</label>
            <input class="stv" type="text" value="{{name::input}}" required="" pattern="[a-zA-Z0-9._]+">
            <br>
            <label class="stv">E-mail:</label>
            <input class="stv" type="email" value="{{email::input}}" required="">
            <br>
            <label class="stv">Create a password:</label>
            <input class="stv" type="password" value="{{password::input}}" required="">
            <label class="stv">Confirm your password:</label>
            <input class="stv" type="password" value="{{passwordCheck::input}}" required="">

            <br>
            <br>

            <div id="button" class="stv-btn stv-btn-shdw" on-click="handleForm">Sign up</div>
        </form>
        <div hidden$="{{!message}}" class="message stv-note stv-note-warn">&nbsp;{{message}}</div>
    </template>

    <script>
        Polymer({
            is: "stv-signup",
            properties: {
                name: {
                    type: String,
                    value: ''
                },
                email: {
                    type: String,
                    value: ''
                },
                password: {
                    type: String,
                    value: ''
                },
                passwordCheck: {
                    type: String,
                    value: ''
                },
                message: {
                    type: String,
                    value: ''
                }
            },
            handleFormKey: function(e) {
                if (e.which == 13) {
                    this.handleForm();
                }
            },
            handleForm: function(e) {
                this.message = '';
                this.email = (this.email === "demo") ? "demo@demo.com" : this.email;
                if (this.$.form.checkValidity()) {
                    if (this.password === this.passwordCheck) {
                        this._signup();
                    } else {
                        this.set('message', 'Sorry, your password does not match.');
                    }
                } else {
                    // alert("Please, you should fill all the fields. If error persist, contact crew at " + CONTACT_MAIL + ".");
                    this.set('message', 'Please, you should fill all the fields.');
                }
            },
            clean: function() {
                this.name = "";
                this.email = "";
                this.password = "";
                this.passwordCheck = "";
            },
            _signup: function() {
                var me = this;
                SteviaManager.users.create({
                    query: {
                        name: this.name,
                        email: this.email,
                    },
                    sid: CryptoJS.SHA1(this.password).toString(),
                    request: {
                        async: true,
                        success: function(response) {
                            if (response.response[0].error == null) {
                                var name = response.response[0].results[0].name;
                                // me.message = email + ' created';
                                Cookies.set('bioinfo_sid', response.response[0].results[0].sessions[0].id, {
                                    path: window.location.pathname
                                });
                                Cookies.set('bioinfo_user', name, {
                                    path: window.location.pathname
                                });

                                me.clean();

                                me.fire('login', {
                                    status: true
                                });
                            } else {
                                console.log(response.response[0].error);
                                me.message = response.response[0].error;
                                //Delete cookies
                                Cookies.expire('bioinfo_sid', {
                                    path: window.location.pathname
                                });
                                Cookies.expire('bioinfo_user', {
                                    path: window.location.pathname
                                });
                            }
                        },
                        error: function() {
                            me.message = 'Server error, try again later.';
                        }
                    }
                });
            }
        });
    </script>
</dom-module>
<dom-module id="stv-profile" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
         :host {
            display: block;
            position: absolute;
            box-sizing: border-box;
            padding: 30px 100px;
            left: 0;
            right: 0;
            margin: 0px auto 0px auto;
            width: 500px;
            transition: all 0.2s;
            box-shadow: 0px 0px 12px 6px rgba(0, 0, 0, 0.30);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .title {
            text-align: center;
            font-size: 25px;
        }

        .icon {
            font-size: 50px;
            color: var(--dark-primary-color);
        }

        .message {
            margin: 20px 0 0 0;
            box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.3);
        }

        #button {
            font-weight: normal;
            height: auto;
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 3px;
            color: var(--text-primary-color);
            background-color: var(--dark-button-color);
        }

        #button:hover {
            background-color: var(--light-button-color);
        }

        #formEmail {
            margin-top: 40px;
        }
    </style>
    <template>
        <div class="title">
            <div>
                Password
            </div>
            <div class="icon">
                <i class="fa fa-user"></i>
            </div>
        </div>
        <form id="formPassword">
            <label class="stv">Old password:</label>
            <input class="stv" type="password" value="{{oldpassword::input}}" required="" pattern="[a-zA-Z0-9]+">
            <br>
            <label class="stv">New password:</label>
            <input class="stv" type="password" value="{{password::input}}" required="" pattern="[a-zA-Z0-9]+">
            <label class="stv">Check password:</label>
            <input class="stv" type="password" value="{{passwordCheck::input}}" required="" pattern="[a-zA-Z0-9]+">
            <br>
            <br>

            <div id="button" class="stv-btn stv-btn-shdw" on-click="handleChangePasswordForm">Change password</div>
        </form>
        <br>
        <div hidden$="{{!message}}" class="message stv-note stv-note-warn">&nbsp;{{message}}</div>
        


    </template>
    <script>
        Polymer({
            is: "stv-profile",
            properties: {
                email: {
                    type: String,
                    value: ''
                },
                oldpassword: {
                    type: String,
                    value: ''
                },
                password: {
                    type: String,
                    value: ''
                },
                passwordCheck: {
                    type: String,
                    value: ''
                },
                message: {
                    type: String,
                    value: ''
                }
            },
            clean: function() {
                this.set('oldpassword', '');
                this.set('password', '');
                this.set('passwordCheck', '');
                this.set('message', '');
            },
            handleChangePasswordForm: function(e) {
                var me = this;
                this.message = '';

                if (this.$.formPassword.checkValidity()) {
                    if (this.password === this.passwordCheck) {
                        SteviaManager.users.updatePassword({
                            id: Cookies('bioinfo_user'),
                            request: {
                                headers: {
                                    'x-stv-1': CryptoJS.SHA1(this.oldpassword).toString(),
                                    'x-stv-2': CryptoJS.SHA1(this.password).toString()
                                },
                                success: function(response) {
                                    if (response.response[0].error == null) {
                                        me.message = 'Password updated';
                                    } else {
                                        me.message = response.response[0].error;
                                    }
                                },
                                error: function() {
                                    me.message = 'Server error, try again later.';
                                }
                            }
                        });
                    } else {
                        this.set('message', 'Sorry, your new password does not match.');
                    }
                } else {
                    this.set('message', 'Please, you should fill all the fields.');
                }
            },
            handleChangeEmailForm: function(e) {
                var me = this;
                this.message = '';

                if (this.$.formEmail.checkValidity()) {
                    SteviaManager.users.updateEmail({
                        id: Cookies('bioinfo_user'),
                        query: {
                            nemail: this.email
                        },
                        request: {
                            success: function(response) {
                                if (response.response[0].error == null) {
                                    me.message = 'E-mail updated';
                                } else {
                                    me.message = response.response[0].error;
                                }
                            },
                            error: function() {
                                me.message = 'Server error, try again later.';
                            }
                        }
                    });
                }
            }
        });
    </script>
</dom-module>
<dom-module id="stv-remember" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: absolute;
            box-sizing: border-box;
            padding: 30px 100px;
            left: 0;
            right: 0;
            margin: 0px auto 0px auto;
            width: 500px;
            transition: all 0.2s;
            box-shadow: 0px 0px 12px 6px rgba(0, 0, 0, 0.30);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .title {
            text-align: center;
            font-size: 25px;
        }

        .icon {
            font-size: 50px;
            color: var(--dark-primary-color);
        }

        .message {
            margin: 20px 0 0 0;
            box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.3);
        }

        #button {
            font-weight: normal;
            height: auto;
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 3px;
            color: var(--text-primary-color);
            background-color: var(--dark-button-color);
        }

        #button:hover {
            background-color: var(--light-button-color);
        }
    </style>
    <template>
        <div class="title">
            <div>
                Reset password
            </div>
            <div class="icon color-2">
                <i class="fa fa-life-ring"></i>
            </div>
        </div>
        <form id="form" on-keypress="handleFormKey">
            
            <label class="stv">User name:</label>
            <input class="stv" type="text" value="{{name::input}}" required="">
            <br>
            <br>

            <div id="button" class="stv-btn stv-btn-shdw" on-click="handleForm">Send reset request</div>
        </form>

        <div hidden$="{{!message}}" class="horizontal layout center message stv-note stv-note-warn">
            <template is="dom-if" if="{{loading}}">
                <i class="fa fa-spinner fa-spin" style="margin-right: 5px;"></i>
            </template>
            <div>{{message}}</div>
        </div>
    </template>
    <script>
        Polymer({
            is: "stv-remember",
            properties: {
                // email: {
                //     type: String,
                //     value: ''
                // },
                name: {
                    type: String,
                    value: ''
                },
                message: {
                    type: String,
                    value: ''
                },
                loading: {
                    type: Boolean,
                    value: false
                }
            },
            //        created: function () {
            //            this.user;
            //            this.email;
            //        },
            handleFormKey: function(e) {
                if (e.which == 13) {
                    this.handleForm();
                }
            },
            handleForm: function(e) {
                var me = this;
                this.message = '';
                this.loading = false;

                if (this.$.form.checkValidity()) {
                    this.message = 'Processing request...';
                    this.loading = true;
                    SteviaManager.users.resetPassword({
                        query: {
                            name: this.name
                        },
                        request: {
                            success: function(response) {
                                if (response.response[0].error == null) {
                                    me.message = 'An email was sent with reset password instructions';
                                } else {
                                    me.message = response.response[0].error;
                                }
                                me.loading = false;
                            },
                            error: function() {
                                me.message = 'Server error, try again later.';
                                me.loading = false;
                            }
                        }
                    });
                }else{
                    this.set('message', "Please, fill the field");
                }
            }
        });
    </script>
</dom-module>
<script>var SteviaManager = {
    host: (typeof window.STEVIA_SERVER_HOST === 'undefined') ? 'http://localhost:5555' : window.STEVIA_SERVER_HOST,
    version: (typeof window.STEVIA_SERVER_VERSION === 'undefined') ? 'v1' : window.STEVIA_SERVER_VERSION,

    users: {
        login: function (args) {
            return SteviaManager._doRequest(args, 'users', 'login');
        },
        logout: function (args) {
            return SteviaManager._doRequest(args, 'users', 'logout');
        },
        read: function (args) {
            return SteviaManager._doRequest(args, 'users', 'info');
        },
        update: function (args) {
            return SteviaManager._doRequest(args, 'users', 'update');
        },
        updateEmail: function (args) {
            return SteviaManager._doRequest(args, 'users', 'change-email');
        },
        updatePassword: function (args) {
            return SteviaManager._doRequest(args, 'users', 'change-password');
        },
        updateNotifications: function (args) {
            return SteviaManager._doRequest(args, 'users', 'change-notifications');
        },
        resetPassword: function (args) {
            return SteviaManager._doRequest(args, 'users', 'reset-password');
        },
        create: function (args) {
            return SteviaManager._doRequest(args, 'users', 'create');
        },
        delete: function (args) {
            return SteviaManager._doRequest(args, 'users', 'delete');
        },
        feedback: function (args) {
            return SteviaManager._doRequest(args, 'users', 'feedback');
        },
    },

    jobs: {
        create: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'create');
        },
        run: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'run');
        },
        delete: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'delete');
        },
        download: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'download');
        },
        info: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'info');
        },
        reportError: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'report-error');
        },
        example: function (args) {
            return SteviaManager._doRequest(args, 'jobs', 'example');
        }
    },
    util: {
        proxy: function (args) {
            return SteviaManager._doRequest(args, 'util', 'proxy');
        }
    },
    tools: {
        search: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'search');
        },
        info: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'info');
        },
        help: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'help');
        },
        update: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'update');
        },
        delete: function (args) {
            return SteviaManager._doRequest(args, 'tools', 'delete');
        }
    },

    files: {
        list: function (args) {
            return SteviaManager._doRequest(args, 'files', 'list');
        },
        saveAttrFile: function (args) {
            return SteviaManager._doRequest(args, 'files', 'save-attr-file');
        },
        read: function (args) {
            return SteviaManager._doRequest(args, 'files', 'info');
        },
        info: function (args) {
            return SteviaManager._doRequest(args, 'files', 'info');
        },
        path: function (args) {
            return SteviaManager._doRequest(args, 'files', 'path');
        },
        delete: function (args) {
            return SteviaManager._doRequest(args, 'files', 'delete');
        },
        search: function (args) {
            return SteviaManager._doRequest(args, 'files', 'search');
        },
        filesByFolder: function (args) {
            return SteviaManager._doRequest(args, 'files', 'files');
        },
        content: function (args) {
            return SteviaManager._doRequest(args, 'files', 'content');
        },
        contentExample: function (args) {
            return SteviaManager._doRequest(args, 'files', 'content-example');
        },
        grep: function (args) {
            return SteviaManager._doRequest(args, 'files', 'grep');
        },
        createFolder: function (args) {
            return SteviaManager._doRequest(args, 'files', 'create-folder');
        },
        // setHeader: function (args) {
        //     return SteviaManager._doRequest(args, 'files', 'set-header');
        // },
        downloadExample: function (args) {
            return SteviaManager._doRequest(args, 'files', 'download-example');
        },
        addAttribute: function (args) {
            return SteviaManager._doRequest(args, 'files', 'add-attribute');
        },
        download: function (args) {
            return SteviaManager._doRequest(args, 'files', 'download');
        },
        move: function (args) {
            return SteviaManager._doRequest(args, 'files', 'move');
        },
        write: function (args) {
            return SteviaManager._doRequest(args, 'files', 'write');
        },
        upload: function (args) {
            var url = SteviaManager._url({
                query: {
                    name: args.name,
                    parentId: args.parentId
                },
                request: {}
            }, 'files', 'upload');
            args.url = url;
            SteviaManager._uploadFile(args);
        }
    },
    _url: function (args, api, action) {
        var host = SteviaManager.host;
        if (typeof args.request.host !== 'undefined' && args.request.host != null) {
            host = args.request.host;
        }
        var version = SteviaManager.version;
        if (typeof args.request.version !== 'undefined' && args.request.version != null) {
            version = args.request.version;
        }
        var id = '';
        if (typeof args.id !== 'undefined' && args.id != null) {
            id = '/' + args.id;
        }

        // var url = host + '/' + version + '/' + api + id + '/' + action;
        var url = host + '/' + api + id + '/' + action;
        url = this._addQueryParamtersToUrl(args.query, url);
        return url;
    },

    _doRequest: function (args, api, action) {
        var url = SteviaManager._url(args, api, action);
        if (args.request.url === true) {
            return url;
        } else {
            var method = 'GET';
            if (typeof args.request.method !== 'undefined' && args.request.method != null) {
                method = args.request.method;
            }
            var async = true;
            if (typeof args.request.async !== 'undefined' && args.request.async != null) {
                async = args.request.async;
            }
            var request = new XMLHttpRequest();
            request.onload = function () {
                var contentType = this.getResponseHeader('Content-Type');
                if (contentType.indexOf('application/json') != -1) {
                    var json = JSON.parse(this.response);
                    if (json.error == null) {
                        args.request.success(json, this);
                    } else {
                        if (window.STEVIA_MANAGER_LOG === true) {
                            console.log('! ----    SteviaManager -------');
                            console.log(json.error);
                            console.log(json);
                            console.log('! ----    SteviaManager -------');
                        }
                        args.request.error(json, this);
                    }
                } else {
                    args.request.success(this.response, this);
                }
            };
            request.onerror = function (e) {
                args.request.error({
                    error: 'Request error.',
                    errorEvent: e
                }, this);
            };
            request.open(method, url, async);
            if (args.request.headers != null) {
                for (var header in args.request.headers) {
                    request.setRequestHeader(header, args.request.headers[header]);
                }
            }

            var stv_app = (window.STV_APP != undefined) ? window.STV_APP : "-";
            request.setRequestHeader("x-stv-app", stv_app);

            var stv_user = (Cookies("bioinfo_user") != undefined) ? Cookies("bioinfo_user") : "-";
            request.setRequestHeader("x-stv-user", stv_user);

            request.setRequestHeader("x-stv-api", api);
            request.setRequestHeader("x-stv-action", action);

            if (args.sid == null) {
                args.sid = Cookies("bioinfo_sid");
            }
            if (args.sid != null) {
                request.setRequestHeader("Authorization", "sid " + args.sid);
                request.withCredentials = true;
            }
            var body = null;
            if (args.request.body != null) {
                body = args.request.body;
            }
            if (args.request.responseType != null) {
                request.responseType = args.request.responseType;
            }
            request.send(body);
            return url;
        }
    },
    _uploadFile: function (args) {
        var url = args.url;
        var blob = args.file;
        var name = args.name;
        var parentId = args.parentId;
        var userId = args.userId;
        var format = args.format;
        var bioFormat = args.bioFormat;
        var callbackProgress = args.callbackProgress;
        var callbackExists = args.callbackExists;

        /**/
        var resume = true;
        var resumeInfo = {};
        var chunkMap = {};
        var chunkId = 0;
        var BYTES_PER_CHUNK = 4 * 1024 * 1024;
        // var BYTES_PER_CHUNK = 10 * 1024 * 1024;
        var SIZE = blob.size;
        var NUM_CHUNKS = Math.max(Math.ceil(SIZE / BYTES_PER_CHUNK), 1);
        var start;
        var end;

        /**/
        var resumeResponse;
        /**/

        var getResumeInfo = function (formData, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, true); //false = sync call
            xhr.setRequestHeader("Authorization", "sid " + Cookies("bioinfo_sid"));
            xhr.withCredentials = true;
            xhr.onload = function (e) {
                console.log(xhr.responseText);
                callback(JSON.parse(xhr.responseText));
            };
            xhr.send(formData);
        };
        var uploadChunk = function (formData, chunk, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, true);
            xhr.setRequestHeader("Authorization", "sid " + Cookies("bioinfo_sid"));
            xhr.withCredentials = true;
            xhr.onload = function (e) {
                chunk.done = true;
                console.log('chunk ' + chunk.id + ' done');
                callback(JSON.parse(xhr.responseText));
            };
            xhr.send(formData);
        };
        var checkChunk = function (id, size) {
            if (typeof resumeInfo[id] === 'undefined') {
                return false;
            } else if (resumeInfo[id].size != size /*|| resumeInfo[id].hash != hash*/ ) {
                return false;
            }
            return true;
        };
        var processChunk = function (c) {
            var chunkBlob = blob.slice(c.start, c.end);

            console.log(c);
            if (checkChunk(c.id, chunkBlob.size) == false) {
                console.log('chunk ' + c.id + ' not uploaded');
                var formData = new FormData();
                formData.append('chunk_id', c.id);
                formData.append('chunk_size', chunkBlob.size);
                /*formData.append('chunk_hash', hash);*/
                formData.append("name", name);
                formData.append('userId', userId);
                formData.append('parentId', parentId);
                /*formData.append('chunk_gzip', );*/
                if (c.last) {
                    formData.append("last_chunk", true);
                    formData.append("total_size", SIZE);
                    formData.append("format", format);
                    formData.append("bioFormat", bioFormat);
                }
                formData.append('chunk_content', chunkBlob);

                uploadChunk(formData, c, function (chunkResponse) {
                    callbackProgress(c, NUM_CHUNKS, chunkResponse);
                    if (!c.last) {
                        processChunk(chunkMap[(c.id + 1)]);
                    } else {

                    }
                });
            } else {
                console.log('chunk ' + c.id + ' already uploaded');
                callbackProgress(c, NUM_CHUNKS, resumeResponse);
                if (!c.last) {
                    processChunk(chunkMap[(c.id + 1)]);
                } else {

                }
            }

        };

        /**/
        /**/

        start = 0;
        end = BYTES_PER_CHUNK;
        while (start < SIZE) {
            var last = false;
            if (chunkId == (NUM_CHUNKS - 1)) {
                last = true;
            }
            chunkMap[chunkId] = {
                id: chunkId,
                start: start,
                end: end,
                size: end - start,
                done: false,
                last: last
            };
            start = end;
            end = start + BYTES_PER_CHUNK;
            if (end > SIZE) {
                end = SIZE;
            }
            chunkId++;
        }
        if (resume) {
            var resumeFormData = new FormData();
            resumeFormData.append('resume_upload', resume);
            resumeFormData.append('chunk_map', JSON.stringify(chunkMap));
            resumeFormData.append('name', name);
            resumeFormData.append('userId', userId);
            resumeFormData.append('parentId', parentId);
            getResumeInfo(resumeFormData, function (response) {
                if (response.error == null) {
                    resumeInfo = response.resumeInfo;
                    resumeResponse = response;
                    if (response.exists) {
                        callbackExists(response.file);
                    } else {
                        setTimeout(function () {
                            processChunk(chunkMap[0]);
                        }, 50);
                    }
                } else {
                    console.log('Upload error: ' + response.error);
                }
            });
        }
    },
    _addQueryParamtersToUrl: function (paramsWS, url) {
        var chr = "?";
        if (url.indexOf("?") != -1) {
            chr = "&";
        }
        var query = this._queryString(paramsWS);
        if (query != "")
            query = chr + query;
        return url + query;
    },
    _queryString: function (obj) {
        var items = [];
        for (var key in obj) {
            if (obj[key] != null && obj[key] != undefined) {
                items.push(key + '=' + obj[key]);
            }
        }
        return items.join('&');
    },

    /*HELP METHODS*/
    getFileContent: function (fileId, cb) {
        SteviaManager.files.download({
            id: fileId,
            request: {
                async: true,
                success: function (response, req) {
                    cb(response, req);
                },
                error: function (response) {

                }
            }
        });
    },
    getFileExampleContent: function (fileName, tool, start, limit, cb) {
        SteviaManager.files.contentExample({
            query: {
                tool: tool,
                file: fileName,
                start: start,
                limit: limit
            },
            request: {
                async: true,
                success: function (response) {
                    cb(response);
                },
                error: function (response) {
                    cb(null);
                }
            }
        });

    },

    getFile: function (fileId, cb) {
        SteviaManager.files.info({
            id: fileId,
            request: {
                async: true,
                success: function (response) {
                    cb(response.response[0].results[0]);
                },
                error: function (response) {

                }
            }
        });
    },
    getJob: function (jobId, cb) {
        SteviaManager.jobs.info({
            id: jobId,
            request: {
                async: true,
                success: function (response) {
                    cb(response.response[0].results[0]);
                },
                error: function (response) {

                }
            }
        });
    },
    getFileByPath: function (path, cb) {
        SteviaManager.files.path({
            query: {
                path: path
            },
            request: {
                async: true,
                success: function (response) {
                    cb(response.response[0].results[0]);
                },
                error: function (response) {

                }
            }
        });
    },
    getPlainFolderFiles: function (fileId, cb) {
        SteviaManager.files.filesByFolder({
            id: fileId,
            request: {
                async: true,
                success: function (response) {
                    cb(response.response[0].results);
                },
                error: function (response) {

                }
            }
        });
    },
    updateFileAttributes: function (fileId, attributes, cb) {
        SteviaManager.files.addAttribute({
            id: fileId,
            request: {
                method: 'POST',
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(attributes),
                success: function (response) {
                    cb(response.response[0].results);
                },
                error: function (response) {

                }
            }
        });
    },
    updateUserNotifications: function (user, notifications, cb) {
        SteviaManager.users.updateNotifications({
            id: user,
            request: {
                method: 'POST',
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(notifications),
                success: function (response) {
                    cb(response.response[0].results[0]);
                },
                error: function (response) {

                }
            }
        });
    },
    getFileURL: function (fileId) {
        return SteviaManager.files.download({
            id: fileId,
            query: {
                sid: Cookies("bioinfo_sid")
            },
            request: {
                url: true
            }
        });
    },
    getExampleFileURL: function (tool, file) {
        return SteviaManager.files.downloadExample({
            query: {
                sid: Cookies("bioinfo_sid"),
                tool: tool,
                file: file
            },
            request: {
                url: true
            }
        });
    },

    //Download the file given a file Id.
    downloadFile: function (fileId, getContent) {
        var url = this.getFileURL(fileId);
        var link = document.createElement('a');
        link.href = url;
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        link.dispatchEvent(event);
    },

    downloadExampleFile: function (tool, filename) {
        var url = this.getExampleFileURL(tool, filename);
        var link = document.createElement('a');
        link.href = url;
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        link.dispatchEvent(event);
    },
};
</script>
<script>var stv = (window.stv != null) ? window.stv : {};
stv.utils = {
    stevia: true,
    //properties
    characters: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
    months: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    number: {
        sign: function (x) {
            return x ? x < 0 ? -1 : 1 : 0;
        }
    },
    //Methods
    formatNumber: function (position) {
        return position.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    },
    formatText: function (text, spaceChar) {
        text = text.replace(new RegExp(spaceChar, "gi"), " ");
        text = text.charAt(0).toUpperCase() + text.slice(1);
        return text;
    },
    titleCase: function (str) {
        return str[0].toUpperCase() + str.slice(1);;
    },
    camelCase: function (str) {
        return str.toLowerCase().replace(/[.-_\s](.)/g, function (match, group1) {
            return group1.toUpperCase();
        })
    },
    camelToSpace: function (str) {
        var result = str.replace(/([A-Z])/g, ' $1').toLowerCase().trim();
        return result.charAt(0).toUpperCase() + result.slice(1);
    },
    closest: function (element, selector) {
        var matches = (element.matches) ? 'matches' : 'msMatchesSelector';
        while (element) {
            if (element[matches](selector)) {
                break;
            }
            element = element.parentElement;
        }
        return element;
    },
    isFunction: function (s) {
        return typeof (s) === 'function' || s instanceof Function;
    },
    parseDate: function (strDate) {
        return strDate.substring(4, 6) + "/" + strDate.substring(6, 8) + "/" + strDate.substring(0, 4) + " " + strDate.substring(8, 10) + ":" + strDate.substring(10, 12) + ":" + strDate.substring(12, 14);
    },
    genId: function (prefix) {
        prefix = prefix || '';
        prefix = prefix.length == 0 ? prefix : prefix + '-';
        return prefix + this.randomString(4) + this.getRandomInt(1000, 9999);
    },
    randomString: function (length) {
        length = length || 10;
        var str = "";
        for (var i = 0; i < length; i++) {
            str += this.characters.charAt(this.getRandomInt(0, this.characters.length - 1));
        }
        return str;
    },
    getRandomInt: function (min, max) {
        // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
        // Using Math.round() will give you a non-uniform distribution!
        return Math.floor(Math.random() * (max - min + 1)) + min;
    },
    endsWithIgnoreCase: function (str, test) {
        return this.endsWith(str.toLowerCase(), test.toLowerCase());
    },
    endsWith: function (str, test) {
        return str.length >= test.length && str.substr(str.length - test.length) == test;
    },
    addQueryParamtersToUrl: function (paramsWS, url) {
        var chr = "?";
        if (url.indexOf("?") != -1) {
            chr = "&";
        }
        var query = stv.utils.queryString(paramsWS);
        if (query != "")
            query = chr + query;
        return url + query;
    },
    queryString: function (obj) {
        var items = [];
        for (var key in obj) {
            if (obj[key] != null && obj[key] != undefined) {
                items.push(key + '=' + encodeURIComponent(obj[key]));
            }
        }
        return items.join('&');
    },
    randomColor: function () {
        var color = "";
        for (var i = 0; i < 6; i++) {
            color += ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f'][Math.floor(Math.random() * 16)]);
        }
        return "#" + color;
    },
    colorLuminance: function (hex, lum) {
        // validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');
        hex = String(hex).replace(/#/gi, '');
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;

        // convert to decimal and change luminosity
        var rgb = "#",
            c, i;
        for (i = 0; i < 3; i++) {
            c = parseInt(hex.substr(i * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb += ("00" + c).substr(c.length);
        }

        return rgb;
    },
    getSpeciesFromAvailable: function (availableSpecies, speciesCode) {
        for (var phylos in availableSpecies) {
            for (var i = 0; i < availableSpecies[phylos].length; i++) {
                var species = availableSpecies[phylos][i];
                if (species.id === speciesCode || species.scientificName.toLowerCase() === speciesCode.toLowerCase()) {
                    return species;
                }
            }
        }
    },
    getSpeciesCode: function (speciesName) {
        var pair = speciesName.split(" ");
        var code;
        if (pair.length < 3) {
            code = (pair[0].charAt(0) + pair[1]).toLowerCase();
        } else {
            code = (pair[0].charAt(0) + pair[1] + pair[pair.length - 1].replace(/[/_().\-]/g, '')).toLowerCase();

        }
        return code;
    },
    basicValidationForm: function (scope) {
        var validated = true;
        var msg = "";
        if (scope.$.outdir.selectedFile === undefined || scope.$.outdir.selectedFile.type != "FOLDER") {
            msg += "Error: Please select an output folder.\n";
            validated = false;
        }
        if (scope.$.inputFile.selectedFile === undefined || scope.$.inputFile.selectedFile.type != "FILE") {
            msg += "Error: Please select an input file.\n";
            validated = false;
        }
        if (scope.$.jobName.value == "") {
            msg += "Error: Please add a job name.\n";
            validated = false;
        }
        if (!validated) {
            alert(msg)
        }
        return validated;
    },
    getUrl: function (fileId) {
        return SteviaManager.files.download({
            id: fileId,
            request: {
                url: true
            }
        });
    },
    getFileContent: function (callback, fileId) {
        SteviaManager.files.content({
            id: fileId,
            request: {
                success: function (response) {
                    callback(response);
                },
                error: function () {
                    this.message = 'Server error, try again later.';
                }
            }
        })
    },
    loadExampleFile: function (callback, toolName, exampleFileName) {

        var me = this;
        SteviaManager.files.contentExample({
            query: {
                toolName: toolName,
                fileName: exampleFileName
            },
            request: {
                //method: 'POST',
                success: function (response) {
                    callback(response);
                    //                            debugger
                    //                            me.loadedMainSelectChanged(false,true);
                },
                error: function () {
                    alert('Server error, try again later.');
                }
            }
        })
    },
    downloadExampleFile: function (toolName, fileName) {
        var url = SteviaManager.files.downloadExample({
            query: {
                toolName: toolName,
                fileName: fileName
            },
            request: {
                url: true
            }
        });
        var link = document.createElement('a');
        link.href = url;
        //link.setAttribute("download", "download.zip");
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        link.dispatchEvent(event);
    },
    argsParser: function (form, args) {
        if (form.toolName == args.tool) {
            for (var key in args) {
                if (typeof (args[key]) == "object") {
                    if (form.$[key] !== undefined)
                        form.$[key].selectedFile = args[key];
                } else {
                    var elems = form.shadowRoot.querySelectorAll('input[name="' + key + '"]');
                    if (form.$[key] !== undefined) {
                        switch (form.$[key].type) {
                        case "checkbox":
                            form.$[key].checked = args[key];
                        default:
                            form.$[key].value = args[key];
                        }
                    }
                    for (var i = 0; i < elems.length; i++) {
                        var elem = elems[i];
                        if (elem.value == args[key])
                            elem.checked = true;
                    }

                }
            }
        }
    },
    getLinks: function (terms) {
        var links = [];
        for (var i = 0; i < terms.length; i++) {
            var term = terms[i];
            links.push(stv.utils.getLink(term));
        }
        return links;
    },
    getLink: function (term) {
        var link = "http://www.ebi.ac.uk/QuickGO/GTerm?id=";
        if (term.indexOf("(") >= 0) {
            var id = term.split("(");
            if (id.length > 1)
                id = id[1];
            id = id.split(")")[0];

        } else
            id = term;
        if (id.indexOf("IPR") == 0)
            link = "http://www.ebi.ac.uk/interpro/entry/";
        link = link + id;
        return link;
    },
    myRound: function (value, decimals) {
        decimals = typeof decimals !== 'undefined' ? decimals : 2;
        value = parseFloat(value);
        /** rounding **/
        if (Math.abs(value) >= 1)
            value = value.toFixed(decimals);
        else
            value = value.toPrecision(decimals);
        value = parseFloat(value);
        return value;
    },
    formatNumber: function (value, decimals) {
        value = stv.utils.myRound(value, decimals);

        if (Math.abs(value) > 0 && Math.abs(value) < 0.001)
            value = value.toExponential();
        return value;
    },
    getSpecies: function (specieValue, species) {
        for (var i = 0; i < species.length; i++) {
            var specie = species[i];
            if (specie.value == specieValue) {
                return specie;
            }
        }
        return null;
    },
    test: function () {
        return this;
    },
    cancelFullscreen: function () {
        if (document.cancelFullScreen) {
            document.cancelFullScreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
        }
    },
    launchFullScreen: function (element) {
        if (element.requestFullScreen) {
            element.requestFullScreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.webkitRequestFullScreen) {
            element.webkitRequestFullScreen();
        }
    },
    parseJobCommand: function (item) {
        var commandObject = {};
        var commandArray = item.commandLine.split(/ -{1,2}/g);
        var tableHtml = '<table cellspacing="0" style="max-width:400px;border-collapse: collapse;border:1px solid #ccc;"><tbody>';
        tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;font-weight:bold;">';
        tableHtml += '<td style="min-width:50px;border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">Parameter</td>';
        tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">Value</td>';
        tableHtml += '</tr>';
        for (var i = 1; i < commandArray.length; i++) {
            //ignore first argument
            var paramenter = commandArray[i];
            var paramenterArray = paramenter.split(/ {1}/g);
            var name = '';
            var value = '';
            if (paramenterArray.length < 2) {
                name = paramenterArray[0];
                value = '<span color:darkgray;font-weight:bold;>This paramenter is a flag</span>';
            } else {
                name = paramenterArray[0];
                value = paramenterArray[1];
            }
            commandObject[name] = value;
            /* clean values for viz*/
            value = value.replace(/\/httpd\/bioinfo\/stevia\/analysis\/.+\/examples\//, '');
            value = value.replace('/httpd/bioinfo/stevia/accounts/', '');
            value = value.replace(/,/g, ", ");

            tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;">';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;color:steelblue;font-weight:bold;white-space: nowrap;">' + name + '</td>';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">' + value + '</td>';
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        return {
            html: tableHtml,
            data: commandObject
        };
    },
    htmlTable: function (object) {
        var tableHtml = '';
        tableHtml += '<table cellspacing="0" style="border-collapse: collapse;border:1px solid #ccc;"><tbody>';
        for (var key in object) {
            tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;">';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;color:steelblue;font-weight:bold;white-space: nowrap;">' + key + '</td>';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">' + object[key] + '</td>';
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        return tableHtml;
    },
    msg: function (title, msg) {
        var div = document.createElement('div');
        div.classList.add('stv-msg-hidden');
        var titleDiv = document.createElement('div');
        titleDiv.textContent = title;
        var msgDiv = document.createElement('div');
        msgDiv.textContent = msg;
        div.appendChild(titleDiv);
        div.appendChild(msgDiv);
        document.body.appendChild(div);
        div.addEventListener('click', function () {
            document.body.removeChild(div);
            div = null;
        });
        setTimeout(function () {
            div.classList.add('stv-msg-shown');
        }, 10);
        setTimeout(function () {
            if (div) {
                div.classList.remove('stv-msg-shown');
            }
        }, 4000);
        setTimeout(function () {
            if (div) {
                document.body.removeChild(div);
                div = null;
            }
        }, 4400);
    },
    repeat: function (string, count) {
        if (string == null) {
            throw new TypeError('can\'t convert ' + string + ' to object');
        }
        var str = '' + string;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (august 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += str;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            str += str;
        }
        return rpt;

    },
    clone: function (obj) {
        return JSON.parse(JSON.stringify(obj));
    },
    timeDiff: function (timeStart, timeEnd) {
        var ts = new Date(Date.parse(timeStart));
        var te = new Date(Date.parse(timeEnd));

        if (isNaN(ts) || isNaN(te)) {
            return "";
        }

        if (ts < te) {
            var milisec_diff = te - ts;
        } else {
            var milisec_diff = ts - te;
        }

        var days = Math.floor(milisec_diff / 1000 / 60 / (60 * 24));
        var daysMessage = days + " Days ";
        if (days === 0) {
            daysMessage = '';
        }
        var date_diff = new Date(milisec_diff);
        var hours = date_diff.getHours() - 1;
        var hoursMessage = hours + " hour";
        var minutesMessage = date_diff.getMinutes() + " minute";
        var secondsMessage = date_diff.getSeconds() + " second";
        if (hours !== 1) {
            hoursMessage += 's ';
        } else {
            hoursMessage += ' ';
        }
        if (date_diff.getMinutes() !== 1) {
            minutesMessage += 's ';
        } else {
            minutesMessage += ' ';
        }
        if (date_diff.getSeconds() !== 1) {
            secondsMessage += 's ';
        } else {
            secondsMessage += ' ';
        }
        if (hours === 0) {
            hoursMessage = '';
        }
        if (date_diff.getMinutes() === 0) {
            minutesMessage = '';
        }
        if (date_diff.getSeconds() === 0) {
            secondsMessage = '';
        }
        return daysMessage + hoursMessage + minutesMessage + secondsMessage;
    },
    deleteIndexedDB: function () {
        window.indexedDB.webkitGetDatabaseNames().onsuccess = function (sender, args) {
            var r = sender.target.result;
            for (var i in r) {
                indexedDB.deleteDatabase(r[i]);
            }
        };
    },
    subsetArray: function (array, from, to) {
        var aux = [];
        from = (from < 0) ? 0 : from;
        to = (to >= array.length) ? array.length : to;

        for (var i = from; i < to; i++) {
            aux.push(array[i]);
        }

        return aux;
    },
    applyFunctionBatch: function (array, batchsize, callback) {

        var end = batchsize;
        var auxArray = this.subsetArray(array, 0, end);

        while (auxArray.length > 0) {
            callback(auxArray);
            auxArray = this.subsetArray(array, end, end + batchsize);
            end += batchsize;
        }
    },
    humanFileSize: function (bytes) {
        var thresh = 1024;
        if (Math.abs(bytes) < thresh) {
            return bytes + ' B';
        }
        var units = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        var u = -1;
        do {
            bytes /= thresh;
            ++u;
        } while (Math.abs(bytes) >= thresh && u < units.length - 1);
        return bytes.toFixed(1) + ' ' + units[u];
    },
    removeDuplicates: function (array) {
        var uniqueArray = array.filter(function (item, pos) {
            return array.indexOf(item) == pos;
        });
        return uniqueArray;
    },
    images: {
        add: "data:image/gif;base64,R0lGODlhEAAQAIcAAD2GNUKNNkOPOESMO0WNPEmPP0iNQUmPQlOVTFWWTVCZQVeeRV6cVmGeWGSgVWSgV2aiWGejW2WrVWirU2uqWGqsW2yqWm61WG+1WG+1WXS3W3S3XHC4WXK5W3O6XHG+X3asZ3iuaHe8YHi0ZH+yany6ZH28Zn2+Z3m9bn25an25a3+5bUD/QHDBY3nBZHrGa3zDa37BaX7Hb4K1boO1boa3cYi4d4y7doq5eYm+eI2+e5O/f4HMdYbJeobJfIXNeYrCeY/CfYnIf4rPfZW/gozLgY7MhI7Sg5LFgJXAgpfHhZfMhZPNiJjLhpjMh5jMipvBl5vBmJTTipbTiZXUipbUi5fVi5nRi53YkqTOlKbPlqbQlqDZlaDZlqXbm6rUnavUnKbIoKfJoa/fpa/fprPZpbTZpbTaprLbqLPdqbXbqLfaqrTdqrXfrLbdrLjVr7jdr7vcr7rWsbfgr77itr3ktsTcuMXducXowMvmw87pydTrz9fu0tzx2ODy3P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAACwALAAAAAAQABAAAAi/AFkIHEiwoME7SWrMwCHH4MAdWfLs0QNnRQiHN+L4qeOlyxg8QCAU3LGmDxYmRqpQOTJHRYSBdpTw4SJFyJ8/P2DIaLNAjEAibsgU8YHiZgURHq4gaSCQBh0rPW5K/cMhxpcCAkmkGcJj6k0OJ8AMEGjjyZQXLSR85dBhiY4EAt9MYOPig4ivFzacEQBlIIgUaJByyIBBQxkLBwo6GKHGiYkSTcxQAODwgYIgW7TkCGDAocAwDAoQQBDFs2mCAQEAOw==",
        del: "data:image/gif;base64,R0lGODlhEAAQAIcAAED/QLpSNL9TOr5WOb5cQL9cQMFNM8RQNMBVPcBZP8xSPNBPPttWS9ddUcJnTMRkTMdrVM1gUc5iVMxmVclrVs1oWNZgVNZuZNtpZdxraN5ratxuadRxZd14c955dOZWTOZYTOZZTulZTelbT+ZWUOZaUuddWepcUOxfVOBlXO5mUuljW+pmXO5qXvBkVvNzXeNrYeNuY+FvcOJwZuJ7deR4ceJ5eeN4eeJ/feN/fOl7cOh6del/ePJ3Y/N5Y+qDfe6Efe+Gfu6KdfaCaPaEbPCFcPCDe/CMd/GOeviGcPiMdvCRf/eRfveTfvmSfvqTf/iUf9ymltynl+6Mge2Tju6Sj/SOgfqah/qdi/GclvGdluGpnvSgnvSinvWjn/qjkfupnPqrneGroOqwrOuzr/Ono/WmoferofarovWsofWvpfKtqvivpPS0qvi2qPm5r/q6rvC1tfC2tvjDvvzHuvnLxPnTzPzUzf3b1P3c2P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAAALAAAAAAQABAAAAi6AAEIHEiwoEE5ODRk8EDG4EAbVObYqdNmxgWHMtbkgfMFCxg6OiQUvFEGz5UlSKA4UeImRoWBcX7cwdJECJGbRHywWSBGYA41YY6gGEq0hxUeFARuePOkiJ6nUEW00IJAIIYzSYZAjcoiywCBHaYweSGirNkRRmg8EDiGARoXKsyKAFHCy4EoAznASIPihIgQH0h0sVCgYIQUZoKsMAGES4MADico2FGlSg0DBBwK3AIhgQAHUjSLJhgQADs=",
        enable: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAKfSURBVDjLpZPrS1NhHMf9O3bOdmwDCWREIYKEUHsVJBI7mg3FvCxL09290jZj2EyLMnJexkgpLbPUanNOberU5taUMnHZUULMvelCtWF0sW/n7MVMEiN64AsPD8/n83uucQDi/id/DBT4Dolypw/qsz0pTMbj/WHpiDgsdSUyUmeiPt2+V7SrIM+bSss8ySGdR4abQQv6lrui6VxsRonrGCS9VEjSQ9E7CtiqdOZ4UuTqnBHO1X7YXl6Daa4yGq7vWO1D40wVDtj4kWQbn94myPGkCDPdSesczE2sCZShwl8CzcwZ6NiUs6n2nYX99T1cnKqA2EKui6+TwphA5k4yqMayopU5mANV3lNQTBdCMVUA9VQh3GuDMHiVcLCS3J4jSLhCGmKCjBEx0xlshjXYhApfMZRP5CyYD+UkG08+xt+4wLVQZA1tzxthm2tEfD3JxARH7QkbD1ZuozaggdZbxK5kAIsf5qGaKMTY2lAU/rH5HW3PLsEwUYy+YCcERmIjJpDcpzb6l7th9KtQ69fi09ePUej9l7cx2DJbD7UrG3r3afQHOyCo+V3QQzE35pvQvnAZukk5zL5qRL59jsKbPzdheXoBZc4saFhBS6AO7V4zqCpiawuptwQG+UAa7Ct3UT0hh9p9EnXT5Vh6t4C22QaUDh6HwnECOmcO7K+6kW49DKqS2DrEZCtfuI+9GrNHg4fMHVSO5kE7nAPVkAxKBxcOzsajpS4Yh4ohUPPWKTUh3PaQEptIOr6BiJjcZXCwktaAGfrRIpwblqOV3YKdhfXOIvBLeREWpnd8ynsaSJoyESFphwTtfjN6X1jRO2+FxWtCWksqBApeiFIR9K6fiTpPiigDoadqCEag5YUFKl6Yrciw0VOlhOivv/Ff8wtn0KzlebrUYwAAAABJRU5ErkJggg==",
        warning: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIsSURBVDjLpVNLSJQBEP7+h6uu62vLVAJDW1KQTMrINQ1vPQzq1GOpa9EppGOHLh0kCEKL7JBEhVCHihAsESyJiE4FWShGRmauu7KYiv6Pma+DGoFrBQ7MzGFmPr5vmDFIYj1mr1WYfrHPovA9VVOqbC7e/1rS9ZlrAVDYHig5WB0oPtBI0TNrUiC5yhP9jeF4X8NPcWfopoY48XT39PjjXeF0vWkZqOjd7LJYrmGasHPCCJbHwhS9/F8M4s8baid764Xi0Ilfp5voorpJfn2wwx/r3l77TwZUvR+qajXVn8PnvocYfXYH6k2ioOaCpaIdf11ivDcayyiMVudsOYqFb60gARJYHG9DbqQFmSVNjaO3K2NpAeK90ZCqtgcrjkP9aUCXp0moetDFEeRXnYCKXhm+uTW0CkBFu4JlxzZkFlbASz4CQGQVBFeEwZm8geyiMuRVntzsL3oXV+YMkvjRsydC1U+lhwZsWXgHb+oWVAEzIwvzyVlk5igsi7DymmHlHsFQR50rjl+981Jy1Fw6Gu0ObTtnU+cgs28AKgDiy+Awpj5OACBAhZ/qh2HOo6i+NeA73jUAML4/qWux8mt6NjW1w599CS9xb0mSEqQBEDAtwqALUmBaG5FV3oYPnTHMjAwetlWksyByaukxQg2wQ9FlccaK/OXA3/uAEUDp3rNIDQ1ctSk6kHh1/jRFoaL4M4snEMeD73gQx4M4PsT1IZ5AfYH68tZY7zv/ApRMY9mnuVMvAAAAAElFTkSuQmCC",
        edit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB80lEQVR42o2T30tTURzArb8ioiAI6kHoZeF7CGE/IISCUDNCqAeL3rIWPfSwByskYUEJIhSChBhJFAiNqMVYPqRuc4tcW3NLt3C7u3d3d3c/+nS+0GRK0134cC6c8/ncc+7ltgFt6jqgcCg6duGQYq84deoBR6lU0iqVSq1arfI/1Dxut3u0Htke6BC5UChgmuYm+XyeXC5HOp1GIsnQNJHJi3x/7WJh/CSLT9r7Rd4jAVlgWRa2bSOjYBgGmqaRyWQwkq9Y8wyhLb0BI0VuaRrfo671xoDIwmakWCyi6zrr36bILt/HXp1l7cNDioEZqnEvgYmr1paAOgYy1u/l3NrqHNngPWpFL8XodTa+3CD8YoCvz/o078i5o1sC29FT78kG7lCzfJgrl7ESvejLThLPuxk8fbhP3KaBVFCdeX7on9yP9bOHfPAu0bEzmKkg4jQNpEKzhOduqW1/xIoNUEpcQlM7WXl6Cj39Q9Y0D4Q/TRJ662Tx3WOS/guYsV42Fm4THe/G/B2T97Jz4OVwJ+hxImPn8Tj381k91TfShfErIvLuAde1Y9g+N7Z/FL/rBDODR8gmgpTL5To7B3o69zF8pR3Pg7PMT90kn47LJ22kaeCPghapidP4Lxy3bduUiVZktdaQH7AxcFAiUm0Rhzji/gUhbp0s2Zf2xwAAAABJRU5ErkJggg==",
        info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAJ1SURBVHjafJJdSJNhFMd/z3QzLWdZrnQmSA2DPqRCK4KuhIq66kLoAy/qoqCguqqL6JsgLwoKKhCMSIy6CDKKRFZZYYQRVhJl02nWmG5uc19u7/vuPV0lW7QOnIsHnt+P8z/Pg4gw26aZ0263uzEUCn2IxWJjXq/3JqBETLIZ8gkePLhfKyKy/Z5HHJf7xe0Jic/n65mejizPK0inUiSTKUSE0dHRhxf6JoSDb4Rjr4QDz0REJBgMtmczFrJKKYVSCjCYnPR/W1FuAwQSGjbHXAA0LRXKZnIm0NJpgAKvd/hSOBz2iIj0eiPS2vtDYsmUPH/uPg9YshklIrOyCb+/eUG5ve3au5C99W2AqGbgKivk8R4X1lSkv2pJZaNmmBQVWWeZnAiGoa+3KovdyBjsW2kn/SvK4Jcgtaf7cDqrGkQMUDkBcgXVS2tOHjp8dG2jOXT1yo5lYOpgFTB0wKTAOqdQMlqOoDD7EE8kREwGXr/oWTg4HjxONAklBayuKSUeT/hFTxrwnwlAMa8I1qyrP3H95RiQgUiC/RsWM+wZ6jIME0M38wtSM0mmojM4nc6mzr5xKDQgnWb/pmoedT29EU3pTMUS+QVKKerq6kqnI3EVHwmAplO8qBh7WTFnzpz9bOg6FovlfxGEixfOrfT6YxCOQ1rDUaIAG4EJ38+PAwNb/95Bzj8ITAZwLHbMT0yHw3N33YVwEnQDqss41VzPkaalX6Iz+m6Xy/Xp34JAAICR7187nLWuvbe6h9C0DA2uRTTVV9J++87OlpaWJxUVFf9+xj+1cfOWls6OO93Nq1zblMVm9flG3pcvXNPm90+E/777ewB+UIqdqtYXHAAAAABJRU5ErkJggg==",
        //    bucket: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90BCg4hBcbCoOMAAABsSURBVDjLY2RgYFBjYGCIZCAPLGeBam4g0wAGJgYKARMDA8NZCvSfZYQy6sk0oJEFiUNqODRQLQxGDYCAb2To/YZswEsyDHiJbMAHMgz4gO6F5aTkQpgXYElZkoGBgZeEbL2cgYHhMwMDw3MA93ARk+mSg4gAAAAASUVORK5CYII=",
        bucket: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QkQDC8RTstxRAAAAGBJREFUOMtjYBgswIWBgeE/idiFgYGBgRFqwH8GBoYGEi1tYGBgYGRBE9QjUvMlGANmgCsDA8NuElzRANXDwAQV2ENGuO1BNoBsMGoAlQ3wJTIdNEDVYgU+ROQBH6rmQgAWgB19xco60wAAAABJRU5ErkJggg==",
        //    dir: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsSAAALEgHS3X78AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKNJREFUeNrEk7sNwkAQBefQ5m6BTiAAQssZiMh0QFUIMrAEpKYD8ynAJeD4nXQEkJHgu4CXv9GsdteFEEjJgMQ4gPli+aWx227cLwAD8FK8QZ4XTyCL6B6qal+YlzLgCpSn87HpbTCdzAKwAkpg1Bdgn/nbmDLQmby6hC3W5qUGGEcCGpNUJwBq09tgHdO+Pe61eamNvIMLgEkaxuoDuL9/42sAM20/EZafbV8AAAAASUVORK5CYII=",
        dir: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDNzU0RUNBNzU3OEIxMUUyOEM3QzkxOEZDOTU1RTdFMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDNzU0RUNBODU3OEIxMUUyOEM3QzkxOEZDOTU1RTdFMCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkM3NTRFQ0E1NTc4QjExRTI4QzdDOTE4RkM5NTVFN0UwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkM3NTRFQ0E2NTc4QjExRTI4QzdDOTE4RkM5NTVFN0UwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+S/WxbAAAAERJREFUeNpi/P//PwMlgJFSA1g2bNiAzYQLQOwIxB8IGcCEQ9wAiPcDsQBBF+CRAxnynlwXEA1GDRg1gCqZiWIDAAIMADidE0PBoGsZAAAAAElFTkSuQmCC",
        r: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90CDRIvNbHTpbwAAADjSURBVDjLpZFBbsIwEEUfVRZYahcVK3qKXoauMFK5C91nkyUB+xC5BqeAA7SKq1B5ugl2EiC04UkjayzN17NnROTRWvvJFbTWL8CBHqbGWOlSlqVkWSbGWAGm3aGHZiMiAByPP6FOd1rP2W7NvhvSCvDe10E+VJPFQpPnm1ZIcsmgPgJVVZGmaejX63y/XL4/AV/JJYPTCeDcN7PZWyuwKAqA8wARqSsGKDVGqXGjV8H07AnRQPq21TK8+YSBAQMN4hb6Df7wB/5eA+4zmEyehxk451itPrhFksSxUeP+lf+z+wXwdayJk/mqtgAAAABJRU5ErkJggg==",
        box: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMHAwRAVvTmTAAAAK/SURBVDjLpZM9bFxFGEXPNzPvZ+39sb2xHceREjDQBwlDCqqIiiotokAghYKEjvSkQkKJkEiB0lOkoAHaBAokFCQKUATIIOLIMbHWrHfX+7zvvZk3MzQODUgU3PJK5+g2F/5n5N/Kb66/1NNK3hAxr4HcFqVuvfju18V/Cu58sPmMVnJZ4K32Qr+t8za+KnCz4kCUuiGibm5euTv5h+CL958/nxj1XivVF+e6C9TVhPmFdbROgEhwNU1d4m09UaJuInLjhct3DgDUh5ee7j14PLxulLvYP/0seadPkub88Wib0eB3bDkmxgbRoFPpxeCuKvjsyQIzOyqImT7/y8Mh++NveW7jLFmrx6m1NlWxz6PHA7otQ7tloAmYJE9isOeeCJRtIrULLLUTjsqG7+//xs72z7jZgCTNONlVJKEiuobW0jqSaoiet19dFQATJcc2FSFEciNoLYwOHcPDASvdjM5cQntxlbR9gqacoFSK84VsnOrkH11Zdmp0FFXjobSeCFgXSDS0Eo11ge7yGXSaU092UUlCaEpC8FK4tDcu4rzZ2a/S+bWI94HSAgFigDQD24Cvp4gIOp0juBJvC2L07B1Uc/Mtg9k7sHMbywZrA3lLECV4AtaCpAp79CcmzXHlhOBrAJrGyNbOVBY7qTO1C9r5EKyPSttAiJEs01SuQStFkrdp6gKd5AzHjixVxCDxp+1paZRUxoc4Kp36bndYbS53U5WlCq0CMYIPMY7GI0mNpiqmGK0oK4jIveGkPgRqfTBt3A8Pqtvrq52HtglnGh9XIaKUkCQ6nj6RyWBsmdXCtFI/bu2Fq5c+3roGzIAgWokCDNACOhfOLb781Ip+vd+RC2dXWibROkxKvvp1z376yZe7d4HpMdz8/YVjiQYyoA30Ti6la2++0n/n83vTW/e3ix1gcgzXgPchBoC/AFu/UBF5InryAAAAAElFTkSuQmCC",
        bluebox: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMHAwTE5pcivoAAALsSURBVDjLXZPPaxxlGMc/77wz+3N2k822tWsTIrQFe/BWEKxKCV5UohdFhJ60p6rgUfpP6C0K4kHx0ENEkV7aElHwUikhFVosRGoTm83+3pnZnXfed2beHtItIQ98+Z6+H57nga8AsNYKDkYcEofcHvKZEEJYcSTszPzqL3fmf3+w/+a51tytby9d6D0N5UecGeBZ8MPv/jh9fy/6dKzMpVPHmvWdbl/XCvKn5Wbl6+ufrNwGssMgYa2VgFj58sZr7VB/LqX3zlKrydJzTTzXxdqcx90hO+0Bk2l8Z74i1z6+cOba5VfOqGeAb3579M/NR53T40xwrDGHFALPEUjn4LoMi0ktwWTKXqCIqAVrbyycvHj2hHYBR+bO8Q/Ov0imEzZ2xrRDRalQwC9LLBalUgaJQy+tU6gvIBJbv3j2RA4IFxDdICFa9ulMCrz/UgOs5kEwpeh57I4Nt/dzsmLOYlEThgFjUePp33IHoD9SJAbuTVyudRweixJvnVtg3/i00wpLPiwQ0hkO6YYKawWj0UjONqAfKHwDkxTqqeW/RHA3hO2+Zqk05e5wTD9KmOqMKDEUqoLNzU0PyF2AQaBoaIhiw0h6TIwgUDCODb5NiWJNlKREyhAozXwOW1tbFSmlcAHbD2KaytCdGgyWglfEs4LeNKeaa4axYRgpwlgTTTXVDDqdTslaewAYh4kNlKUbZsTGonOwCYwm1vq5Ft1AMYgU08SQR5o0gziOcRxHuoCNtdl6uPHX6/Vmi3Yyh9I5IoEgMdkgT9x+qJhEGrdQo77cJMuy+4DJskwLa60DOCtf3HhZpfZKtVx+L3x+sfCv8CFxTINd72HfodQ4aQp5fP24/v/Hd4Nf/5RSJmma6lkXZn1wPvvq5qndsbhS9esf/Zy/UEtzxnURfn8+/fuHV7m353mecV1XSym1lDI72kaxvr5e3N7eruyP0tpG/e3LK/rW2mLNUb7vm3K5nFarVdNqtbJer2dXV1fzJ6cDpboAZRAGAAAAAElFTkSuQmCC",
        refresh: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAK8AAACvABQqw0mAAAAAd0SU1FB90CFA8bKScXIjIAAAJ1SURBVDjLlVJdSJNRGH7es+/7NlduWFLTKAskwjJqZYiBglJhLKguqou6EFkFIkLQH9IPBFI3BsouzMJupGYRajcqmeBFhWBU5oUgpZikrSnzZ9v3nW/ndKEbziXUAwfOOe/7Puc9z/MCq1DwMmB1NX/rzfCNnsc/gK08lPgnnT8Cs33BULg0HI4YKdkHX9DqKwKArXXv1bTMTFcoyruC89E8MxaDw659t6rKhIUwRBLdP2t2v/5bBwQA+5pH8ibnIj3BucgWIQRASw8RERTGYFUtsGmWYUXKmqmr7t4UAnal54GQ8lq8MBlyOU0CEnA67MiwqfvHbhZ+Smgg6o9eV2L8Nhk6wI2lZeggrpvE+TTjxgxxQ4IbmJsJYSa00JQiotnguacJ8zIZOmDosAnzTpowt8tGj0s0ejZqprnDKmPHSNebjHDkUPatt4cTTbZ+LsmO79XK52dZxTNp9/ovAEDnaM62lo8HHrd9SVfiOelVryrSq9vrEx0s8sW2tuEzDgDgT875bcIsjy6owwAwHhjnYT5bGTL29PiHyuwAMO873aL/Ct5PiPjwXe5vq7KJW2hdJxENMFInGCkhIblLj80WRoyxGxZmh1XJGlSIlV8s6A8kuVDXn+MF6JHC7GBkBSNlOSRgiihMsQhAgJGGNNU1atc2HPG6O8YSBABwt2/nGyFlGSCSB4UIBMuyoQKMFNiUjIApRH5t8YfpFOOrO/JrhZBVUiJLxq2ipIkY8Z36uivpC6txqb3YbhqhIingFlLmxmLSKyXAGAaYqh13aFjfcHJwfE2ClSitK9psc85PMVC3M999orX4Kcf/wuPb27VW7A+O2QVVA1M1CQAAAABJRU5ErkJggg==",
        newitem: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAtxJREFUeNqM0llIVHEUBvDv3vlfZ8ac6zZtWpmamtliUUHRDlFJWlEYLdBLtG/QBlFJQUTSU089RZRlG4EvkS9NlqkpldHyYLk1OurcOzp30vHO/y6nBwsSIvzgvBw+fpyHA8MwwDmHbdsjQwSbCACkYDBYp6pqU3Fxcfyf/Z+eYRjQOQf+Bnw+30IiIsMwhizL4n3lV6mn7BzZtm1yzn8SETU0NKz+J2ARobe3t85/+SI1506j9hOHqTEO9FYEtR/ZTx/n5FDH6eOkquoni2g00NjUtEzTtBYioneLCulVHKg2yUkNmelUn5VOtUlueu0SqDE/m4iIIpFI64fm5vU65xAMIlicR9rOn/UEKytgmQbYuARAEDAqRLCiQxBFhtTNWzDzxk1LcjgkFhuKIhLR2qJKcN5Al/q7reF/cXUHoA0MtA9Gh4klJIxz6ro+PZiVC0uOw1jimJEDWZbTDhw8lCi0+/3PtUeV696ePIPUnIwxAf3fOjG/7AK8e/e9ZH2K0uWdPRdivANm3NguED1OJBYWQunvDwgAXIqifO54+CC7/tSxMQELL11B/r6D3cnJybniQDis25Ikfn1wD2GdQLIMISkF5JFhudwgjwySkyCkpILkRER0wpf7d2FJkqSoapQRRPCYjoLDR+EY70VXbS2YxCC4nAARbAAQBJBlwTIMZJRsQN7W7eA6t9O8XkE0jRhWLV2y+Gdm9q0dT6rMhLw8dPn7EAoEMBSLIcpjCPUEEPD3gU1Kw+6qZ6TPKrizq3TbAjUUIkFRVYAIkkfG99bWp4P1b7Z0vq5BXtFGPN6zE6Zuo7SiAh01PkycV4jJRRt96VOmrOHhMESHiBEAgMkNlGwqmXC78mG1DXtQdruTgx/eF5g6x9Tly1pCmtYjMSnxatnFTeXXyn8wxiCMAgxz5EmcTjCXCynxblf1C9910eFwrl254nh/dDhqcQ5zeBgAwBiDIAr4NQAWJarVjshqqgAAAABJRU5ErkJggg=="
    }
};
</script>

<dom-module id="stv-header" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
         :host {
            position: relative;
            display: block;
            box-sizing: border-box;
            cursor: default;
            width: 100%;
        }

        .main {
            position: relative;
            height: 60px;
            font-size: 18px;
            margin: 0;
            padding: 0;
            text-transform: none;
            box-shadow: 0 4px 4px 0px rgba(0, 0, 0, 0.3);
            /*background-color: inherit;*/
            background-color: var(--dark-primary-color);
            color: var(--text-primary-color);
        }

        #left,
        #right,
        #center,
        #menu-wrapper,
        #menu-wrapper::content>.menu {
            height: 100%;
        }

        #tools {
            position: absolute;
            top: 60px;
            width: 100%;
        }

        #left>div,
        #right>div,
        #menu-wrapper::content>.menu div.option {
            box-sizing: border-box;
            cursor: pointer;
            text-align: center;
            border-top: 2px solid transparent;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #left>div>::content>* {
            margin-left: 10px;
            padding: 0 0 1px 0;
        }

        #right>div,
        #menu-wrapper>::content>.menu div.option {
            margin-right: 5px;
            padding: 0 5px 1px 5px;
        }

         :host[small] #left>div,
         :host[small] #right>div,
         :host[small] #menu-wrapper>::content>.menu div.option {
            border-bottom-width: 1px;
        }

        #right>div:hover,
        #menu-wrapper>::content>.menu div.option:hover {
            border-bottom-color: var(--divider-color);
        }

        #menu-wrapper>::content>.menu div.option[active] {
            font-weight: normal;
            border-bottom-color: var(--accent-color);
        }

         :host[small] #right>div:hover,
         :host[small] #menu-wrapper>::content>.menu div.option:hover {
            border-bottom-width: 1px;
        }

        #user {
            color: var(--accent-color);
            /*font-weight: normal;*/
            border-bottom: 2px solid transparent !important;
        }

        div.title {
            font-size: 30px;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }

        div.description {
            font-size: 18px;
        }

        div.description:hover {
            cursor: default;
        }

        @media (max-width: 1250px) {
            div.title {
                font-size: 24px;
            }
            div.description {
                font-size: 14px;
            }
            .option-text {
                font-size: 0.9em;
            }
        }

        @media (max-width: 1150px) {
            div.title {
                font-size: 20px;
            }
            div.description {
                font-size: 13px;
            }
            .option-text {
                font-size: 0.8em;
            }
        }

        @media (max-width: 1050px) {
            .option-text {
                display: none;
            }
        }

        #icon {
            margin-top: 0px !important;
            margin-bottom: 0px !important;
        }
        /*small*/

         :host[small] .main {
            height: 32px;
            font-size: 15px;
            box-shadow: 0 2px 2px 0px rgba(0, 0, 0, 0.3);
        }

         :host[small] #tools {
            top: 32px;
        }

         :host[small] div.title {
            font-size: 22px;
        }

         :host[small] div.description {
            font-size: 15px;
        }
        /*Help menu*/

         :host::content .helpmenu,
         :host::content .launcher,
         :host::content .cluster_stats {
            margin: 0 10px;
        }

         :host::content .helpmenu>[data-menu] {
            margin-top: 10px;
            padding: 5px;
        }
    </style>
    <template>
        <div id="tools">
            <stv-login id="stvLogin" hide-signup$="{{hideSignup}}" hide-anonymous$="{{hideAnonymous}}" menu-option="login" on-login="handleLogin" on-remember="handleRemember" on-signup="handleSignup" on-anonymous="handleAnonymous">
            </stv-login>

            <stv-signup id="stvSignup" on-login="handleLogin" menu-option="signup">
            </stv-signup>

            <stv-profile id="stvProfile" menu-option="profile">
            </stv-profile>

            <stv-remember menu-option="remember">
            </stv-remember>
        </div>

        <div class="main horizontal layout center">
            <div id="left" class="horizontal layout start-justified center">
                <div on-click="handleMenu">
                    <content select=".menu-button"></content>
                </div>
                <div id="icon" data-option="home" on-click="handleMenu">
                    <content select=".icon"></content>
                </div>
                <div class="title" data-option="home" on-click="handleMenu">
                    <content select=".title"></content>
                </div>
                <div id="description" class="description" data-option="home" on-click="handleMenu">
                    <content select=".description"></content>
                </div>
            </div>
            <div id="center" class="horizontal layout flex center">
                <div id="menu-wrapper" hidden$="{{computeMenu(showMenuOnLogin, isLogged)}}" class="horizontal layout center flex">
                    <content select=".menu"></content>
                </div>
            </div>
            <div id="right" class="horizontal layout end-justified center">
                <div id="user" hidden$="{{computeUser(hideLogin, isLogged)}}">
                    <span class="option-text">{{userText}}</span>
                </div>

                <div title="Edit user settings" id="profile" data-option="profile" on-click="handleMenu" hidden$="{{computeProfile(userText, hideSignup, hideLogin, isLogged)}}">
                    <i class="fa fa-user"></i>
                    <span class="option-text"> Profile </span>
                </div>

                <div title="Logout" id="logout" on-click="handleLogoutClick" hidden$="{{computeLogout(hideLogin, isLogged)}}">
                    <i class="fa fa-sign-out"></i>
                    <span class="option-text"> Logout </span>
                </div>

                <div title="Login" id="login" data-option="login" on-click="handleMenu" hidden$="{{computeLogin(hideLogin, isLogged)}}">
                    <i class="fa fa-sign-in"></i>
                    <span class="option-text"> Login </span>
                </div>

                <div title="Sign up" id="signup" data-option="signup" on-click="handleMenu" hidden$="{{computeSignup(hideSignup, hideLogin, isLogged)}}">
                    <i class="fa fa-pencil-square-o"></i>
                    <span class="option-text"> Sign up </span>
                </div>

                <content select=".launcher"></content>

                <content select=".cluster-status"></content>

                <content select=".helpmenu"></content>
            </div>
        </div>
    </template>

    <script>
        Polymer({
            is: "stv-header",
            properties: {
                checkTimeInterval: {
                    type: Number,
                    value: 5000,
                    reflectToAttribute: true
                },
                selectedOption: {
                    type: String,
                    value: "home",
                    notify: true,
                    reflectToAttribute: true,
                    observer: 'selectedOptionChanged'
                },
                hideLogin: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                hideSignup: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                /* @Deprecated */
                showMenuOnLogin: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                isLogged: {
                    type: Boolean,
                    value: false
                },
                hideAnonymous: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                userData: {
                    type: Object,
                    notify: true
                },
                userText: {
                    type: String,
                    value: ''
                },
                jobItem: {
                    type: Object
                },
                allowedTools: {
                    type: Array
                },
                small: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                }
            },

            computeMenu: function(showMenuOnLogin, isLogged) {
                if (showMenuOnLogin) {
                    return !isLogged;
                }
                return false;
            },

            computeUser: function(hideLogin, isLogged) {
                if (hideLogin) {
                    return true;
                }
                return !isLogged
            },
            computeProfile: function(userText, hideSignup, hideLogin, isLogged) {
                if (hideSignup || hideLogin || userText == 'anonymous') {
                    return true;
                }
                return !isLogged
            },
            computeLogout: function(hideLogin, isLogged) {
                if (hideLogin) {
                    return true;
                }
                return !isLogged
            },
            computeSignup: function(hideSignup, hideLogin, isLogged) {
                if (hideLogin || hideSignup) {
                    return true;
                }
                return isLogged
            },
            computeLogin: function(hideLogin, isLogged) {
                if (hideLogin) {
                    return true;
                }
                return isLogged
            },
            selectedOptionChanged: function(neo, old) {
                var menuItems = Polymer.dom(this.root).querySelectorAll('[menu-option]');
                for (var i = 0; i < menuItems.length; i++) {
                    var item = menuItems[i];
                    var currentItemValue = item.getAttribute("menu-option");
                    if (neo == currentItemValue) {
                        item.removeAttribute("hidden");
                    } else {
                        item.setAttribute('hidden', '');
                    }
                }
            },
            //TODO
            ready: function() {
                if (!this.hideLogin) {
                    if (Cookies("bioinfo_sid") && Cookies("bioinfo_user")) {
                        this.sessionInitiated();
                    } else {
                        this.sessionFinished();
                    }
                }
            },
            handleRemember: function(e) {
                this.selectedOption = 'remember';
            },
            handleSignup: function(e) {
                this.selectedOption = 'signup';
            },
            handleAnonymous: function(e) {
                this.anonymousSign();
            },
            handleMenu: function(e) {
                var option = e.currentTarget.dataset['option'];
                console.log(option);
                if (option) {
                    this.selectedOption = option;
                }
            },
            handleLogoutClick: function(e) {
                this.sessionFinished();
            },
            handleSupportMenu: function(e) {
                this.$.helpMenu.classList.toggle('help-menu-shown');
            },
            handleHelpMenuMouseOut: function() {
                this.$.helpMenu.classList.remove('help-menu-shown');
            },
            handleLogin: function(e) {
                e.stopPropagation();
                if (e.detail.status) {
                    this.sessionInitiated();
                } else {
                    this.sessionFinished();
                }
                this.fire('session-change');
            },
            demoLogin: function(username) {
                this.$.stvLogin.user = username;
                this.$.stvLogin.password = "demo";
                this.$.stvLogin._login();
            },
            anonymousSign: function() {
                this.$.stvSignup.name = "anonymous";
                this.$.stvSignup.email = "anonymous@anonymous.anonymous";
                this.$.stvSignup.password = "anonymous";
                this.$.stvSignup._signup();
            },
            sessionInitiated: function(e) {
                var me = this;
                this.isLogged = true;
                this.selectedOption = 'home';

                /**START CHECK**/
                if (!this.userInfoInterval) {
                    this.getUserInfo(); //first call
                    this.userInfoInterval = setInterval(function() {
                        me.getUserInfo();
                    }, this.checkTimeInterval);
                }
                this.fire("login");
            },
            sessionFinished: function(e) {
                this.logout();
                this.isLogged = false;
                this.userData = null;
                this.selectedOption = 'home';
                this.userText = '';
                Cookies.expire('bioinfo_sid', {
                    path: window.location.pathname
                });
                Cookies.expire('bioinfo_user', {
                    path: window.location.pathname
                });

                /**END CHECK**/
                clearInterval(this.userInfoInterval);
                this.userInfoInterval = null;
                this.fire("logout");
            },
            getUserInfo: function(force) {
                var me = this;
                var updatedAt = null;
                if (force != true) {
                    if (this.userData != null) {
                        updatedAt = this.userData.updatedAt;
                    }
                }
                var user = Cookies('bioinfo_user');
                if (!user) {
                    console.log('cookie: bioinfo_user, is not set, session will be finished...');
                    this.sessionFinished();
                } else {
                    SteviaManager.users.read({
                        id: user,
                        query: {
                            updatedAt: updatedAt
                        },
                        request: {
                            success: function(response) {
                                if (response.response[0].error == null && response.response[0].results.length > 0) {
                                    me.userData = response.response[0].results[0];
                                    me.userText = me._checkUserName(me.userData);
                                    console.info("userData has been modified since last call");
                                }
                                if (response.response[0].error != null) {
                                    me.sessionFinished()
                                }
                            },
                            error: function() {
                                console.log('Server error, try again later.');
                            }
                        }
                    });
                }
            },
            logout: function() {
                var me = this;
                var user = Cookies('bioinfo_user');
                if (!user) {
                    console.log('cookie: bioinfo_user, is not set, session will be finished...');
                } else {
                    SteviaManager.users.logout({
                        id: user,
                        request: {
                            success: function(response) {
                                console.log(response);
                            },
                            error: function() {
                                console.log('Server error, try again later.');
                            }
                        }
                    });
                }
            },
            _checkUserName: function(userData) {
                if (userData.name.indexOf('anonymous___') != -1) {
                    return 'anonymous';
                } else {
                    return userData.name;
                }
            }
        });
    </script>
</dom-module>
<script>
    StvApplicationBehavior = {
        properties: {
            version: {
                type: String,
                reflectToAttribute: true
            },
            selectedOption: {
                type: String,
                value: "home",
                notify: true,
                reflectToAttribute: true
            },
            userData: {
                type: Object,
                notify: true
            },
            projects: {
                type: Array,
                notify: true
            },
            maintenance: {
                type: String,
                value: '',
                reflectToAttribute: true,
                observer: 'checkMaintenance'
            },
            smallHeader: {
                type: Boolean,
                value: false,
                reflectToAttribute: true,
            },
            _lastLoggedPanel: {
                type: Object
            },
            _lastLoggedMenu: {
                type: String
            },
            _lastLoggedTasks: {
                type: Array,
                value: function() {
                    return []
                }
            },
            queryParams: {
                type: Object,
                value: function() {
                    return {};
                }
            }
        },
        observers: [
            '_selectedOptionChanged(selectedOption)',
            'selectedOptionChanged(selectedOption)',
            '_userDataChanged(userData)',
            'userDataChanged(userData)',
            '_handleLoadJobFromQueryParam(queryParams.job)'
        ],
        listeners: {
            'need-refresh': 'handleNeedRefresh',
        },
        ready: function() {
            var me = this;
            //cookies
            if (Cookies('app-accept-cookies') == null) {
                var div = document.createElement('div');
                div.classList.add('stv-note', 'stv-note-info');
                div.style.position = 'fixed';
                div.style.left = '0';
                div.style.right = '0';
                div.style.top = '5px';
                div.style.zIndex = '10000';
                div.style.fontSize = '13px';
                div.style.width = '600px';
                div.style.margin = '0 auto';
                div.style.cursor = 'pointer';
                div.style.boxShadow = '0px 0px 6px 3px rgba(0, 0, 0, 0.30)';
                var msg = [
                    'This website uses cookies.',
                    'By continuing to browse this site,',
                    ' you are agreeing to the use of our site cookies.',
                    '<div style="font-size:12px;text-align:right;text-decoration:underline;">OK</div>'
                ];
                div.innerHTML = msg.join(' ');
                div.addEventListener('click', function() {
                    Polymer.dom(me.root).removeChild(div);
                    Cookies.set('app-accept-cookies', 'true', {
                        expires: 3600 * 24 * 7
                    }); // Expires in 1 week
                });
                Polymer.dom(this.root).appendChild(div);
            }

            this.queryParams = this._parseQueryParams();
            this.checkShowMenuOnLogin();

        },
        _selectedOptionChanged: function(neo, old) {
            var menuItems = Polymer.dom(this.root).querySelectorAll('[menu-option]');
            for (var i = 0; i < menuItems.length; i++) {
                var item = menuItems[i];
                var currentItemValues = item.getAttribute("menu-option").split(',');
                if (currentItemValues.indexOf(neo) != -1) {
                    item.removeAttribute("hidden");
                } else {
                    item.setAttribute('hidden', '');
                }
            }

            var optionItems = Polymer.dom(this.root).querySelectorAll('[data-option]');
            for (var i = 0; i < optionItems.length; i++) {
                var el = optionItems[i];
                if (el.dataset.option === this.selectedOption) {
                    el.setAttribute('active', '');
                } else {
                    el.removeAttribute('active')
                }
            }
        },
        selectedOptionChanged: function() {},
        handleNeedRefresh: function() {
            console.log('need-refresh');
            if (this.$.stvHeader != null) {
                this.$.stvHeader.getUserInfo(true);
            }
        },
        handleMenuOption: function(e) {
            var menuOption = e.currentTarget;
            if (menuOption.getAttribute('login-required') == null) {
                var option = menuOption.dataset['option'];
                this.setMenu(option);
            } else if (this.$.stvHeader != null) {
                var option = e.currentTarget.dataset['option'];
                if (this.$.stvHeader.isLogged) {
                    this.setMenu(option);
                } else {
                    this.selectedOption = 'login';
                    this._lastLoggedMenu = option;
                }
            }
        },
        setMenu: function(option) {
            if (option) {
                this.set('selectedOption', option);
            }
        },
        handleMenuPanel: function(e) {
            var menuOption = e.currentTarget;
            var panel = this.$[menuOption.dataset.panel];
            if (menuOption.getAttribute('login-required') == null) {
                panel.hidden = !panel.hidden;
            } else if (this.$.stvHeader != null) {
                var panel = this.$[e.currentTarget.dataset.panel];
                if (panel == null) {
                    panel = document.querySelector(e.currentTarget.dataset.panel);
                }
                if (this.$.stvHeader.isLogged) {
                    panel.hidden = !panel.hidden;
                    if (panel.hidden) {
                        menuOption.removeAttribute('active');
                    } else {
                        menuOption.setAttribute('active', '');
                    }
                } else {
                    this.selectedOption = 'login';
                    this._lastLoggedPanel = panel;
                }

            }
        },
        handlePanelHidden: function(e) {
            var id = e.currentTarget.getAttribute('id');
            var sel = '[data-panel=' + id + ']';
            var el = Polymer.dom(this.$.menu).querySelector(sel);
            if (e.currentTarget.hidden) {
                el.removeAttribute('active');
            } else {
                el.setAttribute('active', '');
            }
        },
        _userDataChanged: function(neo, old) {
            var me = this;
            if (this.userData) {} else {
                console.log("no user data")
            }

            if (this.$.stvHeader != null) {
                if (this.$.stvHeader.isLogged) {
                    if (this._lastLoggedPanel) {
                        this._lastLoggedPanel.show();
                        this._lastLoggedPanel = null;
                    }
                    if (this._lastLoggedMenu) {
                        this.setMenu(this._lastLoggedMenu);
                        this._lastLoggedMenu = null;
                    }
                    for (var i = 0; i < this._lastLoggedTasks.length; i++) {
                        var task = this._lastLoggedTasks[i];
                        task();
                    }
                    this.set('_lastLoggedTasks', []);
                }
            }

            this.checkShowMenuOnLogin();
        },
        userDataChanged: function() {},
        checkMaintenance: function(neo) {
            var me = this;
            if (neo != null && neo !== '') {
                var currentDate = new Date();
                var split = this.maintenance.split(",");
                var startDate = Date.parse(split[0]);
                var endDate = Date.parse(split[1]);
                if (currentDate < startDate || (currentDate >= startDate && currentDate <= endDate)) {
                    var maintenance = Polymer.dom(this).querySelector('#maintenance');
                    if (maintenance == null) {
                        var maintenance = document.createElement('div');
                        maintenance.classList.add('stv-note', 'stv-note-warn');
                        maintenance.setAttribute('id', 'maintenance');
                        maintenance.style.position = 'fixed';
                        maintenance.style.left = '0';
                        maintenance.style.right = '0';
                        maintenance.style.top = '10px';
                        maintenance.style.zIndex = '10000';
                        maintenance.style.fontSize = '16px';
                        maintenance.style.width = '500px';
                        maintenance.style.margin = '0 auto';
                        maintenance.style.boxShadow = '0px 0px 6px 3px rgba(0, 0, 0, 0.30)';
                    }

                    if (currentDate < startDate) {
                        var diffMessage = stv.utils.timeDiff(split[0], split[1]);
                        var msg = ['There will be a <b>', diffMessage,
                            '</b> downtime on this site for maintenance from: <br><br> <b>',
                            new Date(startDate).toString(), '</b> to <br> <b>' + new Date(endDate).toString(), '</b><br><br>',
                            'We apologize for any inconvenience.',
                            '<br> <div style="font-size:14px;text-align:right;">Click to dimiss this message.</div>'
                        ];
                        maintenance.addEventListener('click', function() {
                            Polymer.dom(me.root).removeChild(maintenance);
                        });
                        Polymer.dom(this.root).appendChild(maintenance);
                    }

                    if (currentDate >= startDate && currentDate <= endDate) {
                        var diffMessage = stv.utils.timeDiff(currentDate, split[1]);
                        var msg = ['This site is under maintenance we will be back in: <b><br><br>',
                            diffMessage, '</b> <br><br>',
                            'We apologize for any inconvenience.',
                        ];
                        document.body.removeChild(this);
                        document.body.appendChild(maintenance);
                        document.body.style.backgroundColor = '#333';
                    }

                    maintenance.innerHTML = msg.join(' ');
                }
            }
        },
        checkShowMenuOnLogin: function() {
            if (this.$.stvHeader != null) {
                var menuButtons = this.querySelectorAll("[login-visible]");
                for (var i = 0; i < menuButtons.length; i++) {
                    var menuOption = menuButtons[i];
                    var panel = this.$[menuOption.dataset.panel];
                    if (!this.$.stvHeader.isLogged) {
                        menuOption.hidden = true;
                        if (panel != null) {
                            panel.hide();
                        }
                    } else {
                        menuOption.hidden = false;
                    }
                }
                var menuButtons = this.querySelectorAll("[login-required]");
                for (var i = 0; i < menuButtons.length; i++) {
                    var menuOption = menuButtons[i];
                    var panel = this.$[menuOption.dataset.panel];
                    if (!this.$.stvHeader.isLogged) {
                        if (panel != null) {
                            panel.hide();
                        }
                    }
                }
            }
        },
        _parseQueryParams: function() {
            var url = window.location.href;
            var queryParams = {};
            if (url.indexOf("?") >= 0) {
                var qp = url.substring(url.indexOf("?") + 1).split("&");
                for (var i = 0; i < qp.length; i++) {
                    var elem = qp[i];
                    var fields = elem.split("=");
                    if (fields.length == 1) { // key
                        queryParams[fields[0]] = "";
                    } else if (fields.length == 2) { // key=value
                        queryParams[fields[0]] = fields[1];
                    }
                }
            }
            return queryParams;
        },
        getQueryParam: function(name) {
            var url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        },
        _handleLoadJobFromQueryParam: function(jobId) {
            var me = this;
            if (jobId != null && jobId != "") {
                var stvReport = me.querySelector("stv-report");
                var stvReportParent = stv.utils.closest(stvReport, "[menu-option]");

                if (this.$.stvHeader != null && stvReportParent != null) {
                    var menuOption = stvReportParent.getAttribute("menu-option");
                    var goJob = function() {
                        SteviaManager.getJob(jobId, function(job) {
                            if (job && job.status == "DONE") {
                                stvReport.job = job;
                                me.setMenu(menuOption);
                            } else {
                                me.setMenu('home');
                            }
                        });
                    }
                    if (this.$.stvHeader.isLogged) {
                        goJob();
                    } else {
                        this.push('_lastLoggedTasks', goJob);
                        me.setMenu('login');
                    }
                }
            }
        }
    };
</script>
<dom-module id="stv-footer" assetpath="bower_components/stevia-elements/src/">
    <style>
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
            width: 100%;

            height: 100px;
            cursor: default;
            box-shadow: 0px 0px 5px 5px rgba(0, 0, 0, 0.3);
            padding-top:10px;
            text-align: center;
            margin-bottom:0px;

            background-color: var(--dark-primary-color);
            color:var(--text-primary-color);
        }
    </style>
    <template>
        <content></content>
    </template>

<script>
    Polymer({
        is: "stv-footer"
    });
</script>
</dom-module>
<dom-module id="stv-select" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
         :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            background-color: #FFF;
            height: 23px;
            cursor: pointer;
            outline: transparent solid 0px;
            border: 1px solid var(--divider-color);
        }

        #main {
            position: relative;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
        }

        #text {
            width: 100%;
            box-sizing: border-box;
            padding: 0px 5px;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            overflow: hidden;
            text-overflow: clip;
            white-space: nowrap;
        }

        #arrow {
            box-sizing: border-box;
            height: 100%;
            padding: 0px 5px;
        }

        #list {
            min-width: 100%;
            position: absolute;
            z-index: 1;
            box-sizing: border-box;
            display: none;
            left: 0;
            top: calc(100% - 1px);
            background-color: inherit;
            border: 1px solid var(--divider-color);
            box-shadow: 0px 3px 10px rgba(0, 0, 0, 0.2);
        }

         ::content stv-option {
            padding: 2px 4px;
        }

         ::content stv-option:hover {
            background-color: var(--default-primary-color);
            color: var(--text-primary-color);
        }
    </style>
    <template>
        <div id="main" class="horizontal layout center" on-click="handleClick">
            <div id="text">{{selectedOptionText}}</div>
            <div id="arrow" class="horizontal layout center"><i class="fa fa-angle-down"></i></div>
        </div>
        <div id="list" on-click="handleSelect">
            <content id="content"></content>
        </div>
    </template>
    <script>
        Polymer({
            is: 'stv-select',
            properties: {
                selectedOption: {
                    type: Object
                },
                selectedOptionText: {
                    type: String,
                },
                value: {
                    type: String,
                    notify: true,
                    observer: 'valueChanged'
                },
                tabindex: {
                    type: String,
                    reflectToAttribute: true,
                    value: '-1'
                }
            },
            listeners: {
                'blur': 'hideList',
            },
            ready: function() {
                var me = this;
                this._observer = Polymer.dom(this.$.content).observeNodes(function(info) {
                    me._checkSelected();
                });
            },
            handleClick: function(e) {
                e.stopPropagation();
                this.toggleList(e);
            },
            toggleList: function(e) {
                if (this.$.list.style.display === '') {
                    this.showList(e);
                } else {
                    this.hideList();
                }
            },
            showList: function(e) {
                // var bcr = this.$.main.getBoundingClientRect();
                // this.$.list.style.top = (bcr.top + bcr.height - 1) + 'px';
                // this.$.list.style.left = bcr.left + 'px';
                // this.$.list.style.width = bcr.width + 'px';
                this.$.list.style.display = 'block';

            },
            hideList: function() {
                this.$.list.style.display = '';
            },

            handleSelect: function(e) {
                if (e.target.tagName === 'STV-OPTION') {
                    this.select(e.target);
                    this.hideList();
                    this.fire('option-click');
                }
            },
            select: function(option, notify) {
                if (this.selectedOption !== option) {
                    this.set('selectedOption', option);
                    this.set('selectedOptionText', option.innerText);
                    this.set('value', option.value);
                    if (notify !== false) {
                        this.fire('change');
                    }
                }
            },
            valueChanged: function() {
                this._checkSelected();
            },
            _checkSelected: function() {
                var options = this.$.list.querySelectorAll('stv-option');
                if (this.value == null) {
                    if (options.length > 0) {
                        this.select(options[0], false);
                    }
                } else {
                    for (var i = 0; i < options.length; i++) {
                        var option = options[i];
                        if (option.value === this.value) {
                            this.select(option, false);
                            break;
                        }
                    }
                }
            },
            addOption: function(option) {
                Polymer.dom(this.$.list).appendChild(option);
            }
        });
    </script>
</dom-module>

<dom-module id="stv-option" assetpath="bower_components/stevia-elements/src/">
    <style>
         :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            margin-bottom: 1px;
            /*word-break: normal;break-all;*/
            /*height: 20px;*/
            /*overflow: hidden;*/
            /*text-overflow: clip;*/
        }
    </style>
    <template>
        <content></content>
    </template>
    <script>
        Polymer({
            is: 'stv-option',
            properties: {
                value: {
                    type: String,
                    reflectToAttribute: true
                },
            }
        });
    </script>
</dom-module>
<dom-module id="stv-select-box" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
         :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            border: 1px solid var(--divider-color);
            background-color: #FFF;
        }

        #box {
            position: relative;
            overflow-y: auto;
            height: 100%;
        }

         :host[enable-filter] #box {
             height: calc(100% - 22px);
        }

        .item {
            padding: 2px 5px;
            cursor: pointer;
        }

        .item:hover {
            background-color: var(--hover-color);
        }

        .item[data-checked] {
            background-color: var(--selected-color);
        }

        #input {
            display: block;
            width: 100%;
            height: 22px;
            padding-left: 25px;
            padding-right: 25px;
            border-width: 0 0 1px 0;
        }

        #icon {
            color: var(--secondary-text-color);
            position: absolute;
            top: 0;
            left: 0;
            margin-top: 3px;
        }
    </style>
    <template>
        <input hidden$="{{!enableFilter}}" id="input" class="stv" type="text" placeholder="{{placeholder}}" value="{{filterString::input}}">
        <div hidden$="{{!enableFilter}}" id="icon" class="horizontal layout center">
            <i style="margin-left:7px;" class="fa fa-search"></i>
        </div>
        <div id="box">
            <template is="dom-repeat" items="{{options}}" as="option" filter="{{computeFilter(filterString)}}">
                <div class="item flex" data-checked$="{{isSelected(selected, option)}}" on-mousedown="handleSelect">
                    <span>{{computeOptionDisplay(option)}}</span>
                </div>
            </template>
        </div>
    </template>
    <script>
        Polymer({
            is: 'stv-select-box',
            properties: {
                options: {
                    type: Array,
                    value: function() {
                        return []
                    },
                    observer: 'optionsChanged'
                },
                selected: {
                    type: Object
                },
                disableSelection: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                selectFirst: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: true
                },
                nameAttribute: {
                    type: String,
                    value: 'name'
                },
                titleAttribute: {
                    type: String,
                    value: 'title'
                },
                enableFilter: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                placeholder: {
                    type: String,
                    value: 'Filter...'
                },
                filterString: {
                    type: String
                }
            },
            computeOptionDisplay: function(option) {
                return option[this.titleAttribute];
            },
            optionsChanged: function() {
                if (this.selected != null && this.selected.name) {
                    this.selectByName(this.selected.name);
                } else {
                    this.selectByIndex(0);
                }
            },
            handleSelect: function(e) {
                if (this.disableSelection == false) {
                    this.set('selected', e.model.option);
                    this.fire('select', this.selected);
                }
            },
            isSelected: function(selected, current) {
                return selected == current;
            },
            selectByIndex: function(index) {
                if (this.disableSelection == false) {
                    if (this.options[index] != null) {
                        this.set('selected', this.options[index]);
                        this.fire('select', this.selected);
                    }
                }
            },
            selectByName: function(name) {
                var index = -1;
                for (var i = 0; i < this.options.length; i++) {
                    var option = this.options[i];
                    if (option[this.nameAttribute] == name) {
                        index = i;
                        break;
                    }
                }
                if (index > -1) {
                    this.selectByIndex(index);
                }
            },
            computeFilter: function(string) {
                var me = this;
                if (!string || string == '') {
                    return null;
                } else {
                    string = string.toLowerCase();
                    return function(item) {
                        var title = '',
                            name = ''
                        if (item[me.titleAttribute] != null) {
                            title = item[me.titleAttribute].toLowerCase();
                        }
                        if (item[me.nameAttribute] != null) {
                            name = item[me.nameAttribute].toLowerCase();
                        }
                        return (title.indexOf(string) != -1 || name.indexOf(string) != -1);
                    };
                }
            }
        });
    </script>
</dom-module>
<script>
  /**
   * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
   * coordinate the flow of resize events between "resizers" (elements that control the
   * size or hidden state of their children) and "resizables" (elements that need to be
   * notified when they are resized or un-hidden by their parents in order to take
   * action on their new measurements).
   *
   * Elements that perform measurement should add the `IronResizableBehavior` behavior to
   * their element definition and listen for the `iron-resize` event on themselves.
   * This event will be fired when they become showing after having been hidden,
   * when they are resized explicitly by another resizable, or when the window has been
   * resized.
   *
   * Note, the `iron-resize` event is non-bubbling.
   *
   * @polymerBehavior Polymer.IronResizableBehavior
   * @demo demo/index.html
   **/
  Polymer.IronResizableBehavior = {
    properties: {
      /**
       * The closest ancestor element that implements `IronResizableBehavior`.
       */
      _parentResizable: {
        type: Object,
        observer: '_parentResizableChanged'
      },

      /**
       * True if this element is currently notifying its descedant elements of
       * resize.
       */
      _notifyingDescendant: {
        type: Boolean,
        value: false
      }
    },

    listeners: {
      'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
    },

    created: function() {
      // We don't really need property effects on these, and also we want them
      // to be created before the `_parentResizable` observer fires:
      this._interestedResizables = [];
      this._boundNotifyResize = this.notifyResize.bind(this);
    },

    attached: function() {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      }
    },

    detached: function() {
      if (this._parentResizable) {
        this._parentResizable.stopResizeNotificationsFor(this);
      } else {
        window.removeEventListener('resize', this._boundNotifyResize);
      }

      this._parentResizable = null;
    },

    /**
     * Can be called to manually notify a resizable and its descendant
     * resizables of a resize change.
     */
    notifyResize: function() {
      if (!this.isAttached) {
        return;
      }

      this._interestedResizables.forEach(function(resizable) {
        if (this.resizerShouldNotify(resizable)) {
          this._notifyDescendant(resizable);
        }
      }, this);

      this._fireResize();
    },

    /**
     * Used to assign the closest resizable ancestor to this resizable
     * if the ancestor detects a request for notifications.
     */
    assignParentResizable: function(parentResizable) {
      this._parentResizable = parentResizable;
    },

    /**
     * Used to remove a resizable descendant from the list of descendants
     * that should be notified of a resize change.
     */
    stopResizeNotificationsFor: function(target) {
      var index = this._interestedResizables.indexOf(target);

      if (index > -1) {
        this._interestedResizables.splice(index, 1);
        this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
      }
    },

    /**
     * This method can be overridden to filter nested elements that should or
     * should not be notified by the current element. Return true if an element
     * should be notified, or false if it should not be notified.
     *
     * @param {HTMLElement} element A candidate descendant element that
     * implements `IronResizableBehavior`.
     * @return {boolean} True if the `element` should be notified of resize.
     */
    resizerShouldNotify: function(element) { return true; },

    _onDescendantIronResize: function(event) {
      if (this._notifyingDescendant) {
        event.stopPropagation();
        return;
      }

      // NOTE(cdata): In ShadowDOM, event retargetting makes echoing of the
      // otherwise non-bubbling event "just work." We do it manually here for
      // the case where Polymer is not using shadow roots for whatever reason:
      if (!Polymer.Settings.useShadow) {
        this._fireResize();
      }
    },

    _fireResize: function() {
      this.fire('iron-resize', null, {
        node: this,
        bubbles: false
      });
    },

    _onIronRequestResizeNotifications: function(event) {
      var target = event.path ? event.path[0] : event.target;

      if (target === this) {
        return;
      }

      if (this._interestedResizables.indexOf(target) === -1) {
        this._interestedResizables.push(target);
        this.listen(target, 'iron-resize', '_onDescendantIronResize');
      }

      target.assignParentResizable(this);
      this._notifyDescendant(target);

      event.stopPropagation();
    },

    _parentResizableChanged: function(parentResizable) {
      if (parentResizable) {
        window.removeEventListener('resize', this._boundNotifyResize);
      }
    },

    _notifyDescendant: function(descendant) {
      // NOTE(cdata): In IE10, attached is fired on children first, so it's
      // important not to notify them if the parent is not attached yet (or
      // else they will get redundantly notified when the parent attaches).
      if (!this.isAttached) {
        return;
      }

      this._notifyingDescendant = true;
      descendant.notifyResize();
      this._notifyingDescendant = false;
    }
  };
</script>

<dom-module id="stv-panel" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
         :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.4);
        }

         :host[modal] {
            z-index: 100 !important;
            position: fixed;
            box-shadow: 0px 0px 6px 3px rgba(0, 0, 0, 0.30);
        }

         :host[movable] {
            box-shadow: 0px 0px 6px 3px rgba(0, 0, 0, 0.30);
        }

         :host[fixed] {
            position: fixed;
        }

         :host[collapsed] {
            height: 32px !important;
            min-height: 32px !important;
        }

        #loading {
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            position: absolute;
            background-color: rgba(0, 0, 0, .5);
        }

        #loading-icon {
            color: white;
            font-size: 30px;
            position: absolute;
            top: calc(50% - 15px);
            left: calc(50% - 15px);
        }

        #back {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.6);
        }

        #header {
            position: relative;
            text-transform: capitalize;
            -moz-user-select: -moz-none;
            -khtml-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: var(--default-primary-color);
            color: var(--text-primary-color);
        }

         :host[light-header]>#header {
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

         :host[movable]>#header {
            cursor: move;
        }

        #header>.headeractions>* {
            box-sizing: border-box;
            padding: 2px 5px;
            border: 1px solid transparent;
            cursor: pointer;
        }

        #header>.headeractions>*[data-checked] {
            background-color: rgba(0, 0, 0, 0.20);
        }

        #header>.headeractions>*:hover {
            background-color: rgba(0, 0, 0, 0.20);
        }

        #header>.headeractions>.closable:after {
            font-family: FontAwesome;
            content: '\f00d';
        }

        #header>.headeractions>.collapsible:after {
            font-family: FontAwesome;
            content: '\f106';
        }

         :host[collapsed]>#header>.headeractions>.collapsible:after {
            font-family: FontAwesome;
            content: '\f107';
        }

        #header>.headeractions>.pin:after {
            font-family: FontAwesome;
            content: '\f08d';
        }

         :host[expandible] .headeractions>.expandible:after {
            font-family: FontAwesome;
            content: '\f065';
        }

         :host[expandible][expanded] .headeractions>.expandible:after {
            content: '\f066';
        }

        #header,
        .container,
         ::content .footer {
            position: relative;
        }

        #header,
        #footer {
            box-sizing: border-box;
            padding: 4px 5px 4px 12px;
            height: 32px;
        }

        #footer {
            position: relative;
            border-top: 1px solid var(--divider-color);
            background-color: var(--light-secondary-color);
            color: var(--primary-text-color);
        }

        #footer>div,
        #footer>div>div {
            margin-right: 2px;
            margin-left: 2px;
        }

        .container {
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
            position: relative;
            height: calc(100% - 32px);
        }

         :host[_hasfooter] .container {
            height: calc(100% - 64px);
        }

        #resizerNW {
            top: 0;
            left: 0;
            cursor: nwse-resize;
        }

        #resizerNE {
            top: 0;
            right: 0;
            cursor: nesw-resize;
        }

        #resizerSW {
            bottom: 0;
            left: 0;
            cursor: nesw-resize;
        }

        #resizerSE {
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
        }

        #resizerSE,
        #resizerSW,
        #resizerNE,
        #resizerNW {
            width: 5px;
            height: 5px;
            position: absolute;
        }
    </style>
    <template>

        <div id="back" hidden$="{{!modal}}"></div>

        <div id="header" class="header horizontal layout" on-dblclick="handleHeaderDblclick" on-mousedown="handleHeaderMouseDown" on-mouseup="handleHeaderMouseUp">
            <div class="horizontal layout flex center">
                <content select=".header"></content>
            </div>
            <div class="headeractions horizontal layout center end-justified" on-mousedown="handleActionsMouseDown">
                <div hidden$="{{!expandible}}" class="expandible" on-click="handleExpandAction"></div>
                <div hidden$="{{isPinHidden(movable,moved,fixed)}}" class="pin" on-click="handlePinAction"></div>
                <div hidden$="{{!collapsible}}" class="collapsible" on-click="handleCollapseAction"></div>
                <div hidden$="{{!closable}}" class="closable" on-click="handleCloseAction"></div>
            </div>
        </div>

        <div id="container" class="container horizontal layout" hidden$="{{isContainerHidden(collapsible, collapsed)}}">
            <content select=".container"></content>
        </div>

        <div id="footer" class="horizontal layout flex center" hidden$="{{isFooterHidden(_hasfooter, collapsible, collapsed)}}">
            <content select=".footer"></content>
        </div>

        <div id="loading" hidden$="{{!loading}}">
            <i id="loading-icon" class="fa fa-circle-o-notch fa-spin"></i>
        </div>

        <div hidden$="{{!resizable}}" id="resizerNW" data-value="nw">
        </div>
        <div hidden$="{{!resizable}}" id="resizerNE" data-value="ne">
        </div>
        <div hidden$="{{!resizable}}" id="resizerSW" data-value="sw">
        </div>
        <div hidden$="{{!resizable}}" id="resizerSE" data-value="se">
        </div>
    </template>

    <script>
        (function() {
            var lastWindow_;
            StvPanel = Polymer({
                is: "stv-panel",
                behaviors: [Polymer.IronResizableBehavior],
                properties: {
                    fixed: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    closable: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    collapsible: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    collapsed: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    movable: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    expandible: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    expanded: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    resizable: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    modal: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    constraint: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    moved: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    loading: {
                        type: Boolean,
                        value: false
                    },
                    lightHeader: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    hidden: {
                        type: Boolean,
                        reflectToAttribute: true,
                        observer: 'hiddenChanged'
                    },
                    _hasfooter: {
                        type: Boolean,
                        reflectToAttribute: true,
                        value: false
                    },
                    _firstHidden: {
                        type: Boolean,
                        value: false
                    }
                },
                listeners: {
                    'mousedown': '_updateLastWindow',
                    'iron-resize': 'handleResize',
                    'scroll': 'handleScroll'
                },
                hostAttributes: {
                    'class': 'vertical layout flex'
                },
                handleScroll: function() {
                    e.stopPropagation();
                },
                handleResize: function() {

                },
                ready: function() {
                    var me = this;
                    this.async(function() {
                        if (this.fixed) {
                            this._center();
                        }
                    }, 50);
                    this._hasfooter = this.$.footer.childElementCount > 0;

                    var child = this.$.container.querySelector('.container');
                    if (child != null) {
                        child._parentPanel = this;
                    }

                    //resizer
                    if (this.resizable != null && this.resizable == true) {
                        var resizerNW = this.$.resizerNW;
                        var resizerNE = this.$.resizerNE;
                        var resizerSW = this.$.resizerSW;
                        var resizerSE = this.$.resizerSE;
                        var startX, startWidth, startY, startHeight, mode, topStart, leftStart, startMinWidth, startMinHeight;

                        function initDrag(e) {
                            e.stopPropagation();
                            document.body.classList.add('stv-nosel');
                            mode = e.currentTarget.dataset.value;
                            startX = e.clientX;
                            startY = e.clientY;
                            topStart = parseInt(document.defaultView.getComputedStyle(me).top, 10);
                            leftStart = parseInt(document.defaultView.getComputedStyle(me).left, 10);
                            startWidth = parseInt(document.defaultView.getComputedStyle(me).width, 10);
                            startHeight = parseInt(document.defaultView.getComputedStyle(me).height, 10);
                            startMinWidth = parseInt(document.defaultView.getComputedStyle(me).minWidth, 10);
                            startMinHeight = parseInt(document.defaultView.getComputedStyle(me).minHeight, 10);

                            document.documentElement.addEventListener('mousemove', doDrag, false);
                            document.documentElement.addEventListener('mouseup', stopDrag, false);
                        }

                        function doDrag(e) {
                            if (mode == "se") {
                                me.style.width = (startWidth + e.clientX - startX) + 'px';
                                me.style.height = (startHeight + e.clientY - startY) + 'px';
                            } else if (mode == "ne") {
                                var currentHeight = (startHeight - (e.clientY - startY));
                                if (currentHeight > startMinHeight) {
                                    me.style.height = currentHeight + 'px';
                                    me.style.width = (startWidth + e.clientX - startX) + 'px';
                                    me.style.top = (topStart + e.clientY - startY) + 'px';
                                }
                            } else if (mode == "nw") {
                                var currentHeight = (startHeight - (e.clientY - startY));
                                var currentWidth = (startWidth - (e.clientX - startX));
                                if (currentHeight > startMinHeight) {
                                    me.style.width = currentWidth + 'px';
                                    me.style.height = currentHeight + 'px';
                                    me.style.top = (topStart + (e.clientY - startY)) + 'px';
                                }
                                if (currentWidth > startMinWidth) {
                                    me.style.width = currentWidth + 'px';
                                    me.style.height = currentHeight + 'px';
                                    me.style.left = (leftStart + (e.clientX - startX)) + 'px';
                                }
                            } else if (mode == "sw") {
                                var currentWidth = (startWidth - (e.clientX - startX));
                                if (currentWidth > startMinWidth) {
                                    me.style.height = (startHeight + e.clientY - startY) + 'px';
                                    me.style.width = currentWidth + 'px';
                                    me.style.left = (leftStart + e.clientX - startX) + 'px';
                                }
                            }
                        }

                        function stopDrag(e) {
                            document.documentElement.removeEventListener('mousemove', doDrag, false);
                            document.documentElement.removeEventListener('mouseup', stopDrag, false);
                            document.body.classList.remove('stv-nosel');

                            me.notifyResize();
                        }

                        resizerNW.addEventListener('mousedown', initDrag, false);
                        resizerNE.addEventListener('mousedown', initDrag, false);
                        resizerSW.addEventListener('mousedown', initDrag, false);
                        resizerSE.addEventListener('mousedown', initDrag, false);
                    }
                },
                hiddenChanged: function(neo, old) {
                    // check if is not hidden
                    if (neo == false) {
                        if (this.modal) {
                            this._center();
                        }
                        if (this.fixed && !this._firstHidden) {
                            this._center();
                        }
                        this._firstHidden = true;
                        this._updateLastWindow();
                    }
                    this.fire('hidden', this.hidden);
                },
                show: function() {
                    this.hidden = false;
                    this.hiddenChanged(false);
                },
                hide: function() {
                    this.hidden = true;
                    this.hiddenChanged(true);
                },
                isContainerHidden: function(collapsible, collapsed) {
                    if (collapsible && collapsed) {
                        return true;
                    }
                    return false;
                },
                isFooterHidden: function(_hasfooter, collapsible, collapsed) {
                    if (_hasfooter) {
                        if (collapsible && collapsed && _hasfooter) {
                            return true;
                        } else {
                            return false
                        }
                    } else {
                        return true;
                    }
                },
                isPinHidden: function(movable, moved, fixed) {
                    if (fixed) {
                        return true;
                    }
                    if (this.modal) {
                        return true;
                    }
                    if (!movable) {
                        return true;
                    }
                    return !moved;
                },
                setLoading: function(loading) {
                    this.loading = loading;
                },
                /* */
                toggleCollapse: function() {
                    if (this.collapsible) {
                        this.collapsed = !this.collapsed;
                    }
                },
                handleHeaderDblclick: function(e) {
                    this.toggleCollapse();
                },
                handleCollapseAction: function(e) {
                    this.toggleCollapse();
                },
                handleCloseAction: function() {
                    this.hidden = true;
                    this.fire('close');
                },
                handlePinAction: function(e) {
                    this.style.position = '';
                    this.style.left = '';
                    this.style.top = '';
                    this.style["z-index"] = '2';

                    this.moved = false;
                },
                handleExpandAction: function(e) {
                    e.stopPropagation();
                    var currentZIndex = -1; //no z-index set;
                    if (!isNaN(this.style['z-index'])) {
                        currentZIndex = parseInt(this.style['z-index']);
                    }
                    if (this.expandible) {
                        this.expanded = !this.expanded;
                        if (this.expanded) {
                            this.style.position = 'fixed';
                            this.style.width = '100%';
                            this.style.height = '100%';
                            this.style.top = '';
                            this.style.left = '';
                            this.style['z-index'] = currentZIndex + 100;
                        } else {
                            this.style.width = '';
                            this.style.height = '';
                            this.style.position = '';
                            this.style.top = '';
                            this.style.left = '';
                            if (currentZIndex >= -1) {
                                this.style['z-index'] = currentZIndex - 100;
                            } else {
                                this.style['z-index'] = '';
                            }
                            this._center();
                        }
                        this.notifyResize();
                    }
                    this.fire('expand');
                },

                handleActionsMouseDown: function(e) {
                    e.stopPropagation();
                },
                handleHeaderMouseDown: function(e) {
                    if (this.movable && !this.expanded) {
                        document.body.classList.add('stv-nosel');
                        var me = this;
                        var bcr = this.$.header.getBoundingClientRect();

                        this.headerOffsetX = e.clientX - bcr.left;
                        this.headerOffsetY = e.clientY - bcr.top;

                        window.removeEventListener('mousemove', this.mouseMoveHandler, true);

                        this.mouseMoveHandler = function(moveEvent) {
                            me.handleMouseMove(moveEvent);
                        };
                        window.addEventListener('mousemove', this.mouseMoveHandler, true);
                    }
                },
                handleHeaderMouseUp: function() {
                    if (this.movable) {
                        window.removeEventListener('mousemove', this.mouseMoveHandler, true);
                        document.body.classList.remove('stv-nosel');
                    }
                    // this._updateLastWindow();
                },
                handleMouseMove: function(e) {
                    if (this.movable) {
                        this.moved = true;
                        this.style.position = 'fixed';
                        var left = e.clientX - this.headerOffsetX;
                        var top = e.clientY - this.headerOffsetY;
                        if (this.constraint) {
                            var bcr = this.getBoundingClientRect();
                            var bcrHeader = this.$.header.getBoundingClientRect();
                            var rightLimit = window.innerWidth - bcr.width;
                            var bottomLimit = window.innerHeight - bcrHeader.height;
                            if (left > 0 && left < rightLimit) {
                                this.style.left = left + 'px';
                            }
                            if (top > 0 && top < bottomLimit) {
                                this.style.top = top + 'px';
                            }
                        } else {
                            this.style.left = left + 'px';
                            this.style.top = top + 'px';
                        }

                    }
                },

                /** **/
                _center: function() {
                    var bcr = this.getBoundingClientRect();
                    this.style.left = (window.innerWidth / 2 - bcr.width / 2) + 'px';
                    this.style.top = (window.innerHeight / 2 - bcr.height / 2) + 'px';
                },
                _updateLastWindow: function() {
                    if (lastWindow_) {
                        if (!lastWindow_.expanded && lastWindow_.movable) {
                            lastWindow_.style["z-index"] = '1';
                        }
                    }
                    lastWindow_ = this;
                    if (lastWindow_) {
                        if (!lastWindow_.expanded && lastWindow_.movable) {
                            lastWindow_.style["z-index"] = '2';
                        }
                    }
                }

            });

        })();
    </script>
</dom-module>
<dom-module id="stv-dropdown" assetpath="bower_components/stevia-elements/src/dropdown/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
            /*margin-right: 5px;*/
            /*margin-left: 5px;*/
            /*border: 1px solid #afafaf;*/
            color: var(--primary-text-color);
        }

        :host::content ul a:hover {
            text-decoration: none;
        }

        :host::content > [data-button] {
            /*padding: 5px;*/
            height: 100%;
            cursor: pointer;
            outline: transparent solid 0px;
        }

        :host::content > [data-button]:hover {
            background-color: var(--hover-color);
        }

        :host::content ul {
            box-sizing: border-box;
            display: none;
            position: absolute;
            list-style: none;
            text-decoration: none;
            z-index: 100000;
            border: 1px solid var(--divider-color);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
            min-width: 200px;
            padding: 0;
            box-shadow: 4px 4px 4px rgba(0, 0, 0, 0.2);
            text-align: left;
            cursor: pointer;
            text-transform: none;
            margin: 1px 0 0 0;
            /*transition: all 0.25s;*/
        }

        :host::content ul {
            left: 0;
            top: 100%;
        }

        :host::content ul[data-upward] {
            top: inherit;
            bottom: 100%;
            margin-bottom: 2px;
            left: 0;
        }

        :host::content ul ul {
            top: 0px;
            left: 100%;
        }

        :host::content ul li {
            position: relative;
            text-align: left;
            padding: 3px 30px 4px 10px;
            white-space: nowrap;
        }

        :host::content ul li[data-divider] {
            height: 1px;
            margin: 3px 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--divider-color);
        }

        :host::content ul li[data-sub]:after {
            font-family: 'FontAwesome';
            content: '\f105';
            /* > */
            /*content:'\f0da';*/
            position: absolute;
            right: 10px;
            top: 4px;
        }

        :host::content ul li.active,
        :host::content ul li:active {
            background-color: #DEDEDE;
        }

        :host::content ul li:hover {
            background-color: var(--dark-button-color);
            color: var(--text-primary-color);
        }

        :host::content ul li[data-text]:hover {
            background-color: inherit !important;
            color: inherit !important;
        }

        :host::content ul li[data-divider]:hover {
            background-color: var(--divider-color) !important;
        }

        :host::content > ul li:hover > ul {
            display: block;
        }
        /**/
        /* dark */
        /**/

        :host[dark] {
            /*margin: 0 10px;*/
            color: var(--text-primary-color);
        }

        :host[dark]::content > [data-button]:hover {
            background-color: transparent;
        }

        :host[dark]::content > [data-button]:hover > * {
            color: var(--accent-color);
        }
        /*:host::content > [data-menu] {
            margin-top: 10px;
            padding:5px;
        }*/

        :host[dark]::content ul {
            background-color: var(--dark-primary-color);
            color: var(--text-primary-color);
            border-color: var(--default-primary-color);
        }

        :host[dark]::content ul li[data-divider] {
            background-color: var(--default-primary-color);
        }

        :host[dark]::content ul li[data-divider]:hover {
            background-color: var(--default-primary-color) !important;
        }
    </style>
    <template>
        <content select="[data-button]" on-click="handleShowMenu"></content>
        <content select="[data-menu]"></content>
    </template>

    <script>
        Polymer({
            is: "stv-dropdown",
            properties: {
                button: {
                    type: Object
                },
                menu: {
                    type: Object
                }
            },
            listeners: {
                click: 'clickHandler'
            },
            ready: function() {
                var me = this;
                this.button = this.children[0];
                this.menu = this.children[1];

                document.body.addEventListener('click', function(e) {
                    if (!me.contains(e.target)) {
                        me.hideMenu();
                    }
                });
            },
            clickHandler: function(e) {
                // e.stopPropagation();
                if (this.button != null) {
                    this.handleShowMenu(e);
                };
                if (this.menu.contains(e.target)) {
                    this.async(function() {
                        this.hideMenu();
                    }, 100);
                }
            },
            handleShowMenu: function(e) {
                this.toggleMenu();
            },
            toggleMenu: function() {
                if (this.isMenuHidden()) {
                    this.showMenu();
                } else {
                    this.hideMenu();
                }
            },
            isMenuHidden: function() {
                if (this.menu.style.display != "block") {
                    return true;
                } else {
                    return false;
                }
            },
            hideMenu: function() {
                this.menu.style.display = "none";
            },
            showMenu: function() {
                this.menu.style.display = "block";
                this._getPosition();
            },
            _getPosition: function() {
                var bcrButton = this.button.getBoundingClientRect();
                var bcrMenu = this.menu.getBoundingClientRect();
                var windowHeight = window.innerHeight;
                var windowWidth = window.innerWidth;

                // this.menu.style.top = (bcrButton.bottom) + 'px';
                // this.menu.style.left = (bcrButton.left) + 'px';

                var t;
                var l;
                if ((bcrButton.bottom + bcrMenu.height) > window.innerHeight) {
                    t = (bcrMenu.height - bcrButton.height) + 'px';
                }
                if ((bcrButton.right + bcrMenu.width) > window.innerWidth) {
                    l = -(bcrMenu.width - bcrButton.width) + 'px';
                }
                this.menu.style.top = t;
                this.menu.style.left = l;

            }
        })
    </script>
</dom-module>


<style>
  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }
</style>

<style is="custom-style">
  :root {

    --layout: {
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
    };

    --layout-inline: {
      display: -ms-inline-flexbox;
      display: -webkit-inline-flex;
      display: inline-flex;
    };

    --layout-horizontal: {
      @apply(--layout);

      -ms-flex-direction: row;
      -webkit-flex-direction: row;
      flex-direction: row;
    };

    --layout-horizontal-reverse: {
      @apply(--layout);

      -ms-flex-direction: row-reverse;
      -webkit-flex-direction: row-reverse;
      flex-direction: row-reverse;
    };

    --layout-vertical: {
      @apply(--layout);

      -ms-flex-direction: column;
      -webkit-flex-direction: column;
      flex-direction: column;
    };

    --layout-vertical-reverse: {
      @apply(--layout);

      -ms-flex-direction: column-reverse;
      -webkit-flex-direction: column-reverse;
      flex-direction: column-reverse;
    };

    --layout-wrap: {
      -ms-flex-wrap: wrap;
      -webkit-flex-wrap: wrap;
      flex-wrap: wrap;
    };

    --layout-wrap-reverse: {
      -ms-flex-wrap: wrap-reverse;
      -webkit-flex-wrap: wrap-reverse;
      flex-wrap: wrap-reverse;
    };

    --layout-flex-auto: {
      -ms-flex: 1 1 auto;
      -webkit-flex: 1 1 auto;
      flex: 1 1 auto;
    };

    --layout-flex-none: {
      -ms-flex: none;
      -webkit-flex: none;
      flex: none;
    };

    --layout-flex: {
      -ms-flex: 1 1 0.000000001px;
      -webkit-flex: 1;
      flex: 1;
      -webkit-flex-basis: 0.000000001px;
      flex-basis: 0.000000001px;
    };

    --layout-flex-2: {
      -ms-flex: 2;
      -webkit-flex: 2;
      flex: 2;
    };

    --layout-flex-3: {
      -ms-flex: 3;
      -webkit-flex: 3;
      flex: 3;
    };

    --layout-flex-4: {
      -ms-flex: 4;
      -webkit-flex: 4;
      flex: 4;
    };

    --layout-flex-5: {
      -ms-flex: 5;
      -webkit-flex: 5;
      flex: 5;
    };

    --layout-flex-6: {
      -ms-flex: 6;
      -webkit-flex: 6;
      flex: 6;
    };

    --layout-flex-7: {
      -ms-flex: 7;
      -webkit-flex: 7;
      flex: 7;
    };

    --layout-flex-8: {
      -ms-flex: 8;
      -webkit-flex: 8;
      flex: 8;
    };

    --layout-flex-9: {
      -ms-flex: 9;
      -webkit-flex: 9;
      flex: 9;
    };

    --layout-flex-10: {
      -ms-flex: 10;
      -webkit-flex: 10;
      flex: 10;
    };

    --layout-flex-11: {
      -ms-flex: 11;
      -webkit-flex: 11;
      flex: 11;
    };

    --layout-flex-12: {
      -ms-flex: 12;
      -webkit-flex: 12;
      flex: 12;
    };

    /* alignment in cross axis */

    --layout-start: {
      -ms-flex-align: start;
      -webkit-align-items: flex-start;
      align-items: flex-start;
    };

    --layout-center: {
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
    };

    --layout-end: {
      -ms-flex-align: end;
      -webkit-align-items: flex-end;
      align-items: flex-end;
    };

    --layout-baseline: {
      -ms-flex-align: baseline;
      -webkit-align-items: baseline;
      align-items: baseline;
    };

    /* alignment in main axis */

    --layout-start-justified: {
      -ms-flex-pack: start;
      -webkit-justify-content: flex-start;
      justify-content: flex-start;
    };

    --layout-center-justified: {
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    --layout-end-justified: {
      -ms-flex-pack: end;
      -webkit-justify-content: flex-end;
      justify-content: flex-end;
    };

    --layout-around-justified: {
      -ms-flex-pack: distribute;
      -webkit-justify-content: space-around;
      justify-content: space-around;
    };

    --layout-justified: {
      -ms-flex-pack: justify;
      -webkit-justify-content: space-between;
      justify-content: space-between;
    };

    --layout-center-center: {
      @apply(--layout-center);
      @apply(--layout-center-justified);
    };

    /* self alignment */

    --layout-self-start: {
      -ms-align-self: flex-start;
      -webkit-align-self: flex-start;
      align-self: flex-start;
    };

    --layout-self-center: {
      -ms-align-self: center;
      -webkit-align-self: center;
      align-self: center;
    };

    --layout-self-end: {
      -ms-align-self: flex-end;
      -webkit-align-self: flex-end;
      align-self: flex-end;
    };

    --layout-self-stretch: {
      -ms-align-self: stretch;
      -webkit-align-self: stretch;
      align-self: stretch;
    };

    --layout-self-baseline: {
      -ms-align-self: baseline;
      -webkit-align-self: baseline;
      align-self: baseline;
    };

    /* multi-line alignment in main axis */

    --layout-start-aligned: {
      -ms-flex-line-pack: start;  /* IE10 */
      -ms-align-content: flex-start;
      -webkit-align-content: flex-start;
      align-content: flex-start;
    };

    --layout-end-aligned: {
      -ms-flex-line-pack: end;  /* IE10 */
      -ms-align-content: flex-end;
      -webkit-align-content: flex-end;
      align-content: flex-end;
    };

    --layout-center-aligned: {
      -ms-flex-line-pack: center;  /* IE10 */
      -ms-align-content: center;
      -webkit-align-content: center;
      align-content: center;
    };

    --layout-between-aligned: {
      -ms-flex-line-pack: justify;  /* IE10 */
      -ms-align-content: space-between;
      -webkit-align-content: space-between;
      align-content: space-between;
    };

    --layout-around-aligned: {
      -ms-flex-line-pack: distribute;  /* IE10 */
      -ms-align-content: space-around;
      -webkit-align-content: space-around;
      align-content: space-around;
    };

    /*******************************
              Other Layout
    *******************************/

    --layout-block: {
      display: block;
    };

    --layout-invisible: {
      visibility: hidden !important;
    };

    --layout-relative: {
      position: relative;
    };

    --layout-fit: {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-scroll: {
      -webkit-overflow-scrolling: touch;
      overflow: auto;
    };

    --layout-fullbleed: {
      margin: 0;
      height: 100vh;
    };

    /* fixed position */

    --layout-fixed-top: {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
    };

    --layout-fixed-right: {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
    };

    --layout-fixed-bottom: {
      position: fixed;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-fixed-left: {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
    };

  }

</style>

<dom-module id="stv-dialog" assetpath="bower_components/stevia-elements/src/stv-dialog/">
    <template>
        <style>
            #message {
                /*font-weight: bold;*/
                text-align: center;
                font-size: 1.15em;
            }

            #title {
                box-sizing: border-box;
                font-size: 1.2em;
                text-transform: capitalize;
                padding: 7px 10px;
                background-color: #444;
                color: #fff;
            }

            #content {
                box-sizing: border-box;
                background-color: var(--modal-window-background, rgb(255, 255, 255));
                padding: 10px 15px;
                @apply(--layout-flex);
            }

            .blocking-div {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 1001;
                background-color: rgba(0, 0, 0, 0.7);
            }

            .modal-window {
                box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
                position: absolute;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 1002;
                @apply(--modal-window-style);
                @apply(--layout-vertical);
                min-height: 200px;
                width: 350px;
            }

            .buttons {
                @apply(--layout-horizontal);
                @apply(--layout-end-justified);
                padding: 5px;
                background-color: #eee;
                /*height: 40px;*/
            }

            .buttons>div,
            input {
                font-size: 1.1em;
                display: block;
                position: relative;
                outline: transparent solid 0px;
                box-sizing: border-box;
                border: 1px solid rgba(0, 0, 0, 0.3);
                padding: 4px 7px;
                background-color: #ffffff;
                font-family: inherit;
                color: inherit;
                cursor: pointer;
                box-shadow: 2px 2px 3px 0px rgba(0, 0, 0, 0.1);
                transition: background-color 0.3s;
                @apply(--buttons-style);
                margin: 0 5px;
                width: 100px;
                text-align: center;
            }

            .buttons>div:hover {
                background-color: #f8f8f8;
                box-shadow: 2px 2px 3px 0px rgba(0, 0, 0, 0.3);
            }

            .buttons>div:active {
                background-color: #eeeeee;
            }

            #ok {
                background-color: #188ead !important;
                color: var(--text-primary-color) !important;
            }

            #ok:hover {
                background-color: #20aed4 !important;
            }

            #cancel {
                background-color: #bd1a1a !important;
                color: var(--text-primary-color) !important;
            }

            #cancel:hover {
                background-color: #db1e1e !important;
            }

            .input-wrapper {
                display: block;
                width: 100%;
                position: relative;
                box-sizing: border-box;
                padding: 10px 0;
            }

            input {
                width: 100%;
            }
        </style>
        <div class="blocking-div">
            <div class="modal-window">
                <div id="title">{{_mode}}</div>
                <div id="content">
                    <div id="message">
                        {{message}}
                    </div>
                    <div class="input-wrapper">
                        <input type="text" id="text" hidden="" value$="{{inputValue}}">
                    </div>
                </div>
                <div id="buttonsHolder" class="buttons">
                    <div id="cancel" on-click="_handleCancel" hidden="">Cancel</div>
                    <div id="ok" on-click="_handleOk"></div>
                </div>
            </div>
        </div>

    </template>
    <script>
        StvDialog = Polymer({
            is: "stv-dialog",

            properties: {

                hidden: {
                    type: Boolean,
                    reflectOnAttribute: true
                },

                /**
                 * The type of dialog box to be displayed: "confirm", "alert" or "prompt"
                 */
                _mode: {
                    type: String
                },

                _hasParent: Boolean
            },

            ready: function() {
                this.hidden = true;
            },

            /**
             * Holder for the passed **callback** when calling confirm, alert or prompt functions
             */
            _callback: undefined,

            /**
             * Calls to _executeCb passing true
             */
            _handleOk: function() {
                this._executeCb(true);
            },

            /**
             * Calls to _executeCb passing false
             */
            _handleCancel: function() {
                this._executeCb(false);
            },

            /** Executes _callback passing to it the user response as a boolean.  If _mode === "prompt" it
             * passes the input text as well to _callback. Then it sets _callback to undefined and hides the dialog box.
             *
             * @param userResponse {boolean}
             */
            _executeCb: function(userResponse) {
                if (this._callback !== undefined) {
                    if (this._mode === "prompt") {
                        this._callback(userResponse, this.$.text.value);
                    } else {
                        this._callback(userResponse);
                    }
                }

                this._callback = undefined;
                this._closeDialog();
            },

            /**
             * Sets the message inside the confirm button and the elements needed according to **_mode**.
             *
             * @param {string} confirmBtnMessage The message that will be displayed inside the ok button
             */
            _setElement: function(confirmBtnMessage) {
                this.$.ok.textContent = confirmBtnMessage;
                if (this._mode === "prompt") {
                    this.$.text.removeAttribute("hidden");
                    //TODO: Fix -> The user needs to press enter for the focus to work.
                    this.$.text.focus();
                    this.$.cancel.removeAttribute("hidden");
                } else {
                    this.$.ok.focus();
                    if (this._mode === "confirm") {
                        this.$.cancel.removeAttribute("hidden");
                    }
                }

            },

            /**
             * Resets all the element light DOM to default values
             */
            _closeDialog: function() {
                this.$.text.setAttribute("hidden", true);
                this.$.cancel.setAttribute("hidden", true);
                this.$.text.value = "";
                this.hidden = true;

                if (this._hasParent === false) {
                    document.body.removeChild(this);
                }
            },

            /**
             * Shows an confirm-like dialog to the user.
             *
             * @param {string} msg Message to be displayed in the dialog box
             * @param {function} cb
             */
            confirm: function(msg, cb) {
                if (this.parentElement == null) {
                    this._hasParent = false;
                    document.body.appendChild(this)
                }
                this._mode = "confirm";
                this._setElement("OK");
                this.message = msg;
                this.hidden = false;
                this._callback = cb;
            },

            /**
             * Shows an alert-like dialog to the user.
             *
             * @param {string} msg Message to be displayed in the dialog box
             * @param {function} cb
             */
            alert: function(msg, cb) {
                if (this.parentElement == null) {
                    this._hasParent = false;
                    document.body.appendChild(this)
                }
                this._mode = "alert";
                this._setElement("OK");
                this.message = msg;
                this.hidden = false;
                this._callback = cb;
            },

            /**
             * Shows an prompt-like dialog. Additionally to the user's response, the user's input will be passed as
             * second parameter to the cb.
             *
             * @param {string} msg Message to be displayed in the dialog box
             * @param {function} cb
             */
            prompt: function(msg, cb) {
                if (this.parentElement == null) {
                    this._hasParent = false;
                    document.body.appendChild(this)
                }
                this._mode = "prompt";
                this._setElement("OK");
                this.message = msg;
                this.hidden = false;
                this._callback = cb;
            }
        })
    </script>
</dom-module>
<dom-module id="stv-feedback" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
         :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        #emailPanel {
            width: 500px;
            /*height: 500px;*/
            min-width: 500px;
            /*min-height: 500px;*/
        }

        #emailContent {
            padding: 20px;
        }

        .send {
            width: 100px;
            margin-top: 20px;
        }

        textarea {
            box-sizing: border-box;
            width: 100%;
            height: 300px;
            resize: none;
        }
    </style>
    <template>
        <stv-panel id="emailPanel" modal="" fixed="" closable="" on-close="handleFeedback">
            <div class="header">
                <i class="fa fa-envelope-o"></i> Send an email
            </div>
            <div id="emailContent" class="container flex">
                <div class="horizontal layout">
                    <div class="flex">
                        <label class="stv" for="">Subject:</label>
                        <input class="stv" type="text" value="{{subject::input}}">
                    </div>
                    <div style="margin-left:15px;">
                        <label class="data" for="">Type:</label>
                        <stv-select id="emailType" style="width:150px; margin-top:5px">
                            <stv-option value="suggest">Suggest</stv-option>
                            <stv-option value="question">Question</stv-option>
                            <stv-option value="error">Error</stv-option>
                        </stv-select>
                    </div>
                </div>
                <br>
                <label class="stv" for="">Text:</label>
                <textarea class="stv flex" name="" id="" cols="30" rows="10" value="{{text::input}}" required=""></textarea>
                <br>
                <div class="horizontal layout center end-justified">
                    <div id="Sending" hidden$="{{!sending}}">
                        <i class="fa fa-circle-o-notch fa-spin"></i> Sending...
                    </div>
                    <div class="stv-btn stv-btn-shdw stv-btn-big" on-click="handleSendEmail">&nbsp; Send</div>
                </div>
            </div>
        </stv-panel>
    </template>

    <script>
        Polymer({
            is: "stv-feedback",
            properties: {
                subject: {
                    type: String,
                    value: ""
                },
                text: {
                    type: String,
                    value: ""
                },
                sending: {
                    type: Boolean,
                    value: false
                },
                hidden: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true,
                    observer: 'hiddenChanged'
                }
            },
            hiddenChanged: function() {
                this.$.emailPanel._center();
            },
            handleSendEmail: function(e) {
                e.stopPropagation();
                var me = this;
                var subject = this.subject;
                var text = this.text.trim();
                var type = this.$.emailType.selectedOption.value;

                if (text != null && text != "") {
                    this.sending = true;
                    SteviaManager.users.feedback({
                        query: {
                            subject: subject,
                            type: type,
                            text: text
                        },
                        request: {
                            success: function(response) {
                                if (response.response[0].error == null) {
                                    me.fire('feedbackend');
                                    new StvDialog().alert(response.response[0].results[0]);
                                    me.set('text', '');
                                } else {
                                    new StvDialog().alert('Sorry! There was a problem, try again later');
                                }
                                me.sending = false;
                            },
                            error: function() {
                                new StvDialog().alert('Server error, try again later');
                                me.sending = false;
                            }
                        }
                    });
                }
            },
            handleFeedback: function(e) {
                this.fire('feedbackend');
                this.$.emailPanel.hidden = false;
                this.$.emailPanel.style = "top: 60px;left: 500px";
            }
        })
    </script>
</dom-module>
<script>STV_LAUNCHER_APPS = [{
        "name": "VARIANT",
        "shortDescription": "Fast and accurate functional characterization of variants in VCF files",
        "link": "http://variant.bioinfo.cipf.es/",
        "icon": ""
    },

    {
        "name": "CellBase",
        "shortDescription": "RESTful Web Services for retrieving releant biological information",
        "link": "http://docs.bioinfo.cipf.es/projects/cellbase",
        "icon": ""
    },

    {
        "name": "GenomeMaps",
        "shortDescription": "Our highly efficient next generation genome viewer (used by the ICGC)",
        "link": "http://www.genomemaps.org/",
        "icon": ""
    },

    {
        "name": "BiERapp",
        "shortDescription": "Variant/gene prioritzation tool (from VCF to candidates)",
        "link": "http://bierapp.babelomics.org/",
        "icon": ""
    },

    {
        "name": "TEAM",
        "shortDescription": "",
        "link": "http://team.babelomics.org/",
        "icon": ""
    },

    {
        "name": "RENATO",
        "shortDescription": "",
        "link": "http://renato.bioinfo.cipf.es/",
        "icon": ""
    },

    {
        "name": "PATHiWays",
        "shortDescription": "Inferring the functional effect of gene expression changes in signaling pathways",
        "link": "http://pathiways.babelomics.org/",
        "icon": ""
    }, {
        "name": "PATHiVar",
        "shortDescription": "Assessing the impact of mutations found in next generation sequencing data over human signaling pathways",
        "link": "http://pathivar.babelomics.org/",
        "icon": "http://pathivar.babelomics.org/images/pathiways-logo.svg"
    }, {
        "name": "Babelomics",
        "shortDescription": "A program suite for advanced functional genomic data analysis",
        "link": "http://www.babelomics.org/",
        "icon": "http://bioinfo.cipf.es/apps-beta/babelomics/produccion/images/logoBabelomics_negative.svg"
    }, {
        "name": "Phylemon",
        "shortDescription": "Evolution, phylogenetics, phylogenomics",
        "link": "http://phylemon.bioinfo.cipf.es/",
        "icon": "http://phylemon.bioinfo.cipf.es/css/phylemon_title.png"
    }
];
</script>


<dom-module id="stv-launcher" assetpath="bower_components/stevia-elements/src/stv-launcher/">
    <template>
        <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
            :host {
                font-size: 16px;
            }

            #dropdown {
                background-color: var(--dark-primary-color, #2F2F2F);
                position: absolute;
                margin-top: 20px;
                box-shadow: 0px 0px 10px 5px rgba(0, 0, 0, 0.30);
                opacity: 0;
                padding: 10px 10px 10px 10px;
                width: 460px;
                max-height: 70vh;
                overflow-y: auto;
                z-index: 1000;
            }

            .button {
                margin: 4px 4px 4px 4px;
                color: white;
                text-align: center;
                border: transparent solid 1px;
                width: 95px;
                height: 95px;
            }

            .button > a {
                color: inherit;
                text-decoration: none;
            }

            .button:hover {
                border: solid 1px;
                border-color: var(border-color, white);
            }

            .icon {
                max-height: 64px;
                max-width: 64px;
            }

            .icon.fa {
                color: white;
                font-size: 3em;
            }
        </style>
        <content id="icon"></content>
        <div id="dropdown" hidden="" class="layout horizontal wrap around-justified">
            <template is="dom-repeat" items="{{_applicationsList}}">
                <a href="{{item.link}}" target="_blank" class="button layout vertical around-justified center">
                    <template is="dom-if" if="[[_hasIconUrl(item.icon)]]">
                        <img src="{{item.icon}}" alt="" class="icon">
                    </template>
                    <template is="dom-if" if="[[!_hasIconUrl(item.icon)]]">
                        
                        <svg class="icon" viewBox="0 0 1000 1000" sodipodi:docname="default.svg">
                            <path style="stroke:white" d="M500,10C229.4,10,10,229.4,10,500s219.4,490,490,490s490-219.4,490-490S770.6,10,500,10z M500,921.2C267.4,921.2,78.8,732.6,78.8,500C78.8,267.4,267.4,78.8,500,78.8c232.6,0,421.2,188.6,421.2,421.2S732.6,921.2,500,921.2z" id="path8"></path>
                            <path d="M391.8,681.7c0,0-7.7,7.8-11.3,11.5c-12.5,12.7-12.5,33.3,0,46c8.9,9,21.5,11.3,32.7,7.5l42-37.3l-45.3-46L391.8,681.7z" id="path10"></path>
                            <path d="M573.9,399.1l-45.3,46l25.5,25.9c12.5,12.7,12.5,33.3,0,46l-64.8,65.7l-66.8-67.9c-12.4-12.6-12.4-33,0-45.6l64.9-65.9l0.5,0.5l45.3-46l-0.5-0.5l50.8-51.6c12.4-12.6,12.4-33,0-45.6s-32.5-12.6-44.9,0l-50.8,51.6l-50.8-51.5c-12.5-12.7-32.8-12.7-45.3,0c-12.5,12.7-12.5,33.3,0,46l50.8,51.6l-87.3,88.7c-24.8,25.2-24.8,66,0,91.2l194.6,197.7l12.5,7.5c11,3.7,23.6,1.4,32.4-7.5c12.4-12.6,12.4-33,0-45.6c-3.6-3.7-11.2-11.4-11.2-11.4l-48.9-49.6l87.5-88.7c25-25.4,25-66.5,0-91.9L573.9,399.1z" id="path12"></path>
                            
                            <path style="fill:#ffffff;fill-opacity:1;stroke-width:3;stroke-miterlimit:4;stroke-dasharray:none" d="M 444.54432,984.29356 C 376.27396,977.10805 297.63981,948.71945 236.71877,909.26411 131.41618,841.06517 59.324284,740.39301 26.009051,615.02025 17.980055,584.8053 16.741277,569.20627 16.841214,499.57627 16.946875,425.95858 17.917282,415.52182 28.178964,377.63835 50.940585,293.60836 94.737428,218.01906 156.37824,156.37824 218.01906,94.737428 293.60836,50.940585 377.63835,28.178964 415.52182,17.917282 425.95858,16.946875 499.57627,16.841214 588.08462,16.71418 615.17318,21.364823 682.1603,48.187781 906.42737,137.98866 1032.3558,386.25172 972.08958,619.77195 c -23.16496,89.75966 -61.01979,155.2614 -129.03801,223.27962 -82.85466,82.85466 -177.1667,128.4736 -292.62784,141.5447 -42.80284,4.84564 -57.35966,4.80398 -105.87941,-0.30254 l 0,-1.7e-4 z m 94.9425,-63.275 C 744.10331,900.02097 899.95915,744.70551 920.86733,540.96047 933.74733,415.44842 889.03907,290.93736 798.62712,200.52543 745.14161,147.03992 681.17004,109.99393 607.62712,89.917157 576.11835,81.315453 562.32864,80.11514 497.45763,80.327564 429.21426,80.55103 420.26608,81.492504 385.16949,92.141869 240.63859,135.99691 135.99691,240.63859 92.141869,385.16949 81.481208,420.30331 80.554784,429.14187 80.372258,497.45763 c -0.172966,64.73894 1.04828,78.72487 9.620017,110.16949 20.135295,73.86445 57.265215,137.9661 110.594955,190.93275 69.90473,69.42877 158.58428,112.25149 253.13391,122.23649 18.22878,1.92508 35.32471,3.75377 37.99094,4.06372 2.66618,0.31017 24.16483,-1.41868 47.77474,-3.84152 z" id="path4144" inkscape:connector-curvature="0"></path>
                            <path style="fill:#ffffff;fill-opacity:1;stroke-width:3;stroke-miterlimit:4;stroke-dasharray:none" d="M 558.89831,737.77356 C 546.48755,730.23674 351.12426,530.87285 345.47707,519.98195 c -2.63951,-5.09043 -4.7991,-18.99973 -4.7991,-30.90954 l 0,-21.65422 51.36041,-55.08428 51.36041,-55.08429 -27.43513,-28.41786 c -15.08932,-15.62982 -28.71617,-32.45405 -30.28188,-37.38718 -6.55699,-20.65924 15.67252,-43.9255 35.84958,-37.52155 4.23508,1.34417 19.57271,14.74018 34.08361,29.76893 14.51089,15.02874 28.28732,27.32499 30.61428,27.32499 2.32696,0 17.99612,-13.34746 34.82037,-29.66102 33.55824,-32.53961 42.90804,-35.58009 59.22773,-19.2604 20.95476,20.95476 17.95035,25.66399 -78.58243,123.173 -110.3043,111.4198 -107.64067,103.01354 -50.84746,160.47153 l 38.13559,38.58197 38.13559,-38.58197 c 45.87474,-46.41172 47.99538,-54.72433 21.33842,-83.64372 l -16.79717,-18.22278 21.04796,-20.73146 21.04795,-20.73146 25.7317,25.27773 c 14.15243,13.90275 28.4472,30.42669 31.76616,36.71985 7.24363,13.73483 7.88409,42.758 1.22636,55.57373 -2.64446,5.09044 -25.52582,30.55893 -50.84746,56.59665 -25.32164,26.03773 -46.03934,49.17069 -46.03934,51.40659 0,2.2359 15.41852,20.66703 34.26338,40.95806 29.75498,32.0384 33.91279,38.37662 31.59898,48.16967 -3.05106,12.91344 -16.91861,26.17814 -27.13687,25.95725 -3.82021,-0.0825 -10.75939,-2.46602 -15.4204,-5.29661 z" id="path4146" inkscape:connector-curvature="0"></path>
                            <path style="fill:#ffffff;fill-opacity:1;stroke-width:3;stroke-miterlimit:4;stroke-dasharray:none" d="m 385.74093,738.67551 c -17.66167,-13.89267 -15.3091,-31.99612 7.00364,-53.89442 l 18.16831,-17.83084 20.77115,21.08825 c 11.42413,11.59853 19.93272,21.84489 18.90797,22.76969 -23.37578,21.09561 -43.81448,36.64944 -48.15963,36.64944 -3.03973,0 -10.55088,-3.95196 -16.69144,-8.78212 z" id="path4148" inkscape:connector-curvature="0"></path>
                        </svg>
                    </template>
                    <span>{{item.name}}</span>
                </a>
            </template>
        </div>
    </template>
    <script>
        Polymer({
            is: "stv-launcher",

            properties: {
                dataSrc: String,

                _applicationsList: Object
            },

            ready: function() {
                var icon = Polymer.dom(this).children[0]; // Select the icon established as button
                this._getAppInfo();

                icon.addEventListener("click", this._toogle.bind(this));

                Polymer.dom(this).setAttribute("tabindex", -1); // To make blur work
                this.addEventListener("blur", this._hide.bind(this));
            },

            _toogle: function() {
                var dropdown = this.$.dropdown;
                if (dropdown.hidden) {
                    dropdown.removeAttribute("hidden");
                    this._fadeIn(dropdown);
                } else {
                    dropdown.setAttribute("hidden", true);
                    dropdown.style.opacity = 0;
                }
                this._setDropdownPosition();
            },

            _hide: function() {
                // Made async function to allow link to work
                this.async(function() {
                    Polymer.dom(this.$.dropdown).setAttribute("hidden", true);
                }, 200);
            },

            _getAppInfo: function() {
                // var request = new XMLHttpRequest();
                //
                // var that = this;
                //
                // request.addEventListener("load", function() {
                //     that._applicationsList = JSON.parse(this.responseText);
                // });
                //
                // request.open("GET", this.dataSrc);
                // request.send();
                this._applicationsList = STV_LAUNCHER_APPS;
            },

            _hasIconUrl: function(appIcon) {
                return appIcon !== "";
            },

            _fadeIn: function(el) {
                el.style.opacity = 0;

                var last = +new Date();
                var tick = function() {
                    el.style.opacity = +el.style.opacity + (new Date() - last) / 400;
                    last = +new Date();

                    if (+el.style.opacity < 1) {
                        (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
                    }
                };

                tick();
            },

            _setDropdownPosition: function() {
                var dropdownBCR = this.$.dropdown.getBoundingClientRect();
                var iconBCR = Polymer.dom(this).children[0].getBoundingClientRect();
                var calcMargin = dropdownBCR.width / 2 - iconBCR.width / 2;

                if (dropdownBCR.right + calcMargin > window.innerWidth) {
                    this.$.dropdown.style.marginLeft = (-dropdownBCR.width + iconBCR.width) + "px";
                } else if (dropdownBCR.left - calcMargin >= 0) {
                    this.$.dropdown.style.marginLeft = (-calcMargin) + "px";
                }
            }
        })
    </script>
</dom-module>
<script>/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",function(){return saveAs})}
</script>

<dom-module id="stv-table" assetpath="bower_components/stevia-elements/src/table/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            font-size: 13px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -khtml-user-select: none;
            -ms-user-select: none;
        }

        .scrollfix {
            position: absolute;
            width: 25px;
            height: 100%;
            top: 0;
            right: 0;
            background-color: inherit;
            z-index: 1;
        }

        :host[enable-paging] .scrollfix {
            display: none;
        }

        #wrap {
            height: calc(100% - 30px);
            background-color: #fcfcfc;
        }

        .table-header,
        .table-filter,
        .table-body {
            box-sizing: border-box;
            border-right: 1px solid #dadada;
        }

        .table-header {
            position: relative;
            /*box-sizing: border-box;*/
            background-color: #F1F3F5;
            border-bottom: 1px solid #d3d3d3;
        }

        #headerRow {
            position: relative;
        }

        .table-header-row {
            position: relative;
            box-sizing: border-box;
            font-weight: bold;
            color: #666;
            overflow-y: scroll;
            overflow-x: hidden;
            width: 100%;
            background-color: inherit;
        }

        :host[enable-paging] .table-header-row {
            overflow-y: hidden;
        }

        .table-header-field {
            box-sizing: border-box;
            border-right: 1px solid #d3d3d3;
            /*white-space: nowrap;*/
            /*overflow: hidden;*/
            /*text-overflow: ellipsis;*/
            cursor: pointer;
            position: relative;
        }

        .table-header-field.sort-down>.name:after {
            font-family: 'FontAwesome';
            content: ' \f107';
        }

        .table-header-field.sort-up>.name:after {
            font-family: 'FontAwesome';
            content: ' \f106';
        }

        .table-header-field>.name {
            box-sizing: border-box;
            /*cursor: pointer;*/
            text-align: center;
            padding: 7px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .table-header-field>.sub {
            box-sizing: border-box;
            /*cursor: pointer;*/
            text-align: center;
            border-top: 1px solid #d3d3d3;
        }

        div.table-header-field:last-of-type {
            border-right-width: 0;
        }

        .table-filter {
            position: relative;
            /*box-sizing: border-box;*/
            background-color: #F1F3F5;
            border-bottom: 1px solid #d3d3d3;
        }

        #filterRow {
            position: relative;
            height: 26px;
            overflow-y: scroll;
            overflow-x: hidden;
            width: 100%;
            background-color: inherit;
        }

        :host[enable-paging] #filterRow {
            overflow-y: hidden;
        }

        .table-pager {
            overflow-y: hidden;
            overflow-x: hidden;
        }

        .table-pager>* {
            margin: 0 2px;
        }

        .table-bbar {
            position: relative;
            box-sizing: border-box;
            border-top: 1px solid #d3d3d3;
            background-color: #fafafa;
            color: #666;
            padding: 3px;
        }

        .table-body {
            /*box-sizing: border-box;*/
            overflow-x: auto;
            /*overflow-y: scroll;*/
            height: calc(100% - 28px);
            background-color: #fafafa;
        }

        :host>.table-body {
            overflow-y: scroll;
        }

        :host[enable-paging]>.table-body {
            overflow-y: hidden;
        }

        :host[enable-filter]>.table-body {
            height: calc(100% - 88px);
        }

        .table-row {
            position: relative;
            box-sizing: border-box;
            cursor: default;
            background-color: #fff;
            overflow: hidden;
            border-bottom: 1px solid #ddd;
            height: 30px;
        }

        .table-row.selected {
            background-color: #ccc !important;
        }

        .table-row.selected:hover {
            background-color: #bbb !important;
        }
        /*div.table-row:last-of-type {*/
        /*border-bottom-width: 0;*/
        /*}*/

        .table-row:nth-child(2n) {
            background-color: #fbfbfb;
        }

        .table-row:hover {
            background-color: #eee;
        }

        .table-field {
            position: relative;
            box-sizing: border-box;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-right: 1px solid #d3d3d3;
            float: left;
            height: 100%;
        }

        .table-field>div {
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        div.table-field:last-of-type {
            border-right-width: 0;
        }

        #loading {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            right: 0;
            background-color: rgba(0, 0, 0, .1);
            /*z-index: 2;*/
        }

        #loading-text {
            position: absolute;
            color: #445D76;
            top: 45%;
            font-size: 16px;
            padding: 20px;
            width: 124px;
        }

        .select {
            position: relative;
            display: inline-block;
        }

        .select select {
            box-sizing: content-box;
            width: 100%;
            background: transparent;
            border: 0;
            outline: 0;
            -webkit-appearance: none;
            -moz-appearance: radio-container;
            appearance: none;
        }

        .select select:-moz-focusring {
            color: transparent;
            text-shadow: 0 0 0 #000;
        }

        .select select::-ms-expand {
            display: none;
        }

        .select:after {
            -ms-display: none;
            position: absolute;
            box-sizing: border-box;
            right: 7px;
            top: 0;
            color: inherit;
            font-family: FontAwesome;
            content: '\f107';
            pointer-events: none;
        }

        .select,
        input[type=text] {
            display: block;
            position: relative;
            outline: transparent solid 0px;
            box-sizing: border-box;
            line-height: 21px;
            border: 1px solid #ccc;
            padding: 0px 5px;
            background-color: #fff;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            height: 23px;
            margin: 1px;
        }

        .table-filter-field:last-child>.select,
        .table-filter-field:last-child>input[type=text] {
            margin-right: 15px;
        }

        :host[enable-paging] .table-filter-field:last-child>.select,
        :host[enable-paging] .table-filter-field:last-child>input[type=text] {
            margin-right: 1px;
        }

        input[type=text] {
            transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
        }

        input[type=text]:-moz-ui-invalid {
            box-shadow: none;
        }

        input[type=text]:focus {
            border-color: #66afe9;
            box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6);
        }

        .table-field>.select,
        .table-field>input[type=text] {
            box-sizing: border-box;
            background-color: transparent;
            border-color: transparent;
            height: 100%;
            width: 100%;
            margin: 0;
        }

        .table-field>input[type=text]:hover {
            border-color: #ccc;
        }

        .table-field>input[type=text][readonly]:focus {
            border-color: #ccc;
            box-shadow: inset 0 0 3px 1px rgba(0, 0, 0, .01);
            background-color: #fff;
        }

        .table-field>input[type=text]:focus {
            border-color: #66afe9;
            box-shadow: inset 0 0 3px 1px rgba(102, 175, 233, .5);
            background-color: #fff;
        }

        .table-header-field>.resizer {
            width: 2px;
            height: 100%;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: col-resize;
            display: none;
        }

        .table-header-field:hover>.resizer {
            display: inherit;
            background-color: #E1E3E5;
            border-left: 1px solid #DDD;
        }

        #columnsMenu {
            box-sizing: border-box;
            position: fixed;
            min-width: 200px;
            cursor: pointer;
            transition: opacity 0.1s, visibility 0.1s;
            max-height: 300px;
            overflow-y: auto;
            visibility: hidden;
            opacity: 0;
            list-style: none;
            text-decoration: none;
            z-index: 100000;
            border: 1px solid #afafaf;
            background-color: #fff;
            line-height: 22px;
            margin: 1px 0 0 0;
            padding: 5px 0;
            box-shadow: 4px 4px 4px rgba(0, 0, 0, 0.2);
        }

        li.columnControl {
            cursor: pointer;
        }

        li.columnControl:hover,
        li.columnControl:hover {
            background-color: inherit !important;
            color: inherit !important;
        }

        #list[loading] {
            visibility: hidden;
        }
    </style>
    <template>
        <div id="loading" hidden$="{{!loading}}">
            <div id="loading-text">
                <i class="fa fa-circle-o-notch fa-spin"></i>
                <span>{{loadingMsg}}</span>
            </div>
        </div>

        <div id="wrap" style="overflow-x: scroll;overflow-y:hidden; width:100%;">
            <div id="header" class="table-header" on-contextmenu="handleColumnsMenu">
                <div id="headerRow"></div>
                <div class="scrollfix"></div>
            </div>
            <div id="filter" class="table-filter" hidden$="{{!enableFilter}}">
                <div id="filterRow" hidden$="{{!enableFilter}}"></div>
                <div class="scrollfix"></div>
            </div>
            <div id="list" class="table-body" on-dragover="allowDrop" on-drop="drop" loading$="{{loading}}"></div>
        </div>


        <div class="horizontal layout center table-bbar" style="height:30px;">
            <div id="pager" hidden$="{{!enablePaging}}" class="table-pager horizontal layout center flex">
                <div class="stv-btn stv-btn-shdw" on-click="handleFirstClick"><i class="fa fa-angle-double-left"></i>
                </div>
                <div class="stv-btn stv-btn-shdw" on-click="handlePreviousClick"><i class="fa fa-angle-left"></i></div>
                <div class="">Page</div>
                <input type="text" class="stv" style="width:80px;" value="{{currentPage::input}}">

                <div class="">of</div>
                <div class="">{{computePageTotal(pageSize, itemCount)}}</div>

                <div class="stv-btn stv-btn-shdw" on-click="handleNextClick"><i class="fa fa-angle-right"></i></div>
                <div class="stv-btn stv-btn-shdw" on-click="handleLastClick"><i class="fa fa-angle-double-right"></i>
                </div>

                <div class="flex"></div>
                <content select=".custom-buttons"></content>
                <div class="">{{pageFirstItem}}</div>
                <div class="">-</div>
                <div class="">{{pageLastItem}}</div>
                <div class="">of</div>
                <div class="">{{itemCount}}</div>
            </div>

            <div hidden$="{{enablePaging}}" class="flex">
                <span>Total: </span>
                <span>{{itemCount}}</span>
            </div>
            <div class="stv-btn" style="margin:0 2px;" on-click="handleExportCSVMenuButton" hidden$="{{!enableExport}}">
                <i class="fa fa-download"></i>
            </div>
            <div class="stv-btn" title="Show/Hide Columns" style="margin:0 2px;" on-click="handleColumnsMenuButton" hidden$="{{hideColumnSelector}}">
                <i class="fa fa-bars"></i>
            </div>
        </div>


        <ul id="columnsMenu" on-mouseleave="handleColumnsMenuLeave" on-wheel="handleMenuScroll">
            
            <template is="dom-repeat" items="{{columns}}">
                <li class="columnControl">
                    <stv-table-column-menu-item column="{{item}}" on-column-toggle="handleColumnVisibilityClick"></stv-table-column-menu-item>
                </li>
            </template>
        </ul>
    </template>

    <script>
        Polymer({
            is: 'stv-table',
            behaviors: [
                Polymer.IronResizableBehavior
            ],
            properties: {
                columns: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },
                data: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },
                viewData: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },
                request: {
                    type: Object,
                    observer: 'requestChanged'
                },
                enableRemote: {
                    type: Boolean,
                    observer: 'enableRemoteChanged',
                    value: false
                },
                enablePaging: {
                    type: Boolean,
                    observer: 'enablePagingChanged',
                    value: false
                },
                enableResize: {
                    type: Boolean,
                    value: false
                },
                pageSize: {
                    type: Number,
                    observer: 'pageSizeChanged',
                    value: 10
                },
                currentPage: {
                    type: Number,
                    observer: 'currentPageChanged',
                    value: 1
                },
                pageFirstItem: {
                    type: Number,
                    computed: 'computePageFirstItem(currentPage, pageSize, itemCount)',
                    value: 0
                },
                pageLastItem: {
                    type: Number,
                    computed: 'computePageLastItem(currentPage, pageSize, itemCount)',
                    value: 0
                },
                selected: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },
                enableSelect: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                disableTooltip: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                lastSelectedRow: {
                    type: Object,
                    value: null
                },
                enableFilter: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                filters: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },
                itemCount: {
                    type: Number,
                    value: 0
                },
                pageCount: {
                    type: Number,
                    value: 0
                },
                enableLoading: {
                    type: Boolean,
                    value: false,
                },
                loading: {
                    type: Boolean,
                    value: false,
                    observer: 'handleLoading'
                },
                loadingMsg: {
                    type: String,
                    value: 'Loading...'
                },
                draggable: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false,
                },
                enableEdit: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false,
                },
                hideColumnSelector: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                enableExport: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                exportParsers: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                }
            },
            observers: [
                "dataChanged(data.splices)",
                "selectedChanged(selected.splices)",
                "viewDataChanged(viewData.splices)",
                'columnsChanged(columns.splices)',
            ],
            listeners: {
                'wheel': 'handleScroll',
                'mouseleave': 'handleColumnsMenuLeave',
                'iron-resize': '_onIronResize'
            },
            _onIronResize: function() {
                this._setPageSizeAuto();
            },
            _setPageSizeAuto: function() {
                this.async(function() {
                    var listHeight = this.$.list.getBoundingClientRect().height;
                    if (listHeight != 0) {
                        var n = listHeight / 30;
                        this.set('pageSize', parseInt(Math.floor(n)))
                    }
                }, 150);
            },
            ready: function() {
                var me = this;

                this.exportParsers.separator = "\t";
                this.exportParsers.comment = "#";
                this.exportParsers.chunkSize = 1000;
                this.exportParsers.maxLimit = 1000;

                this.exportParsers.headerParser = function(columns) {
                    var headerLine = this.comment;
                    for (var i = 0; i < columns.length; i++) {
                        if (columns[i].type === "action") {
                            continue;
                        }
                        headerLine += columns[i].title + this.separator;
                    }
                    return headerLine;
                }
                this.exportParsers.dataParser = function(columns, row) {

                    var dataLine = "";
                    for (var j = 0; j < columns.length; j++) {
                        var column = columns[j];

                        if (column.type === "action") {
                            continue;
                        }

                        var key = column.name;
                        var value = (column.defaultValue) ? column.defaultValue : "";

                        if (column.formula) {
                            value = column.formula(row);
                        } else {
                            value = row[key];
                        }

                        dataLine += value + this.separator;
                    }
                    return dataLine;
                }
                this.async(function() {
                    this._setPageSizeAuto();
                    var hiddenParent = stv.utils.closest(this, "[hidden]");
                    if (hiddenParent != null) {
                        var observer = new MutationObserver(function(mutations) {
                            mutations.forEach(function(mutation) {
                                if (mutation.type == 'attributes' && mutation.attributeName == 'hidden') {
                                    me._setPageSizeAuto();
                                }
                            });
                        });
                        observer.observe(hiddenParent, {
                            attributes: true
                        });
                    }
                }, 10);
            },
            isColumnVisible: function(v) {
                return v.visible !== false;
            },
            handleColumnVisibilityClick: function(e) {
                this.columnsChanged();
                this.fire('column-visibility-change', e);
            },
            /* LISTENERS */
            handleScroll: function(e) {
                if (this.enablePaging == true) {
                    e.preventDefault();
                    if (e.deltaY > 0) {
                        this.handleNextClick();
                    }
                    if (e.deltaY < 0) {
                        this.handlePreviousClick();
                    }
                }
            },
            handleColumnsMenu: function(e) {
                e.preventDefault();
                e.stopPropagation();

                this.$.columnsMenu.style.opacity = "1";
                this.$.columnsMenu.style.visibility = "visible";
                this.$.columnsMenu.style.top = (e.clientY + 10) + "px";
                this.$.columnsMenu.style.left = (e.clientX) + "px";
            },
            handleColumnsMenuButton: function(e) {
                e.preventDefault();
                e.stopPropagation();

                this.$.columnsMenu.style.opacity = "1";
                this.$.columnsMenu.style.visibility = "visible";
                var bcrColumnsMenu = this.$.columnsMenu.getBoundingClientRect();
                var bcrCurrent = e.currentTarget.getBoundingClientRect();
                this.$.columnsMenu.style.top = (bcrCurrent.top - bcrColumnsMenu.height) + "px";
                this.$.columnsMenu.style.left = (bcrCurrent.left - bcrColumnsMenu.width + bcrCurrent.width) + "px";
            },
            handleColumnsMenuLeave: function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.$.columnsMenu.style.opacity = "";
                this.$.columnsMenu.style.visibility = "";
            },
            handleMenuScroll: function(e) {
                e.stopPropagation();
            },

            selectedChanged: function(changeRecord) {
                this._updateSelected();
                this.fire('selected', this.selected);
            },
            _updateSelected: function() {
                var els = Polymer.dom(this.$.list).querySelectorAll('.table-row');
                for (var i = 0; i < els.length; i++) {
                    var el = els[i];
                    var index = this.selected.indexOf(el._rowData);
                    if (index >= 0) {
                        el.classList.add("selected");
                    } else {
                        el.classList.remove("selected");
                    }
                }
            },
            /* OBSERVERS */
            dataChanged: function(neo, old) {
                for (var i = 0; i < this.data.length; i++) {
                    var row = this.data[i];
                    delete row._filtered;
                }
                this.refreshPagination();
            },
            refreshPagination: function() {
                this.currentPage = 1;
                var count = 0;
                if (this.data) {
                    this.data.forEach(function(row) {
                        if (row._filtered || row._filtered == null) {
                            count++;
                        }
                    });
                }
                this.itemCount = count;
                this.pageCount = Math.ceil(count / this.pageSize);
                this.filterPage();
            },
            filterPage: function() {
                var filteredRows = this.enableFilter ? this.data.filter(function(r) {
                    if (r._filtered == undefined) {
                        return true;
                    }
                    return r._filtered;
                }) : this.data;
                if (this.enablePaging) {
                    var from = (this.currentPage - 1) * this.pageSize;
                    var to = from + this.pageSize;
                    if (this.request) {
                        this.checkRemote();
                    } else {
                        this.set('viewData', filteredRows.slice(from, to));
                        this._updateSelected();
                    }
                } else {
                    var viewData = [];
                    for (var i = 0; filteredRows && i < filteredRows.length; i++) {
                        var row = filteredRows[i];
                        viewData.push(row);
                    }
                    this.set('viewData', viewData);
                }

            },
            viewDataChanged: function(neo, old) {
                while (this.$.list.firstChild) {
                    this.$.list.removeChild(this.$.list.firstChild);
                }
                for (var i = 0; this.viewData && i < this.viewData.length; i++) {
                    var rowData = this.viewData[i];
                    this._createRow(rowData);
                }

            },
            // pagination
            handleFirstClick: function() {
                this.currentPage = 1;
            },
            handlePreviousClick: function() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                }
            },
            handleNextClick: function() {
                // console.log(this.currentPage);
                // console.log(this.pageCount);
                if (this.currentPage < this.pageCount) {
                    this.currentPage++;
                }
            },
            handleLastClick: function() {
                this.currentPage = this.pageCount;
            },
            currentPageChanged: function(neo, old) {
                this.currentPage = this.currentPage ? parseInt(this.currentPage) : 0;
                this.currentPage = this.currentPage < 1 ? 1 : this.currentPage;
                this.currentPage = this.pageCount > 0 && this.currentPage > this.pageCount ? this.pageCount : this.currentPage;
                this.filterPage();

            },
            pageSizeChanged: function() {
                this.pagesize = parseInt(this.pagesize);
                this.refreshPagination();
            },
            computePageFirstItem: function(currentPage, pageSize, itemCount) {
                return ((currentPage - 1) * pageSize) + 1;
            },
            computePageLastItem: function(currentPage, pageSize, itemCount) {
                var end = currentPage * pageSize;
                if (itemCount < end) {
                    return itemCount;
                }
                return end;
            },
            computePageTotal: function(pageSize, itemCount) {
                return Math.ceil(itemCount / pageSize);
            },
            enablePagingChanged: function(neo, old) {
                this.refreshPagination();
            },
            enableRemoteChanged: function(neo, old) {
                if (this.request) {
                    this.checkRemote();
                }
            },
            requestChanged: function(neo, old) {
                if (this.currentPage != 1) {
                    this.currentPage = 1;
                } else if (this.request && this.request.url != null && this.request.url != "") {
                    this.checkRemote();
                }
            },
            columnsChanged: function(neo, old) {
                this.updateColumns();
                this.viewDataChanged();
            },
            clear: function() {
                this.data = [];
                this.viewData = [];
                this.currentPage = 1;
                this.columns = [];
            },
            refresh: function() {
                this.updateColumns();
                this.dataChanged();
            },
            checkRemote: function() {
                var me = this;
                if (this.enableLoading && this.currentPage == 1) {
                    this.setLoading(true);
                }
                if (this.enableRemote) {
                    this._callRemote(function(resp) {
                        me.itemCount = me.request.parseTotal(resp);
                        me.pageCount = Math.ceil(me.itemCount / me.pageSize);
                        me.viewData = me.request.parse(resp);
                        if (me.enableLoading) {
                            me.setLoading(false);
                        }
                    });
                } else {
                    //                ...
                }
            },
            _callRemote: function(callback) {
                var method = 'GET';
                if (typeof this.request.method !== 'undefined' && this.request.method != null) {
                    method = this.request.method;
                }
                var request = new XMLHttpRequest();
                request.onload = function() {
                    var contentType = this.getResponseHeader('Content-Type');
                    var resp;
                    if (contentType === 'application/json') {
                        resp = JSON.parse(this.response, this);
                    } else {
                        resp = this.response;
                    }
                    callback(resp)
                };
                request.onerror = function() {
                    //                args.request.error(this);
                };
                if (this.request.url && this.request.url != "") {

                    var url = stv.utils.addQueryParamtersToUrl({
                        skip: ((this.currentPage - 1) * this.pageSize),
                        limit: this.pageSize,
                        sort: this.request.sort,
                        search: this.request.search
                    }, this.request.url);
                    request.open(method, url, true);
                    request.send();
                    console.log(url)
                }
            },
            updateColumns: function() {
                var els = this.$.headerRow.querySelectorAll('.table-header-row');
                for (var i = 0; i < els.length; i++) {
                    this.$.headerRow.removeChild(els[i]);
                }

                els = this.$.filterRow.children;
                for (var i = 0; i < els.length; i++) {
                    this.$.filterRow.removeChild(els[i]);
                }

                var totalColWidth = 0;
                for (var i = 0; i < this.columns.length; i++) {
                    var x = [];
                    var column = this.columns[i];
                    // set default width
                    if (isNaN(column.width)) {
                        column.width = 100;
                    }
                    if (column.visible == null) {
                        column.visible = true;
                    }
                    this._processColumn(column, x);
                    column.plainColumns = x;
                    if (column.visible !== false) {
                        totalColWidth += column.width;
                    }

                }
                this._createHeaderRow();
                this._createFilterRow();

                this.$.header.style.width = totalColWidth + 'px';
                this.$.filter.style.width = totalColWidth + 'px';
                this.$.list.style.width = totalColWidth + 'px';

                if (totalColWidth === 0) {
                    this.$.list.setAttribute('hidden', '');
                } else {
                    this.$.list.removeAttribute('hidden');
                }

            },
            _createFilterRow: function() {
                var el = document.createElement('div');
                el.classList.add('horizontal', 'layout', 'style-scope', 'stv-table');
                for (var i = 0; i < this.columns.length; i++) {
                    var column = this.columns[i];
                    if (column.visible !== false) {
                        this._createFilterField(el, column);
                    }
                }
                this.$.filterRow.appendChild(el);
            },
            _createFilterField: function(rowEl, column, rowData) {
                var me = this;
                var el = document.createElement('div');
                el.classList.add('table-filter-field', 'horizontal', 'layout', 'style-scope', 'stv-table');
                if (isNaN(column.width)) {
                    el.classList.add('flex');
                } else {
                    el.style.width = column.width + "px";
                    el.style.minWidth = column.width + "px";
                }
                if (column.plainColumns.length > 0) {
                    // TODO aaleman: nested columns
                    //                for (var i = 0; i < column.plainColumns.length; i++) {
                    //
                    //                    var cEl = document.createElement('div');
                    //                    var c = column.plainColumns[i];
                    //                    cEl.style.width = c.width + "px";
                    //                    var defValue = c.defaultValue != null ? c.defaultValue : '';
                    //                    var value = null;
                    //                    if (c.formula) {
                    //                        value = c.formula(rowData);
                    //                    } else {
                    //                        value = this._deepValue(rowData, c.ak);
                    //                    }
                    //                    cEl.innerHTML = value != null ? value : defValue;
                    //                    el.appendChild(cEl);
                    //                }
                } else {
                    if (!column.type) {
                        column.type = 'text';
                    }
                    switch (column.type) {
                        case 'text':
                            var input = document.createElement("input");
                            input.setAttribute("type", "text");
                            input.setAttribute("placeholder", "filter by " + column.title);
                            input.classList.add('style-scope', 'stv-table');
                            if (isNaN(column.width)) {
                                input.classList.add('flex');
                            } else {
                                input.style.width = column.width + "px";
                            }
                            input._col = column.name;
                            input.addEventListener('input', function(e) {
                                var query = this.value;
                                var filter = {}
                                if (input._col in me.filters) {
                                    filter = me.filters[input._col];
                                }
                                if (query != "") {
                                    filter.type = 'text';
                                    filter.colName = input._col;
                                    filter.query = query;
                                    filter.func = null;
                                    me.filters[input._col] = filter;
                                } else {
                                    delete me.filters[input._col];
                                }
                                me._applyFilters();
                            });
                            el.appendChild(input);
                            break;
                        case 'select':
                            var selwrap = document.createElement("div");
                            selwrap.classList.add('style-scope', 'stv-table', 'select');
                            if (isNaN(column.width)) {
                                selwrap.classList.add('flex');
                            } else {
                                selwrap.style.width = column.width + "px";
                            }
                            var input = document.createElement("select");
                            input.classList.add('style-scope', 'stv-table');
                            selwrap.appendChild(input);

                            input._col = column.name;
                            var option = document.createElement("option");
                            var optVal = "";
                            option.value = optVal;
                            option.text = optVal;
                            input.appendChild(option);
                            for (var i = 0; i < column.options.length; i++) {
                                option = document.createElement("option");
                                optVal = column.options[i];
                                option.value = optVal;
                                option.text = optVal;
                                input.appendChild(option);
                            }
                            input.addEventListener('click', function(e) {
                                var query = this.value;
                                var filter = {}
                                if (input._col in me.filters) {
                                    filter = me.filters[input._col];
                                }
                                if (query != "") {
                                    filter.type = 'select';
                                    filter.colName = input._col;
                                    filter.query = query;
                                    filter.func = null;
                                    me.filters[input._col] = filter;
                                } else {
                                    delete me.filters[input._col];
                                }
                                me._applyFilters();
                            });
                            el.appendChild(selwrap);
                            break;
                        default:
                            var input = document.createElement("div");
                            el.appendChild(input);
                            break;
                    }
                }
                rowEl.appendChild(el);
            },
            _applyFilters: function() {
                if (this.enableRemote) {
                  var filter=[];
                  for (var key in this.filters) {
                    var field = key;
                    var search=this.filters[key].query;
                    filter.push(field+":"+search);
                  }
                  this.set('request.search', filter.join(","));
                } else {
                    for (var i = 0; i < this.data.length; i++) {
                        var row = this.data[i];
                        var filtered = true;
                        for (var key in this.filters) {
                            var filter = this.filters[key];
                            var match = false;
                            switch (filter.type) {
                                case 'text':
                                    var value = row[filter.colName].toLowerCase();
                                    match = (value.indexOf(filter.query.toLowerCase()) >= 0);
                                    break;
                                case 'select':
                                    var value = row[filter.colName].toLowerCase();
                                    match = (value === filter.query.toLowerCase());
                                    break;
                            }
                            filtered &= match;
                        }
                        row._filtered = filtered;
                    }
                }
                this.refreshPagination();
            },
            _processColumn: function(column, x) {
                if (column.columns && column.columns.length > 0) {
                    for (var i = 0; i < column.columns.length; i++) {
                        var col = column.columns[i];
                        col._parentColumn = column;

                        if (column.ak) {
                            col.ak = column.ak + "." + col.name
                        } else {
                            col.ak = column.name + "." + col.name
                        }
                        if (col.columns == null) {
                            x.push(col);
                        }
                        this._processColumn(col, x);
                    }
                }
            },
            _createHeaderRow: function() {
                var el = document.createElement('div');
                el.classList.add('table-header-row', 'horizontal', 'layout', 'style-scope', 'stv-table');
                for (var i = 0; i < this.columns.length; i++) {
                    var column = this.columns[i];
                    if (column.visible !== false) {
                        this._createHeaderField(el, column);
                    }
                }
                this.$.headerRow.appendChild(el);
            },
            _setResizable: function(elem) {
                var me = this;

                var columnName = ".column-" + elem._column.name;

                var resizer = document.createElement('div');
                resizer.classList.add("resizer", 'style-scope', 'stv-table');
                elem.appendChild(resizer);

                var startX, startWidth;

                function initDrag(e) {
                    startX = e.clientX;
                    startWidth = parseInt(document.defaultView.getComputedStyle(elem).width, 10);
                    document.documentElement.addEventListener('mousemove', doDrag, false);
                    document.documentElement.addEventListener('mouseup', stopDrag, false);
                }

                function doDrag(e) {
                    elem.style.width = (startWidth + e.clientX - startX) + 'px';
                    elem.style.minWidth = (startWidth + e.clientX - startX) + 'px';
                }

                function stopDrag(e) {

                    document.documentElement.removeEventListener('mousemove', doDrag, false);
                    document.documentElement.removeEventListener('mouseup', stopDrag, false);

                    var dif = e.clientX - startX;

                    elem.style.width = (startWidth + dif) + 'px';
                    elem._column.width = (startWidth + dif);

                    var parentColumn = elem._column._parentColumn;
                    while (parentColumn != null) {
                        parentColumn.width += dif;
                        parentColumn = parentColumn._parentColumn;
                    }

                    function resizeChildren(columns, d) {

                        if (Array.isArray(columns)) {

                            for (var i = 0; i < columns.length; i++) {
                                var col = columns[i];

                                col.width += (d / columns.length);
                                resizeChildren(col.columns, d / columns.length);
                            }
                        }
                    }

                    resizeChildren(elem._column.columns, dif);

                    me.updateColumns();
                    me.viewDataChanged();
                }

                resizer.addEventListener('mousedown', initDrag, false);
            },

            _createHeaderField: function(rowEl, column) {
                var me = this;
                var el = document.createElement('div');
                el.classList.add('table-header-field', 'vertical', 'layout', 'center-justified', 'style-scope', 'stv-table', ('column-' + column.name.replace(/\s/g, '_')));
                if (isNaN(column.width)) {
                    el.classList.add('flex');
                } else {
                    el.style.width = column.width + "px";
                    el.style.minWidth = column.width + "px";
                }
                el._column = column;
                var nameEl = document.createElement('div');
                nameEl.classList.add('name', 'style-scope', 'stv-table');
                nameEl.innerHTML = column.title;
                el.appendChild(nameEl);

                if (this.enableResize) {
                    this._setResizable(el);
                }

                if (column.columns && column.columns.length > 0) {
                    var subColumnsEl = document.createElement('div');
                    subColumnsEl.classList.add('sub', 'horizontal', 'layout', 'style-scope', 'stv-table');
                    for (var i = 0; i < column.columns.length; i++) {
                        var subColumn = column.columns[i];

                        if (subColumn.visible != false) {
                            this._createHeaderField(subColumnsEl, subColumn);
                        }
                    }
                    el.appendChild(subColumnsEl);
                } else {
                    el.addEventListener('click', this.handleHeaderFieldClick.bind(this));
                }
                rowEl.appendChild(el);
            },
            handleHeaderFieldClick: function(e) {
                var me = this;
                var column = e.currentTarget._column;
                var sortedData = this.data.slice(0);
                var els = this.querySelectorAll('.table-header-field');
                var isSortDown = e.currentTarget.classList.contains("sort-down");

                for (var i = 0; i < els.length; i++) {
                    var el = els[i];
                    el.classList.remove('sort-down');
                    el.classList.remove('sort-up');
                }

                if (this.enableRemote) {

                    // this.request.sort = (isSortDown ? "-" : "") + column.name;
                    this.set("request.sort", (isSortDown ? "-" : "") + column.name);

                    if (isSortDown) {
                        e.currentTarget.classList.add('sort-up');
                    } else {
                        e.currentTarget.classList.add('sort-down');
                    }
                    this.requestChanged();
                } else {

                    if (isSortDown) {
                        sortedData.sort(function(a, b) {
                            return me._columnSort(column, b, a);
                        });
                        e.currentTarget.classList.add('sort-up');
                    } else {
                        sortedData.sort(function(a, b) {
                            return me._columnSort(column, a, b);
                        });
                        e.currentTarget.classList.add('sort-down');
                    }
                    this.data = sortedData;
                }

            },
            _columnSort: function(column, a, b) {
                //checking formula or TODO save calculated value in the item;
                if (column.sort != null) {
                    return column.sort(a, b);
                } else {
                    var aVal, bVal;
                    if (column.formula != null) {
                        aVal = column.formula(a);
                        bVal = column.formula(b);
                    } else {
                        aVal = a[column.name];
                        bVal = b[column.name];
                    }
                    if (!isNaN(bVal) && !isNaN(aVal)) {
                        return aVal - bVal;
                    } else {
                        return (aVal > bVal) - (aVal < bVal);
                    }
                }
            },
            _getPos: function(row) {
                for (var i = 0; i < this.viewData.length; i++) {
                    var elem = this.viewData[i];
                    if (elem === row) {
                        return i;
                    }
                }
                return -1;
            },
            _createRow: function(rowData) {
                var me = this;
                var el = document.createElement('div');
                el.classList.add('table-row', 'horizontal', 'layout', 'style-scope', 'stv-table');
                el._rowData = rowData;
                var id = "idRow_" + this._getPos(rowData);
                el.setAttribute("id", id);
                if (this.draggable) {
                    el.setAttribute("draggable", "true");
                    el.addEventListener('dragstart', this.drag);
                }
                el.addEventListener('click', function(e) {
                    me.fire('rowclick', {
                        row: rowData
                    });
                    var currentTarget = e.currentTarget;
                    console.log("Position: " + me._getPos(currentTarget._rowData));
                    if (me.enableSelect) {
                        if (e.ctrlKey) {
                            me._toggleSelected(currentTarget, rowData);
                        }
                        if (e.button === 0) {
                            if (!e.ctrlKey && !e.shiftKey) {
                                me._clearSelection();
                                me._toggleSelected(currentTarget, rowData);
                            }
                            if (e.shiftKey) {
                                var first = me._getPos(me.lastSelectedRow._rowData);
                                var last = me._getPos(currentTarget._rowData);
                                if (last < first) {
                                    var tmp = last;
                                    last = first;
                                    first = tmp;
                                }
                                me._selectRowsBetweenIndexes(first, last);
                            }
                        }
                    }
                });
                for (var i = 0; i < this.columns.length; i++) {
                    var column = this.columns[i];
                    if (column.visible !== false) {
                        this._createField(el, column, rowData);
                    }
                }
                this.$.list.appendChild(el);
            },
            _toggleSelected: function(domElem, rowData) {
                if (domElem.classList.contains("selected")) {
                    var index = this.selected.indexOf(rowData);
                    if (index >= 0) {
                        this.splice('selected', index, 1);
                        domElem.classList.remove("selected");
                    }
                } else {
                    if (this.selected.indexOf(rowData) < 0) {
                        this.push('selected', rowData);
                        domElem.classList.add("selected");
                    }
                }
                this.lastSelectedRow = domElem;
            },
            _selectRowsBetweenIndexes: function(first, last) {
                var rows = this.$.list.getElementsByClassName("table-row");
                for (var i = 0; i < rows.length; i++) {
                    var obj = rows[i];
                    var pos = this._getPos(obj._rowData);
                    var index = this.selected.indexOf(obj._rowData);
                    if (pos >= first && pos <= last) {
                        obj.classList.add("selected");
                        if (index < 0) {
                            this.push('selected', obj._rowData);
                        }
                    } else {
                        if (index >= 0) {
                            this.splice('selected', index, 1);
                        }
                    }
                }
            },
            _clearSelection: function() {
                var rows = this.$.list.getElementsByClassName("table-row");
                for (var i = 0; i < rows.length; i++) {
                    var obj = rows[i];
                    obj.classList.remove("selected");
                }
                this.splice('selected', 0, this.selected.length);
            },
            _createField: function(rowEl, column, rowData) {
                var me = this;
                var el = document.createElement('div');
                el.classList.add('table-field', 'horizontal', 'layout', 'center', 'style-scope', 'stv-table');
                if (isNaN(column.width)) {
                    el.classList.add('flex');
                } else {
                    el.style.width = column.width + "px";
                    el.style.minWidth = column.width + "px";
                }
                if (column.type === "action") {
                    var remove = document.createElement("i");
                    remove.classList.add("fa", "fa-remove");
                    remove.addEventListener('click', function(e) {
                        me.fire('removerow', {
                            row: rowData
                        });
                        var pos = me._getPos(rowData);
                        if (pos >= 0) {
                            me.splice('data', pos, 1);
                        }
                    });
                    el.classList.add("center-justified")
                    el.appendChild(remove);
                } else if (column.plainColumns.length > 0) {
                    for (var i = 0; i < column.plainColumns.length; i++) {
                        var c = column.plainColumns[i];
                        if (c.visible != false) {
                            this._createTypeField(el, c, rowData, true);
                        }
                    }
                } else {
                    this._createTypeField(el, column, rowData);
                }
                rowEl.appendChild(el);
            },
            _createTypeField: function(el, column, rowData, isSubCol) {
                var me = this;
                var value;
                var defValue = column.defaultValue;

                if (column.formula) {
                    value = column.formula(rowData);
                } else {
                    if (isSubCol == true) {
                        value = this._deepValue(rowData, column.ak);
                    } else {
                        value = rowData[column.name];
                    }
                }

                // set empty string if no value found.
                value = (value == null) ? defValue : value;
                value = (value == null) ? '' : value;

                if (this.enableEdit && column.editable != false) {
                    if (!column.type) {
                        column.type = 'text';
                    }
                    switch (column.type) {
                        case 'text':
                            var input = document.createElement("input");
                            input.setAttribute("type", "text");
                            input.setAttribute("placeholder", "");
                            input.setAttribute("readonly", "");
                            input.classList.add('style-scope', 'stv-table');
                            input._col = column.name;
                            input.addEventListener('dblclick', function(e) {
                                this.removeAttribute('readonly');
                            });
                            input.addEventListener('blur', function(e) {
                                if (!this.hasAttribute('readonly')) {
                                    this.setAttribute('readonly', '');
                                    var val = this.value;
                                    if (column.editFormula != null) {
                                        column.editFormula(rowData, val);
                                    } else {
                                        rowData[column.name] = val;
                                    }
                                    me.fire('update-row', {
                                        row: rowData,
                                        column: column
                                    });
                                }
                            });
                            input.value = value;
                            el.appendChild(input);
                            break;
                        case 'select':
                            //TODO check styles
                            el.classList.add('table-field-nopadding');
                            var selwrap = document.createElement("div");
                            selwrap.classList.add('style-scope', 'stv-table', 'select');
                            if (isNaN(column.width)) {
                                selwrap.classList.add('flex');
                            } else {
                                selwrap.style.width = column.width + "px";
                            }
                            var input = document.createElement("select");
                            input.classList.add('style-scope', 'stv-table');
                            selwrap.appendChild(input);
                            input._col = column.name;
                            var option = document.createElement("option");
                            var optVal = "";
                            option.value = optVal;
                            option.text = optVal;
                            input.appendChild(option);
                            for (var i = 0; i < column.options.length; i++) {
                                option = document.createElement("option");
                                optVal = column.options[i];
                                option.value = optVal;
                                option.text = optVal;
                                input.appendChild(option);
                            }
                            //TODO check
                            input.addEventListener('click', function(e) {
                                var val = this.value;
                                rowData[column.name] = val;
                            });
                            input.value = value;
                            el.appendChild(selwrap);
                            break;
                    }
                } else {
                    var cEl = document.createElement('div');
                    cEl.classList.add('style-scope', 'stv-table');
                    if (isNaN(column.width)) {
                        cEl.classList.add('flex');
                    } else {
                        cEl.style.width = column.width + "px";
                    }
                    cEl.innerHTML = value;
                    if (!this.disableTooltip) {
                        var tooltipValue = value;
                        cEl.setAttribute("title", tooltipValue);
                    }

                    cEl.classList.add('column-' + column.name.replace(/\s/g, '_'));
                    if (column.styleFormula) {
                        var newStyle = column.styleFormula(rowData);
                        for (var key in newStyle) {
                            cEl.style[key] = newStyle[key];
                        }
                    }
                    if (column.classFormula) {
                        var newClass = column.classFormula(rowData);
                        cEl.classList.add(newClass);
                    }
                    el.appendChild(cEl);
                }
            },
            _deepValue: function(obj, path) {
                for (var i = 0, path = path.split('.'), len = path.length; i < len; i++) {
                    var auxPath = path[i];
                    if (auxPath === "undefined") {
                        continue;
                    }
                    obj = auxPath;
                }
                return obj;
            },
            contains: function(searchElem, compareFunction) {
                var cmp = function(a, b) {
                    return a === b;
                }
                if (compareFunction && typeof(compareFunction) === "function") {
                    cmp = compareFunction;
                }
                for (var i = 0; i < this.data.length; i++) {
                    var elem = this.data[i];
                    if (cmp(searchElem, elem)) {
                        return true;
                    }
                }
                return false;
            },
            setLoading: function(loading) {
                this.loading = loading;
            },
            allowDrop: function(e) {
                console.log("drag!!!")
                e.preventDefault();
            },
            drop: function(e) {
                e.preventDefault();
                var data = JSON.parse(e.dataTransfer.getData("rowData"));
                this.push('data', data);
            },
            drag: function(e) {
                e.dataTransfer.setData("rowData", JSON.stringify(e.currentTarget._rowData));
            },
            handleLoading: function(neo, old) {},

            selectElem: function(elem, compareFunction) {

                var selected = null;

                for (var i = 0; i < this.viewData.length && selected == null; i++) {
                    var obj = this.viewData[i];
                    if (compareFunction(elem, obj)) {
                        selected = obj;
                    }
                }

                if (selected != null) {
                    this.selected = [selected];
                } else {
                    this._clearSelection();
                }

            },
            _callRemoteExport: function(url, callback) {
                var method = 'GET';
                if (typeof this.request.method !== 'undefined' && this.request.method != null) {
                    method = this.request.method;
                }
                var request = new XMLHttpRequest();
                request.onload = function() {
                    var contentType = this.getResponseHeader('Content-Type');
                    var resp;
                    if (contentType === 'application/json') {
                        resp = JSON.parse(this.response, this);
                    } else {
                        resp = this.response;
                    }
                    callback(resp)
                };
                request.onerror = function() {
                    //                args.request.error(this);
                };

                request.open(method, url, true);
                request.send();
                console.log(url)
            },
            handleExportCSVMenuButton: function(e) {

                e.stopPropagation();
                var me = this;

                var CSV = this.exportParsers.headerParser(this.columns);
                CSV += "\n";

                var data = (this.enableRemote) ? this.viewData : this.data;

                if (!this.enableRemote) {
                    for (var i = 0; i < data.length; i++) {
                        var row = data[i];
                        CSV += this.exportParsers.dataParser(this.columns, row);
                        CSV += "\n";
                    }
                    var blob = new Blob([CSV], {
                        type: "text/plain;charset=utf-8"
                    });

                    var initialFileName = 'data.csv';
                    var fileName = window.prompt("Please enter file name", initialFileName);
                    if (fileName != null && fileName != "") {
                        saveAs(blob, fileName);
                    }
                } else {
                    var skip = 0;
                    // var limit = this.exportParsers.chunkSize;
                    var dataElems = 0;
                    var limit = (this.itemCount <= this.exportParsers.maxLimit) ? this.itemCount : this.exportParsers.maxLimit;
                    // var limit = 500;
                    // var numTotalResults = this.itemCount;

                    var url = stv.utils.addQueryParamtersToUrl({
                        skip: skip,
                        limit: limit
                    }, this.request.url);

                    this._callRemoteExport(url, function(response) {
                        var data = me.request.parse(response);

                        for (var i = 0; i < data.length; i++) {
                            var row = data[i];
                            CSV += me.exportParsers.dataParser(me.columns, row);
                            CSV += "\n";
                        }
                        var blob = new Blob([CSV], {
                            type: "text/plain;charset=utf-8"
                        });

                        var initialFileName = 'data.csv';
                        var fileName = window.prompt("Please enter file name", initialFileName);
                        if (fileName != null && fileName != "") {
                            saveAs(blob, fileName);
                        }

                    });

                    // while (skip < numTotalResults) {
                    //
                    //     var url = stv.utils.addQueryParamtersToUrl({
                    //         skip: skip,
                    //         limit: limit
                    //
                    //     }, this.request.url);
                    //
                    //     this._callRemoteExport(url, function(response) {
                    //         var data = me.request.parse(response);
                    //         for (var i = 0; i < data.length; i++) {
                    //             var row = data[i];
                    //             CSV += me.exportParsers.dataParser(me.columns, data);
                    //             CSV += "\n";
                    //         }
                    //         console.log(skip);
                    //
                    //         if ((skip + limit) >= numTotalResults) {
                    //             var blob = new Blob([CSV], {
                    //                 type: "text/plain;charset=utf-8"
                    //             });
                    //
                    //             var initialFileName = 'data.csv';
                    //             // var fileName = window.prompt("Please enter file name", initialFileName);
                    //             // if (fileName != null && fileName != "") {
                    //               console.log("SAVEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE")
                    //                 // saveAs(blob, fileName);
                    //             // }
                    //         }
                    //     });
                    //     skip += limit;
                    // }
                }

            },
            exportToTable: function(start, end) {
                start = start || 0;
                end = end || this.data.length;

                var table = document.createElement("table");

                table.classList.add("stv-table");

                var thead = this._createTableHeader();

                var tbody = this._createTableBody(start, end);

                table.appendChild(thead);
                table.appendChild(tbody);
                return table;

            },
            _createTableHeader: function() {
                var thead = document.createElement("thead");
                thead.classList.add("stv-table");
                var tr = document.createElement("tr");
                tr.classList.add("stv-table");

                for (var i = 0; i < this.columns.length; i++) {
                    var column = this.columns[i];
                    if (column.visible !== false) {
                        this._createTableHeaderField(tr, column);
                    }
                }

                thead.appendChild(tr);
                return thead;
            },
            _createTableHeaderField: function(rowEl, column) {

                var th = document.createElement("th");
                th.classList.add("stv-table", ('column-' + column.name.replace(/\s/g, '_')));
                th.innerHTML = column.title;

                rowEl.appendChild(th);

            },

            _createTableBody: function(start, end) {

                var tbody = document.createElement("tbody");
                tbody.classList.add("stv-table");

                for (var i = start; this.data && i < end; i++) {
                    var rowData = this.data[i];
                    var elem = this._createTableRow(rowData);
                    tbody.appendChild(elem);
                }

                return tbody;

            },
            _createTableRow: function(rowData) {

                var tr = document.createElement("tr");
                tr.classList.add("stv-table");

                for (var i = 0; i < this.columns.length; i++) {
                    var column = this.columns[i];
                    if (column.visible !== false) {
                        this._createTableField(tr, column, rowData);
                    }
                }
                return tr;
            },
            _createTableField: function(tr, column, rowData) {
                var td = document.createElement("td");
                td.classList.add("stv-table");

                if (column.plainColumns.length > 0) {
                    for (var i = 0; i < column.plainColumns.length; i++) {
                        var c = column.plainColumns[i];
                        this._createTableTypeField(td, c, rowData, true);
                    }
                } else {
                    this._createTableTypeField(td, column, rowData);
                }

                tr.appendChild(td);
            },
            _createTableTypeField: function(el, column, rowData, isSubCol) {
                var me = this;
                var value;
                var defValue = column.defaultValue;

                if (column.formula) {
                    value = column.formula(rowData);
                } else {
                    if (isSubCol == true) {
                        value = this._deepValue(rowData, column.ak);
                    } else {
                        value = rowData[column.name];
                    }
                }

                // set empty string if no value found.
                value = (value == null) ? defValue : value;
                value = (value == null) ? '' : value;

                var cEl = document.createElement('div');
                cEl.classList.add('stv-table');
                if (isNaN(column.width)) {
                    cEl.classList.add('flex');
                } else {
                    cEl.style.width = column.width + "px";
                }
                cEl.innerHTML = value;
                //            if (!this.disableTooltip) {
                //                var tooltipValue = value;
                //                cEl.setAttribute("title", tooltipValue);
                //            }

                cEl.classList.add('column-' + column.name.replace(/\s/g, '_'));
                el.appendChild(cEl);

            }
        })
    </script>
</dom-module>

<dom-module id="stv-table-column-menu-item" assetpath="bower_components/stevia-elements/src/table/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning"></style>
    <style>

    </style>
    <template>
        <label class="stv-control">
            <input type="checkbox" checked$="{{isColumnVisible(column.visible)}}" on-click="handleColumnVisibilityClick">
            <span>{{column.title}}
                <template is="dom-if" if="{{column.columns}}">
                    ,<template is="dom-repeat" items="{{column.columns}}">
                        <stv-table-subcolum-name column="{{item}}"></stv-table-subcolum-name>
                    </template>
                </template>
            </span>
        </label>
    </template>
    <script>
        Polymer({
            is: 'stv-table-column-menu-item',
            properties: {
                column: {
                    type: Object
                }
            },
            handleColumnVisibilityClick: function(e) {
                this.set('column.visible', !this.column.visible);
                this.fire('column-toggle', this.column);
            },
            isColumnVisible: function(v) {
                return v !== false;
            },
        })
    </script>
</dom-module>

<dom-module id="stv-table-subcolum-name" assetpath="bower_components/stevia-elements/src/table/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning"></style>
    <template>
        {{column.title}}
        <template is="dom-repeat" items="{{column.columns}}">
            {{item.title}}
        </template>
    </template>
    <script>
        Polymer({
            is: 'stv-table-subcolum-name',
            properties: {
                column: {
                    type: Object
                }
            }
        })
    </script>
</dom-module>
<dom-module id="stv-form-box" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
         :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            margin: 7px 5px;
            box-shadow: 0 0 2px 0 rgba(0, 0, 0, 0.3);
        }

        #form {
            border: 1px solid rgba(125, 125, 125, 0.4);
            background-color: var(--text-primary-color);
        }

        #header {
            padding: 5px 10px;
            font-size: 15px;
            background-color: var(--light-secondary-color);
            color: var(--primary-text-color);
        }

         :host[collapsible] #header {
            cursor: pointer;
        }

         :host[collapsible] #header:hover {
            font-weight: bold;
            color: var(--dark-button-color);
        }

        #container {
            padding: 8px 10px;
            border-top: 1px solid rgba(125, 125, 125, 0.3);
        }

        .collapsible {
            padding: 0 2px;
            cursor: pointer;
        }

        .collapsible>i {
            color: var(--secondary-text-color);
            font-size: 12px;
        }

        .collapsible>i:hover {
            font-weight: bold;
            color: var(--dark-button-color);
        }

        .stv-note {
            margin: 20px;
        }

         :host.error {
            box-shadow: 0 0 8px 1px rgba(191, 71, 71, 1);
        }

         :host.error #header {
            color: #BF4747;
        }

         :host[disabled] .disabled {
            position: absolute;
            box-sizing: border-box;
            background-color: rgba(125, 125, 125, 0.3);
            width: 100%;
            height: 100%;
            top:0;
            left:0;
        }
    </style>
    <template>
        <div id="form">
            <div id="header" class="horizontal layout" on-click="handleCollapseAction">
                <div class="horizontal layout flex center">
                    <content select=".header"></content>
                </div>
                <div hidden$="{{!collapsible}}" class="collapsible">
                    <i class$="{{computeIcon(collapsible,collapsed)}}" title="{{computeTitle(collapsible,collapsed)}}"></i>
                </div>
            </div>
            <div id="container" class="horizontal layout" hidden$="{{isContainerHidden(collapsible, collapsed)}}">
                <content select=".container"></content>
            </div>

            <div id="error" class="stv-note stv-note-error" hidden$="{{hideErrors}}">
                <template is="dom-repeat" items="{{errors}}">
                    <div>{{item.msg}}</div>
                </template>
            </div>
        </div>
        <div class="disabled"></div>
    </template>

    <script>
        Polymer({
            is: "stv-form-box",
            properties: {
                collapsible: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                collapsed: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false,
                },
                disabled: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false,
                },
                errors: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                hideErrors: {
                    type: Boolean,
                    value: true

                }
            },
            observers: [
                "computeErrors(errors.splices)"
            ],
            ready: function() {

            },

            handleCollapseAction: function(e) {
                if (this.collapsible) {
                    this.collapsed = !this.collapsed;
                };
            },
            isContainerHidden: function(collapsible, collapsed) {
                if (collapsible && collapsed) {
                    return true;
                }
                return false;
            },
            computeIcon: function(collapsible, collapsed) {
                if (collapsible && collapsed) {
                    return "fa fa-plus";
                } else {
                    return "fa fa-minus";
                }
            },
            computeTitle: function(collapsible, collapsed) {
                if (collapsible && collapsed) {
                    return "Maximize";
                } else {
                    return "Minimize";
                }
            },
            addError: function(msg) {
                this.push('errors', {
                    msg: msg
                });
            },
            clearErrors: function() {
                this.set('errors', []);
            },
            computeErrors: function(errors) {
                if (errors) {
                    this.hideErrors = errors.length == 0;
                } else {
                    this.hideErrors = true;
                }

                if (!this.hideErrors) {
                    this.classList.add("error");
                } else {
                    this.classList.remove("error");
                }
            }
        })
    </script>
</dom-module>
<dom-module id="stv-tooltip" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: inline-block;
            position: relative;
            box-sizing: border-box;
            cursor: pointer;
        }

        #messageInfo {
            position: fixed;
            z-index: 200000;
            box-shadow: 0px 0px 10px 3px rgba(0, 0, 0, 0.30);
            min-width: 200px;
            min-height: 100px;
            margin: 0px;
            overflow-x: auto;
            overflow-y: auto;
        }

        .default {
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
            padding: 5px;
        }

        .dark {
            background-color: var(--dark-primary-color);
            color: var(--text-primary-color);
        }

        .closeInfo {
            position: absolute;
            top: 7px;
            right: 7px;
            cursor: pointer;
            color: var(--secondary-text-color);
        }

        .closeInfo:hover,
        .dark > .closeInfo:hover {
            color: var(--dark-button-color);
        }

        .dark > .closeInfo {
            color: var(--text-primary-color);
        }

        .info {
            color: #4790bf;
        }

        .warn {
            color: #bf9947;
        }

        .error {
            color: #bf4747;
        }

        .button {
            color: var(--button-style-color);
        }
    </style>
    <template>
        <span on-click="showInfo"><i on-click="showInfo" class$="button {{computeIcon(type, icon)}}"></i> {{text}}</span>
        <div id="messageInfo" class$="{{computeClass(type)}}" hidden="">
            <i class="fa fa-times closeInfo" on-click="handleClose"></i>
            <content></content>
        </div>

    </template>

    <script>
        Polymer({
            is: "stv-tooltip",
            properties: {
                type: {
                    type: String,
                    reflectToAttribute: true,
                    value: "default"
                },
                icon: {
                    type: String,
                    reflectToAttribute: true,
                    value: ""
                },
                text: {
                    type: String,
                    reflectToAttribute: true,
                    value: ""
                }
            },
            listeners: {
                click: 'showInfoThis'
            },
            showInfo: function(e) {
                e.stopPropagation();
                this.$.messageInfo.hidden = !this.$.messageInfo.hidden;
                this._getPosition();
                this.fire('tooltip-toggle', !this.$.messageInfo.hidden);
            },
            showInfoThis: function(e) {
                if (e.target === this) {
                    this.showInfo(e);
                }
            },
            _getPosition: function() {
                var bcr = this.getBoundingClientRect();
                var msg = this.$.messageInfo.getBoundingClientRect();
                var windowHeight = window.innerHeight;
                var windowWidth = window.innerWidth;

                this.$.messageInfo.style.top = (bcr.bottom) + 'px';
                this.$.messageInfo.style.left = (bcr.left) + 'px';
                if ((bcr.bottom + msg.height) > window.innerHeight) {
                    this.$.messageInfo.style.top = (bcr.top - msg.height) + 'px';
                }
                if ((bcr.right + msg.width) > window.innerWidth) {
                    this.$.messageInfo.style.left = (bcr.left - msg.width) + 'px';
                }

            },
            computeClass: function(type) {
                if (type == "info") {
                    return "stv-note stv-note-info";
                } else if (type == "warn") {
                    return "stv-note stv-note-warn";
                } else if (type == "error") {
                    return "stv-note stv-note-error";
                } else {
                    return type;
                }
            },
            computeIcon: function(type, icon) {
                if (icon != null && icon !== '') {
                    return 'fa fa-' + icon;
                } else {
                    if (type == "info") {
                        return "fa fa-info " + "info";
                    } else if (type == "warn") {
                        return "fa fa-exclamation-triangle " + "warn";
                    } else if (type == "error") {
                        return "fa fa-exclamation-circle " + "error";
                    }
                    return "fa fa-comment-o";
                }
            },
            handleClose: function(e) {
                e.stopPropagation();
                this.$.messageInfo.hidden = !this.$.messageInfo.hidden;
                this.fire('tooltip-toggle', !this.$.messageInfo.hidden);
            },

        })
    </script>
</dom-module>
<dom-module id="stv-wizard" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            height: 100%;
            width: 100%;
        }

        #wizard-content {
            height: 100%;
        }

        .container {
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .file {
            text-align: center;
            align-self: center;
            border-radius: 4px;
            width: 100px;
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
        }

        .file:hover {
            background-color: var(--light-button-color) !important;
        }

        .next,
        .prev {
            text-align: right;
            color: var(--dark-button-color);
            font-size: 15px;
            margin-right: 5px;
        }

        .init,
        .end {
            text-align: right;
            color: var(--dark-button-color);
            font-size: 15px;
            margin-right: 5px;
        }

        .next {
            margin-right: 15px;
        }

        .prev {
            margin-left: 15px;
        }

        .next:hover,
        .end:hover,
        .init:hover,
        .prev:hover {
            /*background-color: #d3d3d3;*/
            color: var(--accent-color);
            cursor: pointer;
            font-weight: bold;
        }

        #header {
            /*margin-bottom: 10px;*/
            box-sizing: border-box;
            height: 40px;
            padding: 7px 10px;
            background-color: var(--light-secondary-color);
            border-bottom: 1px solid var(--divider-color);
        }

        #container {
            height: calc(100% - 80px);
        }

        #footer {
            height: 40px;
            padding: 7px 10px;
            box-sizing: border-box;
        }

        #title {
            font-size: 20px;
            color: var(--default-primary-color);
        }

        #wizard-bottom {
            box-sizing: border-box;
            height: 40px;
            padding: 7px 10px;
            background-color: var(--light-secondary-color);
            border-top: 1px solid var(--divider-color);
        }

        #wizard-bottom > div {
            margin-left: 10px;
            width: 120px;
        }
    </style>
    <template>
        <div id="wizard-content">
            <div id="header" class="horizontal layout center">
                <div class="flex horizontal layout center start-justified">
                    <div class="init" on-click="handlegoToInit" hidden="{{!handleHiddenStep1(step)}}">
                        <i title="Go to Init" class="fa fa-fast-backward"></i>
                    </div>
                    <div hidden="{{handleHiddenStep1(step)}}"></div>
                    <div class="prev" on-click="handlePrevStepButton" hidden="{{!handleHiddenStep1(step)}}">
                        <i class="fa fa-step-backward"></i> Step {{stepPrev}}
                    </div>
                    <div class="flex" hidden="{{!handleHiddenStep1(step)}}"></div>
                </div>
                <div id="title" class="horizontal layout center">
                    Step {{step}} of {{steps.length}} : &nbsp;
                    <content select=".title"></content>
                </div>
                <div class="flex flex horizontal layout center end-justified">
                    <div class="next" on-click="handleNextStepButton" hidden="{{!handleHiddenStepEnd(step)}}">
                        Step {{stepNext}} <i class="fa fa-step-forward"></i>
                    </div>
                    <div hidden="{{handleHiddenStepEnd(step)}}"></div>
                    <div class="end" on-click="handlegoToEnd" hidden="{{!handleHiddenStepEnd(step)}}">
                        <i class="fa fa-fast-forward"></i>
                    </div>
                </div>
            </div>

            <div id="container" class="flex">
                <content class=".container"></content>
            </div>

            <div class="footer">
                <div id="wizard-bottom" class="horizontal layout end-justified">
                    <div class="stv-btn stv-btn-shdw file" on-click="handlePrevStepButton" hidden="{{!handleHiddenStep1(step)}}"><i class="fa fa-angle-double-left"></i>&nbsp; Previous
                    </div>
                    <div class="stv-btn stv-btn-shdw file" on-click="handleNextStepButton" hidden="{{!handleHiddenStepEnd(step)}}">Next &nbsp;<i class="fa fa-angle-double-right"></i>
                    </div>
                    <div hidden="{{handleHiddenStepEnd(step)}}"> &nbsp; </div>
                </div>
            </div>
        </div>

    </template>

    <script>
        Polymer({
            is: "stv-wizard",
            properties: {
                steps: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                step: {
                    type: Number,
                    value: 1,
                    observer: 'stepChanged'
                },
                stepsNames: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                stepName: {
                    type: Number,
                    value: 1,
                    observer: 'stepNameChanged'
                },
            },
            ready: function() {
                var steps = Polymer.dom(this).querySelectorAll('.step');
                var stepsNames = Polymer.dom(this).querySelectorAll('.stepName');

                this.set('steps', steps);
                this.stepChanged(1, 0);
                this.stepNext = 2;

                this.set('stepsNames', stepsNames);
                this.stepNameChanged(1, 0);
            },
            handleHiddenStep1: function(step) {
                return step != 1;
            },
            handleHiddenStepEnd: function(step) {
                return step != this.steps.length;
            },
            handlePrevStepButton: function(e) {
                this.step = (this.step <= 1) ? 1 : this.step - 1;
                console.log(this.step);
                this.stepName = (this.stepName <= 1) ? 1 : this.stepName - 1;
                console.log(this.stepName);
                this.stepNext = this.step + 1
                this.stepPrev = this.step - 1;
            },
            handleNextStepButton: function(e) {
                this.step = (this.step >= this.steps.length) ? this.steps.length : this.step + 1;
                this.stepName = (this.stepName >= this.stepsNames.length) ? this.stepsNames.length : this.stepName + 1;
                this.stepNext = this.step + 1
                this.stepPrev = this.step - 1;
            },
            stepChanged: function(neo, old) {
                if (this.steps && this.steps.length > 0) {

                    for (var i = 0; i < this.steps.length; i++) {
                        if ((i + 1) == neo) {
                            this.steps[i].hidden = false;

                        } else {
                            this.steps[i].hidden = true;
                        }
                    }

                }
            },
            stepNameChanged: function(neo, old) {
                if (this.stepsNames && this.stepsNames.length > 0) {

                    for (var i = 0; i < this.stepsNames.length; i++) {
                        if ((i + 1) == neo) {
                            this.stepsNames[i].hidden = false;

                        } else {
                            this.stepsNames[i].hidden = true;
                        }
                    }

                }
            },
            goToStep: function(step) {
                this.step = step;
                this.stepName = step;
                this.stepNext = step + 1;
                this.stepPrev = step - 1;
            },
            handlegoToInit: function() {
                this.goToStep(1);
            },
            handlegoToEnd: function() {
                this.goToStep(this.steps.length);
            },
            computeStepLength: function(steps) {
                return steps.length;
            }
        })
    </script>
</dom-module>
<dom-module id="stv-progress-bar" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            box-sizing: border-box;
            position: fixed;
            z-index: 100;
            box-shadow: 0px 0px 6px 3px rgba(0, 0, 0, 0.30);
            width: 500px;
            background-color: var(--light-secondary-color);
            top: 400px;
            left: 500px;
        }

        .bar {
            margin: 10px;
            position: relative;
            height: 10px;
            width: 475px;
            border: 1px solid var(--divider-color);
            background-color: var(--text-primary-color);
            line-height: 20px;
        }

        #progressBar {
            transition: width 0.5s;
            position: absolute;
            top: 0px;
            left: 0px;
            height: 100%;
            width: 100%;
            background-color: var(--light-button-color);
        }

        .percent {
            height: 30px;
            position: relative;
            text-align: right;
            margin-right: 15px;
        }

        .text {
            text-align: center;
            height: 30px;
            margin: 10px;
            font-size: 16px;
            color: var(--primary-text-color);
        }
    </style>
    <template>
        <div class="text">{{text}}</div>
        <div class="bar">
            <div id="progressBar"></div>
        </div>
        <div class="percent">
            <i class="fa fa-spinner fa-spin"></i>
            <span>{{percent}}</span> %
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "stv-progress-bar",
        properties: {
            percent: {
                type: Number,
                value: 0,
                reflectToAttribute: true,
                observer: 'progressChange'
            },
            text: {
                type: String,
                reflectToAttribute: true,
                value: ""
            }
        },
        progressChange: function(neo, old) {
            this.$.progressBar.style.width = neo + '%';
        }
    });
</script>
<script>
  (function() {
    'use strict';

    /**
     * Chrome uses an older version of DOM Level 3 Keyboard Events
     *
     * Most keys are labeled as text, but some are Unicode codepoints.
     * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
     */
    var KEY_IDENTIFIER = {
      'U+0008': 'backspace',
      'U+0009': 'tab',
      'U+001B': 'esc',
      'U+0020': 'space',
      'U+007F': 'del'
    };

    /**
     * Special table for KeyboardEvent.keyCode.
     * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
     * than that.
     *
     * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
     */
    var KEY_CODE = {
      8: 'backspace',
      9: 'tab',
      13: 'enter',
      27: 'esc',
      33: 'pageup',
      34: 'pagedown',
      35: 'end',
      36: 'home',
      32: 'space',
      37: 'left',
      38: 'up',
      39: 'right',
      40: 'down',
      46: 'del',
      106: '*'
    };

    /**
     * MODIFIER_KEYS maps the short name for modifier keys used in a key
     * combo string to the property name that references those same keys
     * in a KeyboardEvent instance.
     */
    var MODIFIER_KEYS = {
      'shift': 'shiftKey',
      'ctrl': 'ctrlKey',
      'alt': 'altKey',
      'meta': 'metaKey'
    };

    /**
     * KeyboardEvent.key is mostly represented by printable character made by
     * the keyboard, with unprintable keys labeled nicely.
     *
     * However, on OS X, Alt+char can make a Unicode character that follows an
     * Apple-specific mapping. In this case, we fall back to .keyCode.
     */
    var KEY_CHAR = /[a-z0-9*]/;

    /**
     * Matches a keyIdentifier string.
     */
    var IDENT_CHAR = /U\+/;

    /**
     * Matches arrow keys in Gecko 27.0+
     */
    var ARROW_KEY = /^arrow/;

    /**
     * Matches space keys everywhere (notably including IE10's exceptional name
     * `spacebar`).
     */
    var SPACE_KEY = /^space(bar)?/;

    /**
     * Matches ESC key.
     *
     * Value from: http://w3c.github.io/uievents-key/#key-Escape
     */
    var ESC_KEY = /^escape$/;

    /**
     * Transforms the key.
     * @param {string} key The KeyBoardEvent.key
     * @param {Boolean} [noSpecialChars] Limits the transformation to
     * alpha-numeric characters.
     */
    function transformKey(key, noSpecialChars) {
      var validKey = '';
      if (key) {
        var lKey = key.toLowerCase();
        if (lKey === ' ' || SPACE_KEY.test(lKey)) {
          validKey = 'space';
        } else if (ESC_KEY.test(lKey)) {
          validKey = 'esc';
        } else if (lKey.length == 1) {
          if (!noSpecialChars || KEY_CHAR.test(lKey)) {
            validKey = lKey;
          }
        } else if (ARROW_KEY.test(lKey)) {
          validKey = lKey.replace('arrow', '');
        } else if (lKey == 'multiply') {
          // numpad '*' can map to Multiply on IE/Windows
          validKey = '*';
        } else {
          validKey = lKey;
        }
      }
      return validKey;
    }

    function transformKeyIdentifier(keyIdent) {
      var validKey = '';
      if (keyIdent) {
        if (keyIdent in KEY_IDENTIFIER) {
          validKey = KEY_IDENTIFIER[keyIdent];
        } else if (IDENT_CHAR.test(keyIdent)) {
          keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
          validKey = String.fromCharCode(keyIdent).toLowerCase();
        } else {
          validKey = keyIdent.toLowerCase();
        }
      }
      return validKey;
    }

    function transformKeyCode(keyCode) {
      var validKey = '';
      if (Number(keyCode)) {
        if (keyCode >= 65 && keyCode <= 90) {
          // ascii a-z
          // lowercase is 32 offset from uppercase
          validKey = String.fromCharCode(32 + keyCode);
        } else if (keyCode >= 112 && keyCode <= 123) {
          // function keys f1-f12
          validKey = 'f' + (keyCode - 112);
        } else if (keyCode >= 48 && keyCode <= 57) {
          // top 0-9 keys
          validKey = String(keyCode - 48);
        } else if (keyCode >= 96 && keyCode <= 105) {
          // num pad 0-9
          validKey = String(keyCode - 96);
        } else {
          validKey = KEY_CODE[keyCode];
        }
      }
      return validKey;
    }

    /**
      * Calculates the normalized key for a KeyboardEvent.
      * @param {KeyboardEvent} keyEvent
      * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
      * transformation to alpha-numeric chars. This is useful with key
      * combinations like shift + 2, which on FF for MacOS produces
      * keyEvent.key = @
      * To get 2 returned, set noSpecialChars = true
      * To get @ returned, set noSpecialChars = false
     */
    function normalizedKeyForEvent(keyEvent, noSpecialChars) {
      // Fall back from .key, to .detail.key for artifical keyboard events,
      // and then to deprecated .keyIdentifier and .keyCode.
      if (keyEvent.key) {
        return transformKey(keyEvent.key, noSpecialChars);
      }
      if (keyEvent.detail && keyEvent.detail.key) {
        return transformKey(keyEvent.detail.key, noSpecialChars);
      }
      return transformKeyIdentifier(keyEvent.keyIdentifier) ||
        transformKeyCode(keyEvent.keyCode) || '';
    }

    function keyComboMatchesEvent(keyCombo, event) {
      // For combos with modifiers we support only alpha-numeric keys
      var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
      return keyEvent === keyCombo.key &&
        (!keyCombo.hasModifiers || (
          !!event.shiftKey === !!keyCombo.shiftKey &&
          !!event.ctrlKey === !!keyCombo.ctrlKey &&
          !!event.altKey === !!keyCombo.altKey &&
          !!event.metaKey === !!keyCombo.metaKey)
        );
    }

    function parseKeyComboString(keyComboString) {
      if (keyComboString.length === 1) {
        return {
          combo: keyComboString,
          key: keyComboString,
          event: 'keydown'
        };
      }
      return keyComboString.split('+').reduce(function(parsedKeyCombo, keyComboPart) {
        var eventParts = keyComboPart.split(':');
        var keyName = eventParts[0];
        var event = eventParts[1];

        if (keyName in MODIFIER_KEYS) {
          parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
          parsedKeyCombo.hasModifiers = true;
        } else {
          parsedKeyCombo.key = keyName;
          parsedKeyCombo.event = event || 'keydown';
        }

        return parsedKeyCombo;
      }, {
        combo: keyComboString.split(':').shift()
      });
    }

    function parseEventString(eventString) {
      return eventString.trim().split(' ').map(function(keyComboString) {
        return parseKeyComboString(keyComboString);
      });
    }

    /**
     * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
     * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
     * The element takes care of browser differences with respect to Keyboard events
     * and uses an expressive syntax to filter key presses.
     *
     * Use the `keyBindings` prototype property to express what combination of keys
     * will trigger the callback. A key binding has the format
     * `"KEY+MODIFIER:EVENT": "callback"` (`"KEY": "callback"` or
     * `"KEY:EVENT": "callback"` are valid as well). Some examples:
     *
     *      keyBindings: {
     *        'space': '_onKeydown', // same as 'space:keydown'
     *        'shift+tab': '_onKeydown',
     *        'enter:keypress': '_onKeypress',
     *        'esc:keyup': '_onKeyup'
     *      }
     *
     * The callback will receive with an event containing the following information in `event.detail`:
     *
     *      _onKeydown: function(event) {
     *        console.log(event.detail.combo); // KEY+MODIFIER, e.g. "shift+tab"
     *        console.log(event.detail.key); // KEY only, e.g. "tab"
     *        console.log(event.detail.event); // EVENT, e.g. "keydown"
     *        console.log(event.detail.keyboardEvent); // the original KeyboardEvent
     *      }
     *
     * Use the `keyEventTarget` attribute to set up event handlers on a specific
     * node.
     *
     * See the [demo source code](https://github.com/PolymerElements/iron-a11y-keys-behavior/blob/master/demo/x-key-aware.html)
     * for an example.
     *
     * @demo demo/index.html
     * @polymerBehavior
     */
    Polymer.IronA11yKeysBehavior = {
      properties: {
        /**
         * The EventTarget that will be firing relevant KeyboardEvents. Set it to
         * `null` to disable the listeners.
         * @type {?EventTarget}
         */
        keyEventTarget: {
          type: Object,
          value: function() {
            return this;
          }
        },

        /**
         * If true, this property will cause the implementing element to
         * automatically stop propagation on any handled KeyboardEvents.
         */
        stopKeyboardEventPropagation: {
          type: Boolean,
          value: false
        },

        _boundKeyHandlers: {
          type: Array,
          value: function() {
            return [];
          }
        },

        // We use this due to a limitation in IE10 where instances will have
        // own properties of everything on the "prototype".
        _imperativeKeyBindings: {
          type: Object,
          value: function() {
            return {};
          }
        }
      },

      observers: [
        '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
      ],


      /**
       * To be used to express what combination of keys  will trigger the relative
       * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
       * @type {!Object}
       */
      keyBindings: {},

      registered: function() {
        this._prepKeyBindings();
      },

      attached: function() {
        this._listenKeyEventListeners();
      },

      detached: function() {
        this._unlistenKeyEventListeners();
      },

      /**
       * Can be used to imperatively add a key binding to the implementing
       * element. This is the imperative equivalent of declaring a keybinding
       * in the `keyBindings` prototype property.
       */
      addOwnKeyBinding: function(eventString, handlerName) {
        this._imperativeKeyBindings[eventString] = handlerName;
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      /**
       * When called, will remove all imperatively-added key bindings.
       */
      removeOwnKeyBindings: function() {
        this._imperativeKeyBindings = {};
        this._prepKeyBindings();
        this._resetKeyEventListeners();
      },

      /**
       * Returns true if a keyboard event matches `eventString`.
       *
       * @param {KeyboardEvent} event
       * @param {string} eventString
       * @return {boolean}
       */
      keyboardEventMatchesKeys: function(event, eventString) {
        var keyCombos = parseEventString(eventString);
        for (var i = 0; i < keyCombos.length; ++i) {
          if (keyComboMatchesEvent(keyCombos[i], event)) {
            return true;
          }
        }
        return false;
      },

      _collectKeyBindings: function() {
        var keyBindings = this.behaviors.map(function(behavior) {
          return behavior.keyBindings;
        });

        if (keyBindings.indexOf(this.keyBindings) === -1) {
          keyBindings.push(this.keyBindings);
        }

        return keyBindings;
      },

      _prepKeyBindings: function() {
        this._keyBindings = {};

        this._collectKeyBindings().forEach(function(keyBindings) {
          for (var eventString in keyBindings) {
            this._addKeyBinding(eventString, keyBindings[eventString]);
          }
        }, this);

        for (var eventString in this._imperativeKeyBindings) {
          this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
        }

        // Give precedence to combos with modifiers to be checked first.
        for (var eventName in this._keyBindings) {
          this._keyBindings[eventName].sort(function (kb1, kb2) {
            var b1 = kb1[0].hasModifiers;
            var b2 = kb2[0].hasModifiers;
            return (b1 === b2) ? 0 : b1 ? -1 : 1;
          })
        }
      },

      _addKeyBinding: function(eventString, handlerName) {
        parseEventString(eventString).forEach(function(keyCombo) {
          this._keyBindings[keyCombo.event] =
            this._keyBindings[keyCombo.event] || [];

          this._keyBindings[keyCombo.event].push([
            keyCombo,
            handlerName
          ]);
        }, this);
      },

      _resetKeyEventListeners: function() {
        this._unlistenKeyEventListeners();

        if (this.isAttached) {
          this._listenKeyEventListeners();
        }
      },

      _listenKeyEventListeners: function() {
        if (!this.keyEventTarget) {
          return;
        }
        Object.keys(this._keyBindings).forEach(function(eventName) {
          var keyBindings = this._keyBindings[eventName];
          var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

          this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

          this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
        }, this);
      },

      _unlistenKeyEventListeners: function() {
        var keyHandlerTuple;
        var keyEventTarget;
        var eventName;
        var boundKeyHandler;

        while (this._boundKeyHandlers.length) {
          // My kingdom for block-scope binding and destructuring assignment..
          keyHandlerTuple = this._boundKeyHandlers.pop();
          keyEventTarget = keyHandlerTuple[0];
          eventName = keyHandlerTuple[1];
          boundKeyHandler = keyHandlerTuple[2];

          keyEventTarget.removeEventListener(eventName, boundKeyHandler);
        }
      },

      _onKeyBindingEvent: function(keyBindings, event) {
        if (this.stopKeyboardEventPropagation) {
          event.stopPropagation();
        }

        // if event has been already prevented, don't do anything
        if (event.defaultPrevented) {
          return;
        }

        for (var i = 0; i < keyBindings.length; i++) {
          var keyCombo = keyBindings[i][0];
          var handlerName = keyBindings[i][1];
          if (keyComboMatchesEvent(keyCombo, event)) {
            this._triggerKeyHandler(keyCombo, handlerName, event);
            // exit the loop if eventDefault was prevented
            if (event.defaultPrevented) {
              return;
            }
          }
        }
      },

      _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
        var detail = Object.create(keyCombo);
        detail.keyboardEvent = keyboardEvent;
        var event = new CustomEvent(keyCombo.event, {
          detail: detail,
          cancelable: true
        });
        this[handlerName].call(this, event);
        if (event.defaultPrevented) {
          keyboardEvent.preventDefault();
        }
      }
    };
  })();
</script>
<script>

  /**
   * `Polymer.IronScrollTargetBehavior` allows an element to respond to scroll events from a
   * designated scroll target.
   *
   * Elements that consume this behavior can override the `_scrollHandler`
   * method to add logic on the scroll event.
   *
   * @demo demo/scrolling-region.html Scrolling Region
   * @demo demo/document.html Document Element
   * @polymerBehavior
   */
  Polymer.IronScrollTargetBehavior = {

    properties: {

      /**
       * Specifies the element that will handle the scroll event
       * on the behalf of the current element. This is typically a reference to an element,
       * but there are a few more posibilities:
       *
       * ### Elements id
       *
       *```html
       * <div id="scrollable-element" style="overflow: auto;">
       *  <x-element scroll-target="scrollable-element">
       *    <!-- Content-->
       *  </x-element>
       * </div>
       *```
       * In this case, the `scrollTarget` will point to the outer div element.
       *
       * ### Document scrolling
       *
       * For document scrolling, you can use the reserved word `document`:
       *
       *```html
       * <x-element scroll-target="document">
       *   <!-- Content -->
       * </x-element>
       *```
       *
       * ### Elements reference
       *
       *```js
       * appHeader.scrollTarget = document.querySelector('#scrollable-element');
       *```
       *
       * @type {HTMLElement}
       */
      scrollTarget: {
        type: HTMLElement,
        value: function() {
          return this._defaultScrollTarget;
        }
      }
    },

    observers: [
      '_scrollTargetChanged(scrollTarget, isAttached)'
    ],

    /**
     * True if the event listener should be installed.
     */
    _shouldHaveListener: true,

    _scrollTargetChanged: function(scrollTarget, isAttached) {
      var eventTarget;

      if (this._oldScrollTarget) {
        this._toggleScrollListener(false, this._oldScrollTarget);
        this._oldScrollTarget = null;
      }
      if (!isAttached) {
        return;
      }
      // Support element id references
      if (scrollTarget === 'document') {

        this.scrollTarget = this._doc;

      } else if (typeof scrollTarget === 'string') {

        this.scrollTarget = this.domHost ? this.domHost.$[scrollTarget] :
            Polymer.dom(this.ownerDocument).querySelector('#' + scrollTarget);

      } else if (this._isValidScrollTarget()) {

        this._boundScrollHandler = this._boundScrollHandler || this._scrollHandler.bind(this);
        this._oldScrollTarget = scrollTarget;
        this._toggleScrollListener(this._shouldHaveListener, scrollTarget);

      }
    },

    /**
     * Runs on every scroll event. Consumer of this behavior may override this method.
     *
     * @protected
     */
    _scrollHandler: function scrollHandler() {},

    /**
     * The default scroll target. Consumers of this behavior may want to customize
     * the default scroll target.
     *
     * @type {Element}
     */
    get _defaultScrollTarget() {
      return this._doc;
    },

    /**
     * Shortcut for the document element
     *
     * @type {Element}
     */
    get _doc() {
      return this.ownerDocument.documentElement;
    },

    /**
     * Gets the number of pixels that the content of an element is scrolled upward.
     *
     * @type {number}
     */
    get _scrollTop() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.pageYOffset : this.scrollTarget.scrollTop;
      }
      return 0;
    },

    /**
     * Gets the number of pixels that the content of an element is scrolled to the left.
     *
     * @type {number}
     */
    get _scrollLeft() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.pageXOffset : this.scrollTarget.scrollLeft;
      }
      return 0;
    },

    /**
     * Sets the number of pixels that the content of an element is scrolled upward.
     *
     * @type {number}
     */
    set _scrollTop(top) {
      if (this.scrollTarget === this._doc) {
        window.scrollTo(window.pageXOffset, top);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollTop = top;
      }
    },

    /**
     * Sets the number of pixels that the content of an element is scrolled to the left.
     *
     * @type {number}
     */
    set _scrollLeft(left) {
      if (this.scrollTarget === this._doc) {
        window.scrollTo(left, window.pageYOffset);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollLeft = left;
      }
    },

    /**
     * Scrolls the content to a particular place.
     *
     * @method scroll
     * @param {number} left The left position
     * @param {number} top The top position
     */
    scroll: function(left, top) {
       if (this.scrollTarget === this._doc) {
        window.scrollTo(left, top);
      } else if (this._isValidScrollTarget()) {
        this.scrollTarget.scrollLeft = left;
        this.scrollTarget.scrollTop = top;
      }
    },

    /**
     * Gets the width of the scroll target.
     *
     * @type {number}
     */
    get _scrollTargetWidth() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.innerWidth : this.scrollTarget.offsetWidth;
      }
      return 0;
    },

    /**
     * Gets the height of the scroll target.
     *
     * @type {number}
     */
    get _scrollTargetHeight() {
      if (this._isValidScrollTarget()) {
        return this.scrollTarget === this._doc ? window.innerHeight : this.scrollTarget.offsetHeight;
      }
      return 0;
    },

    /**
     * Returns true if the scroll target is a valid HTMLElement.
     *
     * @return {boolean}
     */
    _isValidScrollTarget: function() {
      return this.scrollTarget instanceof HTMLElement;
    },

    _toggleScrollListener: function(yes, scrollTarget) {
      if (!this._boundScrollHandler) {
        return;
      }
      var eventTarget = scrollTarget === this._doc ? window : scrollTarget;

      if (yes) {
        eventTarget.addEventListener('scroll', this._boundScrollHandler);
      } else {
        eventTarget.removeEventListener('scroll', this._boundScrollHandler);
      }
    },

    /**
     * Enables or disables the scroll event listener.
     *
     * @param {boolean} yes True to add the event, False to remove it.
     */
    toggleScrollListener: function(yes) {
      this._shouldHaveListener = yes;
      this._toggleScrollListener(yes, this.scrollTarget);
    }

  };

</script>


<dom-module id="iron-list" assetpath="bower_components/iron-list/">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      @media only screen and (-webkit-max-device-pixel-ratio: 1) {
        :host {
          will-change: transform;
        }
      }

      #items {
        @apply(--iron-list-items-container);
        position: relative;
      }

      :host(:not([grid])) #items > ::content > * {
        width: 100%;
      };

      #items > ::content > * {
        box-sizing: border-box;
        margin: 0;
        position: absolute;
        top: 0;
        will-change: transform;
      }
    </style>

    <array-selector id="selector" items="{{items}}" selected="{{selectedItems}}" selected-item="{{selectedItem}}">
    </array-selector>

    <div id="items">
      <content></content>
    </div>

  </template>
</dom-module>

<script>

(function() {

  var IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
  var IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
  var DEFAULT_PHYSICAL_COUNT = 3;
  var HIDDEN_Y = '-10000px';
  var ITEM_WIDTH = 0;
  var ITEM_HEIGHT = 1;
  var SECRET_TABINDEX = -100;

  Polymer({

    is: 'iron-list',

    properties: {

      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The max count of physical items the pool can extend to.
       */
      maxPhysicalCount: {
        type: Number,
        value: 500
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * for the row.
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * The name of the variable to add to the binding scope to indicate
       * if the row is selected.
       */
      selectedAs: {
        type: String,
        value: 'selected'
      },

      /**
       * When true, the list is rendered as a grid. Grid items must have
       * fixed width and height set via CSS. e.g.
       *
       * ```html
       * <iron-list grid>
       *   <template>
       *      <div style="width: 100px; height: 100px;"> 100x100 </div>
       *   </template>
       * </iron-list>
       * ```
       */
      grid: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * When true, tapping a row will select the item, placing its data model
       * in the set of selected items retrievable via the selection property.
       *
       * Note that tapping focusable elements within the list item will not
       * result in selection, since they are presumed to have their * own action.
       */
      selectionEnabled: {
        type: Boolean,
        value: false
      },

      /**
       * When `multiSelection` is false, this is the currently selected item, or `null`
       * if no item is selected.
       */
      selectedItem: {
        type: Object,
        notify: true
      },

      /**
       * When `multiSelection` is true, this is an array that contains the selected items.
       */
      selectedItems: {
        type: Object,
        notify: true
      },

      /**
       * When `true`, multiple items may be selected at once (in this case,
       * `selected` is an array of currently selected items).  When `false`,
       * only one item may be selected at a time.
       */
      multiSelection: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_itemsChanged(items.*)',
      '_selectionEnabledChanged(selectionEnabled)',
      '_multiSelectionChanged(multiSelection)',
      '_setOverflow(scrollTarget)'
    ],

    behaviors: [
      Polymer.Templatizer,
      Polymer.IronResizableBehavior,
      Polymer.IronA11yKeysBehavior,
      Polymer.IronScrollTargetBehavior
    ],

    keyBindings: {
      'up': '_didMoveUp',
      'down': '_didMoveDown',
      'enter': '_didEnter'
    },

    /**
     * The ratio of hidden tiles that should remain in the scroll direction.
     * Recommended value ~0.5, so it will distribute tiles evely in both directions.
     */
    _ratio: 0.5,

    /**
     * The padding-top value for the list.
     */
    _scrollerPaddingTop: 0,

    /**
     * This value is the same as `scrollTop`.
     */
    _scrollPosition: 0,

    /**
     * The sum of the heights of all the tiles in the DOM.
     */
    _physicalSize: 0,

    /**
     * The average `offsetHeight` of the tiles observed till now.
     */
    _physicalAverage: 0,

    /**
     * The number of tiles which `offsetHeight` > 0 observed until now.
     */
    _physicalAverageCount: 0,

    /**
     * The Y position of the item rendered in the `_physicalStart`
     * tile relative to the scrolling list.
     */
    _physicalTop: 0,

    /**
     * The number of items in the list.
     */
    _virtualCount: 0,

    /**
     * A map between an item key and its physical item index
     */
    _physicalIndexForKey: null,

    /**
     * The estimated scroll height based on `_physicalAverage`
     */
    _estScrollHeight: 0,

    /**
     * The scroll height of the dom node
     */
    _scrollHeight: 0,

    /**
     * The height of the list. This is referred as the viewport in the context of list.
     */
    _viewportHeight: 0,

    /**
     * The width of the list. This is referred as the viewport in the context of list.
     */
    _viewportWidth: 0,

    /**
     * An array of DOM nodes that are currently in the tree
     * @type {?Array<!TemplatizerNode>}
     */
    _physicalItems: null,

    /**
     * An array of heights for each item in `_physicalItems`
     * @type {?Array<number>}
     */
    _physicalSizes: null,

    /**
     * A cached value for the first visible index.
     * See `firstVisibleIndex`
     * @type {?number}
     */
    _firstVisibleIndexVal: null,

    /**
     * A cached value for the last visible index.
     * See `lastVisibleIndex`
     * @type {?number}
     */
    _lastVisibleIndexVal: null,

    /**
     * A Polymer collection for the items.
     * @type {?Polymer.Collection}
     */
    _collection: null,

    /**
     * The max number of pages to render. One page is equivalent to the height of the list.
     */
    _maxPages: 2,

    /**
     * The currently focused physical item.
     */
    _focusedItem: null,

    /**
     * The index of the `_focusedItem`.
     */
    _focusedIndex: -1,

    /**
     * The the item that is focused if it is moved offscreen.
     * @private {?TemplatizerNode}
     */
    _offscreenFocusedItem: null,

    /**
     * The item that backfills the `_offscreenFocusedItem` in the physical items
     * list when that item is moved offscreen.
     */
    _focusBackfillItem: null,

    /**
     * The maximum items per row
     */
    _itemsPerRow: 1,

    /**
     * The width of each grid item
     */
    _itemWidth: 0,

    /**
     * The height of the row in grid layout.
     */
    _rowHeight: 0,

    /**
     * The cost of stamping a template in ms.
     */
    _templateCost: 0,

    /**
     * The bottom of the physical content.
     */
    get _physicalBottom() {
      return this._physicalTop + this._physicalSize;
    },

    /**
     * The bottom of the scroll.
     */
    get _scrollBottom() {
      return this._scrollPosition + this._viewportHeight;
    },

    /**
     * The n-th item rendered in the last physical item.
     */
    get _virtualEnd() {
      return this._virtualStart + this._physicalCount - 1;
    },

    /**
     * The height of the physical content that isn't on the screen.
     */
    get _hiddenContentSize() {
      var size = this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;
      return size - this._viewportHeight;
    },

    /**
     * The maximum scroll top value.
     */
    get _maxScrollTop() {
      return this._estScrollHeight - this._viewportHeight + this._scrollerPaddingTop;
    },

    /**
     * The lowest n-th value for an item such that it can be rendered in `_physicalStart`.
     */
    _minVirtualStart: 0,

    /**
     * The largest n-th value for an item such that it can be rendered in `_physicalStart`.
     */
    get _maxVirtualStart() {
      return Math.max(0, this._virtualCount - this._physicalCount);
    },

    /**
     * The n-th item rendered in the `_physicalStart` tile.
     */
    _virtualStartVal: 0,

    set _virtualStart(val) {
      this._virtualStartVal = Math.min(this._maxVirtualStart, Math.max(this._minVirtualStart, val));
    },

    get _virtualStart() {
      return this._virtualStartVal || 0;
    },

    /**
     * The k-th tile that is at the top of the scrolling list.
     */
    _physicalStartVal: 0,

    set _physicalStart(val) {
      this._physicalStartVal = val % this._physicalCount;
      if (this._physicalStartVal < 0) {
        this._physicalStartVal = this._physicalCount + this._physicalStartVal;
      }
      this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
    },

    get _physicalStart() {
      return this._physicalStartVal || 0;
    },

    /**
     * The number of tiles in the DOM.
     */
    _physicalCountVal: 0,

    set _physicalCount(val) {
      this._physicalCountVal = val;
      this._physicalEnd = (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
    },

    get _physicalCount() {
      return this._physicalCountVal;
    },

    /**
     * The k-th tile that is at the bottom of the scrolling list.
     */
    _physicalEnd: 0,

    /**
     * An optimal physical size such that we will have enough physical items
     * to fill up the viewport and recycle when the user scrolls.
     *
     * This default value assumes that we will at least have the equivalent
     * to a viewport of physical items above and below the user's viewport.
     */
    get _optPhysicalSize() {
      if (this.grid) {
        return this._estRowsInView * this._rowHeight * this._maxPages;
      }
      return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;
    },

   /**
    * True if the current list is visible.
    */
    get _isVisible() {
      return Boolean(this.offsetWidth || this.offsetHeight);
    },

    /**
     * Gets the index of the first visible item in the viewport.
     *
     * @type {number}
     */
    get firstVisibleIndex() {
      if (this._firstVisibleIndexVal === null) {
        var physicalOffset = Math.floor(this._physicalTop + this._scrollerPaddingTop);

        this._firstVisibleIndexVal = this._iterateItems(
          function(pidx, vidx) {
            physicalOffset += this._getPhysicalSizeIncrement(pidx);

            if (physicalOffset > this._scrollPosition) {
              return this.grid ? vidx - (vidx % this._itemsPerRow) : vidx;
            }
            // Handle a partially rendered final row in grid mode
            if (this.grid && this._virtualCount - 1 === vidx) {
              return vidx - (vidx % this._itemsPerRow);
            }
          }) || 0;
      }
      return this._firstVisibleIndexVal;
    },

    /**
     * Gets the index of the last visible item in the viewport.
     *
     * @type {number}
     */
    get lastVisibleIndex() {
      if (this._lastVisibleIndexVal === null) {
        if (this.grid) {
          var lastIndex = this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow - 1;
          this._lastVisibleIndexVal = Math.min(this._virtualCount, lastIndex);
        } else {
          var physicalOffset = this._physicalTop;
          this._iterateItems(function(pidx, vidx) {
            if (physicalOffset < this._scrollBottom) {
              this._lastVisibleIndexVal = vidx;
            } else {
              // Break _iterateItems
              return true;
            }
            physicalOffset += this._getPhysicalSizeIncrement(pidx);
          });
        }
      }
      return this._lastVisibleIndexVal;
    },

    get _defaultScrollTarget() {
      return this;
    },

    get _virtualRowCount() {
      return Math.ceil(this._virtualCount / this._itemsPerRow);
    },

    get _estRowsInView() {
      return Math.ceil(this._viewportHeight / this._rowHeight);
    },

    get _physicalRows() {
      return Math.ceil(this._physicalCount / this._itemsPerRow);
    },

    ready: function() {
      this.addEventListener('focus', this._didFocus.bind(this), true);
    },

    attached: function() {
      if (this._physicalCount === 0) {
        this._debounceTemplate(this._render);
      }
      // `iron-resize` is fired when the list is attached if the event is added
      // before attached causing unnecessary work.
      this.listen(this, 'iron-resize', '_resizeHandler');
    },

    detached: function() {
      this.unlisten(this, 'iron-resize', '_resizeHandler');
    },

    /**
     * Set the overflow property if this element has its own scrolling region
     */
    _setOverflow: function(scrollTarget) {
      this.style.webkitOverflowScrolling = scrollTarget === this ? 'touch' : '';
      this.style.overflow = scrollTarget === this ? 'auto' : '';
    },

    /**
     * Invoke this method if you dynamically update the viewport's
     * size or CSS padding.
     *
     * @method updateViewportBoundaries
     */
    updateViewportBoundaries: function() {
      this._scrollerPaddingTop = this.scrollTarget === this ? 0 :
          parseInt(window.getComputedStyle(this)['padding-top'], 10);
      this._viewportWidth = this.$.items.offsetWidth;
      this._viewportHeight = this._scrollTargetHeight;
      this.grid && this._updateGridMetrics();
    },

    /**
     * Recycles the physical items when needed.
     */
    _scrollHandler: function() {
      var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
      var delta = scrollTop - this._scrollPosition;
      var isScrollingDown = delta >= 0;
      // Track the current scroll position.
      this._scrollPosition = scrollTop;
      // Clear indexes.
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;

      // Random access.
      if (Math.abs(delta) > this._physicalSize) {
        var idxAdjustment =  Math.round(delta / this._physicalAverage) * this._itemsPerRow
        this._physicalTop = this._physicalTop + delta;
        this._virtualStart = this._virtualStart + idxAdjustment;
        this._physicalStart = this._physicalStart + idxAdjustment;
        this._update();
      } else {
        var reusables = this._getReusables(isScrollingDown);
        if (isScrollingDown) {
          this._physicalTop = reusables.physicalTop;
          this._virtualStart = this._virtualStart + reusables.indexes.length;
          this._physicalStart = this._physicalStart + reusables.indexes.length;
        } else {
          this._virtualStart = this._virtualStart - reusables.indexes.length;
          this._physicalStart = this._physicalStart - reusables.indexes.length;
        }
        if (reusables.indexes.length === 0) {
          this._increasePoolIfNeeded();
        } else {
          this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);
        }
      }
    },

    /**
     * Returns an object that contains the indexes of the physical items
     * that might be reused and the physicalTop.
     *
     * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
     */
    _getReusables: function(fromTop) {
      var ith, lastIth, offsetContent, physicalItemHeight;
      var idxs = [];
      var protectedOffsetContent = this._hiddenContentSize * this._ratio;
      var virtualStart = this._virtualStart;
      var virtualEnd = this._virtualEnd;
      var physicalCount = this._physicalCount;
      var physicalTop = this._physicalTop + this._scrollerPaddingTop;
      var scrollTop = this._scrollTop;
      var scrollBottom = this._scrollBottom;

      if (fromTop) {
        ith = this._physicalStart;
        lastIth = this._physicalEnd;
        offsetContent = scrollTop - physicalTop;
      } else {
        ith = this._physicalEnd;
        lastIth = this._physicalStart;
        offsetContent = this._physicalBottom - scrollBottom;
      }
      while (true) {
        physicalItemHeight = this._getPhysicalSizeIncrement(ith);
        offsetContent = offsetContent - physicalItemHeight;
        if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {
          break;
        }
        if (fromTop) {
          // Check that index is within the valid range.
          if (virtualEnd + idxs.length + 1 >= this._virtualCount) {
            break;
          }
          // Check that the index is not visible.
          if (physicalTop + physicalItemHeight >= scrollTop) {
            break;
          }
          idxs.push(ith);
          physicalTop = physicalTop + physicalItemHeight;
          ith = (ith + 1) % physicalCount;
        } else {
          // Check that index is within the valid range.
          if (virtualStart - idxs.length <= 0) {
            break;
          }
          // Check that the index is not visible.
          if (physicalTop + this._physicalSize - physicalItemHeight <= scrollBottom) {
            break;
          }
          idxs.push(ith);
          physicalTop = physicalTop - physicalItemHeight;
          ith = (ith === 0) ? physicalCount - 1 : ith - 1;
        }
      }
      return { indexes: idxs, physicalTop: physicalTop - this._scrollerPaddingTop };
    },

    /**
     * Update the list of items, starting from the `_virtualStart` item.
     * @param {!Array<number>=} itemSet
     * @param {!Array<number>=} movingUp
     */
    _update: function(itemSet, movingUp) {
      if (itemSet && itemSet.length === 0) {
        return;
      }
      this._manageFocus();
      this._assignModels(itemSet);
      this._updateMetrics(itemSet);
      // Adjust offset after measuring.
      if (movingUp) {
        while (movingUp.length) {
          var idx = movingUp.pop();
          this._physicalTop -= this._getPhysicalSizeIncrement(idx);
        }
      }
      this._positionItems();
      this._updateScrollerSize();
      this._increasePoolIfNeeded();
    },

    /**
     * Creates a pool of DOM elements and attaches them to the local dom.
     *
     * @param {number} size Size of the pool
     */
    _createPool: function(size) {
      var physicalItems = new Array(size);

      this._ensureTemplatized();

      for (var i = 0; i < size; i++) {
        var inst = this.stamp(null);
        // First element child is item; Safari doesn't support children[0]
        // on a doc fragment.
        physicalItems[i] = inst.root.querySelector('*');
        Polymer.dom(this).appendChild(inst.root);
      }
      return physicalItems;
    },

    /**
     * Increases the pool of physical items only if needed.
     *
     * @return {boolean} True if the pool was increased.
     */
    _increasePoolIfNeeded: function() {
      var self = this;
      var isClientFull = this._physicalBottom >= this._scrollBottom &&
          this._physicalTop <= this._scrollPosition;

      // Base case 2: if the physical size is optimal and the list's client height is full
      // with physical items, don't increase the pool.
      if (this._physicalSize >= this._optPhysicalSize && isClientFull) {
        return false;
      }
      var maxPoolSize = Math.round(this._physicalCount * 0.5);
      // Increase the pool synchronously until the client is filled.
      if (!isClientFull) {
        this._debounceTemplate(this._increasePool.bind(this, maxPoolSize));
        return true;
      }
      this._yield(function() {
        self._increasePool(Math.min(maxPoolSize, Math.max(1, Math.round(50 / self._templateCost))));
      });
      return true;
    },

    _yield: function(cb) {
      var g = window;
      var handle = g.requestIdleCallback ? g.requestIdleCallback(cb) : g.setTimeout(cb, 16);
      // Polymer/issues/3895
      Polymer.dom.addDebouncer(/** @type {!Polymer.Debouncer} */({
        complete: function() {
          g.cancelIdleCallback ? g.cancelIdleCallback(handle) : g.clearTimeout(handle);
          cb();
        }
      }));
    },

    /**
     * Increases the pool size.
     */
    _increasePool: function(missingItems) {
      var nextPhysicalCount = Math.min(
          this._physicalCount + missingItems,
          this._virtualCount - this._virtualStart,
          Math.max(this.maxPhysicalCount, DEFAULT_PHYSICAL_COUNT)
        );
      var prevPhysicalCount = this._physicalCount;
      var delta = nextPhysicalCount - prevPhysicalCount;
      var ts = window.performance.now();

      if (delta <= 0) {
        return;
      }
      // Concat arrays in place.
      [].push.apply(this._physicalItems, this._createPool(delta));
      [].push.apply(this._physicalSizes, new Array(delta));
      this._physicalCount = prevPhysicalCount + delta;
      // Update the physical start if it needs to preserve the model of the focused item.
      // In this situation, the focused item is currently rendered and its model would
      // have changed after increasing the pool if the physical start remained unchanged.
      if (this._physicalStart > this._physicalEnd &&
          this._isIndexRendered(this._focusedIndex) &&
          this._getPhysicalIndex(this._focusedIndex) < this._physicalEnd) {
        this._physicalStart = this._physicalStart + delta;
      }
      this._update();
      this._templateCost = (window.performance.now() - ts) / delta;
    },

    /**
     * Renders the a new list.
     */
    _render: function() {
      if (this.isAttached && this._isVisible) {
        if (this._physicalCount === 0) {
          this.updateViewportBoundaries();
          this._increasePool(DEFAULT_PHYSICAL_COUNT);
        } else {
          // Try to recycle nodes
          var reusables = this._getReusables(true);
          this._physicalTop = reusables.physicalTop;
          this._virtualStart = this._virtualStart + reusables.indexes.length;
          this._physicalStart = this._physicalStart + reusables.indexes.length;
          this._update(reusables.indexes);
          this._update();
        }
      }
    },

    /**
     * Templetizes the user template.
     */
    _ensureTemplatized: function() {
      if (!this.ctor) {
        // Template instance props that should be excluded from forwarding
        var props = {};
        props.__key__ = true;
        props[this.as] = true;
        props[this.indexAs] = true;
        props[this.selectedAs] = true;
        props.tabIndex = true;
        this._instanceProps = props;
        this._userTemplate = Polymer.dom(this).querySelector('template');

        if (this._userTemplate) {
          this.templatize(this._userTemplate);
        } else {
          console.warn('iron-list requires a template to be provided in light-dom');
        }
      }
    },

    /**
     * Implements extension point from Templatizer mixin.
     */
    _getStampedChildren: function() {
      return this._physicalItems;
    },

    /**
     * Implements extension point from Templatizer
     * Called as a side effect of a template instance path change, responsible
     * for notifying items.<key-for-instance>.<path> change up to host.
     */
    _forwardInstancePath: function(inst, path, value) {
      if (path.indexOf(this.as + '.') === 0) {
        this.notifyPath('items.' + inst.__key__ + '.' +
          path.slice(this.as.length + 1), value);
      }
    },

    /**
     * Implements extension point from Templatizer mixin
     * Called as side-effect of a host property change, responsible for
     * notifying parent path change on each row.
     */
    _forwardParentProp: function(prop, value) {
      if (this._physicalItems) {
        this._physicalItems.forEach(function(item) {
          item._templateInstance[prop] = value;
        }, this);
      }
    },

    /**
     * Implements extension point from Templatizer
     * Called as side-effect of a host path change, responsible for
     * notifying parent.<path> path change on each row.
     */
    _forwardParentPath: function(path, value) {
      if (this._physicalItems) {
        this._physicalItems.forEach(function(item) {
          item._templateInstance.notifyPath(path, value, true);
        }, this);
      }
    },

    /**
     * Called as a side effect of a host items.<key>.<path> path change,
     * responsible for notifying item.<path> changes.
     */
    _forwardItemPath: function(path, value) {
      if (!this._physicalIndexForKey) {
        return;
      }
      var dot = path.indexOf('.');
      var key = path.substring(0, dot < 0 ? path.length : dot);
      var idx = this._physicalIndexForKey[key];
      var offscreenItem = this._offscreenFocusedItem;
      var el = offscreenItem && offscreenItem._templateInstance.__key__ === key ?
          offscreenItem : this._physicalItems[idx];

      if (!el || el._templateInstance.__key__ !== key) {
        return;
      }
      if (dot >= 0) {
        path = this.as + '.' + path.substring(dot+1);
        el._templateInstance.notifyPath(path, value, true);
      } else {
        // Update selection if needed
        var currentItem = el._templateInstance[this.as];
        if (Array.isArray(this.selectedItems)) {
          for (var i = 0; i < this.selectedItems.length; i++) {
            if (this.selectedItems[i] === currentItem) {
              this.set('selectedItems.' + i, value);
              break;
            }
          }
        } else if (this.selectedItem === currentItem) {
          this.set('selectedItem', value);
        }
        el._templateInstance[this.as] = value;
      }
    },

    /**
     * Called when the items have changed. That is, ressignments
     * to `items`, splices or updates to a single item.
     */
    _itemsChanged: function(change) {
      if (change.path === 'items') {
        this._virtualStart = 0;
        this._physicalTop = 0;
        this._virtualCount = this.items ? this.items.length : 0;
        this._collection = this.items ? Polymer.Collection.get(this.items) : null;
        this._physicalIndexForKey = {};
        this._firstVisibleIndexVal = null;
        this._lastVisibleIndexVal = null;
        this._physicalCount = this._physicalCount || 0;
        this._physicalItems = this._physicalItems || [];
        this._physicalSizes = this._physicalSizes || [];
        this._physicalStart = 0;
        if (this._scrollTop > this._scrollerPaddingTop) {
          this._resetScrollPosition(0);
        }
        this._removeFocusedItem();
        this._debounceTemplate(this._render);

      } else if (change.path === 'items.splices') {
        this._adjustVirtualIndex(change.value.indexSplices);
        this._virtualCount = this.items ? this.items.length : 0;

        this._debounceTemplate(this._render);

      } else {
        this._forwardItemPath(change.path.split('.').slice(1).join('.'), change.value);
      }
    },

    /**
     * @param {!Array<!PolymerSplice>} splices
     */
    _adjustVirtualIndex: function(splices) {
      splices.forEach(function(splice) {
        // deselect removed items
        splice.removed.forEach(this._removeItem, this);
        // We only need to care about changes happening above the current position
        if (splice.index < this._virtualStart) {
          var delta = Math.max(
              splice.addedCount - splice.removed.length,
              splice.index - this._virtualStart);

          this._virtualStart = this._virtualStart + delta;

          if (this._focusedIndex >= 0) {
            this._focusedIndex = this._focusedIndex + delta;
          }
        }
      }, this);
    },

    _removeItem: function(item) {
      this.$.selector.deselect(item);
      // remove the current focused item
      if (this._focusedItem && this._focusedItem._templateInstance[this.as] === item) {
        this._removeFocusedItem();
      }
    },

    /**
     * Executes a provided function per every physical index in `itemSet`
     * `itemSet` default value is equivalent to the entire set of physical indexes.
     *
     * @param {!function(number, number)} fn
     * @param {!Array<number>=} itemSet
     */
    _iterateItems: function(fn, itemSet) {
      var pidx, vidx, rtn, i;

      if (arguments.length === 2 && itemSet) {
        for (i = 0; i < itemSet.length; i++) {
          pidx = itemSet[i];
          vidx = this._computeVidx(pidx);
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
      } else {
        pidx = this._physicalStart;
        vidx = this._virtualStart;

        for (; pidx < this._physicalCount; pidx++, vidx++) {
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
        for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
          if ((rtn = fn.call(this, pidx, vidx)) != null) {
            return rtn;
          }
        }
      }
    },

    /**
     * Returns the virtual index for a given physical index
     *
     * @param {number} pidx Physical index
     * @return {number}
     */
    _computeVidx: function(pidx) {
      if (pidx >= this._physicalStart) {
        return this._virtualStart + (pidx - this._physicalStart);
      }
      return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;
    },

    /**
     * Assigns the data models to a given set of items.
     * @param {!Array<number>=} itemSet
     */
    _assignModels: function(itemSet) {
      this._iterateItems(function(pidx, vidx) {
        var el = this._physicalItems[pidx];
        var inst = el._templateInstance;
        var item = this.items && this.items[vidx];
        if (item != null) {
          inst[this.as] = item;
          inst.__key__ = this._collection.getKey(item);
          inst[this.selectedAs] = /** @type {!ArraySelectorElement} */ (this.$.selector).isSelected(item);
          inst[this.indexAs] = vidx;
          inst.tabIndex = this._focusedIndex === vidx ? 0 : -1;
          this._physicalIndexForKey[inst.__key__] = pidx;
          el.removeAttribute('hidden');
        } else {
          inst.__key__ = null;
          el.setAttribute('hidden', '');
        }
      }, itemSet);
    },

    /**
     * Updates the height for a given set of items.
     *
     * @param {!Array<number>=} itemSet
     */
     _updateMetrics: function(itemSet) {
      // Make sure we distributed all the physical items
      // so we can measure them.
      Polymer.dom.flush();

      var newPhysicalSize = 0;
      var oldPhysicalSize = 0;
      var prevAvgCount = this._physicalAverageCount;
      var prevPhysicalAvg = this._physicalAverage;

      this._iterateItems(function(pidx, vidx) {
        oldPhysicalSize += this._physicalSizes[pidx] || 0;
        this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;
        newPhysicalSize += this._physicalSizes[pidx];
        this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;
      }, itemSet);

      if (this.grid) {
        this._updateGridMetrics();
        this._physicalSize = Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;
      } else {
        this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;
      }
      // Update the average if it measured something.
      if (this._physicalAverageCount !== prevAvgCount) {
        this._physicalAverage = Math.round(
            ((prevPhysicalAvg * prevAvgCount) + newPhysicalSize) /
            this._physicalAverageCount);
      }
    },

    _updateGridMetrics: function() {
      this._itemWidth = this._physicalCount > 0 ? this._physicalItems[0].getBoundingClientRect().width : 200;
      this._rowHeight = this._physicalCount > 0 ? this._physicalItems[0].offsetHeight : 200;
      this._itemsPerRow = this._itemWidth ? Math.floor(this._viewportWidth / this._itemWidth) : this._itemsPerRow;
    },

    /**
     * Updates the position of the physical items.
     */
    _positionItems: function() {
      this._adjustScrollPosition();

      var y = this._physicalTop;

      if (this.grid) {
        var totalItemWidth = this._itemsPerRow * this._itemWidth;
        var rowOffset = (this._viewportWidth - totalItemWidth) / 2;

        this._iterateItems(function(pidx, vidx) {
          var modulus = vidx % this._itemsPerRow;
          var x = Math.floor((modulus * this._itemWidth) + rowOffset);
          this.translate3d(x + 'px', y + 'px', 0, this._physicalItems[pidx]);
          if (this._shouldRenderNextRow(vidx)) {
            y += this._rowHeight;
          }
        });
      } else {
        this._iterateItems(function(pidx, vidx) {
          this.translate3d(0, y + 'px', 0, this._physicalItems[pidx]);
          y += this._physicalSizes[pidx];
        });
      }
    },

    _getPhysicalSizeIncrement: function(pidx) {
      if (!this.grid) {
        return this._physicalSizes[pidx];
      }
      if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {
        return 0;
      }
      return this._rowHeight;
    },

    /**
     * Returns, based on the current index,
     * whether or not the next index will need
     * to be rendered on a new row.
     *
     * @param {number} vidx Virtual index
     * @return {boolean}
     */
    _shouldRenderNextRow: function(vidx) {
      return vidx % this._itemsPerRow === this._itemsPerRow - 1;
    },

    /**
     * Adjusts the scroll position when it was overestimated.
     */
    _adjustScrollPosition: function() {
      var deltaHeight = this._virtualStart === 0 ? this._physicalTop :
          Math.min(this._scrollPosition + this._physicalTop, 0);

      if (deltaHeight) {
        this._physicalTop = this._physicalTop - deltaHeight;
        // juking scroll position during interial scrolling on iOS is no bueno
        if (!IOS_TOUCH_SCROLLING && this._physicalTop !== 0) {
          this._resetScrollPosition(this._scrollTop - deltaHeight);
        }
      }
    },

    /**
     * Sets the position of the scroll.
     */
    _resetScrollPosition: function(pos) {
      if (this.scrollTarget) {
        this._scrollTop = pos;
        this._scrollPosition = this._scrollTop;
      }
    },

    /**
     * Sets the scroll height, that's the height of the content,
     *
     * @param {boolean=} forceUpdate If true, updates the height no matter what.
     */
    _updateScrollerSize: function(forceUpdate) {
      if (this.grid) {
        this._estScrollHeight = this._virtualRowCount * this._rowHeight;
      } else {
        this._estScrollHeight = (this._physicalBottom +
            Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage);
      }

      forceUpdate = forceUpdate || this._scrollHeight === 0;
      forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;
      forceUpdate = forceUpdate || this.grid && this.$.items.style.height < this._estScrollHeight;

      // Amortize height adjustment, so it won't trigger large repaints too often.
      if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._optPhysicalSize) {
        this.$.items.style.height = this._estScrollHeight + 'px';
        this._scrollHeight = this._estScrollHeight;
      }
    },

    /**
     * Scroll to a specific item in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToItem
     * @param {(Object)} item The item to be scrolled to
     */
    scrollToItem: function(item){
      return this.scrollToIndex(this.items.indexOf(item));
    },

    /**
     * Scroll to a specific index in the virtual list regardless
     * of the physical items in the DOM tree.
     *
     * @method scrollToIndex
     * @param {number} idx The index of the item
     */
    scrollToIndex: function(idx) {
      if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {
        return;
      }
      Polymer.dom.flush();
      // Items should have been rendered prior scrolling to an index.
      if (this._physicalCount === 0) {
        return;
      }
      idx = Math.min(Math.max(idx, 0), this._virtualCount-1);
      // Update the virtual start only when needed.
      if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
        this._virtualStart = this.grid ? (idx - this._itemsPerRow * 2) : (idx - 1);
      }
      this._manageFocus();
      this._assignModels();
      this._updateMetrics();
      // Estimate new physical offset.
      this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow)  * this._physicalAverage;

      var currentTopItem = this._physicalStart;
      var currentVirtualItem = this._virtualStart;
      var targetOffsetTop = 0;
      var hiddenContentSize = this._hiddenContentSize;
      // scroll to the item as much as we can.
      while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {
        targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);
        currentTopItem = (currentTopItem + 1) % this._physicalCount;
        currentVirtualItem++;
      }
      this._updateScrollerSize(true);
      this._positionItems();
      this._resetScrollPosition(this._physicalTop + this._scrollerPaddingTop + targetOffsetTop);
      this._increasePoolIfNeeded();
      // clear cached visible index.
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;
    },

    /**
     * Reset the physical average and the average count.
     */
    _resetAverage: function() {
      this._physicalAverage = 0;
      this._physicalAverageCount = 0;
    },

    /**
     * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
     * when the element is resized.
     */
    _resizeHandler: function() {
      this._debounceTemplate(function() {
        // Skip the resize event on touch devices when the address bar slides up.
        var delta = Math.abs(this._viewportHeight - this._scrollTargetHeight);
        this.updateViewportBoundaries();
        if (('ontouchstart' in window || navigator.maxTouchPoints > 0) && delta > 0 && delta < 100) {
          return;
        }
        if (this._isVisible) {
          // Reinstall the scroll event listener.
          this.toggleScrollListener(true);
          this._resetAverage();
          this._render();
        } else {
          // Uninstall the scroll event listener.
          this.toggleScrollListener(false);
        }
      }.bind(this));
    },

    _getModelFromItem: function(item) {
      var key = this._collection.getKey(item);
      var pidx = this._physicalIndexForKey[key];

      if (pidx != null) {
        return this._physicalItems[pidx]._templateInstance;
      }
      return null;
    },

    /**
     * Gets a valid item instance from its index or the object value.
     *
     * @param {(Object|number)} item The item object or its index
     */
    _getNormalizedItem: function(item) {
      if (this._collection.getKey(item) === undefined) {
        if (typeof item === 'number') {
          item = this.items[item];
          if (!item) {
            throw new RangeError('<item> not found');
          }
          return item;
        }
        throw new TypeError('<item> should be a valid item');
      }
      return item;
    },

    /**
     * Select the list item at the given index.
     *
     * @method selectItem
     * @param {(Object|number)} item The item object or its index
     */
    selectItem: function(item) {
      item = this._getNormalizedItem(item);
      var model = this._getModelFromItem(item);

      if (!this.multiSelection && this.selectedItem) {
        this.deselectItem(this.selectedItem);
      }
      if (model) {
        model[this.selectedAs] = true;
      }
      this.$.selector.select(item);
      this.updateSizeForItem(item);
    },

    /**
     * Deselects the given item list if it is already selected.
     *

     * @method deselect
     * @param {(Object|number)} item The item object or its index
     */
    deselectItem: function(item) {
      item = this._getNormalizedItem(item);
      var model = this._getModelFromItem(item);

      if (model) {
        model[this.selectedAs] = false;
      }
      this.$.selector.deselect(item);
      this.updateSizeForItem(item);
    },

    /**
     * Select or deselect a given item depending on whether the item
     * has already been selected.
     *
     * @method toggleSelectionForItem
     * @param {(Object|number)} item The item object or its index
     */
    toggleSelectionForItem: function(item) {
      item = this._getNormalizedItem(item);
      if (/** @type {!ArraySelectorElement} */ (this.$.selector).isSelected(item)) {
        this.deselectItem(item);
      } else {
        this.selectItem(item);
      }
    },

    /**
     * Clears the current selection state of the list.
     *
     * @method clearSelection
     */
    clearSelection: function() {
      function unselect(item) {
        var model = this._getModelFromItem(item);
        if (model) {
          model[this.selectedAs] = false;
        }
      }

      if (Array.isArray(this.selectedItems)) {
        this.selectedItems.forEach(unselect, this);
      } else if (this.selectedItem) {
        unselect.call(this, this.selectedItem);
      }

      /** @type {!ArraySelectorElement} */ (this.$.selector).clearSelection();
    },

    /**
     * Add an event listener to `tap` if `selectionEnabled` is true,
     * it will remove the listener otherwise.
     */
    _selectionEnabledChanged: function(selectionEnabled) {
      var handler = selectionEnabled ? this.listen : this.unlisten;
      handler.call(this, this, 'tap', '_selectionHandler');
    },

    /**
     * Select an item from an event object.
     */
    _selectionHandler: function(e) {
      var model = this.modelForElement(e.target);
      if (!model) {
        return;
      }
      var modelTabIndex, activeElTabIndex;
      var target = Polymer.dom(e).path[0];
      var activeEl = Polymer.dom(this.domHost ? this.domHost.root : document).activeElement;
      var physicalItem = this._physicalItems[this._getPhysicalIndex(model[this.indexAs])];
      // Safari does not focus certain form controls via mouse
      // https://bugs.webkit.org/show_bug.cgi?id=118043
      if (target.localName === 'input' ||
          target.localName === 'button' ||
          target.localName === 'select') {
        return;
      }
      // Set a temporary tabindex
      modelTabIndex = model.tabIndex;
      model.tabIndex = SECRET_TABINDEX;
      activeElTabIndex = activeEl ? activeEl.tabIndex : -1;
      model.tabIndex = modelTabIndex;
      // Only select the item if the tap wasn't on a focusable child
      // or the element bound to `tabIndex`
      if (activeEl && physicalItem !== activeEl && physicalItem.contains(activeEl) && activeElTabIndex !== SECRET_TABINDEX) {
        return;
      }
      this.toggleSelectionForItem(model[this.as]);
    },

    _multiSelectionChanged: function(multiSelection) {
      this.clearSelection();
      this.$.selector.multi = multiSelection;
    },

    /**
     * Updates the size of an item.
     *
     * @method updateSizeForItem
     * @param {(Object|number)} item The item object or its index
     */
    updateSizeForItem: function(item) {
      item = this._getNormalizedItem(item);
      var key = this._collection.getKey(item);
      var pidx = this._physicalIndexForKey[key];

      if (pidx != null) {
        this._updateMetrics([pidx]);
        this._positionItems();
      }
    },

    /**
     * Creates a temporary backfill item in the rendered pool of physical items
     * to replace the main focused item. The focused item has tabIndex = 0
     * and might be currently focused by the user.
     *
     * This dynamic replacement helps to preserve the focus state.
     */
    _manageFocus: function() {
      var fidx = this._focusedIndex;

      if (fidx >= 0 && fidx < this._virtualCount) {
        // if it's a valid index, check if that index is rendered
        // in a physical item.
        if (this._isIndexRendered(fidx)) {
          this._restoreFocusedItem();
        } else {
          this._createFocusBackfillItem();
        }
      } else if (this._virtualCount > 0 && this._physicalCount > 0) {
        // otherwise, assign the initial focused index.
        this._focusedIndex = this._virtualStart;
        this._focusedItem = this._physicalItems[this._physicalStart];
      }
    },

    _isIndexRendered: function(idx) {
      return idx >= this._virtualStart && idx <= this._virtualEnd;
    },

    _isIndexVisible: function(idx) {
      return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;
    },

    _getPhysicalIndex: function(idx) {
      return this._physicalIndexForKey[this._collection.getKey(this._getNormalizedItem(idx))];
    },

    _focusPhysicalItem: function(idx) {
      if (idx < 0 || idx >= this._virtualCount) {
        return;
      }
      this._restoreFocusedItem();
      // scroll to index to make sure it's rendered
      if (!this._isIndexRendered(idx)) {
        this.scrollToIndex(idx);
      }

      var physicalItem = this._physicalItems[this._getPhysicalIndex(idx)];
      var model = physicalItem._templateInstance;
      var focusable;
      // set a secret tab index
      model.tabIndex = SECRET_TABINDEX;
      // check if focusable element is the physical item
      if (physicalItem.tabIndex === SECRET_TABINDEX) {
       focusable = physicalItem;
      }
      // search for the element which tabindex is bound to the secret tab index
      if (!focusable) {
        focusable = Polymer.dom(physicalItem).querySelector('[tabindex="' + SECRET_TABINDEX + '"]');
      }
      // restore the tab index
      model.tabIndex = 0;
      // focus the focusable element
      this._focusedIndex = idx;
      focusable && focusable.focus();
    },

    _removeFocusedItem: function() {
      if (this._offscreenFocusedItem) {
        Polymer.dom(this).removeChild(this._offscreenFocusedItem);
      }
      this._offscreenFocusedItem = null;
      this._focusBackfillItem = null;
      this._focusedItem = null;
      this._focusedIndex = -1;
    },

    _createFocusBackfillItem: function() {
      var fidx = this._focusedIndex;
      var pidx = this._getPhysicalIndex(fidx);

      if (this._offscreenFocusedItem || pidx == null || fidx < 0) {
        return;
      }
      if (!this._focusBackfillItem) {
        // Create a physical item.
        var stampedTemplate = this.stamp(null);
        this._focusBackfillItem = stampedTemplate.root.querySelector('*');
        Polymer.dom(this).appendChild(stampedTemplate.root);
      }
      // Set the offcreen focused physical item.
      this._offscreenFocusedItem = this._physicalItems[pidx];
      this._offscreenFocusedItem._templateInstance.tabIndex = 0;
      this._physicalItems[pidx] = this._focusBackfillItem;
      // Hide the focused physical.
      this.translate3d(0, HIDDEN_Y, 0, this._offscreenFocusedItem);
    },

    _restoreFocusedItem: function() {
      var pidx, fidx = this._focusedIndex;

      if (!this._offscreenFocusedItem || this._focusedIndex < 0) {
        return;
      }
      // Assign models to the focused index.
      this._assignModels();
      // Get the new physical index for the focused index.
      pidx = this._getPhysicalIndex(fidx);

      if (pidx != null) {
        // Flip the focus backfill.
        this._focusBackfillItem = this._physicalItems[pidx];
        this._focusBackfillItem._templateInstance.tabIndex = -1;
        // Restore the focused physical item.
        this._physicalItems[pidx] = this._offscreenFocusedItem;
        // Reset the offscreen focused item.
        this._offscreenFocusedItem = null;
        // Hide the physical item that backfills.
        this.translate3d(0, HIDDEN_Y, 0, this._focusBackfillItem);
      }
    },

    _didFocus: function(e) {
      var targetModel = this.modelForElement(e.target);
      var focusedModel = this._focusedItem ? this._focusedItem._templateInstance : null;
      var hasOffscreenFocusedItem = this._offscreenFocusedItem !== null;
      var fidx = this._focusedIndex;

      if (!targetModel || !focusedModel) {
        return;
      }
      if (focusedModel === targetModel) {
        // if the user focused the same item, then bring it into view if it's not visible
        if (!this._isIndexVisible(fidx)) {
          this.scrollToIndex(fidx);
        }
      } else {
        this._restoreFocusedItem();
        // restore tabIndex for the currently focused item
        focusedModel.tabIndex = -1;
        // set the tabIndex for the next focused item
        targetModel.tabIndex = 0;
        fidx = targetModel[this.indexAs];
        this._focusedIndex = fidx;
        this._focusedItem = this._physicalItems[this._getPhysicalIndex(fidx)];
        if (hasOffscreenFocusedItem && !this._offscreenFocusedItem) {
          this._update();
        }
      }
    },

    _didMoveUp: function() {
      this._focusPhysicalItem(this._focusedIndex - 1);
    },

    _didMoveDown: function(e) {
      // disable scroll when pressing the down key
      e.detail.keyboardEvent.preventDefault();
      this._focusPhysicalItem(this._focusedIndex + 1);
    },

    _didEnter: function(e) {
      this._focusPhysicalItem(this._focusedIndex);
      this._selectionHandler(e.detail.keyboardEvent);
    }
  });

})();

</script>
<script>; 
/* https://github.com/anpur/line-navigator Anton Purin MIT 2016 */
var createFileWrapper = function() {

    function FileWrapper (file, encoding) {
        var self = this;        

        // Node JS
        if (self.isNode(file)) {
            self.fs = require('fs');

            var StringDecoder = require('string_decoder').StringDecoder;
            self.string_decoder = new StringDecoder(encoding);

            if (self.fs.statSync(file) === undefined)
                throw "File '" + file + "' doesn't exists!";

            var fd = self.fs.openSync(file, 'r');
            
            self.readChunk = function (offset, length, callback) {
                var buffer = new Buffer(length);

                self.fs.read(fd, buffer, 0, length, offset, function (e, br) { callback(e, buffer, br); });
            };

            self.decode = function(buffer, callback) {
                callback(self.string_decoder.write(buffer));
            };

            self.getSize = function() {
                return self.fs.statSync(file)["size"];
            };
        } 

        // HTML5 File
        else if (self.isHtml5File(file)) {
            self.readChunk = function (offset, length, callback) {
                lastPosition = offset + length;
                var reader = new FileReader();

                reader.onloadend = function(progress) {
                    var buffer;
                    if (reader.result) {
                        buffer = new Int8Array(reader.result, 0);
                        buffer.slice = buffer.subarray;
                    }
                    callback(progress.err, buffer, progress.loaded);
                };

                reader.readAsArrayBuffer(file.slice(offset, offset + length));
            };

            self.decode = function(buffer, callback) {
                var reader = new FileReader();
                reader.onloadend = function(progress) {
                    callback(progress.currentTarget.result);
                };
                if (typeof encoding !== 'undefined') {
                    reader.readAsText(new Blob([buffer]), encoding);
                } else {
                    reader.readAsText(new Blob([buffer]));
                }
            };

            self.getSize = function() {
                return file.size;
            };
        } 
        // Unknown
        else {
            throw "Given file should be instance of the File class for browser \
            or a string containing a path to a file for Node.js, \
            but it is neither: [" + (typeof file) + "] " + file;
        }
    }

    FileWrapper.prototype.isNode = function (file) { 
        return typeof module !== 'undefined' && module.exports && typeof file === 'string'; 
    };

    FileWrapper.prototype.isHtml5File = function (file) { 
        return typeof File !== 'undefined' && file instanceof File; 
    }

    return FileWrapper;
}

// Node.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = createFileWrapper();
}
// AMD
else if (typeof define === 'function') {
    define(function(){
        return createFileWrapper();    
    });
}
// Vanilla
else {
    FileWrapper = createFileWrapper();
}</script>
<script>;
/* https://github.com/anpur/line-navigator Anton Purin MIT 2016 */
var getLineNavigatorClass = function() {
    function LineNavigator (file, options) {
        var self = this;

        // options init 
        options =       options           ? options           : {};        
        var encoding =  options.encoding  ? options.encoding  : 'utf8';
        var chunkSize = options.chunkSize ? options.chunkSize : 1024 * 4;
        var milestones = [];

        var wrapper = new FileWrapper(file, encoding);
        var oldFileSize = wrapper.getSize();

        var getFileSize = function (position) {
            return oldFileSize = oldFileSize > position
                ? oldFileSize 
                : wrapper.getSize(file);
        }

        var getProgressSimple = function(position) {
            var size = getFileSize(position);
            return Math.round(100 * position / size);
        }

        self.readSomeLines = function(index, callback) {
            var place = self.getPlaceToStart(index, milestones);     

            wrapper.readChunk(place.offset, chunkSize, function readChunkCallback(err, buffer, bytesRead) {                
                if (err) return callback(err, index);

                var isEof = bytesRead < chunkSize;
  
                var chunkContent = self.examineChunk(buffer, bytesRead, isEof); 
                if (chunkContent === undefined)
                    return callback('Line ' + index + ' is out of index, last available: ' + (milestones.length > 0 ? milestones[milestones.length - 1].lastLine : "none"), index);
                var inChunk = { 
                    firstLine: place.firstLine, 
                    lastLine: place.firstLine + chunkContent.lines - 1, 
                    offset: place.offset,
                    length: chunkContent.length + 1
                };

                if (place.isNew) 
                    milestones.push(inChunk);               

                var targetInChunk = inChunk.firstLine <= index && index <= inChunk.lastLine;

                if (targetInChunk) {
                    var bomOffset = place.offset !== 0 ? 0 : self.getBomOffset(buffer, encoding);

                    wrapper.decode(buffer.slice(bomOffset, inChunk.length), function(text) {
                        var expectedLinesCount = inChunk.lastLine - inChunk.firstLine + (isEof ? 2 : 1);
                        
                        var lines = text.split(self.splitLinesPattern);                            
                        if (!isEof)
                            lines = lines.slice(0, lines.length - 1);                   
                        if (index != inChunk.firstLine)
                            lines = lines.splice(index - inChunk.firstLine); 
                          
                        callback(undefined, index, lines, isEof, getProgressSimple(inChunk.offset + inChunk.length), inChunk);
                    });
                } else {
                    if (!isEof) {                        
                        place = self.getPlaceToStart(index, milestones);
                        wrapper.readChunk(place.offset, chunkSize, readChunkCallback);
                    } else {
                        return callback('Line ' + index + ' is out of index, last available: ' + inChunk.lastLine, index);
                    }
                }                
            });
        };        

        self.readLines = function(index, count, callback) {
            if (count === 0) 
                return callback(undefined, index, [], false, 0);            

            var result = [];
            self.readSomeLines(index, function readLinesCallback(err, partIndex, lines, isEof, progress, inChunk) {
                if (err) return callback(err, index);

                var resultEof = !isEof
                    ? false
                    :  partIndex + lines.length <= index + count;

                result = result.concat(lines);

                if (result.length >= count || isEof) {
                    result = result.splice(0, count);
                    var progress = self.getProgress(inChunk, index + result.length - 1, getFileSize(inChunk.offset + inChunk.length));
                    return callback(undefined, index, result, resultEof, progress);
                }

                self.readSomeLines(partIndex + lines.length, readLinesCallback);
            });
        };

        self.find = function(regex, index, callback) {
            self.readSomeLines(index, function readSomeLinesHandler(err, firstLine, lines, isEof, progress) {
                if (err) return callback(err);

                for (var i = 0; i < lines.length; i++) {
                    var match = self.searchInLine(regex, lines[i]);
                    if (match)       
                        return callback(undefined, firstLine + i, match);                    
                }

                if (isEof) 
                    return callback();

                self.readSomeLines(firstLine + lines.length + 1, readSomeLinesHandler);
            });
        };

        self.findAll = function(regex, index, limit, callback) {
            var results = [];

            self.readSomeLines(index, function readSomeLinesHandler(err, firstLine, lines, isEof) {
                if (err) return callback(err, index);

                for (var i = 0; i < lines.length; i++) {
                    var match = self.searchInLine(regex, lines[i]);
                    if (match) {
                        match.index = firstLine + i;
                        results.push(match);
                        if (results.length >= limit)
                            return callback(undefined, index, true, results);
                    }
                }
                if (isEof)
                    return callback(undefined, index, false, results);

                self.readSomeLines(firstLine + lines.length, readSomeLinesHandler);
            });
        };
    }

    LineNavigator.prototype.splitLinesPattern = /\r\n|\n|\r/;

    LineNavigator.prototype.getProgress = function (milestone, index, fileSize) {
        var linesInMilestone = milestone.lastLine - milestone.firstLine + 1;
        var indexNumberInMilestone = index - milestone.firstLine;
        var indexLineAssumablePosition = index !== milestone.lastLine 
            ? milestone.offset + milestone.length / linesInMilestone * indexNumberInMilestone
            : milestone.offset + milestone.length;

        return Math.floor(100 * (indexLineAssumablePosition / fileSize));
    }

    LineNavigator.prototype.searchInLine = function(regex, line) {
        var match = regex.exec(line);
        return !match 
            ? null 
            : {
                    offset: line.indexOf(match[0]),
                    length: match[0].length,
                    line: line
              };
    }

    LineNavigator.prototype.getPlaceToStart = function (index, milestones) {
        for (var i = milestones.length - 1; i >= 0; i--) {
            if (milestones[i].lastLine < index) 
                return { 
                    firstLine: milestones[i].lastLine + 1, 
                    offset: milestones[i].offset + milestones[i].length,
                    isNew: i === milestones.length - 1
                };
        }
        return { firstLine: 0, offset: 0, isNew: milestones.length === 0 };
    }

    // searches for line end, which can be \r\n, \n or \r (Windows, *nix, MacOs line endings)
    // returns line end postion including all line ending
    LineNavigator.prototype.getLineEnd = function (buffer, start, end, isEof) {
        var newLineCode = '\n'.charCodeAt(0);
        var caretReturnCode = '\r'.charCodeAt(0);

        for (var i = start; i < end; i++) {
            var char = buffer[i];
            if (char === newLineCode) {
                return i;
            } else if (char === caretReturnCode) {
                // \r is a last character in a given buffer and it is not the end of file yet, so it could be \r\n sequence which was separated
                var canBeSplitted = (i == end - 1) && !isEof; 

                if (!canBeSplitted) {
                    return buffer[i + 1] === newLineCode 
                        ? i + 1 
                        : i;
                } else {
                    return undefined;
                }
            }
        }
    }

    LineNavigator.prototype.examineChunk = function(buffer, bytesRead, isEof) {
        var lines = 0;
        var length = 0;
        
        do {
            var position = LineNavigator.prototype.getLineEnd(buffer, length, bytesRead, isEof);
            if (position !== undefined) {
                lines++;
                length = position + 1;
            }
        } while (position !== undefined);

        if (isEof) {
            lines++;
            length = bytesRead;
        }

        return length > 0 
            ? { lines: lines, length: length - 1 } 
            : undefined;
    };    

    var bomUtf8 = [239, 187, 191];
    var bomUtf16le = [255, 254];

    var arrayStartsWith = function (array, startsWith) {
        for (var i = 0; i < array.length && i < startsWith.length; i++) {
            if (array[i] !== startsWith[i])
                return false;
            if (i == startsWith.length - 1) 
                return true;
        }
        return false;
    };

    LineNavigator.prototype.getBomOffset = function(buffer, encoding) {
        switch (encoding.toLowerCase()) {
            case 'utf8':
                return arrayStartsWith(buffer, bomUtf8) ? bomUtf8.length : 0;
            case 'utf16le':
                return arrayStartsWith(buffer, bomUtf16le) ? bomUtf16le.length : 0;
            default:
                return 0;
        }
    }

    return LineNavigator;    
};

// Node.js
if (typeof module !== 'undefined' && module.exports) {
    FileWrapper = require('./file-wrapper.js');
    module.exports = getLineNavigatorClass();
}
// AMD
else if (typeof define === 'function') {
    define(['./file-wrapper'], function(fileWrapper){
        FileWrapper = fileWrapper;
        return getLineNavigatorClass();    
    });
}
// Vanilla
else {
    if (typeof FileWrapper === 'undefined') {
        throw "For vanilla JS please add 'file-wrapper.js' script tag before this one."
    }
    LineNavigator = getLineNavigatorClass();
}</script>

<script>function Validator(options) {
    if (!(this instanceof Validator)) {
        return new Validator(options);
    }

    this.file = options.file ? options.file : null;

    this.log = [];
    this.line = 0;
    this.progress = 0;
    this._readBytes = 0;
    this._events = {};
    this.numLines = 0;
    this.linesToRead = 2000;

}

Validator.prototype = {
    init: function () {
        this.file = null;
        this.log = [];
        this.line = 0;
        this.numLines = 0;
        this.progress = 0;
        this._readBytes = 0;
        this.linesToRead = 2000;
    },
    stop: function (cb) {
        if (this._navigator != null) {
            this._navigator._stop = true;
        }
    },

    validate: function () {
        var me = this;

        /*Check if file is \r or \n , \r\n */
        this._detectCRSeparator(this.file, function (res) {
            var lastReadBytes = null;

            if (res) {
                me._navigator = new LineNavigator(me.file, undefined, {
                    newLineCode: '\r'.charCodeAt(0),
                    splitPattern: /\r/
                });
            } else {
                me._navigator = new LineNavigator(me.file, {
                    chunkSize: 1024 * 50
                });
            }
            me._totalBytes = me.file.size;
            var indexToStartWith = 0;

            lastReadBytes = 0;

            me._navigator.readLines(indexToStartWith, me.linesToRead, function linesReadHandler(err, index, lines, eof, progress) {
                if (err) {
                    me._emit("err");
                    return;
                }
                // console.log(lines.length);
                console.log(progress);

                var isLast = false;
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    isLast = (i == (lines.length - 1) && eof);

                    me.line++;
                    me.numLines++;
                    me._readBytes += line.length;
                    me.progress = (me._readBytes / me._totalBytes) * 100;
                    me.validateLine(line, isLast);
                }
                me._emit("progress", me.progress);

                if (eof) {
                    me._emit("progress", 100);
                    me._emit("end");
                    me._validateEnd();
                    return;
                }

                // if (lastReadBytes == me._readBytes) {
                //     me._emit("progress", 100);
                //     me._emit("end");
                //     me._validateEnd();
                //     return;
                // }

                lastReadBytes = me._readBytes;

                if (me._navigator._stop != true) {
                    me._navigator.readLines(index + lines.length, me.linesToRead, linesReadHandler);
                } else {
                    me._emit("stop");
                    console.log("STOP!!!!!");
                }
            });

        });
        // });
    },
    validateLine: function (line) {
        return true;
    },
    _validateEnd: function () {
        this.validateEnd();
    },
    validateEnd: function () {
        return true;
    },
    addLog: function (type, msg, column) {
        var log = {
            type: type,
            msg: msg,
            line: this.line,
            column: column
        };
        this.log.push(log);
        this._emit("log", log);
    },
    on: function (eventName, cb) {
        this._events[eventName] = cb;
    },
    _emit: function (event) {
        if (typeof this._events[event] === 'function') {
            this._events[event].apply(this, Array.prototype.slice.call(arguments, 1));
        }
    },
    _detectCRSeparator: function (file, cb) {
        var reader = new FileReader();
        reader.onload = function (e) {
            var regex = /\r(?!\n)/;
            if (regex.test(e.target.result)) {
                cb(true);
            } else {
                cb(false);
            }
        }
        reader.readAsText(file);
    }
}
</script>
<script>function VCFValidator(options) {
    if (!(this instanceof VCFValidator)) {
        return new VCFValidator(options);
    }
    Validator.call(this, options);

    this._header = true;
    this._fileFormat = false;
    this._contigs = {};
    this._info = {};
    this._format = {};
    this._filter = {};
    this._alt = {};
    this._headerElements = [];
    this._samples = [];
    this._columnsSize = 0;
    this._refTag = false;

    this._duplicates = {};
    this._sorted = true;

    this._prevChrPos = null;

    this._regExp = {
        "headerId": /ID=(\w+)/,
        "chrId": /ID=([\w\.]+)/,
        "filterId": /ID=([\w\s\.]+)/,
        // "filterId": /ID=\"?([\w\s\.]+)\"?/,
        "headerNumber": /Number=(\w+|\.)/,
        "headerType": /Type=(\w+)/,
        "headerDesc": /Description=\"(.+)\"/,
        "actg": /^[ACGTN]+$/i,
        "gt": /^(\.|\d+)([|/](\.|\d+))?$/,
        "alpha": /^(\w+)$/,
        "idSemiColon": /^(\w+(;\w+)?)+$/,
        "integer": /^(-+)?(\d+)$/,
        "float": /^(-+)?(\d+(\.\d+)?(e-\d+)?)$/,
        "altID": /^[<]+(\w+)+[>]$/

    }
}

VCFValidator.prototype = Object.create(Validator.prototype);

VCFValidator.prototype.validateLine = function (line) {

    if (this._header) { // parse Header
        this.parseHeader(line);
    } else {
        if (!this._refTag) {
            this._checkReferenceTag();
            this._refTag = true;
        }
        if (!this._fileFormat) {
            this.addLog("error", "The file format declaration must be present");
            this._fileFormat = true;
        }
        this.parseData(line);
    }

}

VCFValidator.prototype.isHeaderLine = function (line) {
    return line.startsWith("#");
}

VCFValidator.prototype.parseHeader = function (line) {
    if (this.line == 0) { // parse fileformat
        if (!line.startsWith("##fileformat=")) {
            this.addLog("error", "The file format declaration must be the first line in the file");
        }
    }

    if (line.startsWith("##")) {
        var lineData = line.substring(2);
        var key = lineData.substring(0, lineData.indexOf("="))
        var value = lineData.substring(lineData.indexOf("=") + 1)

        if (key == "" || value == "") {
            this.addLog("error", "All lines must be key=value pairs.")
        }

        if (key.toLowerCase() == "fileformat") {
            this._fileFormat = true;

        } else if (key.toLowerCase() == "contig") {
            var contigId = this._getDataFromRegExp(value, "chrId");
            this._contigs[contigId] = contigId;
        } else if (key.toLowerCase() == "info") {
            var id = this._getDataFromRegExp(value, "headerId");
            var number = this._getDataFromRegExp(value, "headerNumber");
            var type = this._getDataFromRegExp(value, "headerType");
            var description = this._getDataFromRegExp(value, "headerDesc");

            if (id == null || number == null || type == null || description == null) {
                this.addLog("error", "INFO fields must be described as ##INFO=<ID=ID,Number=number,Type=type,Description='description'> ")
            }

            this._info[id] = {
                id: id,
                number: number,
                type: type,
                description: description
            }
        } else if (key.toLowerCase() == "format") {
            var id = this._getDataFromRegExp(value, "headerId");
            var number = this._getDataFromRegExp(value, "headerNumber");
            var type = this._getDataFromRegExp(value, "headerType");
            var description = this._getDataFromRegExp(value, "headerDesc");

            if (id == null || number == null || type == null || description == null) {
                this.addLog("error", "FORMAT fields must be described as ##FORMAT=<ID=ID,Number=number,Type=type,Description='description'> ")
            }

            this._format[id] = {
                id: id,
                number: number,
                type: type,
                description: description
            }
        } else if (key.toLowerCase() == "filter") {
            var id = this._getDataFromRegExp(value, "filterId");
            // var id = this._getDataFromRegExp(value, "headerId");
            var description = this._getDataFromRegExp(value, "headerDesc");

            if (id == null || description == null) {
                this.addLog("error", "FILTER fields must be described as ##FILTER=<ID=ID,Description='description'>")
            }

            this._filter[id] = {
                id: id,
                description: description
            }

        } else if (key.toLowerCase() == "alt") {
            var id = this._getDataFromRegExp(value, "headerId");
            var description = this._getDataFromRegExp(value, "headerDesc");
            id = id.split(":");
            if (id.length == 1) {
                if (id[0] != "DEL" && id[0] != "INS" && id[0] != "DUP" && id[0] != "INV" && id[0] != "CNV") {
                    this.addLog("warning", "The first level type for the alternate ID must be: DEL,INS,DUP,INV or CNV")
                }
            } else {
                id = value;
            }

            if (id == null || description == null) {
                this.addLog("error", "ALT fields must be described as ##ALT=<ID=ID,Description='description'>")
            }

            this._alt["<" + id + ">"] = {
                id: "<" + id + ">",
                description: description
            }

        } else {

            this._headerElements.push({
                id: key,
                value: value
            });
        }

    } else if (line.startsWith("#CHROM")) {
        this._header = false;
        splits = line.split("\t");
        this._columnsSize = splits.length;
        if (splits.length < 8) {
            this.addLog("error", "Must contain at least 8 columns(CHROM to INFO)");
        } else if (splits.length > 9) {
            for (var i = 9; i < splits.length; i++) {
                this._samples.push(splits[i]);
            }
        }
    } else {
        this.addLog("error", "All header lines must be prefixed by '##");
    }
}

VCFValidator.prototype._getDataFromRegExp = function (data, regExpId) {
    var regExp = this._regExp[regExpId];
    if (regExp == null) {
        return null;
    }
    if (regExp.test(data)) {
        var groups = regExp.exec(data);
        if (groups != null && groups.length > 1) {
            return groups[1];
        }
    }
    return null;

}

VCFValidator.prototype.parseData = function (line) {
    if (line == "") {
        this.addLog("warning", "Empty line found.");
        return;
    }
    if (this.isHeaderLine(line)) {
        this.addLog("error", "Must not start with a header prefix (#)");
        return;
    }

    var columns = line.split("\t");

    if (columns.length < 8) {
        this.addLog("error", "Must contain at least 8 columns(CHROM to INFO)");
    } else if (columns.length - 9 != this._samples.length) {
        this.addLog("error", "The number of samples must match those listed in the header");
    }

    if (this._columnsSize != columns.length) {
        this.addLog("error", "All ines must have the same number of columns");
    }
    if (columns.length >= 8) {
        // Chromosome
        var chr = columns[0];
        if (chr == "") {
            this.addLog("error", "Chromosome must not be empty", 0);
        }
        if (chr.search(":") >= 0) {
            this.addLog("error", "Chromosome must not contain colons", 0);
        }
        if (chr.search(" ") >= 0) {
            this.addLog("error", "Chromosome must not contain whitespaces", 0);
        }

        if (this._contigs[chr] == null) {
            this.addLog("error", "Chromosome must be present on contig tags in header.", 0)
        }

        // Position
        var pos = columns[1]
        if (pos == "") {
            this.addLog("error", "Position must not be empty", 1);
        }
        pos = parseInt(pos)
        if (isNaN(pos)) {
            this.addLog("error", "Position must be numeric", 1);
        }

        // Check duplicates
        var chr_pos = chr + "_" + pos;
        if (chr_pos in this._duplicates) {
            this.addLog("warning", "There must be no chromosome+position duplicates");
        }

        this._duplicates[chr_pos] = null;

        // Id

        var id = columns[2];

        if (id != ".") {
            if (!this._regExp["idSemiColon"].test(id)) {
                this.addLog("error", "If more than one ID is specified, they must be semi-colon separated", 2);
                idSplits = id.split(";");
                for (var i = 0; i < idSplits.length; i++) {
                    if (!this._regExp["alpha"].test(idSplits[i])) {
                        this.addLog("error", "ID must be alphanumeric", 2);
                    }
                }
            }

        }

        // ref

        var ref = columns[3];
        if (ref == "") {
            this.addLog("error", "Reference allele must not be empty", 3);
        }

        if (!this._regExp["actg"].test(ref)) {
            this.addLog("error", "Reference allele must match the regular expression /^[ACTGN.]+$/", 3);
        }

        // alt

        var alt = columns[4];

        if (alt == "") {
            this.addLog("error", "Alternate allele must not be empty", 4);
        }

        var altSplits = alt.split(",");
        var altSplitsUnique = altSplits.filter(function (item, pos) {
            return altSplits.indexOf(item) == pos;
        });

        if (altSplits.length != altSplitsUnique.length) {
            this.addLog("error", "Alternate must contain each allele only once", 4)
        }

        if (altSplitsUnique.indexOf(ref) >= 0) {
            this.addLog("error", "The reference allele must not be in the list of alternate alleles", 4)
        }

        if (alt != "." && alt != "*") {
            for (var i = 0; i < altSplits.length; i++) {
                var altElem = altSplits[i];

                if (!this._regExp["actg"].test(altElem)) {
                    if (this._regExp["altID"].test(altElem)) {
                        if (this._alt[altElem] == null) {
                            this.addLog("error", "Alternate allele " + altElem + " must be specified in ALT field in header", 4)
                        }
                    } else {
                        this.addLog("error", "Alternate allele must match the regular expression /^[ACTGN]+$/", 4)

                    }
                }
                if (altElem.length != ref.length) { // TODO aaleman: Check this
                    if (altElem.charAt(0) != ref.charAt(0)) {
                        this.addLog("warning", "The first base of each allele must match the reference if their lengths are different", 4);
                    }
                }
            }
        }

        // Qual
        var qual = columns[5];
        if (qual != ".") {
            var qualFloat = parseFloat(qual);
            if (isNaN(qualFloat) || qualFloat < 0) {
                this.addLog("error", "Quality must be a non-negative float", 5);
            }

        }

        // Filter
        var filter = columns[6];
        if (filter == "") {
            this.addLog("error", "Filter status field must not be empty", 6);
        }
        if (filter != 'PASS' && filter != ".") {
            var filterIds = filter.split(";");
            for (var i = 0; i < filterIds.length; i++) {
                var id = filterIds[i];
                if (this._filter[id] == null) {
                    this.addLog("error", "Filter status must be specified in header, be PASS or be set to the missing value '.'", 6);
                }
            }
        }

        var aggregate = columns.length == 8;

        // Info
        var info = columns[7];
        if (info == "") {
            this.addLog("error", "Info field must not be empty", 7);
        }
        var infoFields = info.split(";");
        // if (infoFields.length != Object.keys(this._info).length) {
        //   this.addLog("error", "Info must have the same number of fields specified in header");
        // }

        if (infoFields.length != 1 || infoFields[0] != '.') {
            for (var i = 0; i < infoFields.length; i++) {
                var field = infoFields[i];
                if (field.indexOf("=") > 0) {
                    var key = field.substring(0, field.indexOf("="));
                    var value = field.substring(field.indexOf("=") + 1);
                    if (this._info[key] == null) {
                        this.addLog("warning", "Info field '" + key + "' must be specified in header", 7);
                    } else {
                        var v = value.split(",");
                        if (v.length > 1) {
                            switch (this._info[key].number) {
                            case "A":
                                //'A': one value per alternate
                                var expected = altSplits.length;
                                if (expected != v.length) {
                                    this.addLog("warning", "Wrong number of values in INFO field '" + key + " (expected one value per alternate)", 7);
                                }
                                break;
                            case "R":
                                //'R': one value for each possible allele
                                var expected = altSplits.length + 1;
                                if (expected != v.length) {
                                    this.addLog("warning", "Wrong number of values in INFO field '" + key + " (expected one value for each possible  allele, including the reference)", 7);
                                }
                                break;
                            case "G":
                                //'G': one value for each possible genotype
                                // var expected = altSplits.length * (altSplits.length + 1) / 2;
                                // var typeMSG = aggregate ? "warning" : "error";
                                var typeMSG = "warning";
                                if (!aggregate) {
                                    var expected = this._binomial(altSplits.length + this._ploidy, this._ploidy);
                                    if (expected != found) {

                                    }
                                }
                                this.addLog(typeMSG, "Wrong number of values in INFO field '" + key + " (expected: '" + expected + "', found: '" + found + "'). Must have one value for each possible genotype", 7);
                                break;
                            }

                            if (this._info[key].type == 'Flag') {
                                this.addLog("warning", "Flag type must not have value", 7);
                            } else {
                                this._checkFormatDataType(v, this._info[key], 'INFO');
                            }
                        }
                    }
                } else {
                    if (this._info[field] == null) {
                        this.addLog("warning", "Info field must be specified in header", 7);
                    } else if (this._info[field].type != "Flag") {
                        this.addLog("warning", "Info field must be a Flag type or have a data value", 7);
                    } else {
                        if (this._info[field].number != 0) {
                            this.addLog("warning", "In Info, Number must be 0 for a Flag type", 7);
                        }
                    }
                }
            }
        }
    }
    // if (!(columns.length > 8)) {
    //     return;
    // }

    if (columns.length > 8) {
        // Format
        var format = columns[8];

        if (this._samples.length > 0 && format == "") {
            this.addLog("error", "Must not be empty if the file contains any samples", 8);
        }

        if (format != "" && format.indexOf("GT") >= 0 && !format.startsWith("GT")) {
            this.addLog("error", "GT must be the first field if it is present", 8);
        }

        var formatSplits = format.split(":");
        // ...

        for (var i = 0; i < formatSplits.length; i++) {
            var formatKey = formatSplits[i];
            if (this._format[formatKey] == null) {
                this.addLog("warning", "FORMAT field '" + formatKey + "'must be specified in header", 8);
            }
        }

        // Samples
        var samplesData = [];

        for (var i = 9; i < columns.length; i++) {
            samplesData.push(columns[i]);
        }

        var dataLength = 0;
        for (var i = 0; i < samplesData.length; i++) {
            var sampleData = samplesData[i];
            dataLength += sampleData.length;

            if (sampleData == "") {
                this.addLog("error", "Sample fields must be not empty", 8);
            } else {
                var sampleDataSplit = sampleData.split(":");

                for (var j = 0; j < sampleDataSplit.length; j++) {
                    var sampleValue = sampleDataSplit[j];
                    var formatKey = formatSplits[j];
                    var formatElem = this._format[formatKey];

                    if (formatElem == null) {
                        continue;
                    }

                    if (j == 0) { // GT must be the first.

                        var gtGroups = this._regExp["gt"].exec(sampleValue);
                        if (gtGroups.length == 4) { // GT=0/0,0/1....
                            this._ploidy = 2;

                        } else if (gtGroups.length == 2) {
                            this._ploidy = 1;
                            debugger
                        } else {
                            debugger
                        }
                    }

                    // Check Number
                    var found = sampleValue.split(",").length;

                    switch (formatElem.number) {
                    case ".":
                        this._checkFormatDataType(sampleValue.split(","), formatElem, 'FORMAT', i);
                        break;
                    case "A":
                        var expected = altSplits.length;
                        if (expected != found) {
                            this.addLog("error", "Wrong number of values in FORMAT field '" + formatKey + " (expected one value per alternate)", 8);
                        }
                        this._checkFormatDataType(sampleValue.split(","), formatElem, 'FORMAT', i);
                        break;
                    case "R":
                        var expected = altSplits.length + 1;
                        if (expected != found) {
                            this.addLog("error", "Wrong number of values in FORMAT field '" + formatKey + " (expected one value for each possible  allele, including the reference)", 8);
                        }
                        this._checkFormatDataType(sampleValue.split(","), formatElem, 'FORMAT', i);
                        break;
                    case "G":
                        var expected = this._binomial(altSplits.length + this._ploidy, this._ploidy);
                        if (expected != found) {
                            this.addLog("error", "Wrong number of values in FORMAT field '" + formatKey + " (expected: '" + expected + "', found: '" + found + "'). Must have one value for each possible genotype", 8);
                        }
                        this._checkFormatDataType(sampleValue.split(","), formatElem, 'FORMAT', i);
                        break;
                    default:
                        var expected = parseInt(formatElem.number);
                        if (expected != found) {
                            this.addLog("error", "Wrong number of values in FORMAT field '" + formatKey + " (expected: '" + expected + "', found: '" + found + "'.", 8);
                        }
                        this._checkFormatDataType(sampleValue.split(","), formatElem, 'FORMAT', i);
                        break;
                    }
                }

                var gt = sampleDataSplit[0];
                if (!this._regExp["gt"].test(gt)) {
                    this.addLog("error", "GT must match the regular expression ^(\.|\d+)([|/]?)", 8 + i);
                } else {
                    var gtGroups = this._regExp["gt"].exec(gt);
                    if (gtGroups.length == 2) { // GT = 0,1
                        var gtAllele = parseInt(gtGroups[1]);
                        if (gtAllele > altSplits.length) {
                            this.addLog("error", "An allele index must not be greater than the number of alleles in that variant", 8 + i);
                        }
                    } else if (gtGroups.length == 4) { // GT = 0/0,0/1,....
                        var gtAllele0 = parseInt(gtGroups[1]);
                        var gtAllele1 = parseInt(gtGroups[3]);

                        if (gtAllele0 > altSplits.length || gtAllele1 > altSplits.length) {
                            this.addLog("error", "An allele index must not be greater than the number of alleles in that variant", 8 + i);
                        }

                    }
                }

                if (sampleDataSplit.length != formatSplits.length && sampleDataSplit[0] != "./.") {
                    this.addLog("error", "The number of sub-fields can not be greater than the number in the FORMAT column. Expected : " + formatSplits.length + ", found: " + sampleDataSplit.length, 8 + i);
                }
            }
        }

    }
};

VCFValidator.prototype._checkReferenceTag = function () {

    for (var i = 0; i < this._headerElements.length; i++) {
        var headerElement = this._headerElements[i];
        if (headerElement.id === "reference") {
            return;
        }
    }
    this.addLog("warning", "The tag 'reference' must be present");

};

VCFValidator.prototype._binomial = function (n, k) {
    if ((typeof n !== 'number') || (typeof k !== 'number'))
        return false;
    var coeff = 1;
    for (var x = n - k + 1; x <= n; x++) coeff *= x;
    for (x = 1; x <= k; x++) coeff /= x;
    return coeff;
};

VCFValidator.prototype._isInt = function (value) {
    var x;
    if (isNaN(value)) {
        return false;
    }
    x = parseFloat(value);
    return (x | 0) === x;
};

VCFValidator.prototype._isInt = function (n) {
    return this._regExp["integer"].test(n);
};

VCFValidator.prototype._isFloat = function (n) {
    return this._regExp["float"].test(n);
};

VCFValidator.prototype._checkFormatDataType = function (data, formatElem, field, num) {
    num = 9 + num;
    for (var i = 0; i < data.length; i++) {
        var elem = data[i];
        if (elem == ".") {
            continue;
        }

        if (formatElem.type === "Integer") {
            if (!this._isInt(elem)) {
                this.addLog("error", field + " field '" + formatElem.id + "' defined as '" + formatElem.type + "' . Value '" + elem + "' is not '" + formatElem.type + "'.", num);
            }
        } else if (formatElem.type === "Float") {
            if (!this._isFloat(elem)) {
                this.addLog("error", field + " field '" + formatElem.id + "' defined as '" + formatElem.type + "' . Value '" + elem + "' is not '" + formatElem.type + "'.", num);
            }
        } else if (formatElem.type === "Character") {
            if (elem.length > 1) {
                this.addLog("error", field + " field '" + formatElem.id + "' defined as '" + formatElem.type + "' . Expected one character, found '" + elem.length + "'", num);
            }
        }
    }
};
</script>
<script>function BEDValidator(options) {
    if (!(this instanceof BEDValidator)) {
        return new BEDValidator(options);
    }
    Validator.call(this, options);

    // this._header = true;
    this._duplicates = {};
    this._sorted = true;
    this._columnsSize = null;

}

BEDValidator.prototype = Object.create(Validator.prototype);

BEDValidator.prototype.validateLine = function (line) {
    if (this.isHeaderLine(line)) { // parse Header
        this.parseHeader(line);
    } else {
        this.parseData(line);
    }

}

BEDValidator.prototype.isHeaderLine = function (line) {
    if (line.startsWith("#") == true || line.startsWith("browser") == true || line.startsWith("track") == true) {
        return true;
    } else {
        return false;
    }
}

BEDValidator.prototype.parseHeader = function (line) {}

BEDValidator.prototype.parseData = function (line) {
    if (line == "") {
        this.addLog("warning", "Empety line");
    } else {
        var columns = line.split("\t");

        if (this._columnsSize == null) {
            this._columnsSize = columns.length;
        }

        if (columns.length < 3) {
            this.addLog("error", "Must contain at least 3 columns");
        }

        if (this._columnsSize != columns.length) {
            this.addLog("error", "All ines must have the same number of columns");
        }

        // Chromosome
        var chr = columns[0];
        if (chr == "") {
            this.addLog("error", "Chromosome must not be empty");
        }

        if (chr.search(" ") >= 0) {
            this.addLog("error", "Chromosome must not contain whitespaces");
        }

        // Start
        var start = columns[1]
        if (start == "") {
            this.addLog("error", "Start must not be empty");
        }
        start = parseInt(start)
        if (isNaN(start)) {
            this.addLog("error", "Start must be numeric");
        } else {
            if (start < 0) {
                this.addLog("error", "Start must be greater or equal than 0");
            }
        }

        // End
        var end = columns[2]
        if (end == "") {
            this.addLog("error", "End must not be empty");
        }
        end = parseInt(end)
        if (isNaN(end)) {
            this.addLog("error", "End must be numeric");
        } else {
            if (end < 0) {
                this.addLog("error", "End must be greater or equal than 0");
            }
            if (end < start) {
                this.addLog("error", "End must be greater or equal than Start");
            }
        }
    }

}
</script>
<script>function ExpressionValidator(options) {
    if (!(this instanceof ExpressionValidator)) {
        return new ExpressionValidator(options);
    }
    Validator.call(this, options);

    // this._header = true;
    this._duplicates = {};
    this._sorted = true;
    this._columnsSize = null;

}

ExpressionValidator.prototype = Object.create(Validator.prototype);

ExpressionValidator.prototype.validateLine = function (line, isLast) {

    if (this.isHeaderLine(line)) { // parse Header
        this.parseHeader(line);
    } else {
        this.parseData(line, isLast);
    }

}

ExpressionValidator.prototype.isHeaderLine = function () {
    return this.line === 1;
}
ExpressionValidator.prototype.validateEnd = function () {
    if (this.numLines < 2) {
        this.addLog("error", "The file contains one line or less.");
    }
}

ExpressionValidator.prototype.parseHeader = function (line) {
    var cols = line.split('\t');
    this._columnsSize = cols.length;

    if (cols.length < 2) {
        this.addLog("error", "Header columns must be 2 or higher.");
    } else {
        var v = parseFloat(cols[1]);
        if (isNaN(v)) {

        } else {
            this.addLog("warning", "Header could not be set correctly, sample names seems to be numbers.")
        }
    }
}

ExpressionValidator.prototype.parseData = function (line, isLast) {
    if (line == "") {
        if (!isLast)
            this.addLog("warning", "Empty line.");
    } else {
        var columns = line.split("\t");

        if (this._columnsSize !== columns.length) {
            this.addLog("error", "Column length must be same as the header column length.");
        } else {
            if (columns.length > 1) {
                var found = false;
                for (var i = 1; i < columns.length; i++) {
                    var c = columns[i];
                    var v = parseFloat(c);
                    if (isNaN(v)) {
                        found = true;
                        break;
                    }
                }
                if (found) {
                    this.addLog("error", "Column values must be numbers");
                }
            } else {
                this.addLog("error", "Number of columns must be 2 or higher.");
            }
        }
    }

    // this.addLog("info", "checking line");

    // if (this._columnsSize == null) {
    //     this._columnsSize = columns.length;
    // }
    //
    // if (columns.length < 3) {
    //     this.addLog("error", "Must contain at least 3 columns");
    // }
    //
    // if (this._columnsSize != columns.length) {
    //     this.addLog("error", "All ines must have the same number of columns");
    // }
    //
    // // Chromosome
    // var chr = columns[0];
    // if (chr == "") {
    //     this.addLog("error", "Chromosome must not be empty");
    // }
    //
    // if (chr.search(" ") >= 0) {
    //     this.addLog("error", "Chromosome must not contain whitespaces");
    // }
    //
    // // Start
    // var start = columns[1]
    // if (start == "") {
    //     this.addLog("error", "Start must not be empty");
    // }
    // start = parseInt(start)
    // if (isNaN(start)) {
    //     this.addLog("error", "Start must be numeric");
    // } else {
    //     if (start < 0) {
    //         this.addLog("error", "Start must be greater or equal than 0");
    //     }
    // }
    //
    // // Start
    // var end = columns[1]
    // if (end == "") {
    //     this.addLog("error", "End must not be empty");
    // }
    // end = parseInt(end)
    // if (isNaN(end)) {
    //     this.addLog("error", "End must be numeric");
    // } else {
    //     if (end < 0) {
    //         this.addLog("error", "End must be greater or equal than 0");
    //     }
    //     if (end > start) {
    //         this.addLog("error", "End must be greater or equal than Start");
    //     }
    // }

}
</script>
<script>function ExperimentalDesignValidator(options) {
    if (!(this instanceof ExperimentalDesignValidator)) {
        return new ExperimentalDesignValidator(options);
    }
    Validator.call(this, options);

    // this._header = true;
    this._duplicates = {};
    this._sorted = true;

}

ExperimentalDesignValidator.prototype = Object.create(Validator.prototype);

ExperimentalDesignValidator.prototype.validateLine = function (line, isLast) {
    this.parseData(line);
}

ExperimentalDesignValidator.prototype.validateEnd = function () {
    if (this.numLines < 1) {
        this.addLog("error", "The file is empty");
    }
}

ExperimentalDesignValidator.prototype.parseData = function (line, isLast) {
    if (line == "") {
        if (!isLast)
            this.addLog("warning", "Empty line.");
    } else {
        var columns = line.split("\t");

        if (columns.length < 2) {
            this.addLog("error", "Number of columns must be 2");
        }
    }
}
</script>
<script>function RankedListValidator(options) {
    if (!(this instanceof RankedListValidator)) {
        return new RankedListValidator(options);
    }
    Validator.call(this, options);

    this._columnsSize = -1;
}

RankedListValidator.prototype = Object.create(Validator.prototype);

RankedListValidator.prototype.validateLine = function (line, isLast) {
    this.parseData(line, isLast);
}

RankedListValidator.prototype.parseData = function (line, isLast) {
    if (line == "") {
        if (!isLast)
            this.addLog("warning", "Empty line.");
    } else {
        var columns = line.split("\t");

        if (this._columnsSize == -1) {
            this._columnsSize = columns.length;
        }

        if (this._columnsSize !== columns.length) {
            this.addLog("error", "Column length must be same as the header column length.");
        }
    }
}
</script>


<dom-module name="stv-validator" noscript="">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            height: 300px;
        }

        #header,
        #footer {
            box-sizing: border-box;
            background-color: var(--light-secondary-color);
            padding: 0 7px;
        }

        #header {
            height: 30px;
            border-bottom: 1px solid var(--divider-color);
        }

        #footer {
            height: 30px;
            border-top: 1px solid var(--divider-color);
        }

        #footer>* {
            margin-left: 3px;
        }

        .line {
            width: 40px;
        }

        .type {
            width: 60px;
        }

        #stop {
            margin-left: 7px;
            background-color: var(--dark-button-color);
            color: var(--text-primary-color);
        }

        #stop:hover {
            background-color: var(--light-button-color);
        }

        .type[type="error"],
        .error-count {
            color: #bf4747;
        }

        .type[type="info"],
        .info-count {
            color: #4790bf;
        }

        .type[type="warning"],
        .warning-count {
            color: #bf9947;
        }

        .item {
            /*display: block;*/
            /*position: relative;*/
            /*box-sizing: border-box;*/
            /*height: auto;*/
            /*margin: 3px;*/
            padding: 1px 2px;
            height: 50px;
            border-left: 2px solid transparent;
        }

        .item:hover {
            border-left: 2px solid var(--divider-color);
        }

        .view {
            cursor: pointer;
            visibility: hidden;
        }

        .item:hover>.view {
            visibility: visible;
        }

        .view>i:hover {
            color: var(--dark-button-color);
        }

        .line {
            padding-right: 1px;
            text-align: center;
        }

        .type {
            padding: 0 1px;
            text-align: center;
        }

        .msg {
            word-break: break-all;
            font-size: .95em;
        }

        .item[type="error"] {
            background-color: rgba(191, 71, 71, 0.15);
            border: 1px solid rgba(191, 71, 71, 0.3)
        }

        .item[type="warning"] {
            background-color: rgba(255, 191, 0, 0.15);
            border: 1px solid rgba(255, 191, 0, 0.3);
        }

        #log {
            position: relative;
            height: calc(100% - 60px);
            overflow-y: auto;
            /*background-color: #FAFAFA;*/
            background-color: white;
        }

        .count {
            padding: 0 5px;
        }

        .count>span {
            color: black;
        }

        .uploadbar {
            position: relative;
            height: 18px;
            width: 100px;
            background-color: var(--light-primary-color);
            line-height: 18px;
            border: 1px solid var(--divider-color);
        }

        .uploadprogress {
            position: absolute;
            top: 0px;
            left: 0px;
            height: 100%;
            width: 100%;
            background-color: var(--hover-color);
            /*margin-top: 10px;*/
        }

        .uploadtext {
            position: absolute;
            text-align: center;
            top: 0px;
            left: 0px;
            height: 100%;
            width: 100%;
        }

        .header>div {
            padding-left: 2px;
        }

        .wrapped-text {
            white-space: pre-wrap;
            padding: 10px;
            overflow-y: auto;
            min-width: 400px;
            min-height: 150px;
        }

        #linePreviewPanel {
            max-width: 1000px;
        }
    </style>
    <template>

        <div id="header" class="horizontal layout center">
            <div class="line">Line</div>
            <div class="type">Type</div>
            <div class="msg">Message</div>
            <div class="flex"></div>
            <div class="uploadbar" hidden$="{{!uploading}}">
                <div id="progressBar" class="uploadprogress"></div>
                <div class="uploadtext">
                    <i id="spin" hidden$="{{computeSpin(progress)}}" class="fa fa-spinner fa-spin"></i>
                    <span>{{progress}}</span> %
                </div>
                <br>
            </div>
            <div id="stop" class="stv-btn stv-btn-shdw" on-click="handleStop">Stop</div>
        </div>
        <iron-list id="log" items="{{logIron}}" as="item">
            <template>
                <div class="horizontal layout center item" type$="{{item.type}}">
                    <div class="line">{{item.line}}</div>
                    <div class="type" type$="{{item.type}}">{{item.type}}</div>
                    <div class="msg flex">{{item.msg}}</div>
                    <div class="view" line="{{item.line}}" on-click="handleLogViewClick" title="View line"><i class="fa fa-search"></i></div>
                </div>
            </template>
        </iron-list>

        <div id="footer" class="counts horizontal layout center">
            <div class="stv-btn stv-btn-shdw" on-click="handleView" data-value="error" data-checked$="{{computeView(view, 'error')}}">
                <div class="error-count count">Errors:
                    <span>{{errorCount}}</span>
                </div>
            </div>
            <div class="stv-btn stv-btn-shdw" on-click="handleView" data-value="warning" data-checked$="{{computeView(view, 'warning')}}">
                <div class="warning-count count">Warning:
                    <span>{{warningCount}}</span>
                </div>
            </div>
            <div class="stv-btn stv-btn-shdw" on-click="handleView" data-value="info" data-checked$="{{computeView(view, 'info')}}">
                <div class="info-count count">Info:
                    <span>{{infoCount}}</span>
                </div>
            </div>
            <div class="flex"></div>
            <div class="count">Lines:
                <span>{{numLines}}</span>
            </div>
        </div>

        <stv-panel modal="" movable="" closable="" hidden="" id="linePreviewPanel" on-close="handleCloseLinePreview">
            <div class="header">
                <i class="fa fa-view"></i> &nbsp; View line
            </div>
            <div class="container wrapped-text">{{linePreview}}</div>
        </stv-panel>


    </template>

    <script>
        Polymer({
            is: "stv-validator",
            properties: {
                file: {
                    type: Object,
                    value: function() {
                        return {};
                    },
                    observer: 'fileChanged'
                },
                validator: {
                    type: Object,
                    value: function() {
                        return new Validator({});
                    },
                    observer: 'validatorChanged'
                },
                logIron: {
                    type: Array
                },
                log: {
                    type: Object,
                    value: function() {
                        return {
                            error: [],
                            warning: [],
                            info: []
                        }
                    }
                },
                errorCount: {
                    type: Number,
                    value: 0
                },
                warningCount: {
                    type: Number,
                    value: 0
                },
                infoCount: {
                    type: Number,
                    value: 0
                },
                numLines: {
                    type: Number,
                    value: 0
                },
                progress: {
                    type: Number,
                    value: 0,
                    observer: 'progressChanged'
                },
                view: {
                    type: String,
                    value: 'error'
                },
            },
            ready: function() {
                this.set("logIron", this.log[this.view]);
            },
            handleView: function(e) {
                this.view = e.currentTarget.dataset.value;
                this.set("logIron", this.log[this.view]);
            },
            computeView: function(view, value) {
                return view === value;
            },
            reset: function() {
                this.progress = 0;
                this.set("log", {
                    error: [],
                    warning: [],
                    info: []
                });
                this.set("logIron", this.log[this.view]);
                this.errorCount = 0;
                this.warningCount = 0;
                this.infoCount = 0;
                this.numLines = 0;
                if (this.validator) {
                    this.validator.init();
                }
                this.setFile();
            },
            validate: function() {
                this.set("log", {
                    error: [],
                    warning: [],
                    info: []
                });
                this.set("logIron", this.log[this.view]);
                this.errorCount = 0;
                this.warningCount = 0;
                this.infoCount = 0;
                this.numLines = 0;
                this.validator.validate();
            },
            handleStop: function(e) {
                this.stop();
            },
            stop: function() {
                if (this.validator) {
                    this.validator.stop();
                }
            },
            setFile: function(file) {
                this.fileChanged(file);
            },
            validatorChanged: function(neo, old) {
                var me = this;
                neo.on("end", function(e) {
                    me.numLines = me.validator.numLines;
                    me.fire("end");
                });

                neo.on("err", function(e) {
                    me.fire("err");
                });

                neo.on("stop", function(e) {
                    me.$.spin.setAttribute('hidden', '');
                    me.fire("stop");
                });

                neo.on("log", function(e) {
                    switch (e.type) {
                        case "error":
                            me.errorCount++;
                            if (me.errorCount == 100) {
                                me.stop();
                                new StvDialog().alert('File has more than 100 errors, the validation has been stopped.');
                            }
                            break;
                        case "warning":
                            me.warningCount++;
                            break;
                    }
                    if (me.log[e.type] == me.logIron) {
                        me.push("logIron", e);
                    } else {
                        me.push('log.' + e.type, e);
                    }
                });

                neo.on("lines", function(e) {
                    me.set('numLines', e);
                });

                neo.on("progress", function(e) {
                    me.set('progress', Math.ceil(e));
                });

                neo.init();

            },
            fileChanged: function(neo, old) {
                if (neo && this.validator) {
                    this.validator.init();
                    this.validator.file = neo;
                }
            },
            computeLog: function(validator) {
                if (validator) {
                    return validator.log;
                } else {
                    return [];
                }
            },
            progressChanged: function(neo, old) {
                // console.log("progress : " + neo);
                this.$.progressBar.style.width = neo + '%';
            },
            computeSpin: function(progress) {
                return progress >= 100 || progress <= 0;
            },
            handleLogViewClick: function(e) {
                var me = this;
                var elem = e.currentTarget;
                var line = elem.line - 1;
                this.column = elem.column;
                this.validator._navigator.readLines(line, 1, function linesReadHandler(err, index, lines, eof, progress) {
                    if (err) {
                        return;
                    }

                    if (lines.length > 0) {
                        var aux = lines[0].split("\t");
                        aux[me.column] = '<span style="color:red">' + aux[me.column] + '</span>';
                        me.linePreview = aux;
                        me.$.linePreviewPanel.show();
                    }

                    if (eof) {
                        return;
                    }

                });
            },
            handleCloseLinePreview: function(e) {
                e.stopPropagation();
                this.linePreview = "";
            }
        })
    </script>
</dom-module>
<dom-module id="stv-import-file" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            padding: 20px 30px;
        }

        #importBox {
            width: 500px;
            height: 390px;
        }

        .importBut {
            width: 100px;
            color: var(--default-primary-color);
        }

        .filename {
            /*word-break: break-all;*/
            padding: 0 4px;
            border: 1px solid var(--divider-color);
            background-color: var(--hover-color);
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            max-width: 360px;
        }

        stv-validator {
            border: 1px solid var(--divider-color);
        }

        #recheckButton {
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
        }

        #recheckButton:hover {
            background-color: var(--light-button-color) !important;
        }
    </style>
    <template>
        <div id="importBox" class="vertical layout">
            <div class="horizontal layout">
                <div class="stv-btn stv-btn-shdw" on-click="handleBrowseClick" pattern="[a-zA-Z0-9_-]+">
                    <span>Choose file...</span>
                </div>
                <div class="flex">
                </div>
                <input type="file" hidden="" id="fileInput" required="" on-change="handleInputChange" disabled$="{{uploading}}">
                <div class="jso-btn jso-btn-shdw importBut" on-click="handleImport"><i class="fa fa-plus-square-o"></i>&nbsp; Import
                </div>
            </div>
            <div class="horizontal layout" style="line-height: 22px;margin-top: 5px;">
                <label class="stv">Selected file name: &nbsp;</label>
                <div class="filename flex">{{fileName}}</div>
                <div id="recheckButton" class="jso-btn jso-btn-shdw" style="height:24px;" on-click="handleRecheck">
                    Revalidate
                </div>
            </div>
            <label class="stv" style="margin-top:15px;">File validation log:</label>
            <stv-validator id="validator" bioformats="{{bioformats}}" on-end="handleValidatorEnd" on-stop="handleValidatorStop"></stv-validator>
        </div>


    </template>


    <script>
        Polymer({
            is: "stv-import-file",
            properties: {
                bioformat: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },
                uploading: {
                    type: Boolean,
                    value: false
                },
                fileName: {
                    type: String,
                    value: 'None'
                },
                validating: {
                    type: Boolean,
                    value: false
                },
                bioformats: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                stop: {
                    type: Boolean,
                    value: false
                }

            },
            ready: function(e) {},

            handleValidatorEnd: function(e) {
                new StvDialog().alert('Validation has finished succesfully. Check errors or click on import button');
                this.validating = false;
            },

            handleValidatorStop: function(e) {
                new StvDialog().alert('Validation has been stopped.');
                this.validating = false;
                this.stop = true;
                //
                // if (this._wantRevalidate == true) {
                //     this._wantRevalidate = null;
                //     this.revalidate();
                // }
            },
            handleRecheck: function(e) {
                // this.$.validator.reset();
                // this.validate();
                if (this.validating == true) {
                    this._wantRevalidate = true;
                    this.$.validator.stop();
                } else {
                    this.revalidate(e);
                }
            },
            revalidate: function(e) {
                this.$.validator.reset();
                this.handleValidate(e);
            },

            handleBrowseClick: function(e) {
                if (this.uploading == false) {
                    this.$.fileInput.click();
                }
            },
            handleValidate: function(e) {
                this.validating == true;
                this.stop = false;
                var file = this.$.fileInput.files[0];
                if (file != null) {
                    this.$.validator.reset();
                    // var validator;

                    var validator = new Validator({});

                    if (this.bioformat.validator) {
                        if (typeof this.bioformat.validator !== "function") {
                            new StvDialog().alert("Validator '" + this.bioformat.validator + "' not recognized.");
                            return;
                        }
                        validator = new this.bioformat.validator({});
                    } else {
                        validator = new Validator({});
                    }
                    this.$.validator.validator = validator;
                    this.$.validator.setFile(file);
                    this.$.validator.validate();
                }

            },
            handleInputChange: function(e) {
                if (this.uploading == false) {
                    this.inputFile = this.$.fileInput.files[0];
                    this.fileName = this.inputFile.name;
                    this.handleValidate(e);

                }
            },
            handleImport: function(e) {
              var me=this;
                var file = this.$.fileInput.files[0];
                if (file == null) {
                    new StvDialog().alert("No file selected.")
                    return;
                }
                if (this.uploading == true) {
                    new StvDialog().alert("Upload already in progress.")
                    return;
                }
                if (this.validating == false && this.stop == false) {

                    if (this.$.validator.errorCount > 0) {
                        new StvDialog().alert("The file contains errors.")
                        return;
                    }
                    if (this.$.validator.warningCount > 0) {
                        new StvDialog().confirm("Are you sure?", function(answer) {
                            if (answer == true) {
                              me.fire('importfile');
                                 return;
                            } else {
                                return;
                            }
                        });
                    }
                    // this.fire('importfile');
                }
                // if (this.validating == false && this.stop==false) {
                //     // this.uploading=true;
                //     this.fire('importfile');
                // }
            }
        });
    </script>
</dom-module>
<dom-module id="stv-ontology-tree-item" assetpath="bower_components/stevia-elements/src/ontology/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
            /*width:100%;*/
            /*overflow: hidden;
            text-overflow: clip;*/
        }

        .main {
            cursor: pointer;
            border: 1px solid transparent;
            white-space: nowrap;
            /*overflow: hidden;
            text-overflow: clip;*/
        }

        .main:hover > * {
            background-color: var(--hover-color)
        }

        .folder:before {
            font-family: "FontAwesome";
            display: inline-block;
            width: 20px;
            text-align: center;
            content: '\f07b';
        }

        .file:before {
            font-family: "FontAwesome";
            display: inline-block;
            width: 20px;
            text-align: center;
            content: '\f0f6';
        }

        .fOpen:before {
            font-family: "FontAwesome";
            display: inline-block;
            width: 20px;
            text-align: center;
            content: '\f07c';
        }

        :host[selected] #name {
            background-color: var(--selected-color);
        }

        .arrow:before {
            font-family: "FontAwesome";
            display: inline-block;
            width: 12px;
            text-align: center;
            content: '\f0da';
        }

        .arrow[open]:before {
            content: '\f0d7';
        }

        .arrow[empty]:before {
            content: '\00a0';
        }

        .arrow {
            padding: 2px 0 2px 2px;
        }

        #name {
            padding: 2px 2px 2px 0;
        }
    </style>
    <template>
        <div class="main horizontal layout stv-nosel">
            <div class="arrow" empty$="{{isEmpty(file.children)}}" open$="{{file.open}}" on-click="toggleOpen"></div>
            <div id="name" class$="{{computeClass(file)}}" on-click="handleClick" on-dblclick="toggleOpen">{{computeName(file.name)}}</div>
        </div>
        <div style="margin-left:7px;" hidden$="{{!file.open}}">
            <template is="dom-repeat" items="{{auxItems}}" as="f">
                <stv-ontology-tree-item file="{{f}}" tree="{{tree}}">
                </stv-ontology-tree-item>
            </template>
        </div>
    </template>
    <script>
        Polymer({
            is: "stv-ontology-tree-item",
            properties: {
                file: {
                    type: Object,
                    observer: 'fileChanged'
                },
                auxItems: {
                    type: Array
                },
                selected: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                tree: {
                    type: Array,
                    notify: true
                }
            },
            fileChanged: function(neo, old) {
                if (neo) {
                    this.checkFiles();
                }
            },
            checkFiles: function() {
                if (this.file.open == true) {
                    if (this.file.children == null) {
                        this.set('auxItems', []);
                    } else {
                        this.set('auxItems', this.file.children);
                    }
                } else {
                    this.set('auxItems', []);
                }
            },
            isEmpty: function(f) {
                return f.length == 0;
            },
            computeName: function(name) {
                if (name.indexOf('anonymous___') != -1) {
                    name = 'anonymous';
                }
                return name;
            },
            handleClick: function(e) {
                this.selected = !this.selected;
            },
            toggleOpen: function(e) {
                this.getChildren(this.file.children);
            },
            computeClass: function(file) {
                if (file.children.length > 0) {
                    if (file.open == true) {
                        return "fOpen flex"
                    } else {
                        return "folder flex"
                    }
                } else {
                    return "file flex"
                }
            },
            getChildren(children) {
                var me = this;
                var ids = [];
                var type = "hpo";
                for (var i = 0; i < children.length; i++) {
                    ids.push(children[i].id);
                }

                if (ids[0].indexOf("GO") >= 0) {
                    type = "go";
                }

                if (localStorage["bioinfo_biertool_" + type]) {
                    //Coger los hijos del local storage: JSON.parse(localStorage["bioinfo_biertool_" + type]);
                } else {
                  //Coger los hijos del WS
                    BiodbManager[type].info({
                        query: {
                            id: ids.join(",")
                        },
                        request: {
                            success: function(response) {
                                if (response.error === '' || response.error.msg == "") {
                                    var responseChildrenMap = {};
                                    for (var i = 0; i < response.result.length; i++) {
                                        responseChildrenMap[response.result[i].id] = response.result[i];
                                    }
                                    for (var i = 0; i < me.file.children.length; i++) {
                                        var child = me.file.children[i];
                                        child.children = responseChildrenMap[child.id].children;

                                    }
                                    //meter los hijos al local storage JSON.parse(localStorage["bioinfo_biertool_" + type]);
                                    me.set('file.open', !me.file.open);
                                    me.checkFiles();
                                } else {
                                    console.log(response.error.msg);
                                }
                            },
                            error: function() {
                                console.log('Server error, try again later.');
                            }
                        }
                    });
                }
            }
        });
    </script>
</dom-module>
<dom-module id="stv-ontology-tree" assetpath="bower_components/stevia-elements/src/ontology/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
            background-color: inherit;
        }
    </style>
    <template>
        <template is="dom-repeat" items="{{tree}}" as="file">
            <stv-ontology-tree-item file="{{file}}" tree="{{tree}}">
            </stv-ontology-tree-item>
        </template>
    </template>
    <script>
        Polymer({
            is: "stv-ontology-tree",
            properties: {
                tree: {
                    type: Array,
                    observer: 'treeChanged'
                }
            },
            treeChanged: function(neo, old) {
                var openIndex = {};
                if (old) {
                    for (var i = 0; i < old.length; i++) {
                        this._createOpenIndex(openIndex, old[i]);
                    }
                }
                if (neo) {
                    for (var i = 0; i < neo.length; i++) {
                        this._initFile(neo[i], null, openIndex);
                    }
                }
            },
            _initFile: function(file, parent, openIndex) {
                if (parent == null) {
                    file.path = file.name;
                } else {
                    file.path = parent.path + '/' + file.name;
                    file.parent = parent;
                }
                var defaultOpen = (file.open == true) ? file.open : false;
                file.open = openIndex[file.path] || defaultOpen;
                for (var i = 0; i < file.children.length; i++) {
                    this._initFile(file.children[i], file, openIndex);
                }
            },
            _createOpenIndex: function(openIndex, file) {
                if (openIndex[file.path] == null) {
                    openIndex[file.path] = file.open;
                    for (var i = 0; i < file.children.length; i++) {
                        this._createOpenIndex(openIndex, file.children[i]);
                    }
                }
            }
        });
    </script>
</dom-module>
<script>
    JsoApplicationBehavior = {
        properties: {
            version: {
                type: String,
                reflectToAttribute: true
            },
            selectedOption: {
                type: String,
                value: "home",
                notify: true,
                reflectToAttribute: true,
                observer: '_selectedOptionChanged'
            },
            userData: {
                type: Object,
                notify: true,
                observer: 'userDataChanged'
            },
            projects: {
                type: Array,
                notify: true
            },
            maintenance: {
                type: String,
                value: '',
                reflectToAttribute: true,
                observer: 'checkMaintenance'
            },
            smallHeader: {
                type: Boolean,
                value: false,
                reflectToAttribute: true,
            },
            _lastLogedRequest: {
                type: Object
            }
        },
        ready: function(){
          var me=this;
          //cookies
          if (Cookies('app-accept-cookies') == null) {
              var div = document.createElement('div');
              div.style.position = 'fixed';
              div.style.backgroundColor = '#8ba7a7';
              div.style.color = '#fff';
              div.style.padding = '10px';
              div.style.left = '0';
              div.style.right = '0';
              div.style.top = '5px';
              div.style.zIndex = '10000';
              div.style.fontSize = '13px';
              div.style.width = '600px';
              div.style.margin = '0 auto';
              div.style.cursor = 'pointer';
              div.style.boxShadow = '0px 0px 6px 3px rgba(0, 0, 0, 0.30)';
              var msg = [
                  'This website uses cookies.',
                  'By continuing to browse this site,',
                  ' you are agreeing to the use of our site cookies.',
                  '<div style="font-size:12px;text-align:right;text-decoration:underline;">OK</div>'
              ];
              div.innerHTML = msg.join(' ');
              div.addEventListener('click', function() {
                  Polymer.dom(me.root).removeChild(div);
                  Cookies.set('app-accept-cookies', 'true', {
                      expires: 3600 * 24 * 7
                  }); // Expires in 1 week
              });
              Polymer.dom(this.root).appendChild(div);
          }
        },
        _selectedOptionChanged: function(neo, old) {
            var menuItems = Polymer.dom(this.root).querySelectorAll('[menu-option]');
            for (var i = 0; i < menuItems.length; i++) {
                var item = menuItems[i];
                var currentItemValues = item.getAttribute("menu-option").split(',');
                if (currentItemValues.indexOf(neo) != -1) {
                    item.removeAttribute("hidden");
                } else {
                    item.setAttribute('hidden', '');
                }
            }

            var optionItems = Polymer.dom(this.root).querySelectorAll('[data-option]');
            for (var i = 0; i < optionItems.length; i++) {
                var el = optionItems[i];
                if (el.dataset.option === this.selectedOption) {
                    el.setAttribute('active', '');
                } else {
                    el.removeAttribute('active')
                }
            }
            this.selectedOptionChanged(neo, old);
        },
        selectedOptionChanged: function(neo, old) {
            // abstract method;
        },
        handleMenuOption: function(e) {
            var option = e.currentTarget.dataset['option'];
            this.setMenu(option);
        },
        handleLoggedOnlyMenuOption: function(e) {
            if (this.$.jsoHeader != null) {
                var option = e.currentTarget.dataset['option'];
                if (this.$.jsoHeader.isLogged) {
                    this.setMenu(option);
                } else {
                    this.selectedOption = 'login';
                }
            }
        },
        setMenu: function(option) {
            if (option) {
                this.set('selectedOption', option);
            }
        },
        handleMenuPanel: function(e) {
            var panel = this.$[e.currentTarget.dataset.panel];
            panel.hidden = !panel.hidden;
        },
        handleLoggedOnlyMenuPanel: function(e) {
            var option = e.currentTarget;
            if (this.$.jsoHeader != null) {
                var panel = this.$[e.currentTarget.dataset.panel];
                if (panel == null) {
                    panel = document.querySelector(e.currentTarget.dataset.panel);
                }
                if (this.$.jsoHeader.isLogged) {
                    panel.hidden = !panel.hidden;
                    if (panel.hidden) {
                        option.removeAttribute('active');
                    } else {
                        option.setAttribute('active', '');
                    }
                } else {
                    this.selectedOption = 'login';
                    this._lastLogedRequest = panel;
                }
            }
        },
        handlePanelHidden: function(e) {
            var id = e.currentTarget.getAttribute('id');
            var sel = '[data-panel=' + id + ']';
            var el = Polymer.dom(this.$.menu).querySelector(sel);
            if (e.currentTarget.hidden) {
                el.removeAttribute('active');
            } else {
                el.setAttribute('active', '');
            }
        },
        userDataChanged: function(neo, old) {
            var me = this;
            if (this.userData) {
                var projectIds = [];
                for (var i = 0; i < this.userData.projects.length; i++) {
                    var p = this.userData.projects[i];
                    projectIds.push(p.id);
                }
                var projects = [];
                OpencgaManager.projects.studies({
                    id: projectIds.join(','),
                    query: {
                        sid: Cookies("bioinfo_sid")
                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                for (var i = 0; i < response.response.length; i++) {
                                    var r = response.response[i];
                                    me.userData.projects[i].studies = r.result;
                                    projects.push(me.userData.projects[i]);
                                }
                                /* update projects property*/
                                me.projects = projects;
                            } else {
                                console.log(response.error);
                                console.log(response.response[0].errorMsg);
                            }
                            me.loading = false;
                        },
                        error: function() {
                            console.log('Server error, try again later.');
                            me.loading = false;
                        }
                    }
                });
            } else {
                this.set('projects', []);
                console.log("no user data")
            }
        },
        checkMaintenance: function(neo) {
            var me = this;
            if (neo != null && neo !== '') {
                var currentDate = new Date();
                var split = this.maintenance.split(",");
                var startDate = Date.parse(split[0]);
                var endDate = Date.parse(split[1]);
                if (currentDate < startDate || (currentDate >= startDate && currentDate <= endDate)) {
                    var maintenance = Polymer.dom(this).querySelector('#maintenance');
                    if (maintenance == null) {
                        var maintenance = document.createElement('div');
                        maintenance.classList.add('jso-note', 'jso-note-warn');
                        maintenance.setAttribute('id', 'maintenance');
                        maintenance.style.position = 'fixed';
                        maintenance.style.left = '0';
                        maintenance.style.right = '0';
                        maintenance.style.top = '10px';
                        maintenance.style.zIndex = '10000';
                        maintenance.style.fontSize = '16px';
                        maintenance.style.width = '500px';
                        maintenance.style.margin = '0 auto';
                        maintenance.style.boxShadow = '0px 0px 6px 3px rgba(0, 0, 0, 0.30)';
                    }

                    if (currentDate < startDate) {
                        var diffMessage = Utils.timeDiff(split[0], split[1]);
                        var msg = ['There will be a <b>', diffMessage,
                            '</b> downtime on this site for maintenance from: <br><br> <b>',
                            new Date(startDate).toString(), '</b> to <br> <b>' + new Date(endDate).toString(), '</b><br><br>',
                            'We apologize for any inconvenience.',
                            '<br> <div style="font-size:14px;text-align:right;">Click to dimiss this message.</div>'
                        ];
                        maintenance.addEventListener('click', function() {
                            Polymer.dom(me.root).removeChild(maintenance);
                        });
                        Polymer.dom(this.root).appendChild(maintenance);
                    }

                    if (currentDate >= startDate && currentDate <= endDate) {
                        var diffMessage = Utils.timeDiff(currentDate, split[1]);
                        var msg = ['This site is under maintenance we will be back in: <b><br><br>',
                            diffMessage, '</b> <br><br>',
                            'We apologize for any inconvenience.',
                        ];
                        document.body.removeChild(this);
                        document.body.appendChild(maintenance);
                        document.body.style.backgroundColor = '#333';
                    }

                    maintenance.innerHTML = msg.join(' ');
                }
            }
        },
        checkShowMenuOnLogin: function() {
            var menuButtons = this.querySelectorAll("[show-on-login]");
            if (this.$.jsoHeader != null) {
                for (var i = 0; i < menuButtons.length; i++) {
                    var elem = menuButtons[i];
                    if (!this.$.jsoHeader.isLogged) {
                        elem.hidden = true;
                    } else {
                        elem.hidden = false;
                    }
                }
            }

        }
    };
</script>
<script>
    JsoOpencgaManagerBehavior = {
        properties: {

        },
        /**
         * Get files information given a file Id.
         */
        _getFileBean: function(fileId, cb) {
            OpencgaManager.files.info({
                id: fileId,
                query: {
                    sid: Cookies('bioinfo_sid')
                },
                request: {
                    success: function(response) {
                        cb(response.response[0].result[0])
                    },
                    error: function(response) {}
                }
            });
        },
        /**
         * Get files information given a file ids array.
         */
        _getFilesBeans: function(fileIds, cb) {
            OpencgaManager.files.info({
                id: fileIds,
                query: {
                    sid: Cookies('bioinfo_sid')
                },
                request: {
                    success: function(response) {
                        var fileBeans = [];
                        for (var i = 0; i < response.response.length; i++) {
                            var res = response.response[i];
                            var file = res.result[0];
                            fileBeans.push(file);
                        }
                        cb(fileBeans)
                    },
                    error: function(response) {}
                }
            });
        },
        /**
         * Get content given a file Id.
         */
        _getFileContent: function(fileId, cb) {
            OpencgaManager.files.content({
                id: fileId,
                query: {
                    sid: Cookies('bioinfo_sid')
                },
                request: {
                    async: true,
                    success: function(response) {
                        cb(response);
                    },
                    error: function(response) {

                    }
                }
            });
        },
        _getFileURL: function(fileId) {
            return OpencgaManager.files.download({
                id: fileId,
                query: {
                    sid: Cookies("bioinfo_sid")
                },
                request: {
                    url: true
                }
            });
        },
        /**
         * Download the file given a file Id.
         */
        _downloadFile: function(fileId) {
            var url = this._getFileURL(fileId);
            var link = document.createElement('a');
            link.href = url;
            var event = new MouseEvent('click', {
                'view': window,
                'bubbles': true,
                'cancelable': true
            });
            link.dispatchEvent(event);
        },
        _uploadFile: function(studyId, path, fileName, fileContent, bioFormat, callback) {
            var blob = new Blob([fileContent], {
                type: 'text/plain'
            });
            var config = {
                inputFile: blob,
                fileName: fileName,
                userId: Cookies("bioinfo_user"),
                sid: Cookies("bioinfo_sid"),
                studyId: studyId,
                relativeFilePath: path + fileName,
                fileFormat: 'PLAIN',
                bioFormat: bioFormat,
                description: '',
                callbackProgress: function(chunk, total, response) {
                    var percentProgress = Math.round((chunk.id / total) * 100);
                    console.log(percentProgress);
                    if (chunk.last) {
                        var uploadedFile = response.response[0].result[0];
                        callback(uploadedFile);
                    }
                },
                error: function(msg, result) {
                    console.log(msg);
                    callback(null, msg, result);
                }
            };
            OpencgaManager.files.upload2(config);
        },
        _updateFileAttributes: function(fileId, attributes, cb) {
            OpencgaManager.files.update({
                id: fileId,
                query: {
                    sid: Cookies('bioinfo_sid'),
                    // attributes: encodeURIComponent(JSON.stringify(attributes))
                    attributes: JSON.stringify(attributes)
                },
                request: {
                    success: function(response) {
                        cb(response.response[0].result[0])
                    },
                    error: function(response) {}
                }
            });
        },
        _getJobBean: function(jobId, cb) {
            OpencgaManager.jobs.info({
                id: jobId,
                query: {
                    sid: Cookies('bioinfo_sid')
                },
                request: {
                    success: function(response) {
                        cb(response.response[0].result[0])
                    },
                    error: function(response) {}
                }
            });
        },
        _createFolder: function(studyId, path, folderName, cb) {
            var me = this;
            var folder;
            OpencgaManager.files.createFolder({
                query: {
                    sid: Cookies('bioinfo_sid'),
                    folder: path + folderName,
                    studyId: studyId
                },
                request: {
                    success: function(response) {
                        cb(response.response[0].result[0]);
                    },
                    error: function() {}
                }
            });
        },
        _deleteFile: function(fileId, cb) {
            OpencgaManager.files.delete({
                id: fileId,
                query: {
                    sid: Cookies('bioinfo_sid'),
                },
                request: {
                    success: function(response) {
                        cb(response.response[0].result[0]);
                    },
                    error: function() {}
                }
            });
        },
        _deleteJob: function(jobId, cb, deleteFiles) {
            if (deleteFiles !== false) {
                deleteFiles = true;
            }
            OpencgaManager.jobs.delete({
                id: jobId,
                query: {
                    sid: Cookies('bioinfo_sid'),
                    deleteFiles: deleteFiles
                },
                request: {
                    success: function(response) {
                        cb(response.response[0].result[0]);
                    },
                    error: function() {
                        cb()
                    }
                }
            });
        }
    };
</script>
<dom-module id="jso-panel" assetpath="bower_components/jsorolla/src/lib/components/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.4);
        }

        :host[modal] {
            z-index: 100 !important;
            position: fixed;
            box-shadow: 0px 0px 6px 3px rgba(0, 0, 0, 0.30);
        }

        :host[movable] {
            box-shadow: 0px 0px 6px 3px rgba(0, 0, 0, 0.30);
        }

        :host[fixed] {
            position: fixed;
        }

        #loading {
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            position: absolute;
            background-color: rgba(0, 0, 0, .5);
        }

        #loading-icon {
            color: white;
            font-size: 30px;
            position: absolute;
            top: calc(50% - 15px);
            left: calc(50% - 15px);
        }

        #back {
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.6);
        }

        #header {
            position: relative;
            text-transform: capitalize;
            -moz-user-select: -moz-none;
            -khtml-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: var(--default-primary-color);
            color: var(--text-primary-color);
        }

        :host[light-header] > #header {
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        :host[movable] > #header {
            cursor: move;
        }

        #header > .headeractions > * {
            box-sizing: border-box;
            padding: 2px 5px;
            border: 1px solid transparent;
            cursor: pointer;
        }

        #header > .headeractions > *[data-checked] {
            background-color: rgba(0, 0, 0, 0.20);
        }

        #header > .headeractions > *:hover {
            background-color: rgba(0, 0, 0, 0.20);
        }

        #header > .headeractions > .closable:after {
            font-family: FontAwesome;
            content: '\f00d';
        }

        #header > .headeractions > .collapsible:after {
            font-family: FontAwesome;
            content: '\f106';
        }

        :host[collapsed] > #header > .headeractions > .collapsible:after {
            font-family: FontAwesome;
            content: '\f107';
        }

        #header > .headeractions > .pin:after {
            font-family: FontAwesome;
            content: '\f08d';
        }

        :host[expandible] .headeractions > .expandible:after {
            font-family: FontAwesome;
            content: '\f065';
        }

        :host[expandible][expanded] .headeractions > .expandible:after {
            content: '\f066';
        }

        #header,
        .container,
        ::content .footer {
            position: relative;
        }

        #header,
        #footer {
            box-sizing: border-box;
            padding: 4px 5px 4px 12px;
            height: 32px;
        }

        #footer {
            position: relative;
            border-top: 1px solid var(--divider-color);
            background-color: var(--light-secondary-color);
            color: var(--primary-text-color);
        }

        #footer > div,
        #footer > div > div {
            margin-right: 2px;
            margin-left: 2px;
        }

        .container {
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
            position: relative;
            height: calc(100% - 32px);
        }

        :host[_hasfooter] .container {
            height: calc(100% - 64px);
        }
    </style>
    <template>

        <div id="back" hidden$="{{!modal}}"></div>

        <div id="header" class="header horizontal layout" on-dblclick="handleHeaderDblclick" on-mousedown="handleHeaderMouseDown" on-mouseup="handleHeaderMouseUp">
            <div class="horizontal layout flex center">
                <content select=".header"></content>
            </div>
            <div class="headeractions horizontal layout center end-justified" on-mousedown="handleActionsMouseDown">
                <div hidden$="{{!expandible}}" class="expandible" on-click="handleExpandAction"></div>
                <div hidden$="{{isPinHidden(movable,moved,fixed)}}" class="pin" on-click="handlePinAction"></div>
                <div hidden$="{{!collapsible}}" class="collapsible" on-click="handleCollapseAction"></div>
                <div hidden$="{{!closable}}" class="closable" on-click="handleCloseAction"></div>
            </div>
        </div>

        <div id="container" class="container horizontal layout" hidden$="{{isContainerHidden(collapsible, collapsed)}}">
            <content select=".container"></content>
        </div>

        <div id="footer" class="horizontal layout flex center" hidden$="{{isFooterHidden(_hasfooter, collapsible, collapsed)}}">
            <content select=".footer"></content>
        </div>

        <div id="loading" hidden$="{{!loading}}">
            <i id="loading-icon" class="fa fa-circle-o-notch fa-spin"></i>
        </div>
    </template>
</dom-module>
<script>
    (function() {
        var lastWindow_;

        JsoPanel = Polymer({
            is: "jso-panel",
            behaviors: [
                Polymer.IronResizableBehavior
            ],
            properties: {
                fixed: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                closable: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                collapsible: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                collapsed: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                movable: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                expandible: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                expanded: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                modal: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                constraint: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                moved: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                loading: {
                    type: Boolean,
                    value: false
                },
                lightHeader: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                hidden: {
                    type: Boolean,
                    reflectToAttribute: true,
                    observer: 'hiddenChanged'
                },
                _hasfooter: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                _firstHidden: {
                    type: Boolean,
                    value: false
                }
            },
            listeners: {
                'mousedown': '_updateLastWindow'
            },
            hostAttributes: {
                'class': 'vertical layout flex'
            },
            ready: function() {
                this.async(function() {
                    if (this.fixed) {
                        this._center();
                    }
                }, 50);
                this._hasfooter = this.$.footer.childElementCount > 0;

                var child = this.$.container.querySelector('.container');
                if (child != null) {
                    child._parentJsoPanel = this;
                }
            },
            hiddenChanged: function(neo, old) {
                // check if is not hidden
                if (neo == false) {
                    if (this.modal) {
                        this._center();
                    }
                    if (this.fixed && !this._firstHidden) {
                        this._center();
                    }
                    this._firstHidden = true;
                    this._updateLastWindow();
                }
                this.fire('hidden', this.hidden);
                this.notifyResize();
            },
            show: function() {
                this.hidden = false;
                this.hiddenChanged(false);
            },
            hide: function() {
                this.hidden = true;
                this.hiddenChanged(true);
            },
            isContainerHidden: function(collapsible, collapsed) {
                if (collapsible && collapsed) {
                    return true;
                }
                return false;
            },
            isFooterHidden: function(_hasfooter, collapsible, collapsed) {
                if (_hasfooter) {
                    if (collapsible && collapsed && _hasfooter) {
                        return true;
                    } else {
                        return false
                    }
                } else {
                    return true;
                }
            },
            isPinHidden: function(movable, moved, fixed) {
                if (fixed) {
                    return true;
                }
                if (this.modal) {
                    return true;
                }
                if (!movable) {
                    return true;
                }
                return !moved;
            },
            setLoading: function(loading) {
                this.loading = loading;
            },
            /* */
            toggleCollapse: function() {
                if (this.collapsible) {
                    this.collapsed = !this.collapsed;
                    this.notifyResize();
                }
            },
            handleHeaderDblclick: function(e) {
                this.toggleCollapse();
            },
            handleCollapseAction: function(e) {
                this.toggleCollapse();
            },
            handleCloseAction: function() {
                this.hidden = true;
                this.fire('close');
            },
            handlePinAction: function(e) {
                this.style.position = '';
                this.style.left = '';
                this.style.top = '';
                this.style["z-index"] = '2';

                this.moved = false;
                this.notifyResize();
            },
            handleExpandAction: function(e) {
                e.stopPropagation();
                var currentZIndex = -1; //no z-index set;
                if (!isNaN(this.style['z-index'])) {
                    currentZIndex = parseInt(this.style['z-index']);
                }
                if (this.expandible) {
                    this.expanded = !this.expanded;
                    if (this.expanded) {
                        this.style.position = 'fixed';
                        this.style.width = '100%';
                        this.style.height = '100%';
                        this.style.top = '';
                        this.style.left = '';
                        this.style['z-index'] = currentZIndex + 100;
                    } else {
                        this.style.width = '';
                        this.style.height = '';
                        this.style.position = '';
                        this.style.top = '';
                        this.style.left = '';
                        if (currentZIndex >= -1) {
                            this.style['z-index'] = currentZIndex - 100;
                        } else {
                            this.style['z-index'] = '';
                        }
                        this._center();
                    }
                }
                this.fire('expand');
                this.notifyResize();
            },

            handleActionsMouseDown: function(e) {
                e.stopPropagation();
            },
            handleHeaderMouseDown: function(e) {
                if (this.movable && !this.expanded) {
                    document.body.classList.add('jso-nosel');
                    var me = this;
                    var bcr = this.$.header.getBoundingClientRect();

                    this.headerOffsetX = e.clientX - bcr.left;
                    this.headerOffsetY = e.clientY - bcr.top;

                    window.removeEventListener('mousemove', this.mouseMoveHandler, true);

                    this.mouseMoveHandler = function(moveEvent) {
                        me.handleMouseMove(moveEvent);
                    };
                    window.addEventListener('mousemove', this.mouseMoveHandler, true);
                }
            },
            handleHeaderMouseUp: function() {
                if (this.movable) {
                    window.removeEventListener('mousemove', this.mouseMoveHandler, true);
                    document.body.classList.remove('jso-nosel');
                }
                // this._updateLastWindow();
            },
            handleMouseMove: function(e) {
                if (this.movable) {
                    this.moved = true;
                    this.style.position = 'fixed';
                    var left = e.clientX - this.headerOffsetX;
                    var top = e.clientY - this.headerOffsetY;
                    if (this.constraint) {
                        var bcr = this.getBoundingClientRect();
                        var bcrHeader = this.$.header.getBoundingClientRect();
                        var rightLimit = window.innerWidth - bcr.width;
                        var bottomLimit = window.innerHeight - bcrHeader.height;
                        if (left > 0 && left < rightLimit) {
                            this.style.left = left + 'px';
                        }
                        if (top > 0 && top < bottomLimit) {
                            this.style.top = top + 'px';
                        }
                    } else {
                        this.style.left = left + 'px';
                        this.style.top = top + 'px';
                    }

                }
            },

            /** **/
            _center: function() {
                var bcr = this.getBoundingClientRect();
                this.style.left = (window.innerWidth / 2 - bcr.width / 2) + 'px';
                this.style.top = (window.innerHeight / 2 - bcr.height / 2) + 'px';
                this.notifyResize();
            },
            _updateLastWindow: function() {
                if (lastWindow_) {
                    if (!lastWindow_.expanded && lastWindow_.movable) {
                        lastWindow_.style["z-index"] = '1';
                    }
                }
                lastWindow_ = this;
                if (lastWindow_) {
                    if (!lastWindow_.expanded && lastWindow_.movable) {
                        lastWindow_.style["z-index"] = '2';
                    }
                }
            }

        });

    })();
</script>
<dom-module id="jso-wizard" assetpath="bower_components/jsorolla/src/lib/components/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            height: 100%;
            width: 100%;
        }

        #wizard-content {
            height: 100%;
        }

        .container {
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .file {
            text-align: center;
            color: #445D76;
            width: 100px;
            align-self: center;
        }

        .next,
        .prev {
            text-align: right;
            color: var(--dark-button-color);
            font-size: 15px;
            margin-right: 5px;
        }

        .init,
        .end {
            text-align: right;
            color: var(--dark-button-color);
            font-size: 15px;
            margin-right: 5px;
        }

        .next {
            margin-right: 15px;
        }

        .prev {
            margin-left: 15px;
        }

        .next:hover,
        .end:hover,
        .init:hover,
        .prev:hover {
            /*background-color: #d3d3d3;*/
            color: #6B6B6B;
            cursor: pointer;
            font-weight: bold;
        }

        #header {
            /*margin-bottom: 10px;*/
            box-sizing: border-box;
            height: 40px;
            padding: 7px 10px;
            background-color: var(--light-secondary-color);
            border-bottom: 1px solid var(--divider-color);
        }

        #container {
          height: calc(100% - 80px);
        }

        #footer {
            height: 40px;
            padding: 7px 10px;
            box-sizing: border-box;
        }

        #title {
            font-size: 20px;
            color: #445d76;
        }

        #wizard-bottom {
            box-sizing: border-box;
            height: 40px;
            padding: 7px 10px;
            background-color: var(--light-secondary-color);
            border-top: 1px solid var(--divider-color);
        }

        #wizard-bottom > div {
            margin-left: 10px;
            width: 120px;
        }
    </style>
    <template>
        <div id="wizard-content">
            <div id="header" class="horizontal layout center">
                <div class="flex horizontal layout center start-justified">
                    <div class="init" on-click="handlegoToInit" hidden="{{!handleHiddenStep1(step)}}">
                        <i title="Go to Init" class="fa fa-fast-backward"></i>
                    </div>
                    <div hidden="{{handleHiddenStep1(step)}}"></div>
                    <div class="prev" on-click="handlePrevStepButton" hidden="{{!handleHiddenStep1(step)}}">
                        <i class="fa fa-step-backward"></i> Step {{stepPrev}}
                    </div>
                    <div class="flex" hidden="{{!handleHiddenStep1(step)}}"></div>
                </div>
                <div id="title" class="horizontal layout center">
                    Step {{step}} of {{steps.length}} : &nbsp;
                    <content select=".title"></content>
                </div>
                <div class="flex flex horizontal layout center end-justified">
                    <div class="next" on-click="handleNextStepButton" hidden="{{!handleHiddenStepEnd(step)}}">
                        Step {{stepNext}} <i class="fa fa-step-forward"></i>
                    </div>
                    <div hidden="{{handleHiddenStepEnd(step)}}"></div>
                    <div class="end" on-click="handlegoToEnd" hidden="{{!handleHiddenStepEnd(step)}}">
                        <i class="fa fa-fast-forward"></i>
                    </div>
                </div>
            </div>

            <div id="container" class="flex">
                <content class=".container"></content>
            </div>

            <div class="footer">
                <div id="wizard-bottom" class="horizontal layout end-justified">
                    <div class="jso-btn jso-btn-shdw file" on-click="handlePrevStepButton" hidden="{{!handleHiddenStep1(step)}}"><i class="fa fa-angle-double-left"></i>&nbsp; Previous
                    </div>
                    <div class="jso-btn jso-btn-shdw file" on-click="handleNextStepButton" hidden="{{!handleHiddenStepEnd(step)}}">Next &nbsp;<i class="fa fa-angle-double-right"></i>
                    </div>
                    <div hidden="{{handleHiddenStepEnd(step)}}"> &nbsp; </div>
                </div>
            </div>
        </div>

    </template>

    <script>
        Polymer({
            is: "jso-wizard",
            properties: {
                steps: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                step: {
                    type: Number,
                    value: 1,
                    observer: 'stepChanged'
                },
                stepsNames: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                stepName: {
                    type: Number,
                    value: 1,
                    observer: 'stepNameChanged'
                },
            },
            ready: function() {
                var steps = Polymer.dom(this).querySelectorAll('.step');
                var stepsNames = Polymer.dom(this).querySelectorAll('.stepName');

                this.set('steps', steps);
                this.stepChanged(1, 0);
                this.stepNext = 2;

                this.set('stepsNames', stepsNames);
                this.stepNameChanged(1, 0);
            },
            handleHiddenStep1: function(step) {
                return step != 1;
            },
            handleHiddenStepEnd: function(step) {
                return step != this.steps.length;
            },
            handlePrevStepButton: function(e) {
                this.step = (this.step <= 1) ? 1 : this.step - 1;
                console.log(this.step);
                this.stepName = (this.stepName <= 1) ? 1 : this.stepName - 1;
                console.log(this.stepName);
                this.stepNext = this.step + 1
                this.stepPrev = this.step - 1;
            },
            handleNextStepButton: function(e) {
                this.step = (this.step >= this.steps.length) ? this.steps.length : this.step + 1;
                this.stepName = (this.stepName >= this.stepsNames.length) ? this.stepsNames.length : this.stepName + 1;
                this.stepNext = this.step + 1
                this.stepPrev = this.step - 1;
            },
            stepChanged: function(neo, old) {
                if (this.steps && this.steps.length > 0) {

                    for (var i = 0; i < this.steps.length; i++) {
                        if ((i + 1) == neo) {
                            this.steps[i].hidden = false;

                        } else {
                            this.steps[i].hidden = true;
                        }
                    }

                }
            },
            stepNameChanged: function(neo, old) {
                if (this.stepsNames && this.stepsNames.length > 0) {

                    for (var i = 0; i < this.stepsNames.length; i++) {
                        if ((i + 1) == neo) {
                            this.stepsNames[i].hidden = false;

                        } else {
                            this.stepsNames[i].hidden = true;
                        }
                    }

                }
            },
            goToStep: function(step) {
                this.step = step;
                this.stepName = step;
                this.stepNext = step + 1;
                this.stepPrev = step - 1;
            },
            handlegoToInit: function() {
                this.goToStep(1);
            },
            handlegoToEnd: function() {
                this.goToStep(this.steps.length);
            },
            computeStepLength: function(steps) {
                debugger
                return steps.length;
            }
        })
    </script>
</dom-module>
<dom-module id="jso-tooltip" assetpath="bower_components/jsorolla/src/lib/components/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: inline-block;
            position: relative;
            box-sizing: border-box;
            cursor: pointer;
        }

        #messageInfo {
            position: fixed;
            z-index: 200000;
            box-shadow: 0px 0px 10px 3px rgba(0, 0, 0, 0.30);
            min-width: 200px;
            min-height: 100px;
            margin: 0px;
            overflow-x: auto;
            overflow-y: auto;
        }

        .default {
            background-color: var(--light-primary-color);
            padding: 5px;
        }

        .closeInfo {
            position: absolute;
            top: 7px;
            right: 7px;
            cursor: pointer;
            color: var(--secondary-text-color);
        }

        .closeInfo:hover {
            color: var(--primary-text-color);
        }

        .info {
            color: #4790bf;
        }

        .warn {
            color: #bf9947;
        }

        .error {
            color: #bf4747;
        }
    </style>
    <template>
        <span on-click="showInfo"><i on-click="showInfo" class$="{{computeIcon(type, icon)}}"></i> {{text}}</span>
        <div id="messageInfo" class$="{{computeClass(type)}}" hidden="">
            <i class="fa fa-times closeInfo" on-click="handleClose"></i>
            <content></content>
        </div>

    </template>

    <script>
        Polymer({
            is: "jso-tooltip",
            properties: {
                type: {
                    type: String,
                    reflectToAttribute: true,
                    value: ""
                },
                icon: {
                    type: String,
                    reflectToAttribute: true,
                    value: ""
                },
                text: {
                    type: String,
                    reflectToAttribute: true,
                    value: ""
                }
            },
            listeners: {
                click: 'showInfoThis'
            },
            showInfo: function(e) {
                e.stopPropagation();
                this.$.messageInfo.hidden = !this.$.messageInfo.hidden;
                this._getPosition();
            },
            showInfoThis: function(e) {
                if (e.target === this) {
                    this.showInfo(e);
                }
            },
            _getPosition: function() {
                var bcr = this.getBoundingClientRect();
                var msg = this.$.messageInfo.getBoundingClientRect();
                var windowHeight = window.innerHeight;
                var windowWidth = window.innerWidth;

                this.$.messageInfo.style.top = (bcr.bottom) + 'px';
                this.$.messageInfo.style.left = (bcr.left) + 'px';
                if ((bcr.bottom + msg.height) > window.innerHeight) {
                    this.$.messageInfo.style.top = (bcr.top - msg.height) + 'px';
                }
                if ((bcr.right + msg.width) > window.innerWidth) {
                    this.$.messageInfo.style.left = (bcr.left - msg.width) + 'px';
                }

            },
            computeClass: function(type) {
                if (type == "info") {
                    return "jso-note jso-note-info";
                } else if (type == "warn") {
                    return "jso-note jso-note-warn";
                } else if (type == "error") {
                    return "jso-note jso-note-error";
                } else {
                    return "default";
                }
            },
            computeIcon: function(type, icon) {
                if (icon != null && icon !== '') {
                    return 'fa fa-' + icon;
                } else {
                    if (type == "info") {
                        return "fa fa-info " + "info";
                    } else if (type == "warn") {
                        return "fa fa-exclamation-triangle " + "warn";
                    } else if (type == "error") {
                        return "fa fa-exclamation-circle " + "error";
                    }
                    return "fa fa-comment-o";
                }
            },
            handleClose: function(e) {
                e.stopPropagation();
                this.$.messageInfo.hidden = !this.$.messageInfo.hidden;
            },

        })
    </script>
</dom-module>
<dom-module id="jso-opencga-input-text" assetpath="bower_components/jsorolla/src/lib/components/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">

    </style>
    <template>


        <div class="horizontal layout">
            <div class="flex">
                <label id="label" class="jso">{{label}}</label>
            </div>
            <div>
                <jso-opencga-button-tooltip hidden$="{{_hideTooltip}}" message="{{tooltip}}"></jso-opencga-button-tooltip>
            </div>

        </div>

        <input class="jso" id="input" type="text" value="{{value::input}}" placeholder="{{placeholder}}" required$="{{required}}" pattern="{{pattern}}">
        

        
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-input-text",
        properties: {
            label: {
                type: String
            },
            value: {
                type: String
            },
            placeholder: {
                type: String
            },
            required: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            pattern: {
                type: String
            },
            message: {
                type: String
            },
            tooltip: {
                type: String,
                value: ""
            },
            _hideTooltip: {
                type: Boolean
            }
        },
        ready: function () {
            this._hideTooltip = (this.tooltip == "")
        },
        getValue: function () {
            return this.value;
        }
//        isTooltipHidden: function(){
//            return this.tooltip != "";
//        }
    });
</script>
<dom-module id="jso-select" assetpath="bower_components/jsorolla/src/lib/components/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            background-color: #FFF;
            height: 23px;
            cursor: pointer;
            outline: transparent solid 0px;
            border: 1px solid var(--divider-color);
        }

        #main {
            position: relative;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
        }

        #text {
            width: 100%;
            box-sizing: border-box;
            padding: 0px 5px;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            overflow: hidden;
            text-overflow: clip;
        }

        #arrow {
            box-sizing: border-box;
            height: 100%;
            padding: 0px 5px;
        }

        #list {
            min-width: 100%;
            position: absolute;
            z-index: 1;
            box-sizing: border-box;
            display: none;
            left: 0;
            top: calc(100% - 1px);
            background-color: inherit;
            border: 1px solid var(--divider-color);
            box-shadow: 0px 3px 10px rgba(0, 0, 0, 0.2);
        }

        ::content jso-option {
            padding: 2px 4px;
        }

        ::content jso-option:hover {
            background-color: var(--default-primary-color);
            color: var(--text-primary-color);
        }
    </style>
    <template>
        <div id="main" class="horizontal layout center" on-click="handleClick">
            <div id="text">{{selectedOptionText}}</div>
            <div id="arrow" class="horizontal layout center"><i class="fa fa-angle-down"></i></div>
        </div>
        <div id="list" on-click="handleSelect">
            <content id="content"></content>
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'jso-select',
        properties: {
            selectedOption: {
                type: Object
            },
            selectedOptionText: {
                type: String,
            },
            value: {
                type: String,
                observer: 'valueChanged'
            },
            tabindex: {
                type: String,
                reflectToAttribute: true,
                value: '-1'
            }
        },
        listeners: {
            'blur': 'hideList',
        },
        ready: function() {
            var me = this;
            this._observer = Polymer.dom(this.$.content).observeNodes(function(info) {
                me._checkSelected();
            });
        },
        handleClick: function(e) {
            e.stopPropagation();
            this.toggleList(e);
        },
        toggleList: function(e) {
            if (this.$.list.style.display === '') {
                this.showList(e);
            } else {
                this.hideList();
            }
        },
        showList: function(e) {
            // var bcr = this.$.main.getBoundingClientRect();
            // this.$.list.style.top = (bcr.top + bcr.height - 1) + 'px';
            // this.$.list.style.left = bcr.left + 'px';
            // this.$.list.style.width = bcr.width + 'px';
            this.$.list.style.display = 'block';

        },
        hideList: function() {
            this.$.list.style.display = '';
        },

        handleSelect: function(e) {
            if (e.target.tagName === 'JSO-OPTION') {
                this.select(e.target);
                this.hideList();
            }
        },
        select: function(option, notify) {
            if (this.selectedOption !== option) {
                this.set('selectedOption', option);
                this.set('selectedOptionText', option.value);
                this.set('value', option.value);
                if (notify !== false) {
                    this.fire('change');
                }
            }
        },
        valueChanged: function(){
          this._checkSelected();
        },
        _checkSelected: function() {
            var options = this.$.list.querySelectorAll('jso-option');
            if (this.value == null) {
                if (options.length > 0) {
                    this.select(options[0], false);
                }
            } else {
                for (var i = 0; i < options.length; i++) {
                    var option = options[i];
                    if (option.value === this.value) {
                        this.select(option, false);
                        break;
                    }
                }
            }
        }
    });
</script>

<dom-module id="jso-option" assetpath="bower_components/jsorolla/src/lib/components/">
    <style>
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            margin-bottom:1px;
            /*word-break: normal;break-all;*/
            /*height: 20px;*/
            /*overflow: hidden;*/
            /*text-overflow: clip;*/
        }
    </style>
    <template>
        <content></content>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'jso-option',
        properties: {
            value: {
                type: String,
                reflectToAttribute: true
            },
        }
    });
</script>
<dom-module id="jso-opencga-button-tooltip" assetpath="bower_components/jsorolla/src/lib/components/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            cursor: pointer;
        }

        .tooltip {
            display: inline;
            position: relative;
        }

        .tooltip:hover:after {
            background: rgba(0, 0, 0, .8);
            box-shadow: 0px 0px 6px 3px rgba(0, 0, 0, 0.30);
            bottom: 100%;
            color: #fff;
            content: attr(data-title);
            left: 0;
            padding: 10px 15px;
            position: absolute;
            z-index: 98;
            width: 220px;
        }

        .tooltip:hover:before {
            /*border: solid;*/
            /*border-color: rgba(0, 0, 0, .8) transparent;*/
            /*border-width: 6px 6px 0 6px;*/
            /*bottom: 20px;*/
            /*content: "";*/
            /*left: 0;*/
            /*position: absolute;*/
            /*z-index: 99;*/
        }

    </style>
    <template>

        <span data-title$="{{message}}" class="tooltip"><i class="fa fa-info"></i></span>

        
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-button-tooltip",
        properties: {
            message: {
                type: String
            }
        }
    });
</script>
<dom-module id="jso-feature-info-menu" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        .project-item {
            padding: 2px 5px;
        }

        .project-item:hover {
            background-color: #eee;
        }

        .project-item[data-checked] {
            background-color: #ddd;
        }

        .section {
            color: var(--secondary-text-color)
        }

        .option {
            margin: 2px;
            padding: 1px 5px;
            cursor: pointer;
            border-bottom: 1px solid transparent;
            border-top: 1px solid transparent;
        }

        .option:hover {
            background-color: var(--hover-color);
        }

        .option[data-sel] {
            font-weight: bold;
            border-bottom: 1px solid var(--accent-color);
        }
    </style>
    <template>
        <template is="dom-repeat" items="{{options}}" as="entry">
            <template is="dom-if" if="{{entry.section}}">
                <div class="section">{{entry.section}}</div>
            </template>
            <template is="dom-if" if="{{entry.option}}">
                <div class="option" on-click="handleOptionClick" data-sel$="{{isSelected(entry,selected)}}">{{entry.option}}</div>
            </template>
        </template>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-feature-info-menu",
        properties: {
            options: {
                type: Array,
                observer: 'optionsChanged'
            },
            selected: {
                type: Object
            }
        },
        optionsChanged: function (neo, old) {
            if (neo) {
                for (var i = 0; i < neo.length; i++) {
                    var entry = neo[i];
                    if ('option' in entry) {
                        this.set('selected', entry);
                        break;
                    }
                }
            }
        },
        handleOptionClick: function (e) {
            this.set('selected', e.model.entry);
            this.fire('option-click', e.currentTarget.textContent);
        },
        isSelected: function (entry, selected) {
            return entry == selected;
        }
    });
</script>
<dom-module id="jso-gene-info" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        #title {
            border-bottom: 1px solid var(--divider-color);
        }

        #title > * {
            margin-right: 7px;
        }

        #name {
            font-size: 1.3em;
            color: var(--default-primary-color);
        }

        #id {
            font-size: 1.15em;
        }

        a {
            text-decoration: none;
        }

        label,
        a:link,
        a:visited {
            color: var(--secondary-text-color);
        }
    </style>
    <template>

        <div id="title">
            <span id="name">{{gene.name}}</span>
            <span id="id">{{gene.id}}</span>
            <a target="_blank" href$="{{ensemblUrl}}"> Ensembl <i class="fa fa-external-link"></i></a>
            <a target="_blank" href$="{{wikipathwaysUrl}}"> Wikipathways <i class="fa fa-external-link"></i>
            </a>
        </div>
        <div style="margin-top:5px;">
            <label>Location: </label>
            <span>{{gene.chromosome}}</span> :
            <span>{{gene.start}}</span> -
            <span>{{gene.end}}</span>
            <br>
            <label>Strand:</label> <span>{{gene.strand}}</span>
        </div>
        <div>
            <label>Biotype:</label>
            <span>{{gene.biotype}}</span>
        </div>
        <div>
            <label>Description: </label>
            <span>{{gene.description}}</span>
        </div>
        <div>
            <label>Source: </label> <span>{{gene.source}}</span>
        </div>
        <div>
            <label>Status: </label><span>{{gene.status}}</span>
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-gene-info",
        properties: {
            gene: {
                type: Object
            },
            ensemblUrl: {
                type: String,
                computed: 'computeEnsemblUrl(gene)'
            },
            wikipathwaysUrl: {
                type: String,
                computed: 'computeWikipathwayslUrl(gene)'
            }
        },
        computeEnsemblUrl: function (gene) {
            return "http://www.ensembl.org/Multi/Search/Results?q=" + gene.name;
        },
        computeWikipathwayslUrl: function (gene) {
            return "http://wikipathways.org//index.php?query=" + gene.name + "&title=Special%3ASearchPathways&doSearch=1&sa=Search";
        }

    });
</script>
<dom-module id="jso-transcript-info" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        #title {
            border-bottom: 1px solid var(--divider-color);
        }

        #title > * {
            margin-right: 7px;
        }

        #name {
            font-size: 1.3em;
            color: var(--default-primary-color)
        }

        #id {
            font-size: 1.15em;
        }

        a {
            text-decoration: none;
        }

        label,
        a:link,
        a:visited {
            color: var(--secondary-text-color)
        }
    </style>
    <template>
        <div id="title">
            <span id="name">{{transcript.name}}</span>
            <span id="id">{{transcript.id}}</span>
            <a target="_blank" href$="{{ensemblUrl}}"> Ensembl <i class="fa fa-external-link"></i></a>
            
        </div>
        <div style="margin-top:5px;">
            <label>Location: </label>
            <span>{{transcript.chromosome}}</span> :
            <span>{{transcript.start}}</span> -
            <span>{{transcript.end}}</span>
            <br>
            <label>Strand:</label> <span>{{transcript.strand}}</span>
        </div>

        <div>
            <label>Biotype:</label>
            <span>{{transcript.biotype}}</span>
        </div>
        <div>
            <label>Description: </label>
            <span>{{transcript.description}}</span>
        </div>
        
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-transcript-info",
        properties: {
            transcript: {
                type: Object
            },
            ensemblUrl: {
                type: String,
                computed: 'computeEnsemblUrl(transcript)'
            }
        },
        computeEnsemblUrl: function (transcript) {
            return "http://www.ensembl.org/Multi/Search/Results?q=" + transcript.name;
        }

    });
</script>
<dom-module id="jso-xref-info" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        label {
            color: var(--secondary-text-color);
        }

        a:link {
            color: var(--dark-primary-color);
        }

        a:visited {
            color: var(--default-primary-color);
        }
        a:hover{
            text-decoration: underline;
        }
    </style>
    <template>
        <div class="horizontal layout">
            <div><a target="_blank" href$="{{url}}">{{xref.id}}</a></div>
            
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-xref-info",
        properties: {
            xref: {
                type: Object,

            },
            url: {
                type: String,
                computed: 'computeUrl(xref)'
            }
        },
        dbs: {
            go: 'http://amigo.geneontology.org/amigo/term/',
            interpro: 'http://www.ebi.ac.uk/interpro/entry/',
        },
        computeUrl: function (xref) {
            return this.dbs[xref.dbName] + xref.id;
        }
    });
</script>
<dom-module id="jso-transcript-xrefs-info" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            margin-bottom: 10px;
        }

        #title {
            border-bottom: 1px solid var(--divider-color);
            margin-bottom: 5px;
        }

        #title > * {
            margin-right: 7px;
        }

        #name {
            font-size: 1.3em;
            color: var(--default-primary-color);
        }

        #id {
            font-size: 1.15em;
        }

        jso-xref-info {
            padding: 3px 7px;
        }

        label,
        a:link,
        a:visited {
            color: var(--secondary-text-color)
        }
    </style>
    <template>
        <div id="title" class="flex">
            <span id="name">{{transcript.name}}</span>
            <span id="id">{{transcript.id}}</span>
            <label><span>{{count}}</span> items</label>
        </div>
        <template is="dom-repeat" items="{{transcript.xrefs}}" as="xref" filter="filter">
            <jso-xref-info xref="{{xref}}"></jso-xref-info>
        </template>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-transcript-xrefs-info",
        properties: {
            transcript: {
                type: Object,
                observer: 'transcriptChanged'
            },
            count: {
                type: Number,
                value: 0
            },
            dbname: {
                type: String
            }
        },
        transcriptChanged: function (neo, old) {
            if (neo) {
                this.count = 0;
            }
        },
        filter: function (item) {
            if (item.dbName == this.dbname) {
                this.count++;
                return true;
            } else {
                return false;
            }
        }
    });
</script>
<dom-module id="jso-proteins-3d" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            cursor:move;
        }

        #menu {
            heigth: 20px;
            cursor: default;
        }


        .protein {
            margin: 2px;
            padding: 1px 5px;
            cursor: pointer;
            border-bottom: 1px solid transparent;
        }

        .protein:hover {
            background-color: var(--hover-color);
        }

        .protein[data-sel] {
            font-weight: bold;
            border-bottom: 1px solid var(--accent-color);
        }
    </style>
    <template>
        <div id="menu" class="horizontal layout">
            <template is="dom-repeat" items="{{proteins}}" as="protein">
                <div class="protein" on-click="handleClick" data-sel$="{{isSelected(protein,selected)}}">{{protein.id}}</div>
            </template>
        </div>

        <canvas id="canvas"></canvas>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-proteins-3d",
        properties: {
            proteins: {
                type: Array,
                observer: 'proteinsChanged'
            },
            selected: {
                type: Object
            }
        },
        proteinsChanged: function (neo, old) {
            if (neo && neo.length > 0) {
                this.loadProtein(neo[0].id);
                this.set('selected', neo[0]);
            }
        },
        handleClick: function (e) {
            this.set('selected', e.model.protein);
            this.loadProtein(this.selected.id);
        },
        isSelected: function (protein, selected) {
            return protein == selected;
        },
        loadProtein: function (pdb_name) {

            ChemDoodle.default_backgroundColor = '#fafafa';
            ChemDoodle.default_border = '1px solid transparent';

            var pdb = new ChemDoodle.TransformCanvas3D('canvas', 440, 330);
            if (!pdb.gl) {
                pdb.emptyMessage = 'Your browser does not support WebGL';
                pdb.displayMessage();
            } else {
                pdb.specs.set3DRepresentation('Ball and Stick');
                pdb.specs.proteins_ribbonCartoonize = true;
//                pdb.handle = null;
//                pdb.timeout = 15;
//                pdb.startAnimation = ChemDoodle._AnimatorCanvas.prototype.startAnimation;
//                pdb.stopAnimation = ChemDoodle._AnimatorCanvas.prototype.stopAnimation;
//                pdb.isRunning = ChemDoodle._AnimatorCanvas.prototype.isRunning;
//                pdb.dblclick = ChemDoodle.RotatorCanvas.prototype.dblclick;
//                pdb.nextFrame = function (delta) {
//                    var matrix = [];
//                    mat4.identity(matrix);
//                    var change = delta / 1000;
//                    var increment = Math.PI / 15;
//                    mat4.rotate(matrix, increment * change, [1, 0, 0]);
//                    mat4.rotate(matrix, increment * change, [0, 1, 0]);
//                    mat4.rotate(matrix, increment * change, [0, 0, 1]);
//                    mat4.multiply(this.rotationMatrix, matrix);
//                };
                $.get('http://www.rcsb.org/pdb/files/' + pdb_name + '.pdb', function (data) {
                    var mol = ChemDoodle.readPDB(data);
                    pdb.loadMolecule(mol);
//                    pdb.startAnimation();
                });
            }
        }
    });
</script>
<dom-module id="jso-gene-info-panel" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        #panel {
            width: 600px;
            height: 400px;
        }

        #left {
            box-sizing: border-box;
            border-right: 1px solid var(--divider-color);
            padding: 5px;
            width: 150px;
        }

        #right {
            padding: 5px;
            overflow-y: auto;
        }

        jso-transcript-info {
            margin-bottom: 10px;
        }
    </style>
    <template>
        <jso-panel closable="" movable="" fixed="" id="panel" on-hidden="handlePanelHidden">
            <div class="header">
                <i class="fa fa-info"></i> &nbsp; Gene information
            </div>
            <div class="container flex horizontal layout">
                <jso-feature-info-menu id="left" options="{{options}}" on-option-click="handleOption"></jso-feature-info-menu>
                <div id="right" class="horizontal layout flex">
                    <jso-gene-info gene="{{gene}}" option="Information"></jso-gene-info>

                    <div option="Transcripts" hidden="">
                        <template is="dom-repeat" items="{{gene.transcripts}}" as="transcript">
                            <jso-transcript-info transcript="{{transcript}}"></jso-transcript-info>
                        </template>
                    </div>
                    <div option="GO" class="flex" hidden="">
                        <template is="dom-repeat" items="{{gene.transcripts}}" as="transcript">
                            <jso-transcript-xrefs-info transcript="{{transcript}}" dbname="go"></jso-transcript-xrefs-info>
                        </template>
                    </div>
                    <div option="Interpro" class="flex" hidden="">
                        <template is="dom-repeat" items="{{gene.transcripts}}" as="transcript">
                            <jso-transcript-xrefs-info transcript="{{transcript}}" dbname="interpro"></jso-transcript-xrefs-info>
                        </template>
                    </div>
                    <jso-proteins-3d option="3D structure" hidden="" proteins="{{proteins}}"></jso-proteins-3d>
                </div>
            </div>
        </jso-panel>
    </template>
</dom-module>
<script>
    JsoGeneInfoPanel = Polymer({
        is: "jso-gene-info-panel",
        factoryImpl: function (query, feature, host, species) {
            this.feature = feature;
            this.host = host;
            this.species = species;
            this.query = query;
        },
        properties: {
            query: {
                type: String,
                observer: 'queryChanged'
            },
            feature: {
                type: Object
            },
            host: {
                type: String
            },
            species: {
                type: Object
            },
            gene: {
                type: Object
            },
            proteins: {
                type: Array
            },
            options: {
                type: Array,
                value: [
                    {section: "Genomic"},
                    {option: "Information"},
                    {option: "Transcripts"},
//                    {option: "Xrefs"},
                    {section: "Functional information"},
                    {option: "GO"},
//                    {option: "Reactome"},
                    {option: "Interpro"},

//                    {section: "Regulatory"},
//                    {option: "TFBS"},
//                    {option: "miRNA targets"},

                    {section: "Protein"},
//                    {option: "Features"},
                    {option: "3D structure"}
                ]
            },
            option: {
                type: String
            }
        },
        handlePanelHidden: function () {
            this.parentNode.removeChild(this);
        },
        queryChanged: function (neo, old) {
            if (neo) {
                this.getInfo();
            }
        },
        getInfo: function () {
            var me = this;
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'feature',
                subCategory: 'gene',
                query: this.query,
                resource: 'info',
                success: function (response) {
                    me.set('gene', response.response[0].result[0]);
                    console.log(me.gene)
                },
                error: function () {
                    console.log('Server error');
                }
            });
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'feature',
                subCategory: 'id',
                query: this.query,
                resource: 'xref',
                params: {
                    dbname: 'pdb'
                },
                success: function (response) {
                    var items = [];
                    var resitems = response.response[0].result;
                    for (var i=0;i< resitems.length; i++){
                        var item = resitems[i];
                        if(item.dbName == 'pdb'){
                            items.push(item);
                        }
                    }
                    me.set('proteins', items);
                },
                error: function () {
                    console.log('Server error');
                }
            });
        },
        handleOption: function (e) {
            var option = e.detail;
            var els = Polymer.dom(this.$.right).querySelectorAll('[option]');
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                if (el.getAttribute('option') == option) {
                    el.removeAttribute('hidden');
                } else {
                    el.setAttribute('hidden', '');
                }
            }
        }
    });
</script>
<dom-module id="jso-exon-info" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        #title {
            border-bottom: 1px solid var(--divider-color);
        }

        #title > * {
            margin-right: 7px;
        }

        #id {
            font-size: 1.15em;
            color: var(--default-primary-color);
        }

        a {
            text-decoration: none;
        }

        label,
        a:link,
        a:visited {
            color: var(--secondary-text-color);
        }
    </style>
    <template>

        <div id="title">
            <span id="id">{{exon.id}}</span>
            <a target="_blank" href$="{{ensemblUrl}}"> Ensembl <i class="fa fa-external-link"></i></a>
        </div>
        <div style="margin-top:5px;">
            <label>Location: </label>
            <span>{{exon.chromosome}}</span> :
            <span>{{exon.start}}</span> -
            <span>{{exon.end}}</span>
            <br>
            <label>Strand:</label> <span>{{exon.strand}}</span>
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-exon-info",
        properties: {
            exon: {
                type: Object
            },
            ensemblUrl: {
                type: String,
                computed: 'computeEnsemblUrl(exon)'
            }
        },
        computeEnsemblUrl: function (exon) {
            return "http://www.ensembl.org/Multi/Search/Results?q=" + exon.name;
        }

    });
</script>
<dom-module id="jso-snp-info" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        #title {
            border-bottom: 1px solid var(--divider-color);
        }

        #title > * {
            margin-right: 7px;
        }

        #id {
            font-size: 1.30em;
            color: var(--default-primary-color);
        }

        a {
            text-decoration: none;
        }

        label,
        a:link,
        a:visited {
            color: var(--secondary-text-color);
        }

        .ml {
            margin-left: 15px;
        }
    </style>
    <template>
        <div id="title">
            <span id="id">{{snp.id}}</span>
            <a target="_blank" href$="{{ensemblUrl}}"> Ensembl <i class="fa fa-external-link"></i></a>
        </div>
        <div style="margin-top:5px;">
            <label>Location: </label>
            <span>{{snp.chromosome}}</span> :
            <span>{{snp.start}}</span> -
            <span>{{snp.end}}</span>
            <label class="ml">Strand:</label> <span>{{snp.strand}}</span>
            <br>
            <label>Alleles:</label> <span>{{snp.alleleString}}</span>
            <br>
            <label>Ancestral:</label> <span>{{snp.ancestralAllele}}</span>
            <br>
            <label>Reference:</label> <span>{{snp.reference}}</span>
            <br>
            <label>Alternate:</label> <span>{{snp.alternate}}</span>
            <br>
            <label>Most severe SO term:</label> <span>{{snp.displayConsequenceType}}</span>
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-snp-info",
        properties: {
            snp: {
                type: Object
            },
            ensemblUrl: {
                type: String,
                computed: 'computeEnsemblUrl(snp)'
            }
        },
        computeEnsemblUrl: function (snp) {
            return "http://www.ensembl.org/Multi/Search/Results?q=" + snp.id;
        }

    });
</script>
<dom-module id="jso-transcript-info-panel" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        #panel {
            width: 700px;
            height: 420px;
        }

        #left {
            box-sizing: border-box;
            border-right: 1px solid var(--divider-color);
            padding: 5px;
            width: 150px;
        }

        #right {
            overflow-y: auto;
            overflow-x: hidden;
        }

        jso-exon-info {
            margin-bottom: 10px;
        }

        .p5 {
            padding: 5px;
        }
    </style>
    <template>
        <jso-panel closable="" movable="" fixed="" id="panel" on-hidden="handlePanelHidden">
            <div class="header">
                <i class="fa fa-info"></i> &nbsp; Transcript information
            </div>
            <div class="container flex horizontal layout">
                <jso-feature-info-menu id="left" options="{{options}}" on-option-click="handleOption"></jso-feature-info-menu>
                <div id="right" class="horizontal layout flex">
                    <jso-transcript-info class="p5" transcript="{{transcript}}" option="Information"></jso-transcript-info>
                    <jso-gene-info class="p5" gene="{{gene}}" option="Gene" hidden=""></jso-gene-info>
                    <div option="Exons" class="flex p5" hidden="">
                        <template is="dom-repeat" items="{{transcript.exons}}" as="exon">
                            <jso-exon-info exon="{{exon}}"></jso-exon-info>
                        </template>
                    </div>
                    <jso-transcript-xrefs-info transcript="{{transcript}}" dbname="go" option="GO" class="flex p5" hidden=""></jso-transcript-xrefs-info>
                    <jso-transcript-xrefs-info transcript="{{transcript}}" dbname="interpro" option="Interpro" class="flex p5" hidden=""></jso-transcript-xrefs-info>

                    <div option="SNPs" class="flex" hidden="">
                        <jso-table enable-paging="" enable-filter="" columns="{{snpcols}}" data="{{snps}}" style="height:388px"></jso-table>
                    </div>
                    <div option="Clinical" class="flex" hidden="">
                        <jso-table enable-paging="" enable-filter="" columns="{{variantcols}}" data="{{variants}}" style="height:388px"></jso-table>
                    </div>
                    <div option="TFBS" class="flex" hidden="">
                        <jso-table enable-paging="" enable-filter="" columns="{{tfbscols}}" data="{{tfbss}}" style="height:388px"></jso-table>
                    </div>

                    <div option="miRNA Targets" class="flex" hidden="">
                        <jso-table enable-paging="" enable-filter="" columns="{{mirnacols}}" data="{{mirnas}}" style="height:388px"></jso-table>
                    </div>

                    <jso-proteins-3d option="3D structure" hidden="" proteins="{{proteins}}"></jso-proteins-3d>
                </div>
            </div>
        </jso-panel>
    </template>
</dom-module>
<script>
    JsoTranscriptInfoPanel = Polymer({
        is: "jso-transcript-info-panel",
        factoryImpl: function (query, feature, host, species) {
            this.feature = feature;
            this.host = host;
            this.species = species;
            this.query = query;
        },
        properties: {
            query: {
                type: String,
                observer: 'queryChanged'
            },
            feature: {
                type: Object
            },
            host: {
                type: String
            },
            species: {
                type: Object
            },
            gene: {
                type: Object
            },
            transcript: {
                type: Object
            },
            snps: {
                type: Array
            },
            snpcols: {
                type: Array,
                value: [{
                    name: 'id',
                    title: 'Id'
                }, {
                    name: 'alleleString',
                    title: 'Alleles'
                }, {
                    name: 'displayConsequenceType',
                    width: 170,
                    title: 'SO term'
                }, {
                    title: 'Location (strand)',
                    name:'location',
                    width: 180,
                    formula: function (row) {
                        return new Region(row).toString() + " (" + row.strand + ")";
                    },
                    type: 'none'
                }]
            },
            variants: {
                type: Array
            },
            variantcols: {
                type: Array,
                value: [{
                    name: 'reference',
                    title: 'Reference'
                }, {
                    name: 'alternate',
                    title: 'Alternate'
                }, {
                    title: 'Location',
                    name:'location',
                    width: 180,
                    formula: function (row) {
                        return new Region(row).toString();
                    },
                    type: 'none'
                }]
            },
            tfbss: {
                type: Array
            },
            tfbscols: {
                type: Array,
                value: [{
                    name: 'name',
                    title: 'Name'
                }, {
                    name: 'cellTypes',
                    title: 'Cell types'
                }, {
                    name: 'score',
                    title: 'Score'
                }, {
                    title: 'Location',
                    name:'location',
                    width: 180,
                    formula: function (row) {
                        return new Region(row).toString();
                    },
                    type: 'none'
                }]
            },
            mirnas: {
                type: Array
            },
            mirnacols: {
                type: Array,
                value: [{
                    name: 'name',
                    title: 'Name'
                }, {
                    name: 'score',
                    title: 'Score'
                }, {
                    name: 'source',
                    title: 'Source'
                }, {
                    title: 'Location (strand)',
                    name:'location',
                    width: 190,
                    formula: function (row) {
                        return new Region(row).toString() + " (" + row.strand + ")";
                    },
                    type: 'none'
                }]
            },
            proteins: {
                type: Array
            },
            options: {
                type: Array,
                value: [
                    {section: "Genomic"},
                    {option: "Information"},
                    {option: "Gene"},
                    {option: "Exons"},
                    {section: "Functional information"},
                    {option: "GO"},
                    {option: "Interpro"},
                    {section: "Variation"},
                    {option: "SNPs"},
                    {option: "Clinical"},
                    {section: "Regulatory"},
                    {option: "TFBS"},
                    {option: "miRNA Targets"},
                    {section: "Protein"},
//                    {option: "Features"},
                    {option: "3D structure"}


                ]
            },
            option: {
                type: String
            }
        },
        handlePanelHidden: function () {
            this.parentNode.removeChild(this);
        },
        queryChanged: function (neo, old) {
            if (neo) {
                this.getInfo();
            }
        },
        getInfo: function () {
            var me = this;
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'feature',
                subCategory: 'gene',
                query: this.query,
                resource: 'info',
                success: function (response) {
                    me.set('gene', response.response[0].result[0]);
                    console.log(me.gene)
                },
                error: function () {
                    console.log('Server error');
                }
            });
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'feature',
                subCategory: 'transcript',
                query: this.query,
                resource: 'info',
                success: function (response) {
                    // me.set('gene', response.response[0].result[0]);
                    me.set('transcript', response.response[0].result[0]);
                    // console.log(me.gene)
                    console.log(me.transcript)
                },
                error: function () {
                    console.log('Server error');
                }
            });
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'feature',
                subCategory: 'id',
                query: this.query,
                resource: 'xref',
                params: {
                    dbname: 'pdb'
                },
                success: function (response) {
                    var items = [];
                    var resitems = response.response[0].result;
                    for (var i=0;i< resitems.length; i++){
                        var item = resitems[i];
                        if(item.dbName == 'pdb'){
                            items.push(item);
                        }
                    }
                    me.set('proteins', items);
                },
                error: function () {
                    console.log('Server error');
                }
            });
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'genomic',
                subCategory: 'region',
                query: new Region(this.feature),
                // resource: 'snp',
                resource: 'variation',
                params: {
                    exclude: 'consequenceTypes,transcriptVariations,populationFrequencies,xrefs,_chunkIds'
                },
                success: function (response) {
                    me.set('snps', response.response[0].result);
                },
                error: function () {
                    console.log('Server error');
                }
            });
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'genomic',
                subCategory: 'region',
                query: new Region(this.feature),
                resource: 'clinical',
                params: {
                    include: 'chromosome,start,end,reference,alternate'
                },
                success: function (response) {
                    me.set('variants', response.response[0].result);
                },
                error: function () {
                    console.log('Server error');
                }
            });
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'genomic',
                subCategory: 'region',
                query: new Region(this.feature),
                resource: 'regulatory',
                params: {
                    type: 'TF_binding_site'
                },
                success: function (response) {
                    me.set('tfbss', response.response[0].result);
                },
                error: function () {
                    console.log('Server error');
                }
            });
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'genomic',
                subCategory: 'region',
                query: new Region(this.feature),
                resource: 'regulatory',
                params: {
                    type: 'mirna_target'
                },
                success: function (response) {
                    me.set('mirnas', response.response[0].result);
                },
                error: function () {
                    console.log('Server error');
                }
            });
        },
        handleOption: function (e) {
            var option = e.detail;
            var els = Polymer.dom(this.$.right).querySelectorAll('[option]');
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                if (el.getAttribute('option') == option) {
                    el.removeAttribute('hidden');
                } else {
                    el.setAttribute('hidden', '');
                }
            }
        }
    });
</script>
<dom-module id="jso-snp-info-panel" assetpath="bower_components/jsorolla/src/lib/components/cellbase/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        #panel {
            width: 600px;
            height: 400px;
        }

        #left {
            box-sizing: border-box;
            border-right: 1px solid var(--divider-color);
            padding: 5px;
            width: 150px;
        }

        #right {
            padding: 5px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        jso-transcript-info {
            margin-bottom: 10px;
        }
    </style>
    <template>
        <jso-panel closable="" movable="" fixed="" id="panel" on-hidden="handlePanelHidden">
            <div class="header">
                <i class="fa fa-info"></i> &nbsp; SNP information
            </div>
            <div class="container flex horizontal layout">
                <jso-feature-info-menu id="left" options="{{options}}" on-option-click="handleOption"></jso-feature-info-menu>
                <div id="right" class="horizontal layout flex">
                    <jso-snp-info snp="{{snp}}" option="Information"></jso-snp-info>
                    <div option="Transcripts" hidden="">
                        <template is="dom-repeat" items="{{transcripts}}" as="transcript">
                            <jso-transcript-info transcript="{{transcript}}"></jso-transcript-info>
                        </template>
                    </div>
                </div>
            </div>
        </jso-panel>
    </template>
</dom-module>
<script>
    JsoSnpInfoPanel = Polymer({
        is: "jso-snp-info-panel",
        factoryImpl: function (query, feature, host, species) {
            this.feature = feature;
            this.host = host;
            this.species = species;
            this.query = query;
        },
        properties: {
            query: {
                type: String,
                observer: 'queryChanged'
            },
            feature: {
                type: Object
            },
            host: {
                type: String
            },
            species: {
                type: Object
            },
            snp: {
                type: Object
            },
            transcripts: {
                type: Array
            },
            options: {
                type: Array,
                value: [
                    {section: "Genomic"},
                    {option: "Information"},
                    {option: "Transcripts"},
                    {section: "Annotation"},
                    {option: "Consequence Type"},
                    {option: "Clinical"} // (antigua "Annotated phenotype" que ahora se leeria de Clinical)


                ]
            },
            option: {
                type: String
            }
        },
        handlePanelHidden: function () {
            this.parentNode.removeChild(this);
        },
        queryChanged: function (neo, old) {
            if (neo) {
                this.getInfo();
            }
        },
        getInfo: function () {
            var me = this;            
            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'feature',
                subCategory: 'variation',
                query: this.query,
                resource: 'info',
                success: function (response) {
                    me.set('snp', response.response[0].result[0]);
                    console.log(me.snp)
                },
                error: function () {
                    console.log('Server error');
                }
            });

            CellBaseManager.get({
                host: this.host,
                species: this.species,
                category: 'genomic',
                subCategory: 'region',
                query: new Region(this.feature),
                resource: 'gene',
                success: function (response) {
                    var genes = response.response[0].result;
                    var transcripts = [];
                    for (var i = 0; i < genes.length; i++) {
                        var gene = genes[i];
                        for (var j = 0; j < gene.transcripts.length; j++) {
                            var transcript = gene.transcripts[j];
                            if (me.feature.start <= transcript.end && me.feature.end >= transcript.start) {
                                transcripts.push(transcript);
                            }
                        }
                    }
                    me.set('transcripts', transcripts);
                    console.log(me.transcripts)
                },
                error: function () {
                    console.log('Server error');
                }
            });
        },
        handleOption: function (e) {
            var option = e.detail;
            var els = Polymer.dom(this.$.right).querySelectorAll('[option]');
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                if (el.getAttribute('option') == option) {
                    el.removeAttribute('hidden');
                } else {
                    el.setAttribute('hidden', '');
                }
            }
        }
    });
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function GenomeViewer(args) {
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    var _this = this;
    this.id = Utils.genId("GenomeViewer");

    //set default args
    this.autoRender = true;
    this.version = 'Powered by <a target="_blank" href="http://www.genomemaps.org/">Genome Maps</a>';
    this.target;

    this.width;
    this.height;

    this.cellBaseHost = 'http://bioinfo.hpc.cam.ac.uk/cellbase';
    this.cellBaseVersion = 'v3';

    this.quickSearchResultFn;
    this.quickSearchDisplayKey = 'name';

    this.drawNavigationBar = true;
    this.drawKaryotypePanel = true;
    this.drawChromosomePanel = true;
    this.drawOverviewTrackListPanel = true;
    this.overviewZoomMultiplier = 8;
    this.karyotypePanelConfig = {
        hidden: false,
        collapsed: false,
        collapsible: true
    };
    this.chromosomePanelConfig = {
        hidden: false,
        collapsed: false,
        collapsible: true
    };
    this.regionPanelConfig = {
        hidden: false,
        collapsed: false,
        collapsible: true
    };
    this.navigationBarConfig = {};
    this.drawStatusBar = true;
    this.resizable = true;
    this.sidePanel = true;//enable or disable sidePanel at construction
    this.trackListTitle = 'Detailed information';//enable or disable sidePanel at construction
    this.trackPanelScrollWidth = 18;

    this.zoom;

    this.chromosomes;
    this.chromosomeList;

    //set instantiation args, must be last
    _.extend(this, args);

    this.chromosomes = this.getChromosomes();
    this.species.chromosomes = this.chromosomes;

    this.defaultRegion = new Region(this.region);

    this.sidePanelWidth = (this.sidePanel) ? 25 : 0;


    //events attachments
    this.on(this.handlers);

    this.fullscreen = false;
    this.resizing = false;

    this.changingRegion = false;

    this.rendered = false;
    if (this.autoRender) {
        this.render();
    }
}

GenomeViewer.prototype = {
    render: function () {
        console.log("Initializing Genome Viewer");

        //HTML skel
        this.div = document.createElement('div');
        this.div.setAttribute('id', this.id);
        this.div.setAttribute('class', 'ocb-gv ocb-box-vertical');

        this.navigationbarDiv = document.createElement('div');
        this.navigationbarDiv.setAttribute('class', 'ocb-gv-navigation');
        this.div.appendChild(this.navigationbarDiv);

        this.centerPanelDiv = document.createElement('div');
        this.centerPanelDiv.setAttribute('class', 'ocb-gv-center');
        this.div.appendChild(this.centerPanelDiv);

        this.statusbarDiv = document.createElement('div');
        this.statusbarDiv.setAttribute('class', 'ocb-gv-status');
        this.div.appendChild(this.statusbarDiv);


        this.rightSidebarDiv = document.createElement('div');
        this.rightSidebarDiv.setAttribute('class', 'ocb-gv-right-side');
        this.centerPanelDiv.appendChild(this.rightSidebarDiv);

        this.leftSidebarDiv = document.createElement('div');
        this.leftSidebarDiv.setAttribute('class', 'ocb-gv-left-side');
        this.centerPanelDiv.appendChild(this.leftSidebarDiv);


        this.karyotypeDiv = document.createElement('div');
        this.karyotypeDiv.setAttribute('class', 'ocb-gv-karyotype');
        this.centerPanelDiv.appendChild(this.karyotypeDiv);

        this.chromosomeDiv = document.createElement('div');
        this.chromosomeDiv.setAttribute('class', 'ocb-gv-chromosome');
        this.centerPanelDiv.appendChild(this.chromosomeDiv);


        this.trackListPanelsDiv = document.createElement('div');
        this.trackListPanelsDiv.setAttribute('class', 'ocb-gv-tracklist-target');
        this.centerPanelDiv.appendChild(this.trackListPanelsDiv);

        this.regionDiv = document.createElement('div');
        this.regionDiv.setAttribute('class', 'ocb-gv-overview');
        this.trackListPanelsDiv.appendChild(this.regionDiv);

        this.tracksDiv = document.createElement('div');
        this.tracksDiv.setAttribute('class', 'ocb-gv-detailed');
        this.trackListPanelsDiv.appendChild(this.tracksDiv);


        this._init();

        this.rendered = true;
    },

    _init: function () {
        var _this = this;
        this._checkAndSetMinimumRegion(this.region, this.getSVGCanvasWidth());
        this.zoom = this._calculateZoomByRegion(this.region);

//        // Resize
//        if (this.resizable) {
//            $(window).resize(function (event) {
//                if (event.target == window) {
//                    if (!_this.resizing) {//avoid multiple resize events
//                        _this.resizing = true;
//                        _this.setWidth($(_this.targetDiv).width());
//                        setTimeout(function () {
//                            _this.resizing = false;
//                        }, 400);
//                    }
//                }
//            });
////            $(this.targetDiv).resizable({
////                handles: 'e',
////                ghost: true,
////                stop: function (event, ui) {
////                    _this._setWidth($(_this.targetDiv).width());
////                }
////            });
//        }

        /* Navigation Bar */
        if (this.drawNavigationBar) {
            this.navigationBar = this._createNavigationBar(this.navigationbarDiv);
        }


        /*karyotype Panel*/
        if (this.drawKaryotypePanel) {
            this.karyotypePanel = this._drawKaryotypePanel(this.karyotypeDiv);
        }

        /* Chromosome Panel */
        if (this.drawChromosomePanel) {
            this.chromosomePanel = this._drawChromosomePanel(this.chromosomeDiv);
        }

        /* Region Panel, is a TrackListPanel Class */
        if (this.drawOverviewTrackListPanel) {
            this.overviewTrackListPanel = this._createOverviewTrackListPanel(this.regionDiv);
        }
        /*TrackList Panel*/
        this.trackListPanel = this._createTrackListPanel(this.tracksDiv);

        /*Status Bar*/
        if (this.drawStatusBar) {
            this.statusBar = this._createStatusBar(this.statusbarDiv);
        }


        this.on('region:change region:move', function (event) {
            if (event.sender != _this) {
                _this.region.load(event.region);
            }
        });
        this.on('width:change', function (event) {
            if (event.sender != _this) {
                _this.width = event.width;
                $(_this.div).width(event.width);
                $(_this.targetDiv).width(event.width);
            }
        });
        //this.on('species:change', function (event) {
        //    _this.species = event.species;
        //    _this.chromosomes = _this.getChromosomes();
        //});

        $("html").bind('keydown.genomeViewer', function (e) {
            switch (e.keyCode) {
                case 40://down arrow
                case 109://minus key
                    if (e.shiftKey) {
                        _this.increaseZoom(-10);
                    }
                    break;
                case 38://up arrow
                case 107://plus key
                    if (e.shiftKey) {
                        _this.increaseZoom(10);
                    }
                    break;
            }
        });
    },

    draw: function () {
        this.targetDiv = ( this.target instanceof HTMLElement ) ? this.target : document.querySelector('#' + this.target);
        if (!this.targetDiv) {
            console.log('target not found');
            return;
        }
        this.targetDiv.appendChild(this.div);
    },
    destroy: function () {
        while (this.div.firstChild) {
            this.div.removeChild(this.div.firstChild);
        }
        $(this.div).remove();
        this.off();
        this.rendered = false;
        $("html").unbind(".genomeViewer");
        $("body").unbind(".genomeViewer");
        delete this;
    },
    getChromosomes: function () {
        var saveChromosomes = function (chromsomeList) {
            var chromosomes = {};
            for (var i = 0; i < chromsomeList.length; i++) {
                var chromosome = chromsomeList[i];
                chromosomes[chromosome.name] = chromosome;
            }
            return chromosomes;
        }

        var chromosomes;
        if (typeof this.chromosomeList !== 'undefined') {
            chromosomes = saveChromosomes(this.chromosomeList);
        } else {
            CellBaseManager.get({
                host: this.cellBaseHost,
                version: this.cellBaseVersion,
                species: this.species,
                category: 'genomic',
                subCategory: 'chromosome',
                resource: 'search',
                // resource: 'all',
                async: false,
                success: function (data) {
                    chromosomes = saveChromosomes(data.response[0].result[0].chromosomes);
                    for (var i = 0; i < chromosomes.length; i++) {
                        var chr = chromosomes[i];
                        debugger
                    }
                },
                error: function (data) {
                    console.log('Could not get chromosome list');
                }
            });
        }
        return chromosomes;
    },
    /**/
    /*Components*/
    /**/

    _createNavigationBar: function (target) {
        var _this = this;

        if (!$.isFunction(this.quickSearchResultFn)) {
            this.quickSearchResultFn = function (query) {
                var results = [];
                var speciesCode = Utils.getSpeciesCode(this.species.scientificName);

                CellBaseManager.get({
                    host: _this.cellBaseHost,
                    version: _this.cellBaseVersion,
//                    host: 'http://ws.bioinfo.cipf.es/cellbase/rest',
                    species: speciesCode,
                    category: 'feature',
                    subCategory: 'id',
                    query: query,
                    resource: 'starts_with',
                    params: {
                        limit: 10
                    },
                    async: false,
                    success: function (data, textStatus, jqXHR) {
                        results = data.response[0].result;
//                        var features = data.response[0].result;
//                        for (var i = 0; i < features.length; i++) {
//                            results.push(features[i].name)
//                        }
                    }
                });
                return results;
            };
        }

        var goFeature = function (feature) {
            _this._regionChangeHandler({region: new Region(feature)});
//            if (featureName != null) {
//                if (featureName.slice(0, "rs".length) == "rs" || featureName.slice(0, "AFFY_".length) == "AFFY_" || featureName.slice(0, "SNP_".length) == "SNP_" || featureName.slice(0, "VAR_".length) == "VAR_" || featureName.slice(0, "CRTAP_".length) == "CRTAP_" || featureName.slice(0, "FKBP10_".length) == "FKBP10_" || featureName.slice(0, "LEPRE1_".length) == "LEPRE1_" || featureName.slice(0, "PPIB_".length) == "PPIB_") {
//                    this.openSNPListWidget(featureName);
//                } else {
//                    console.log(featureName);
//                    CellBaseManager.get({
//                        host: _this.cellBaseHost,
//                        version: _this.cellBaseVersion,
//                        species: _this.species,
//                        category: 'feature',
//                        subCategory: 'id',
//                        query: featureName,
//                        resource: 'info',
//                        params: {
//                            include: 'chromosome,start,end'
//                        },
//                        success: function (data) {
//                            debugger
//                            var feat = data.response[0].result[0];
//                            var region = new Region(feat);
//                            _this._regionChangeHandler({region: region});
//                        }
//                    });
//                }
//            }
        };

        var navigationBar = new NavigationBar({
            target: target,
            cellBaseHost: this.cellBaseHost,
            cellBaseVersion: this.cellBaseVersion,
            availableSpecies: this.availableSpecies,
            species: this.species,
            region: this.region,
            width: this.width,
            svgCanvasWidthOffset: this.trackPanelScrollWidth + this.sidePanelWidth,
            zoom: this.zoom,
            quickSearchResultFn: this.quickSearchResultFn,
            quickSearchDisplayKey: this.quickSearchDisplayKey,
            componentsConfig: this.navigationBarConfig.componentsConfig,
            karyotypePanelConfig: this.karyotypePanelConfig,
            chromosomePanelConfig: this.chromosomePanelConfig,
            regionPanelConfig: this.regionPanelConfig,
            handlers: {
                'region:change': function (event) {
                    _this._regionChangeHandler(event);
                },
                'region:move': function (event) {
                    _this._regionMoveHandler(event);
                },
                'zoom:change': function (event) {
                    _this._zoomChangeHandler(event);
                },
                'species:change': function (event) {
                    _this._speciesChangeHandler(event);
                },

                'karyotype-button:change': function (event) {
                    if (event.selected) {
                        _this.karyotypePanel.show();
                    } else {
                        _this.karyotypePanel.hide();
                    }
                },
                'chromosome-button:change': function (event) {
                    if (event.selected) {
                        _this.chromosomePanel.show();
                    } else {
                        _this.chromosomePanel.hide();
                    }
                },
                'region-button:change': function (event) {
                    if (event.selected) {
                        _this.overviewTrackListPanel.show();
                    } else {
                        _this.overviewTrackListPanel.hide();
                    }
                },
                'fullscreen:click': function (event) {
                    if (_this.fullscreen) {
                        $(_this.div).css({width: 'auto'});
                        Utils.cancelFullscreen();//no need to pass the dom object;
                        _this.fullscreen = false;
                    } else {
                        $(_this.div).css({width: screen.width});
                        Utils.launchFullScreen(_this.div);
                        _this.fullscreen = true;
                    }
                },
                'restoreDefaultRegion:click': function (event) {
                    event.region = _this.defaultRegion;
                    _this._regionChangeHandler(event);
                },
                'autoHeight-button:change': function (event) {
                    _this.toggleAutoHeight(event.selected);
                },
                'quickSearch:select': function (event) {
                    goFeature(event.item);
                    _this.trigger('quickSearch:select', event);
                },
                'quickSearch:go': function (event) {
                    goFeature(event.item);
                }
            }
        });

        this.on('region:change', function (event) {
//            if (event.sender != navigationBar) {
            _this.navigationBar.setRegion(event.region, _this.zoom);
//            }
        });
        this.on('region:move', function (event) {
            if (event.sender != navigationBar) {
                _this.navigationBar.moveRegion(event.region);
            }
        });
        this.on('width:change', function (event) {
            _this.navigationBar.setWidth(event.width);
        });

        navigationBar.draw();

        return navigationBar;
    },

    _drawKaryotypePanel: function (target) {
        var _this = this;
        var karyotypePanel = new KaryotypePanel({
            target: target,
            cellBaseHost: this.cellBaseHost,
            cellBaseVersion: this.cellBaseVersion,
            width: this.width - this.sidePanelWidth,
            height: 125,
            species: this.species,
            title: 'Karyotype',
            collapsed: this.karyotypePanelConfig.collapsed,
            collapsible: this.karyotypePanelConfig.collapsible,
            hidden: this.karyotypePanelConfig.hidden,
            region: this.region,
            autoRender: true,
            handlers: {
                'region:change': function (event) {
                    _this._regionChangeHandler(event);
                }
            }
        });

        this.on('region:change region:move', function (event) {
//            if (event.sender != karyotypePanel) {
            karyotypePanel.setRegion(event.region);
//            }
        });
        this.on('width:change', function (event) {
            karyotypePanel.setWidth(event.width - _this.sidePanelWidth);
        });
//        this.on('species:change', function (event) {
//            karyotypePanel.setSpecies(event.species);
//        });

        karyotypePanel.draw();

        return karyotypePanel;
    },

    _drawChromosomePanel: function (target) {
        var _this = this;

        var chromosomePanel = new ChromosomePanel({
            target: target,
            cellBaseHost: this.cellBaseHost,
            cellBaseVersion: this.cellBaseVersion,
            autoRender: true,
            width: this.width - this.sidePanelWidth,
            height: 65,
            species: this.species,
            title: 'Chromosome',
            collapsed: this.chromosomePanelConfig.collapsed,
            collapsible: this.chromosomePanelConfig.collapsible,
            hidden: this.chromosomePanelConfig.hidden,
            region: this.region,
            handlers: {
                'region:change': function (event) {
                    _this._regionChangeHandler(event);
                }
            }
        });

        this.on('region:change region:move', function (event) {
//            if (event.sender != chromosomePanel) {
            chromosomePanel.setRegion(event.region);
//            }
        });
        this.on('width:change', function (event) {
            chromosomePanel.setWidth(event.width - _this.sidePanelWidth);
        });
//        this.on('species:change', function (event) {
//            chromosomePanel.setSpecies(event.species);
//        });

        chromosomePanel.draw();

        return chromosomePanel;
    },

    _createOverviewTrackListPanel: function (target) {
        var _this = this;
        var trackListPanel = new TrackListPanel({
            cellBaseHost: this.cellBaseHost,
            cellBaseVersion: this.cellBaseVersion,
            target: target,
            autoRender: true,
            width: this.width - this.sidePanelWidth,
            zoomMultiplier: this.overviewZoomMultiplier,
            title: 'Region overview',
            showRegionOverviewBox: true,
            collapsible: this.regionPanelConfig.collapsible,
            region: this.region,
            species: this.species,
            handlers: {
                'region:change': function (event) {
                    event.sender = undefined;
                    _this._regionChangeHandler(event);
                },
                'region:move': function (event) {
                    _this._regionMoveHandler(event);
                }
            }
        });

        this.on('region:change', function (event) {
            if (event.sender != trackListPanel) {
                trackListPanel.setRegion(event.region);
            }
        });
        this.on('region:move', function (event) {
            if (event.sender != trackListPanel) {
                trackListPanel.moveRegion(event);
            }
        });
        this.on('width:change', function (event) {
            trackListPanel.setWidth(event.width - _this.sidePanelWidth);
        });
//        this.on('species:change', function (event) {
//            trackListPanel.setSpecies(event.species);
//        });

        trackListPanel.draw();

        return trackListPanel;
    },

    _createTrackListPanel: function (target) {
        var _this = this;
        var trackListPanel = new TrackListPanel({
            target: target,
            cellBaseHost: this.cellBaseHost,
            cellBaseVersion: this.cellBaseVersion,
            autoRender: true,
            width: this.width - this.sidePanelWidth,
            title: this.trackListTitle,
            region: this.region,
            species: this.species,
            hidden: this.regionPanelConfig.hidden,
            handlers: {
                'region:change': function (event) {
                    event.sender = undefined;
                    _this._regionChangeHandler(event);
                },
                'region:move': function (event) {
                    _this._regionMoveHandler(event);
                }
            }
        });

        this.on('region:change', function (event) {
            if (event.sender != trackListPanel) {
                trackListPanel.setRegion(event.region);
            }
        });
        this.on('region:move', function (event) {
            if (event.sender != trackListPanel) {
                trackListPanel.moveRegion(event);
            }
        });
        this.on('width:change', function (event) {
            trackListPanel.setWidth(event.width - _this.sidePanelWidth);
        });
//        this.on('species:change', function (event) {
//            trackListPanel.setSpecies(event.species);
//        });

        this.on('feature:highlight', function (event) {
            trackListPanel.highlight(event);
        });

        trackListPanel.draw();

        return trackListPanel;
    },

    _createStatusBar: function (target) {
        var _this = this;
        var statusBar = new StatusBar({
            target: target,
            autoRender: true,
            region: this.region,
            width: this.width,
            version: this.version
        });

        this.on('region:change', function (event) {
            statusBar.setRegion(event);
        });


        this.trackListPanel.on('mousePosition:change', function (event) {
            statusBar.setMousePosition(event);
        });

        statusBar.draw();
        return statusBar;
    },


    /*****************/
    /** PRIVATE HELPER METHODS **/
    /*****************/
    _checkAndSetNewChromosomeRegion: function (region) {
        var newChr = this.chromosomes[region.chromosome];
        if (region.chromosome !== this.region.chromosome) {
            if (region.start > newChr.size || region.end > newChr.size) {
                region.start = Math.round(newChr.size / 2);
                region.end = Math.round(newChr.size / 2);
            }
        }
    },
    _checkAndSetMinimumRegion: function (region, width) {
        var minLength = Math.floor(width / 10);
        if (region.length() < minLength) {
            var centerPosition = region.center();
            var aux = Math.ceil((minLength / 2) - 1);
            region.start = Math.floor(centerPosition - aux);
            region.end = Math.floor(centerPosition + aux);
        }
    },
    _calculateRegionByZoom: function (zoom) {
        // mrl = minimum region length
        // zlm = zoom level multiplier

        // mrl * zlm ^ 100 = chr.size
        // zlm = (chr.size/mrl)^(1/100)
        // zlm = (chr.size/mrl)^0.01

        var minNtPixels = 10; // 10 is the minimum pixels per nt
        var chr = this.chromosomes[this.region.chromosome];
        var minRegionLength = this.getSVGCanvasWidth() / minNtPixels;
        var zoomLevelMultiplier = Math.pow(chr.size / minRegionLength, 0.01); // 0.01 = 1/100  100 zoom levels

//      regionLength = mrl * (Math.pow(zlm,ZOOM))
        var regionLength = minRegionLength * (Math.pow(zoomLevelMultiplier, 100 - zoom)); // invert   100 - zoom

        var centerPosition = this.region.center();
        var aux = Math.ceil((regionLength / 2) - 1);
        var start = Math.floor(centerPosition - aux);
        var end = Math.floor(centerPosition + aux);

        return {start: start, end: end};
    },
    _calculateZoomByRegion: function (region) {
        var minNtPixels = 10; // 10 is the minimum pixels per nt
        var chr = this.chromosomes[region.chromosome];
        var minRegionLength = this.getSVGCanvasWidth() / minNtPixels;
        var zoomLevelMultiplier = Math.pow(chr.size / minRegionLength, 0.01); // 0.01 = 1/100  100 zoom levels

        var regionLength = region.length();

//      zoom = Math.log(REGIONLENGTH/mrl) / Math.log(zlm);
        var zoom = Math.log(regionLength / minRegionLength) / Math.log(zoomLevelMultiplier);
        return 100 - Math.round(zoom);
    },
    /*****************/
    /*****************/
    /*****************/



    /*****************/
//    _startRegionChange: function () {
//        if (this.changingRegion === true) {
////            return false;
//            return true
//        } else {
//            this.changingRegion = true;
//            return true;
//        }
//    },
//    _endRegionChange: function () {
//        this.changingRegion = false;
//    },

//    _checkStatus: function () {
//        var ok = true;
//        if (typeof this.overviewTrackListPanel !== 'undefined') {
//            if (this.overviewTrackListPanel.status !== 'ready') {
//                ok = false;
//            }
//        }
//        if (typeof this.trackListPanel !== 'undefined') {
//            if (this.trackListPanel.status !== 'ready') {
//                ok = false;
//            }
//        }
//        if (ok) {
//            this._endRegionChange();
//        }
//    },
//    checkTrackListReady: function () {
//        var _this = this;
//        var checkAllTrackListStatus = function (status) {
//            if (_this.overviewTrackListPanel && _this.overviewTrackListPanel.status != status) {
//                return false;
//            }
//            if (_this.trackListPanel.status != status) {
//                return false;
//            }
//            return true;
//        };
//        if (checkAllTrackListStatus('ready')) {
////            console.log('-------------all tracklist ready')
//            _this.trigger('tracks:ready', {sender: _this});
//        }
////        var checkStatus = function () {
////            if (checkAllTrackStatus('ready')) {
////                _this.trigger('tracks:ready', {sender: _this});
////            } else {
////                setTimeout(checkStatus, 100);
////            }
////        };
////        setTimeout(checkStatus, 10);
//    },

    _checkChangingRegion: function () {
        if (typeof this.overviewTrackListPanel !== 'undefined') {
            if (!this.overviewTrackListPanel.checkTracksReady()) {
                return false;
            }
        }
        if (typeof this.trackListPanel !== 'undefined') {
            if (!this.trackListPanel.checkTracksReady()) {
                return false;
            }
        }
        return true;
    },

    /*****************/




    /*****************/
    /** EVENT METHODS **/
    /*****************/
    _regionChangeHandler: function (event) {
        if (this._checkChangingRegion()) {

            /**/
            this._checkAndSetNewChromosomeRegion(event.region);
            this._checkAndSetMinimumRegion(event.region, this.getSVGCanvasWidth());
            this.zoom = this._calculateZoomByRegion(event.region);
            //Relaunch
            this.trigger('region:change', event);
            /**/
            return true;
        } else {
            if (event.sender) {
                if (event.sender.updateRegionControls) {
                    event.sender.updateRegionControls();
                }
            }
            console.log('****************************');
            console.log('**************************** region change already in progress');
            console.log('****************************');
            return false;
        }
    },
    _regionMoveHandler: function (event) {
        //Relaunch
        this.trigger('region:move', event);
    },
    _zoomChangeHandler: function (event) {
        event.zoom = Math.min(100, event.zoom);
        event.zoom = Math.max(0, event.zoom);
        this.zoom = event.zoom;
        this.region.load(this._calculateRegionByZoom(event.zoom));
        this.setRegion(this.region);
    },
    _speciesChangeHandler: function (event) {
        //Relaunch
        this.trigger('species:change', event);
        this._updateSpecies(event.species);


        var firstGeneRegion;
        CellBaseManager.get({
            host: this.cellBaseHost,
            async: false,
            category: 'feature',
            subCategory: 'gene',
            resource: 'first',
            species: event.species,
            params: {
                include: 'chromosome,start,end'
            },
            success: function (r) {
                firstGeneRegion = r.response[0].result[0];
            }
        });


        var region = new Region(firstGeneRegion);
        this.setRegion(region);
    },
    _updateSpecies: function (species) {
        this.species = species;
        this.chromosomes = this.getChromosomes();
        this.species.chromosomes = this.chromosomes;

        if (this.overviewTrackListPanel) {
            this.overviewTrackListPanel.setSpecies(species);
        }
        if (this.trackListPanel) {
            this.trackListPanel.setSpecies(species);
        }
        if (this.chromosomePanel) {
            this.chromosomePanel.setSpecies(species);
        }
        if (this.karyotypePanel) {
            this.karyotypePanel.setSpecies(species);
        }
        if (this.navigationBar) {
            this.navigationBar.setSpecies(species);
        }
    },
    _getSpeciesByTaxonomy: function (taxonomyCode) {
        //find species object
        var speciesObject = null;
        for (var i = 0; i < this.availableSpecies.items.length; i++) {
            for (var j = 0; j < this.availableSpecies.items[i].items.length; j++) {
                var species = this.availableSpecies.items[i].items[j];
                var taxonomy = Utils.getSpeciesCode(species.scientificName);
                if (taxonomy === taxonomyCode) {
                    speciesObject = species;
                    break;
                }
            }
        }
        return speciesObject;
    },

    /*****************/
    /*****************/
    /*****************/
    /*****************/
    /** API METHODS **/
    /*****************/
    setSpeciesByTaxonomy: function (taxonomyCode) {
        var species = this._getSpeciesByTaxonomy(taxonomyCode);
        if (species != null) {
            this._speciesChangeHandler({species: species});
        } else {
            console.log("Species taxonomy not found on availableSpecies.")
        }
    },
    setRegion: function (region, taxonomy) {
        if (taxonomy != null) {
            var species = this._getSpeciesByTaxonomy(taxonomy);
            this._updateSpecies(species);
        }
        return this._regionChangeHandler({region: new Region(region)});
    },
    moveRegion: function (disp) {
        this.region.start += disp;
        this.region.end += disp;
        this.trigger('region:move', {region: this.region, disp: -disp, sender: this});
    },
    setWidth: function (width) {
        var me = this;
        var newRegion = new Region(this.region);
        var newLength = width * this.region.length() / this.width;
        var centerPosition = this.region.center();
        var aux = Math.ceil((newLength / 2) - 1);
        newRegion.start = Math.floor(centerPosition - aux);
        newRegion.end = Math.floor(centerPosition + aux);

        this.width = width;

        if (this.overviewTrackListPanel) {
            this.overviewTrackListPanel.setWidth(width);
        }
        if (this.trackListPanel) {
            this.trackListPanel.setWidth(width);
        }
        if (this.chromosomePanel) {
            this.chromosomePanel.setWidth(width);
        }
        if (this.karyotypePanel) {
            this.karyotypePanel.setWidth(width);
        }
        if (this.navigationBar) {
            this.navigationBar.setWidth(width);
        }

        var hasChanged = this._regionChangeHandler({
            region: newRegion
        });
    },
    setZoom: function (zoom) {
        zoom = Math.min(100, zoom);
        zoom = Math.max(0, zoom);
        this.zoom = zoom;
        this.region.load(this._calculateRegionByZoom(zoom));
        this.setRegion(this.region);
    },
    increaseZoom: function (zoomToIncrease) {
        var zoom = this.zoom + zoomToIncrease;
        this.setZoom(zoom);
    },
    setCellBaseHost: function (host) {
        if (host != this.cellBaseHost) {
            this.cellBaseHost = host;
            this.navigationBar.setCellBaseHost(this.cellBaseHost);
            this.chromosomePanel.setCellBaseHost(this.cellBaseHost);
            this.karyotypePanel.setCellBaseHost(this.cellBaseHost);
            this.trackListPanel.setCellBaseHost(this.cellBaseHost);
            this.overviewTrackListPanel.setCellBaseHost(this.cellBaseHost);

            this._updateSpecies(this.species);
            this.setRegion(new Region(this.region));
        }
    },

    /*****************/
    /*****************/
    getSVGCanvasWidth: function () {
        return this.width - this.trackPanelScrollWidth - this.sidePanelWidth;
    },
    /*****************/
    /*****************/
    /*****************/







    mark: function (args) {
        var attrName = args.attrName || 'feature_id';
        var cssClass = args.class || 'ocb-feature-mark';
        if ('attrValues' in args) {
            args.attrValues = ($.isArray(args.attrValues)) ? args.attrValues : [args.attrValues];
            for (var key in args.attrValues) {
                $('rect[' + attrName + '~=' + args.attrValues[key] + ']').attr('class', cssClass);
            }

        }
    },
    unmark: function (args) {
        var attrName = args.attrName || 'feature_id';
        if ('attrValues' in args) {
            args.attrValues = ($.isArray(args.attrValues)) ? args.attrValues : [args.attrValues];
            for (var key in args.attrValues) {
                $('rect[' + attrName + '~=' + args.attrValues[key] + ']').attr('class', '');
            }

        }
    },

    highlight: function (args) {
        this.trigger('feature:highlight', args);
    },


    getRightSidePanelId: function () {
        return $(this.rightSidebarDiv).attr('id');
    },
    getLeftSidePanelId: function () {
        return $(this.leftSidebarDiv).attr('id');
    },
    getNavigationPanelId: function () {
        return $(this.navigationbarDiv).attr('id');
    },
    getStatusPanelId: function () {
        return $(this.statusbarDiv).attr('id');
    },
    setNavigationBar: function (navigationBar) {
        this.navigationBar = navigationBar;
        var config = {
            availableSpecies: this.availableSpecies,
            species: this.species,
            region: this.region,
            width: this.width,
            svgCanvasWidthOffset: this.trackPanelScrollWidth + this.sidePanelWidth
        };
        _.extend(this.navigationBar, config);
        navigationBar.render(this.getNavigationPanelId());
    },

    toggleAutoHeight: function (bool) {
        this.trackListPanel.toggleAutoHeight(bool);
        this.overviewTrackListPanel.toggleAutoHeight(bool);
    },
    updateHeight: function () {
        this.trackListPanel.updateHeight();
        this.overviewTrackListPanel.updateHeight();
    },


    setSpeciesVisible: function (bool) {
        this.navigationBar.setSpeciesVisible(bool);
    },

    setChromosomesVisible: function (bool) {
        this.navigationBar.setChromosomeMenuVisible(bool);
    },

    setKaryotypePanelVisible: function (bool) {
        this.karyotypePanel.setVisible(bool);
        this.navigationBar.setVisible({'karyotype': bool});
    },

    setChromosomePanelVisible: function (bool) {
        this.chromosomePanel.setVisible(bool);
        this.navigationBar.setVisible({'chromosome': bool});
    },

    setRegionOverviewPanelVisible: function (bool) {
        this.overviewTrackListPanel.setVisible(bool);
        this.navigationBar.setVisible({'region': bool});
    },
    setRegionTextBoxVisible: function (bool) {
        this.navigationBar.setRegionTextBoxVisible(bool);
    },
    setSearchVisible: function (bool) {
        this.navigationBar.setSearchVisible(bool);
    },
    setFullScreenVisible: function (bool) {
        this.navigationBar.setFullScreenButtonVisible(bool);
    },

    /*Track management*/
    addOverviewTrack: function (track) {
        this.overviewTrackListPanel.addTrack(track);
    },

    addTrack: function (track) {
        this.trackListPanel.addTrack(track);
    },

    getTrackById: function (trackId) {
        return this.trackListPanel.getTrackById(trackId);
    },

    removeTrack: function (track) {
        return this.trackListPanel.removeTrack(track);
    },

    restoreTrack: function (track, index) {
        return this.trackListPanel.restoreTrack(track, index);
    },

    setTrackIndex: function (track, newIndex) {
        return this.trackListPanel.setTrackIndex(track, newIndex);
    },

    scrollToTrack: function (track) {
        return this.trackListPanel.scrollToTrack(track);
    },

    showTrack: function (track) {
        this.trackListPanel.showTrack(track);
    },

    hideTrack: function (track) {
        this.trackListPanel.hideTrack(track);
    },
    containsTrack: function (track) {
        return this.trackListPanel.containsTrack(track);
    },
    containsTrackById: function (trackId) {
        return (this.getTrackById(trackId) != null) ? true : false;
    },
    deleteTracksCache:function(){
         this.overviewTrackListPanel.deleteTracksCache();
         this.trackListPanel.deleteTracksCache();
    },

    // TODO - DEPRECATED
    checkRenderedTrack: function (trackId) {
        console.log('DEPRECATED METHOD')
        console.log(this.checkRenderedTrack);
        this.trackExists(trackId);
    }
};
</script><script>CODON_CONFIG = {
    '': {text: '', color: 'transparent'},
    'R': {text: 'Arg', color: '#BBBFE0'},
    'H': {text: 'His', color: '#BBBFE0'},
    'K': {text: 'Lys', color: '#BBBFE0'},

    'D': {text: 'Asp', color: '#F8B7D3'},
    'E': {text: 'Glu', color: '#F8B7D3'},

    'F': {text: 'Phe', color: '#FFE75F'},
    'L': {text: 'Leu', color: '#FFE75F'},
    'I': {text: 'Ile', color: '#FFE75F'},
    'M': {text: 'Met', color: '#FFE75F'},
    'V': {text: 'Val', color: '#FFE75F'},
    'P': {text: 'Pro', color: '#FFE75F'},
    'A': {text: 'Ala', color: '#FFE75F'},
    'W': {text: 'Trp', color: '#FFE75F'},
    'G': {text: 'Gly', color: '#FFE75F'},


    'T': {text: 'Thr', color: '#B3DEC0'},
    'S': {text: 'Ser', color: '#B3DEC0'},
    'Y': {text: 'Tyr', color: '#B3DEC0'},
    'Q': {text: 'Gln', color: '#B3DEC0'},
    'N': {text: 'Asn', color: '#B3DEC0'},
    'C': {text: 'Cys', color: '#B3DEC0'},

    'X': {text: ' X ', color: '#f0f0f0'},
    '*': {text: ' * ', color: '#DDDDDD'}
};

GENE_BIOTYPE_COLORS = {
    "3prime_overlapping_ncrna": "Orange",
    "ambiguous_orf": "SlateBlue",
    "antisense": "SteelBlue",
    "disrupted_domain": "YellowGreen",
    "IG_C_gene": "#FF7F50",
    "IG_D_gene": "#FF7F50",
    "IG_J_gene": "#FF7F50",
    "IG_V_gene": "#FF7F50",
    "lincRNA": "#8b668b",
    "miRNA": "#8b668b",
    "misc_RNA": "#8b668b",
    "Mt_rRNA": "#8b668b",
    "Mt_tRNA": "#8b668b",
    "ncrna_host": "Fuchsia",
    "nonsense_mediated_decay": "seagreen",
    "non_coding": "orangered",
    "non_stop_decay": "aqua",
    "polymorphic_pseudogene": "#666666",
    "processed_pseudogene": "#666666",
    "processed_transcript": "#0000ff",
    "protein_coding": "#a00000",
    "pseudogene": "#666666",
    "retained_intron": "goldenrod",
    "retrotransposed": "lightsalmon",
    "rRNA": "indianred",
    "sense_intronic": "#20B2AA",
    "sense_overlapping": "#20B2AA",
    "snoRNA": "#8b668b",
    "snRNA": "#8b668b",
    "transcribed_processed_pseudogene": "#666666",
    "transcribed_unprocessed_pseudogene": "#666666",
    "unitary_pseudogene": "#666666",
    "unprocessed_pseudogene": "#666666",
    // "": "orangered",
    "other": "#000000"
};

SNP_BIOTYPE_COLORS = {
    "2KB_upstream_variant": "#a2b5cd",
    "5KB_upstream_variant": "#a2b5cd",
    "500B_downstream_variant": "#a2b5cd",
    "5KB_downstream_variant": "#a2b5cd",
    "3_prime_UTR_variant": "#7ac5cd",
    "5_prime_UTR_variant": "#7ac5cd",
    "coding_sequence_variant": "#458b00",
    "complex_change_in_transcript": "#00fa9a",
    "frameshift_variant": "#ff69b4",
    "incomplete_terminal_codon_variant": "#ff00ff",
    "inframe_codon_gain": "#ffd700",
    "inframe_codon_loss": "#ffd700",
    "initiator_codon_change": "#ffd700",
    "non_synonymous_codon": "#ffd700",
    "intergenic_variant": "#636363",
    "intron_variant": "#02599c",
    "mature_miRNA_variant": "#458b00",
    "nc_transcript_variant": "#32cd32",
    "splice_acceptor_variant": "#ff7f50",
    "splice_donor_variant": "#ff7f50",
    "splice_region_variant": "#ff7f50",
    "stop_gained": "#ff0000",
    "stop_lost": "#ff0000",
    "stop_retained_variant": "#76ee00",
    "synonymous_codon": "#76ee00",
    "other": "#000000"
};

SEQUENCE_COLORS = {A: "#009900", C: "#0000FF", G: "#857A00", T: "#aa0000", N: "#555555"};

SAM_FLAGS = [
    ["read paired", 0x1],
    ["read mapped in proper pair", 0x2],
    ["read unmapped", 0x4],
    ["mate unmapped", 0x8],
    ["read reverse strand", 0x10],
    ["mate reverse strand", 0x20],
    ["first in pair", 0x40],
    ["second in pair", 0x80],
    ["not primary alignment", 0x100],
    ["read fails platform/vendor quality checks", 0x200],
    ["read is PCR or optical duplicate", 0x400]
];

FEATURE_TYPES = {

    //methods
    formatTitle: function (str) {
        var s = str;
        if (str) {
            str.replace(/_/gi, " ");
            s = s.charAt(0).toUpperCase() + s.slice(1);
        }
        return s;
    },
    getTipCommons: function (f) {
        var strand = (f.strand != null) ? f.strand : "NA";
        return 'start-end:&nbsp;<span style="font-weight: bold">' + f.start + '-' + f.end + '</span><br>' +
            'strand:&nbsp;<span style="font-weight: bold">' + strand + '</span><br>' +
            'length:&nbsp;<span style="font-weight: bold; color:#005fdb">' + (f.end - f.start + 1).toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,") + '</span><br>';
    },
    getTipTitleCommons: function (f) {
        var tokens = [];
        if (f.featureType) tokens.push(f.featureType);
        if (f.id) tokens.push(f.id);
        if (f.name) tokens.push(f.name);
        return tokens.join(' - ');
    },
    getLabelCommons: function (f) {
        var tokens = [];
        if (f.id) tokens.push(f.id);
        if (f.name) tokens.push(f.name);
        return tokens.join(' - ');
    },
    _getSimpleKeys: function (f) {
        var s = '';
        for (key in f) {
            if (key == 'start' || key == 'end' || key == 'id' || key == 'name' || key == 'length') {
                continue;
            }
            if (_.isNumber(f[key]) || _.isString(f[key])) {
                s += key + ':&nbsp;<span style="font-weight: bold">' + f[key] + '</span><br>'
            }
        }
        return s
    },

    //items
    sequence: {
        color: SEQUENCE_COLORS
    },
    undefined: {
        label: function (f) {
            var str = "";
            str += f.chromosome + ":" + f.start + "-" + f.end;
            return str;
        },
        tooltipTitle: function (f) {
            return FEATURE_TYPES.getTipTitleCommons(f);
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#aaa",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "lightgray"
    },
    gene: {
        label: function (f) {
            var name = (f.name != null) ? f.name : f.id;
            var str = "";
            str += (f.strand < 0 || f.strand == '-') ? "<" : "";
            str += " " + name + " ";
            str += (f.strand > 0 || f.strand == '+') ? ">" : "";
            if (f.biotype != null && f.biotype != '') {
                str += " [" + f.biotype + "]";
            }
            return str;
        },
        tooltipTitle: function (f) {
            var name = (f.name != null) ? f.name : f.id;
            return FEATURE_TYPES.formatTitle('Gene') + ' - <span class="ok">' + name + '</span>';
        },
        tooltipText: function (f) {
            var color = GENE_BIOTYPE_COLORS[f.biotype];
            return 'id:&nbsp;<span class="ssel">' + f.id + '</span><br>' +
                'biotype:&nbsp;<span class="emph" style="color:' + color + ';">' + f.biotype + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f) +
                'source:&nbsp;<span class="ssel">' + f.source + '</span><br><br>' +
                'description:&nbsp;<span class="emph">' + f.description + '</span><br>';
        },
        color: function (f) {
            return GENE_BIOTYPE_COLORS[f.biotype];
        },
        infoWidgetId: "id",
        height: 4,
        histogramColor: "lightblue"
    },
    transcript: {
        label: function (f) {
            var name = (f.name != null) ? f.name : f.id;
            var str = "";
            str += (f.strand < 0) ? "<" : "";
            str += " " + name + " ";
            str += (f.strand > 0) ? ">" : "";
            if (f.biotype != null && f.biotype != '') {
                str += " [" + f.biotype + "]";
            }
            return str;
        },
        tooltipTitle: function (f) {
            var name = (f.name != null) ? f.name : f.id;
            return FEATURE_TYPES.formatTitle('Transcript') +
                ' - <span class="ok">' + name + '</span>';
        },
        tooltipText: function (f) {
            var color = GENE_BIOTYPE_COLORS[f.biotype];
            return 'id:&nbsp;<span class="ssel">' + f.id + '</span><br>' +
                'biotype:&nbsp;<span class="emph" style="color:' + color + ';">' + f.biotype + '</span><br>' +
                'description:&nbsp;<span class="emph">' + f.description + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f);
        },
        color: function (f) {
            return GENE_BIOTYPE_COLORS[f.biotype];
        },
        infoWidgetId: "id",
        height: 1,
        histogramColor: "lightblue"
    },
    exon: {//not yet
        label: function (f) {
            var name = (f.name != null) ? f.name : f.id;
            return name;
        },
        tooltipTitle: function (f) {
            var name = (f.name != null) ? f.name : f.id;
            if (name == null) {
                name = ''
            }
            return FEATURE_TYPES.formatTitle('Exon') + ' - <span class="ok">' + name + '</span>';
        },
        tooltipText: function (e, t) {
            return FEATURE_TYPES.getTipCommons(e) + FEATURE_TYPES._getSimpleKeys(e);
            //var ename = (e.name != null) ? e.name : e.id;
            //var tname = (t.name != null) ? t.name : t.id;
            //var color = GENE_BIOTYPE_COLORS[t.biotype];
            //return 'transcript name:&nbsp;<span class="ssel">' + t.name + '</span><br>' +
            //    'transcript Ensembl&nbsp;ID:&nbsp;<span class="ssel">' + t.id + '</span><br>' +
            //    'transcript biotype:&nbsp;<span class="emph" style="color:' + color + ';">' + t.biotype + '</span><br>' +
            //    'transcript description:&nbsp;<span class="emph">' + t.description + '</span><br>' +
            //    'transcript start-end:&nbsp;<span class="emph">' + t.start + '-' + t.end + '</span><br>' +
            //    'exon start-end:&nbsp;<span class="emph">' + e.start + '-' + e.end + '</span><br>' +
            //    'strand:&nbsp;<span class="emph">' + t.strand + '</span><br>' +
            //    'length:&nbsp;<span class="info">' + (e.end - e.start + 1).toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,") + '</span><br>';
        },
        color: function (f) {
            return "black";
        },
        infoWidgetId: "id",
        height: 7,
        histogramColor: "lightblue"
    },
    snp: {
        label: function (f) {
            var change = f.reference + ' > ' + f.alternate;
            var name = '';
            if('name' in f){
              name += f.name;
            }else if('id' in f){
              name += f.id;
            }
            return name + ' ' + change;
        },
        tooltipTitle: function (f) {
          var change = f.reference + ' > ' + f.alternate;
          var name = '';
          if('name' in f){
            name += f.name;
          }else if('id' in f){
            name += f.id;
          }
            return 'SNP' + ' - <span class="ok">' +  name + ' ' + change + '</span>';
        },
        tooltipText: function (f) {
            return 'alleles:&nbsp;<span class="ssel">' + f.alleleString + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f) +
                'conseq. type :&nbsp;<span class="ssel">' + f.displayConsequenceType + '</span><br>';
//                'source:&nbsp;<span class="ssel">' + f.source + '</span><br>';

        },
        color: function (f) {
            return SNP_BIOTYPE_COLORS[f.displayConsequenceType];
        },
        infoWidgetId: "id",
        strokeColor: "#555",
        height: 8,
        histogramColor: "orange"
    },
    vcf: {
        label: function (f) {
            return f.id;
            try {
                var fields = f.sampleData.split("\t");
            } catch (e) {
                //Uncaught TypeError: Cannot call method 'split' of undefined
                console.log(e)
                debugger
            }

            if (fields.length > 10 || fields.length == 9)
                return f.id + " " + f.ref + "/" + f.alt + "";
            else {
                var gt = fields[9].split(":")[0];
                if (gt.indexOf(".") != -1 || gt.indexOf("-") != -1)
                    return gt;
                var label = "";
                var alt = f.alt.split(",");
                if (gt.charAt(0) == '0')
                    label = f.ref;
                else {
                    var pos = gt.charAt(0) - 1
                    label = alt[pos]
                }
                label += gt.charAt(1)
                if (gt.charAt(2) == '0')
                    label += f.ref;
                else {
                    var pos = gt.charAt(2) - 1
                    label += alt[pos]
                }

                return label;
            }
        },
        tooltipTitle: function (f) {
            return 'VCF variant - <span class="ok">' + f.id + '</span>';
        },
        tooltipText: function (f) {
            return 'alleles (ref/alt):&nbsp;<span class="emph">' + f.reference + "/" + f.alternate + '</span><br>' +
                'quality:&nbsp;<span class="emph">' + f.quality + '</span><br>' +
                'filter:&nbsp;<span class="emph">' + f.filter + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f);
        },
        color: function (f) {
            return "black";
        },
        infoWidgetId: "id",
        height: 8,
        histogramColor: "gray"
    },
    gff2: {
        label: function (f) {
            var str = "";
            str += f.label;
            return str;
        },
        tooltipTitle: function (f) {
            return f.featureType.toUpperCase() +
                ' - <span class="ok">' + f.label + '</span>';
        },
        tooltipText: function (f) {
            return 'score:&nbsp;<span class="emph">' + f.score + '</span><br>' +
                'frame:&nbsp;<span class="emph">' + f.frame + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f);
        },
        getColor: function (f) {
            return "black";
        },
        height: 8,
        histogramColor: "gray"
    },
    gff3: {
        label: function (f) {
            var str = "";
            str += f.label;
            return str;
        },
        tooltipTitle: function (f) {
            return f.featureType.toUpperCase() +
                ' - <span class="ok">' + f.label + '</span>';
        },
        tooltipText: function (f) {
            return 'score:&nbsp;<span class="emph">' + f.score + '</span><br>' +
                'frame:&nbsp;<span class="emph">' + f.frame + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f);
        },
        color: function (f) {
            return "black";
        },
        height: 8,
        histogramColor: "gray",
        infoWidgetId: 'id',
        handlers: {
            'feature:mouseover': function (e) {
                console.log(e)
            },
            'feature:click': function (e) {
                console.log(e)
            }
        }
    },
    gtf: {
        label: function (f) {
            var str = "";
            str += f.label;
            return str;
        },
        tooltipTitle: function (f) {
            return f.featureType.toUpperCase() +
                ' - <span class="ok">' + f.label + '</span>';
        },
        tooltipText: function (f) {
            return 'score:&nbsp;<span class="emph">' + f.score + '</span><br>' +
                'frame:&nbsp;<span class="emph">' + f.frame + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f);
        },
        color: function (f) {
            return "black";
        },
        height: 8,
        histogramColor: "gray",
        infoWidgetId: 'id',
        handlers: {
            'feature:mouseover': function (e) {
                console.log(e)
            },
            'feature:click': function (e) {
                console.log(e)
            }
        }
    },
    bed: {
        label: function (f) {
            var str = "";
            str += f.label;
            return str;
        },
        tooltipTitle: function (f) {
            return FEATURE_TYPES.formatTitle(f.featureType);
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f);
        },
        color: function (f) {
            //XXX convert RGB to Hex
            var rgbColor = new Array();
            rgbColor = f.itemRgb.split(",");
            var hex = function (x) {
                var hexDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
                return isNaN(x) ? "00" : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
            };
            var hexColor = hex(rgbColor[0]) + hex(rgbColor[1]) + hex(rgbColor[2]);
            return "#" + hexColor;
        },
        height: 8,
        histogramColor: "orange",
        infoWidgetId: 'id',
        handlers: {
            'feature:mouseover': function (e) {
                console.log(e)
            },
            'feature:click': function (e) {
                console.log(e)
            }
        }
    },
    alignment: {
        explainFlags: function (flags) {
            var summary = '<div style="background:#FFEF93;font-weight:bold;margin:0 15px 0 0;">flags : <span class="ssel">' + flags + '</span></div>';
            for (var i = 0; i < SAM_FLAGS.length; i++) {
                if (SAM_FLAGS[i][1] & flags) {
                    summary += SAM_FLAGS[i][0] + "<br>";
                }
            }
            return summary;
        },
        label: function (f) {
            return "Alignment  " + f.chromosome + ":" + f.start + "-" + f.end;
        },
        tooltipTitle: function (f) {
            return 'Alignment' + ' - <span class="ok">' + f.name + '</span>';
        },
        tooltipText: function (f) {
            f.strand = FEATURE_TYPES.alignment.strand(f);
            var cigar = '';
            for (var i = 0; i < f.differences.length; i++) {
                var d = f.differences[i];
                cigar += d.length + d.op
            }

            var one = 'cigar:&nbsp;<span class="ssel">' + cigar + '</span><br>' +
                'insert size:&nbsp;<span class="ssel">' + f.inferredInsertSize + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f) + '<br>' +
                this.explainFlags(f.flags);

            var three = '<div style="background:#FFEF93;font-weight:bold;">attributes</div>';
            delete f.attributes["BQ"];//for now because is too long
            for (var key in f.attributes) {
                three += key + ":" + f.attributes[key] + "<br>";
            }
            var style = "background:#FFEF93;font-weight:bold;";
            return '<div style="float:left">' + one + '</div>' +
                '<div style="float:right">' + three + '</div>';
        },
        color: function (f, chr) {
            if (f.mateReferenceName != chr) {
                return "lightgreen";
            }
            return (parseInt(f.flags) & (0x10)) == 0 ? "DarkGray" : "LightGray";
            /**/
        },
        strokeColor: function (f) {
            if (this.mateUnmappedFlag(f)) {
                return "tomato"
            }
            return (parseInt(f.flags) & (0x10)) == 0 ? "LightGray" : "DarkGray";
        },
        strand: function (f) {
            return (parseInt(f.flags) & (0x10)) == 0 ? "Forward" : "Reverse";
        },
        readPairedFlag: function (f) {
            return (parseInt(f.flags) & (0x1)) == 0 ? false : true;
        },
        firstOfPairFlag: function (f) {
            return (parseInt(f.flags) & (0x40)) == 0 ? false : true;
        },
        mateUnmappedFlag: function (f) {
            return (parseInt(f.flags) & (0x8)) == 0 ? false : true;
        },
        infoWidgetId: "id",
        height: 13,
        histogramColor: "grey"
    },
    bam: {
        explainFlags: function (flags) {
            var summary = '<div style="background:#FFEF93;font-weight:bold;">flags : <span>' + flags + '</span></div>';
            for (var i = 0; i < SAM_FLAGS.length; i++) {
                if (SAM_FLAGS[i][1] & flags) {
                    summary += SAM_FLAGS[i][0] + "<br>";
                }
            }
            return summary;
        },
        label: function (f) {
            return "Read  " + f.chromosome + ":" + f.start + "-" + f.end;
        },
        tooltipTitle: function (f) {
            return 'Read' + ' - <span class="ok">' + f.QNAME + '</span>';
        },
        tooltipText: function (f) {
            f.strand = this.strand(f);
            var cigar = '';
            for (var i = 0; i < f.differences.length; i++) {
                var d = f.differences[i];
                cigar += d.length + d.op
            }

            var one = 'CIGAR:&nbsp;<b>' + cigar + '</b><br>' +
                'TLEN:&nbsp;<b>' + f.TLEN + '</b><br>' +
                'RNAME:&nbsp;<b>' + f.RNAME + '</b><br>' +
                'POS:&nbsp;<b>' + f.POS + '</b><br>' +
                'MAPQ:&nbsp;<b>' + f.MAPQ + '</b><br>' +
                'RNEXT:&nbsp;<b>' + f.RNEXT + '</b><br>' +
                'PNEXT:&nbsp;<b>' + f.PNEXT + '</b><br>' +
                FEATURE_TYPES.getTipCommons(f) + '<br>' +
                this.explainFlags(f.FLAG)+ '<br>';

            var three = '<div style="background:#FFEF93;font-weight:bold;">Optional fields</div>';
            for (var key in f.OPTIONAL) {
                three += key + ":" + f.OPTIONAL[key] + "<br>";
            }
            var style = "background:#FFEF93;font-weight:bold;";
            return '<div>' + one + '</div>' +
                '<div>' + three + '</div>';
        },
        color: function (f, chr) {
            if (f.RNEXT == "=" || f.RNAME == f.RNEXT) {
                return (parseInt(f.FLAG) & (0x10)) == 0 ? "DarkGray" : "LightGray";
            }else{
                return "lightgreen";
            }
            /**/
        },
        strokeColor: function (f) {
            if (this.mateUnmappedFlag(f)) {
                return "tomato"
            }
            return (parseInt(f.FLAG) & (0x10)) == 0 ? "LightGray" : "DarkGray";
        },
        strand: function (f) {
            return (parseInt(f.FLAG) & (0x10)) == 0 ? "Forward" : "Reverse";
        },
        readPairedFlag: function (f) {
            return (parseInt(f.FLAG) & (0x1)) == 0 ? false : true;
        },
        firstOfPairFlag: function (f) {
            return (parseInt(f.FLAG) & (0x40)) == 0 ? false : true;
        },
        mateUnmappedFlag: function (f) {
            return (parseInt(f.FLAG) & (0x8)) == 0 ? false : true;
        },
        infoWidgetId: "id",
        height: 13,
        histogramColor: "grey"
    },
    variantMulti: {
        label: function (f) {
            return f.id;
            debugger
            try {
                var fields = f.sampleData.split("\t");
            } catch (e) {
                //Uncaught TypeError: Cannot call method 'split' of undefined
                console.log(e)
                debugger
            }

            if (fields.length > 10 || fields.length == 9)
                return f.id + " " + f.ref + "/" + f.alt + "";
            else {
                var gt = fields[9].split(":")[0];
                if (gt.indexOf(".") != -1 || gt.indexOf("-") != -1)
                    return gt;
                var label = "";
                var alt = f.alt.split(",");
                if (gt.charAt(0) == '0')
                    label = f.ref;
                else {
                    var pos = gt.charAt(0) - 1
                    label = alt[pos]
                }
                label += gt.charAt(1)
                if (gt.charAt(2) == '0')
                    label += f.ref;
                else {
                    var pos = gt.charAt(2) - 1
                    label += alt[pos]
                }

                return label;
            }
        },
        tooltipTitle: function (f) {
            return 'VCF variant - <span class="ok">' + f.id + '</span>';
        },
        tooltipText: function (f) {
            return 'alleles (ref/alt):&nbsp;<span class="emph">' + f.reference + "/" + f.alternate + '</span><br>' +
                'type:&nbsp;<span class="emph">' + f.type + '</span><br>' +
//                'quality:&nbsp;<span class="emph">' + f.quality + '</span><br>' +
//                'filter:&nbsp;<span class="emph">' + f.filter + '</span><br>' +
                FEATURE_TYPES.getTipCommons(f);
        },
        color: '#8BC34A',
        infoWidgetId: "id",
        height: 10,
        histogramColor: "gray"
    },
    variant: {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return FEATURE_TYPES.getTipTitleCommons(f);
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#8BC34A",
        strokeColor: "#555",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#58f3f0"
    },
    'TF_binding_site': {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return FEATURE_TYPES.getTipTitleCommons(f);
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#58f3f0",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#58f3f0"
    },
    'mirna_target': {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return FEATURE_TYPES.getTipTitleCommons(f);
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#8af688",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#8af688"
    },
    'Histone': {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return FEATURE_TYPES.getTipTitleCommons(f);
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#7a91c7",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#7a91c7"
    },
    'Polymerase': {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return FEATURE_TYPES.getTipTitleCommons(f);
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#44c2d4",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#44c2d4"
    },
    'Open Chromatin': {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return FEATURE_TYPES.getTipTitleCommons(f);
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#ba56b8",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#ba56b8"
    },
    'Clinvar': {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return 'Clinvar' + ' - ' + f.clinvarSet.title;
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#d7ff9a",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#d7ff9a"
    },
    'Cosmic': {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return 'Cosmic';
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#009aff",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#009aff"
    },
    'GWAS': {
        label: function (f) {
            return FEATURE_TYPES.getLabelCommons(f);
        },
        tooltipTitle: function (f) {
            return 'GWAS';
        },
        tooltipText: function (f) {
            return FEATURE_TYPES.getTipCommons(f) + FEATURE_TYPES._getSimpleKeys(f);
        },
        color: "#ff6500",
        infoWidgetId: "id",
        height: 10,
        histogramColor: "#ff6500"
    }
};
</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

var Utils = {
    //properties
    characters: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
    months: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov", "Dec"],
    number: {
        sign: function (x) {
            return x ? x < 0 ? -1 : 1 : 0;
        }
    },
    //Methods
    formatNumber: function (position) {
        return position.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    },
    formatText: function (text, spaceChar) {
        text = text.replace(new RegExp(spaceChar, "gi"), " ");
        text = text.charAt(0).toUpperCase() + text.slice(1);
        return text;
    },
    titleCase: function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);;
    },
    camelCase: function (str) {
        return str.toLowerCase().replace(/[.-_\s](.)/g, function (match, group1) {
            return group1.toUpperCase();
        })
    },
    camelToSpace: function (str) {
        var result = str.replace(/([A-Z])/g, ' $1').toLowerCase().trim();
        return result.charAt(0).toUpperCase() + result.slice(1);
    },
    closest: function (element, selector) {
        var matches = (element.matches) ? 'matches' : 'msMatchesSelector';
        while (element) {
            if (element[matches](selector)) {
                break;
            }
            element = element.parentElement;
        }
        return element;
    },
    isFunction: function (s) {
        return typeof (s) === 'function' || s instanceof Function;
    },
    parseDate: function (strDate) {
        return strDate.substring(4, 6) + "/" + strDate.substring(6, 8) + "/" + strDate.substring(0, 4) + " " + strDate.substring(8, 10) + ":" + strDate.substring(10, 12) + ":" + strDate.substring(12, 14);
    },
    genId: function (prefix) {
        prefix = prefix || '';
        prefix = prefix.length == 0 ? prefix : prefix + '-';
        return prefix + this.randomString(4) + this.getRandomInt(1000, 9999);
    },
    randomString: function (length) {
        length = length || 10;
        var str = "";
        for (var i = 0; i < length; i++) {
            str += this.characters.charAt(this.getRandomInt(0, this.characters.length - 1));
        }
        return str;
    },
    getRandomInt: function (min, max) {
        // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
        // Using Math.round() will give you a non-uniform distribution!
        return Math.floor(Math.random() * (max - min + 1)) + min;
    },
    endsWithIgnoreCase: function (str, test) {
        var regex = new RegExp('^.*\\.(' + test + ')$', 'i');
        return regex.test(str);
    },
    endsWith: function (str, test) {
        return str.length >= test.length && str.substr(str.length - test.length) == test;
    },
    addQueryParamtersToUrl: function (paramsWS, url) {
        var chr = "?";
        if (url.indexOf("?") != -1) {
            chr = "&";
        }
        var query = Utils.queryString(paramsWS);
        if (query != "")
            query = chr + query;
        return url + query;
    },
    queryString: function (obj) {
        var items = [];
        for (var key in obj) {
            if (obj[key] != null && obj[key] != undefined) {
                items.push(key + '=' + encodeURIComponent(obj[key]));
            }
        }
        return items.join('&');
    },
    randomColor: function () {
        var color = "";
        for (var i = 0; i < 6; i++) {
            color += ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f'][Math.floor(Math.random() * 16)]);
        }
        return "#" + color;
    },
    colorLuminance: function (hex, lum) {
        // validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');
        hex = String(hex).replace(/#/gi, '');
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;

        // convert to decimal and change luminosity
        var rgb = "#",
            c, i;
        for (i = 0; i < 3; i++) {
            c = parseInt(hex.substr(i * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb += ("00" + c).substr(c.length);
        }

        return rgb;
    },
    getSpeciesFromAvailable: function (availableSpecies, speciesCode) {
        for (var phylos in availableSpecies) {
            for (var i = 0; i < availableSpecies[phylos].length; i++) {
                var species = availableSpecies[phylos][i];
                if (species.id === speciesCode || species.scientificName.toLowerCase() === speciesCode.toLowerCase()) {
                    return species;
                }
            }
        }
    },
    getSpeciesCode: function (speciesName) {
        var pair = speciesName.split(" ");
        var code;
        if (pair.length < 3) {
            code = (pair[0].charAt(0) + pair[1]).toLowerCase();
        } else {
            code = (pair[0].charAt(0) + pair[1] + pair[pair.length - 1].replace(/[/_().\-]/g, '')).toLowerCase();

        }
        return code;
    },
    basicValidationForm: function (scope) {
        var validated = true;
        var msg = "";
        if (scope.$.outdir.selectedFile === undefined || scope.$.outdir.selectedFile.type != "FOLDER") {
            msg += "Error: Please select an output folder.\n";
            validated = false;
        }
        if (scope.$.inputFile.selectedFile === undefined || scope.$.inputFile.selectedFile.type != "FILE") {
            msg += "Error: Please select an input file.\n";
            validated = false;
        }
        if (scope.$.jobName.value == "") {
            msg += "Error: Please add a job name.\n";
            validated = false;
        }
        if (!validated) {
            alert(msg)
        }
        return validated;
    },
    getUrl: function (fileId) {
        return OpencgaManager.files.download({
            id: fileId,
            query: {
                sid: Cookies("bioinfo_sid")
            },
            request: {
                url: true
            }
        });
    },
    getFileContent: function (callback, fileId) {
        OpencgaManager.files.content({
            id: fileId,
            query: {
                sid: Cookies("bioinfo_sid")
            },
            request: {
                success: function (response) {
                    callback(response);
                },
                error: function () {
                    this.message = 'Server error, try again later.';
                }
            }
        })
    },
    loadExampleFile: function (callback, toolName, exampleFileName) {

        var me = this;
        OpencgaManager.files.contentExample({
            query: {
                toolName: toolName,
                fileName: exampleFileName
            },
            request: {
                //method: 'POST',
                success: function (response) {
                    callback(response);
                    //                            debugger
                    //                            me.loadedMainSelectChanged(false,true);
                },
                error: function () {
                    console.log('utils.js223:Server error, try again later.');
                }
            }
        })
    },
    downloadExampleFile: function (toolName, fileName) {
        var url = OpencgaManager.files.downloadExample({
            query: {
                toolName: toolName,
                fileName: fileName
            },
            request: {
                url: true
            }
        });
        var link = document.createElement('a');
        link.href = url;
        //link.setAttribute("download", "download.zip");
        var event = new MouseEvent('click', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        link.dispatchEvent(event);
    },
    argsParser: function (form, args) {
        if (form.toolName == args.tool) {
            for (var key in args) {
                if (typeof (args[key]) == "object") {
                    if (form.$[key] !== undefined)
                        form.$[key].selectedFile = args[key];
                } else {
                    var elems = form.shadowRoot.querySelectorAll('input[name="' + key + '"]');
                    if (form.$[key] !== undefined) {
                        switch (form.$[key].type) {
                        case "checkbox":
                            form.$[key].checked = args[key];
                        default:
                            form.$[key].value = args[key];
                        }
                    }
                    for (var i = 0; i < elems.length; i++) {
                        var elem = elems[i];
                        if (elem.value == args[key])
                            elem.checked = true;
                    }

                }
            }
        }
    },
    getLinks: function (terms) {
        var links = [];
        for (var i = 0; i < terms.length; i++) {
            var term = terms[i];
            links.push(Utils.getLink(term));
        }
        return links;
    },
    getLink: function (term) {
        var link = "http://www.ebi.ac.uk/QuickGO/GTerm?id=";
        if (term.indexOf("(") >= 0) {
            var id = term.split("(");
            if (id.length > 1)
                id = id[1];
            id = id.split(")")[0];

        } else
            id = term;
        if (id.indexOf("IPR") == 0)
            link = "http://www.ebi.ac.uk/interpro/entry/";
        link = link + id;
        return link;
    },
    myRound: function (value, decimals) {
        decimals = typeof decimals !== 'undefined' ? decimals : 2;
        value = parseFloat(value);
        /** rounding **/
        if (Math.abs(value) >= 1)
            value = value.toFixed(decimals);
        else
            value = value.toPrecision(decimals);
        value = parseFloat(value);
        return value;
    },
    formatNumber: function (value, decimals) {
        value = Utils.myRound(value, decimals);

        if (Math.abs(value) > 0 && Math.abs(value) < 0.001)
            value = value.toExponential();
        return value;
    },
    getSpecies: function (specieValue, species) {
        for (var i = 0; i < species.length; i++) {
            var specie = species[i];
            if (specie.value == specieValue) {
                return specie;
            }
        }
        return null;
    },
    test: function () {
        return this;
    },
    cancelFullscreen: function () {
        if (document.cancelFullScreen) {
            document.cancelFullScreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
        }
    },
    launchFullScreen: function (element) {
        if (element.requestFullScreen) {
            element.requestFullScreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.webkitRequestFullScreen) {
            element.webkitRequestFullScreen();
        }
    },
    parseJobCommand: function (item) {
        var commandObject = {};
        var commandArray = item.commandLine.split(/ -{1,2}/g);
        var tableHtml = '<table cellspacing="0" style="max-width:400px;border-collapse: collapse;border:1px solid #ccc;"><tbody>';
        tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;font-weight:bold;">';
        tableHtml += '<td style="min-width:50px;border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">Parameter</td>';
        tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">Value</td>';
        tableHtml += '</tr>';
        for (var i = 1; i < commandArray.length; i++) {
            //ignore first argument
            var paramenter = commandArray[i];
            var paramenterArray = paramenter.split(/ {1}/g);
            var name = '';
            var value = '';
            if (paramenterArray.length < 2) {
                name = paramenterArray[0];
                value = '<span color:darkgray;font-weight:bold;>This paramenter is a flag</span>';
            } else {
                name = paramenterArray[0];
                value = paramenterArray[1];
            }
            commandObject[name] = value;
            /* clean values for viz*/
            value = value.replace(/\/httpd\/bioinfo\/opencga\/analysis\/.+\/examples\//, '');
            value = value.replace('/httpd/bioinfo/opencga/accounts/', '');
            value = value.replace(/,/g, ", ");

            tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;">';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;color:steelblue;font-weight:bold;white-space: nowrap;">' + name + '</td>';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">' + value + '</td>';
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        return {
            html: tableHtml,
            data: commandObject
        };
    },
    htmlTable: function (object) {
        var tableHtml = '';
        tableHtml += '<table cellspacing="0" style="border-collapse: collapse;border:1px solid #ccc;"><tbody>';
        for (var key in object) {
            tableHtml += '<tr style="border-collapse: collapse;border:1px solid #ccc;">';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;color:steelblue;font-weight:bold;white-space: nowrap;">' + key + '</td>';
            tableHtml += '<td style="border-collapse: collapse;border:1px solid #ccc;padding: 5px;background-color: whiteSmoke;">' + object[key] + '</td>';
            tableHtml += '</tr>';
        }
        tableHtml += '</tbody></table>';
        return tableHtml;
    },
    msg: function (title, msg) {
        var div = document.createElement('div');
        div.classList.add('jso-msg-hidden');
        var titleDiv = document.createElement('div');
        titleDiv.textContent = title;
        var msgDiv = document.createElement('div');
        msgDiv.textContent = msg;
        div.appendChild(titleDiv);
        div.appendChild(msgDiv);
        document.body.appendChild(div);
        div.addEventListener('click', function () {
            document.body.removeChild(div);
            div = null;
        });
        setTimeout(function () {
            div.classList.add('jso-msg-shown');
        }, 10);
        setTimeout(function () {
            if (div) {
                div.classList.remove('jso-msg-shown');
            }
        }, 4000);
        setTimeout(function () {
            if (div) {
                document.body.removeChild(div);
                div = null;
            }
        }, 4400);
    },
    repeat: function (string, count) {
        if (string == null) {
            throw new TypeError('can\'t convert ' + string + ' to object');
        }
        var str = '' + string;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (august 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += str;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            str += str;
        }
        return rpt;

    },
    clone: function (obj) {
        return JSON.parse(JSON.stringify(obj));
    },
    timeDiff: function (timeStart, timeEnd) {
        var ts = new Date(Date.parse(timeStart));
        var te = new Date(Date.parse(timeEnd));

        if (isNaN(ts) || isNaN(te)) {
            return "";
        }

        if (ts < te) {
            var milisec_diff = te - ts;
        } else {
            var milisec_diff = ts - te;
        }

        var days = Math.floor(milisec_diff / 1000 / 60 / (60 * 24));
        var daysMessage = days + " Days ";
        if (days === 0) {
            daysMessage = '';
        }
        var date_diff = new Date(milisec_diff);
        var hours = date_diff.getHours() - 1;
        var hoursMessage = hours + " hour";
        var minutesMessage = date_diff.getMinutes() + " minute";
        var secondsMessage = date_diff.getSeconds() + " second";
        if (hours !== 1) {
            hoursMessage += 's ';
        } else {
            hoursMessage += ' ';
        }
        if (date_diff.getMinutes() !== 1) {
            minutesMessage += 's ';
        } else {
            minutesMessage += ' ';
        }
        if (date_diff.getSeconds() !== 1) {
            secondsMessage += 's ';
        } else {
            secondsMessage += ' ';
        }
        if (hours === 0) {
            hoursMessage = '';
        }
        if (date_diff.getMinutes() === 0) {
            minutesMessage = '';
        }
        if (date_diff.getSeconds() === 0) {
            secondsMessage = '';
        }
        return daysMessage + hoursMessage + minutesMessage + secondsMessage;
    },
    deleteIndexedDB: function () {
        window.indexedDB.webkitGetDatabaseNames().onsuccess = function (sender, args) {
            var r = sender.target.result;
            for (var i in r) {
                indexedDB.deleteDatabase(r[i]);
            }
        };
    },
    subsetArray: function (array, from, to) {
        var aux = [];
        from = (from < 0) ? 0 : from;
        to = (to >= array.length) ? array.length : to;

        for (var i = from; i < to; i++) {
            aux.push(array[i]);
        }

        return aux;
    },
    applyFunctionBatch: function (array, batchsize, callback) {

        var end = batchsize;
        var auxArray = this.subsetArray(array, 0, end);

        while (auxArray.length > 0) {
            callback(auxArray);
            auxArray = this.subsetArray(array, end, end + batchsize);
            end += batchsize;
        }
    }

};

Utils.images = {
    add: "data:image/gif;base64,R0lGODlhEAAQAIcAAD2GNUKNNkOPOESMO0WNPEmPP0iNQUmPQlOVTFWWTVCZQVeeRV6cVmGeWGSgVWSgV2aiWGejW2WrVWirU2uqWGqsW2yqWm61WG+1WG+1WXS3W3S3XHC4WXK5W3O6XHG+X3asZ3iuaHe8YHi0ZH+yany6ZH28Zn2+Z3m9bn25an25a3+5bUD/QHDBY3nBZHrGa3zDa37BaX7Hb4K1boO1boa3cYi4d4y7doq5eYm+eI2+e5O/f4HMdYbJeobJfIXNeYrCeY/CfYnIf4rPfZW/gozLgY7MhI7Sg5LFgJXAgpfHhZfMhZPNiJjLhpjMh5jMipvBl5vBmJTTipbTiZXUipbUi5fVi5nRi53YkqTOlKbPlqbQlqDZlaDZlqXbm6rUnavUnKbIoKfJoa/fpa/fprPZpbTZpbTaprLbqLPdqbXbqLfaqrTdqrXfrLbdrLjVr7jdr7vcr7rWsbfgr77itr3ktsTcuMXducXowMvmw87pydTrz9fu0tzx2ODy3P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAACwALAAAAAAQABAAAAi/AFkIHEiwoME7SWrMwCHH4MAdWfLs0QNnRQiHN+L4qeOlyxg8QCAU3LGmDxYmRqpQOTJHRYSBdpTw4SJFyJ8/P2DIaLNAjEAibsgU8YHiZgURHq4gaSCQBh0rPW5K/cMhxpcCAkmkGcJj6k0OJ8AMEGjjyZQXLSR85dBhiY4EAt9MYOPig4ivFzacEQBlIIgUaJByyIBBQxkLBwo6GKHGiYkSTcxQAODwgYIgW7TkCGDAocAwDAoQQBDFs2mCAQEAOw==",
    del: "data:image/gif;base64,R0lGODlhEAAQAIcAAED/QLpSNL9TOr5WOb5cQL9cQMFNM8RQNMBVPcBZP8xSPNBPPttWS9ddUcJnTMRkTMdrVM1gUc5iVMxmVclrVs1oWNZgVNZuZNtpZdxraN5ratxuadRxZd14c955dOZWTOZYTOZZTulZTelbT+ZWUOZaUuddWepcUOxfVOBlXO5mUuljW+pmXO5qXvBkVvNzXeNrYeNuY+FvcOJwZuJ7deR4ceJ5eeN4eeJ/feN/fOl7cOh6del/ePJ3Y/N5Y+qDfe6Efe+Gfu6KdfaCaPaEbPCFcPCDe/CMd/GOeviGcPiMdvCRf/eRfveTfvmSfvqTf/iUf9ymltynl+6Mge2Tju6Sj/SOgfqah/qdi/GclvGdluGpnvSgnvSinvWjn/qjkfupnPqrneGroOqwrOuzr/Ono/WmoferofarovWsofWvpfKtqvivpPS0qvi2qPm5r/q6rvC1tfC2tvjDvvzHuvnLxPnTzPzUzf3b1P3c2P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAAALAAAAAAQABAAAAi6AAEIHEiwoEE5ODRk8EDG4EAbVObYqdNmxgWHMtbkgfMFCxg6OiQUvFEGz5UlSKA4UeImRoWBcX7cwdJECJGbRHywWSBGYA41YY6gGEq0hxUeFARuePOkiJ6nUEW00IJAIIYzSYZAjcoiywCBHaYweSGirNkRRmg8EDiGARoXKsyKAFHCy4EoAznASIPihIgQH0h0sVCgYIQUZoKsMAGES4MADico2FGlSg0DBBwK3AIhgQAHUjSLJhgQADs=",
    enable: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAKfSURBVDjLpZPrS1NhHMf9O3bOdmwDCWREIYKEUHsVJBI7mg3FvCxL09290jZj2EyLMnJexkgpLbPUanNOberU5taUMnHZUULMvelCtWF0sW/n7MVMEiN64AsPD8/n83uucQDi/id/DBT4Dolypw/qsz0pTMbj/WHpiDgsdSUyUmeiPt2+V7SrIM+bSss8ySGdR4abQQv6lrui6VxsRonrGCS9VEjSQ9E7CtiqdOZ4UuTqnBHO1X7YXl6Daa4yGq7vWO1D40wVDtj4kWQbn94myPGkCDPdSesczE2sCZShwl8CzcwZ6NiUs6n2nYX99T1cnKqA2EKui6+TwphA5k4yqMayopU5mANV3lNQTBdCMVUA9VQh3GuDMHiVcLCS3J4jSLhCGmKCjBEx0xlshjXYhApfMZRP5CyYD+UkG08+xt+4wLVQZA1tzxthm2tEfD3JxARH7QkbD1ZuozaggdZbxK5kAIsf5qGaKMTY2lAU/rH5HW3PLsEwUYy+YCcERmIjJpDcpzb6l7th9KtQ69fi09ePUej9l7cx2DJbD7UrG3r3afQHOyCo+V3QQzE35pvQvnAZukk5zL5qRL59jsKbPzdheXoBZc4saFhBS6AO7V4zqCpiawuptwQG+UAa7Ct3UT0hh9p9EnXT5Vh6t4C22QaUDh6HwnECOmcO7K+6kW49DKqS2DrEZCtfuI+9GrNHg4fMHVSO5kE7nAPVkAxKBxcOzsajpS4Yh4ohUPPWKTUh3PaQEptIOr6BiJjcZXCwktaAGfrRIpwblqOV3YKdhfXOIvBLeREWpnd8ynsaSJoyESFphwTtfjN6X1jRO2+FxWtCWksqBApeiFIR9K6fiTpPiigDoadqCEag5YUFKl6Yrciw0VOlhOivv/Ff8wtn0KzlebrUYwAAAABJRU5ErkJggg==",
    warning: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIsSURBVDjLpVNLSJQBEP7+h6uu62vLVAJDW1KQTMrINQ1vPQzq1GOpa9EppGOHLh0kCEKL7JBEhVCHihAsESyJiE4FWShGRmauu7KYiv6Pma+DGoFrBQ7MzGFmPr5vmDFIYj1mr1WYfrHPovA9VVOqbC7e/1rS9ZlrAVDYHig5WB0oPtBI0TNrUiC5yhP9jeF4X8NPcWfopoY48XT39PjjXeF0vWkZqOjd7LJYrmGasHPCCJbHwhS9/F8M4s8baid764Xi0Ilfp5voorpJfn2wwx/r3l77TwZUvR+qajXVn8PnvocYfXYH6k2ioOaCpaIdf11ivDcayyiMVudsOYqFb60gARJYHG9DbqQFmSVNjaO3K2NpAeK90ZCqtgcrjkP9aUCXp0moetDFEeRXnYCKXhm+uTW0CkBFu4JlxzZkFlbASz4CQGQVBFeEwZm8geyiMuRVntzsL3oXV+YMkvjRsydC1U+lhwZsWXgHb+oWVAEzIwvzyVlk5igsi7DymmHlHsFQR50rjl+981Jy1Fw6Gu0ObTtnU+cgs28AKgDiy+Awpj5OACBAhZ/qh2HOo6i+NeA73jUAML4/qWux8mt6NjW1w599CS9xb0mSEqQBEDAtwqALUmBaG5FV3oYPnTHMjAwetlWksyByaukxQg2wQ9FlccaK/OXA3/uAEUDp3rNIDQ1ctSk6kHh1/jRFoaL4M4snEMeD73gQx4M4PsT1IZ5AfYH68tZY7zv/ApRMY9mnuVMvAAAAAElFTkSuQmCC",
    edit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB80lEQVR42o2T30tTURzArb8ioiAI6kHoZeF7CGE/IISCUDNCqAeL3rIWPfSwByskYUEJIhSChBhJFAiNqMVYPqRuc4tcW3NLt3C7u3d3d3c/+nS+0GRK0134cC6c8/ncc+7ltgFt6jqgcCg6duGQYq84deoBR6lU0iqVSq1arfI/1Dxut3u0Htke6BC5UChgmuYm+XyeXC5HOp1GIsnQNJHJi3x/7WJh/CSLT9r7Rd4jAVlgWRa2bSOjYBgGmqaRyWQwkq9Y8wyhLb0BI0VuaRrfo671xoDIwmakWCyi6zrr36bILt/HXp1l7cNDioEZqnEvgYmr1paAOgYy1u/l3NrqHNngPWpFL8XodTa+3CD8YoCvz/o078i5o1sC29FT78kG7lCzfJgrl7ESvejLThLPuxk8fbhP3KaBVFCdeX7on9yP9bOHfPAu0bEzmKkg4jQNpEKzhOduqW1/xIoNUEpcQlM7WXl6Cj39Q9Y0D4Q/TRJ662Tx3WOS/guYsV42Fm4THe/G/B2T97Jz4OVwJ+hxImPn8Tj381k91TfShfErIvLuAde1Y9g+N7Z/FL/rBDODR8gmgpTL5To7B3o69zF8pR3Pg7PMT90kn47LJ22kaeCPghapidP4Lxy3bduUiVZktdaQH7AxcFAiUm0Rhzji/gUhbp0s2Zf2xwAAAABJRU5ErkJggg==",
    info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAJ1SURBVHjafJJdSJNhFMd/z3QzLWdZrnQmSA2DPqRCK4KuhIq66kLoAy/qoqCguqqL6JsgLwoKKhCMSIy6CDKKRFZZYYQRVhJl02nWmG5uc19u7/vuPV0lW7QOnIsHnt+P8z/Pg4gw26aZ0263uzEUCn2IxWJjXq/3JqBETLIZ8gkePLhfKyKy/Z5HHJf7xe0Jic/n65mejizPK0inUiSTKUSE0dHRhxf6JoSDb4Rjr4QDz0REJBgMtmczFrJKKYVSCjCYnPR/W1FuAwQSGjbHXAA0LRXKZnIm0NJpgAKvd/hSOBz2iIj0eiPS2vtDYsmUPH/uPg9YshklIrOyCb+/eUG5ve3au5C99W2AqGbgKivk8R4X1lSkv2pJZaNmmBQVWWeZnAiGoa+3KovdyBjsW2kn/SvK4Jcgtaf7cDqrGkQMUDkBcgXVS2tOHjp8dG2jOXT1yo5lYOpgFTB0wKTAOqdQMlqOoDD7EE8kREwGXr/oWTg4HjxONAklBayuKSUeT/hFTxrwnwlAMa8I1qyrP3H95RiQgUiC/RsWM+wZ6jIME0M38wtSM0mmojM4nc6mzr5xKDQgnWb/pmoedT29EU3pTMUS+QVKKerq6kqnI3EVHwmAplO8qBh7WTFnzpz9bOg6FovlfxGEixfOrfT6YxCOQ1rDUaIAG4EJ38+PAwNb/95Bzj8ITAZwLHbMT0yHw3N33YVwEnQDqss41VzPkaalX6Iz+m6Xy/Xp34JAAICR7187nLWuvbe6h9C0DA2uRTTVV9J++87OlpaWJxUVFf9+xj+1cfOWls6OO93Nq1zblMVm9flG3pcvXNPm90+E/777ewB+UIqdqtYXHAAAAABJRU5ErkJggg==",
    //    bucket: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90BCg4hBcbCoOMAAABsSURBVDjLY2RgYFBjYGCIZCAPLGeBam4g0wAGJgYKARMDA8NZCvSfZYQy6sk0oJEFiUNqODRQLQxGDYCAb2To/YZswEsyDHiJbMAHMgz4gO6F5aTkQpgXYElZkoGBgZeEbL2cgYHhMwMDw3MA93ARk+mSg4gAAAAASUVORK5CYII=",
    bucket: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QkQDC8RTstxRAAAAGBJREFUOMtjYBgswIWBgeE/idiFgYGBgRFqwH8GBoYGEi1tYGBgYGRBE9QjUvMlGANmgCsDA8NuElzRANXDwAQV2ENGuO1BNoBsMGoAlQ3wJTIdNEDVYgU+ROQBH6rmQgAWgB19xco60wAAAABJRU5ErkJggg==",
    //    dir: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsSAAALEgHS3X78AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKNJREFUeNrEk7sNwkAQBefQ5m6BTiAAQssZiMh0QFUIMrAEpKYD8ynAJeD4nXQEkJHgu4CXv9GsdteFEEjJgMQ4gPli+aWx227cLwAD8FK8QZ4XTyCL6B6qal+YlzLgCpSn87HpbTCdzAKwAkpg1Bdgn/nbmDLQmby6hC3W5qUGGEcCGpNUJwBq09tgHdO+Pe61eamNvIMLgEkaxuoDuL9/42sAM20/EZafbV8AAAAASUVORK5CYII=",
    dir: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDNzU0RUNBNzU3OEIxMUUyOEM3QzkxOEZDOTU1RTdFMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDNzU0RUNBODU3OEIxMUUyOEM3QzkxOEZDOTU1RTdFMCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkM3NTRFQ0E1NTc4QjExRTI4QzdDOTE4RkM5NTVFN0UwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkM3NTRFQ0E2NTc4QjExRTI4QzdDOTE4RkM5NTVFN0UwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+S/WxbAAAAERJREFUeNpi/P//PwMlgJFSA1g2bNiAzYQLQOwIxB8IGcCEQ9wAiPcDsQBBF+CRAxnynlwXEA1GDRg1gCqZiWIDAAIMADidE0PBoGsZAAAAAElFTkSuQmCC",
    r: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90CDRIvNbHTpbwAAADjSURBVDjLpZFBbsIwEEUfVRZYahcVK3qKXoauMFK5C91nkyUB+xC5BqeAA7SKq1B5ugl2EiC04UkjayzN17NnROTRWvvJFbTWL8CBHqbGWOlSlqVkWSbGWAGm3aGHZiMiAByPP6FOd1rP2W7NvhvSCvDe10E+VJPFQpPnm1ZIcsmgPgJVVZGmaejX63y/XL4/AV/JJYPTCeDcN7PZWyuwKAqA8wARqSsGKDVGqXGjV8H07AnRQPq21TK8+YSBAQMN4hb6Df7wB/5eA+4zmEyehxk451itPrhFksSxUeP+lf+z+wXwdayJk/mqtgAAAABJRU5ErkJggg==",
    box: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMHAwRAVvTmTAAAAK/SURBVDjLpZM9bFxFGEXPNzPvZ+39sb2xHceREjDQBwlDCqqIiiotokAghYKEjvSkQkKJkEiB0lOkoAHaBAokFCQKUATIIOLIMbHWrHfX+7zvvZk3MzQODUgU3PJK5+g2F/5n5N/Kb66/1NNK3hAxr4HcFqVuvfju18V/Cu58sPmMVnJZ4K32Qr+t8za+KnCz4kCUuiGibm5euTv5h+CL958/nxj1XivVF+e6C9TVhPmFdbROgEhwNU1d4m09UaJuInLjhct3DgDUh5ee7j14PLxulLvYP/0seadPkub88Wib0eB3bDkmxgbRoFPpxeCuKvjsyQIzOyqImT7/y8Mh++NveW7jLFmrx6m1NlWxz6PHA7otQ7tloAmYJE9isOeeCJRtIrULLLUTjsqG7+//xs72z7jZgCTNONlVJKEiuobW0jqSaoiet19dFQATJcc2FSFEciNoLYwOHcPDASvdjM5cQntxlbR9gqacoFSK84VsnOrkH11Zdmp0FFXjobSeCFgXSDS0Eo11ge7yGXSaU092UUlCaEpC8FK4tDcu4rzZ2a/S+bWI94HSAgFigDQD24Cvp4gIOp0juBJvC2L07B1Uc/Mtg9k7sHMbywZrA3lLECV4AtaCpAp79CcmzXHlhOBrAJrGyNbOVBY7qTO1C9r5EKyPSttAiJEs01SuQStFkrdp6gKd5AzHjixVxCDxp+1paZRUxoc4Kp36bndYbS53U5WlCq0CMYIPMY7GI0mNpiqmGK0oK4jIveGkPgRqfTBt3A8Pqtvrq52HtglnGh9XIaKUkCQ6nj6RyWBsmdXCtFI/bu2Fq5c+3roGzIAgWokCDNACOhfOLb781Ip+vd+RC2dXWibROkxKvvp1z376yZe7d4HpMdz8/YVjiQYyoA30Ti6la2++0n/n83vTW/e3ix1gcgzXgPchBoC/AFu/UBF5InryAAAAAElFTkSuQmCC",
    bluebox: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMHAwTE5pcivoAAALsSURBVDjLXZPPaxxlGMc/77wz+3N2k822tWsTIrQFe/BWEKxKCV5UohdFhJ60p6rgUfpP6C0K4kHx0ENEkV7aElHwUikhFVosRGoTm83+3pnZnXfed2beHtItIQ98+Z6+H57nga8AsNYKDkYcEofcHvKZEEJYcSTszPzqL3fmf3+w/+a51tytby9d6D0N5UecGeBZ8MPv/jh9fy/6dKzMpVPHmvWdbl/XCvKn5Wbl6+ufrNwGssMgYa2VgFj58sZr7VB/LqX3zlKrydJzTTzXxdqcx90hO+0Bk2l8Z74i1z6+cOba5VfOqGeAb3579M/NR53T40xwrDGHFALPEUjn4LoMi0ktwWTKXqCIqAVrbyycvHj2hHYBR+bO8Q/Ov0imEzZ2xrRDRalQwC9LLBalUgaJQy+tU6gvIBJbv3j2RA4IFxDdICFa9ulMCrz/UgOs5kEwpeh57I4Nt/dzsmLOYlEThgFjUePp33IHoD9SJAbuTVyudRweixJvnVtg3/i00wpLPiwQ0hkO6YYKawWj0UjONqAfKHwDkxTqqeW/RHA3hO2+Zqk05e5wTD9KmOqMKDEUqoLNzU0PyF2AQaBoaIhiw0h6TIwgUDCODb5NiWJNlKREyhAozXwOW1tbFSmlcAHbD2KaytCdGgyWglfEs4LeNKeaa4axYRgpwlgTTTXVDDqdTslaewAYh4kNlKUbZsTGonOwCYwm1vq5Ft1AMYgU08SQR5o0gziOcRxHuoCNtdl6uPHX6/Vmi3Yyh9I5IoEgMdkgT9x+qJhEGrdQo77cJMuy+4DJskwLa60DOCtf3HhZpfZKtVx+L3x+sfCv8CFxTINd72HfodQ4aQp5fP24/v/Hd4Nf/5RSJmma6lkXZn1wPvvq5qndsbhS9esf/Zy/UEtzxnURfn8+/fuHV7m353mecV1XSym1lDI72kaxvr5e3N7eruyP0tpG/e3LK/rW2mLNUb7vm3K5nFarVdNqtbJer2dXV1fzJ6cDpboAZRAGAAAAAElFTkSuQmCC",
    refresh: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAK8AAACvABQqw0mAAAAAd0SU1FB90CFA8bKScXIjIAAAJ1SURBVDjLlVJdSJNRGH7es+/7NlduWFLTKAskwjJqZYiBglJhLKguqou6EFkFIkLQH9IPBFI3BsouzMJupGYRajcqmeBFhWBU5oUgpZikrSnzZ9v3nW/ndKEbziXUAwfOOe/7Puc9z/MCq1DwMmB1NX/rzfCNnsc/gK08lPgnnT8Cs33BULg0HI4YKdkHX9DqKwKArXXv1bTMTFcoyruC89E8MxaDw659t6rKhIUwRBLdP2t2v/5bBwQA+5pH8ibnIj3BucgWIQRASw8RERTGYFUtsGmWYUXKmqmr7t4UAnal54GQ8lq8MBlyOU0CEnA67MiwqfvHbhZ+Smgg6o9eV2L8Nhk6wI2lZeggrpvE+TTjxgxxQ4IbmJsJYSa00JQiotnguacJ8zIZOmDosAnzTpowt8tGj0s0ejZqprnDKmPHSNebjHDkUPatt4cTTbZ+LsmO79XK52dZxTNp9/ovAEDnaM62lo8HHrd9SVfiOelVryrSq9vrEx0s8sW2tuEzDgDgT875bcIsjy6owwAwHhjnYT5bGTL29PiHyuwAMO873aL/Ct5PiPjwXe5vq7KJW2hdJxENMFInGCkhIblLj80WRoyxGxZmh1XJGlSIlV8s6A8kuVDXn+MF6JHC7GBkBSNlOSRgiihMsQhAgJGGNNU1atc2HPG6O8YSBABwt2/nGyFlGSCSB4UIBMuyoQKMFNiUjIApRH5t8YfpFOOrO/JrhZBVUiJLxq2ipIkY8Z36uivpC6txqb3YbhqhIingFlLmxmLSKyXAGAaYqh13aFjfcHJwfE2ClSitK9psc85PMVC3M999orX4Kcf/wuPb27VW7A+O2QVVA1M1CQAAAABJRU5ErkJggg==",
    newitem: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAtxJREFUeNqM0llIVHEUBvDv3vlfZ8ac6zZtWpmamtliUUHRDlFJWlEYLdBLtG/QBlFJQUTSU089RZRlG4EvkS9NlqkpldHyYLk1OurcOzp30vHO/y6nBwsSIvzgvBw+fpyHA8MwwDmHbdsjQwSbCACkYDBYp6pqU3Fxcfyf/Z+eYRjQOQf+Bnw+30IiIsMwhizL4n3lV6mn7BzZtm1yzn8SETU0NKz+J2ARobe3t85/+SI1506j9hOHqTEO9FYEtR/ZTx/n5FDH6eOkquoni2g00NjUtEzTtBYioneLCulVHKg2yUkNmelUn5VOtUlueu0SqDE/m4iIIpFI64fm5vU65xAMIlicR9rOn/UEKytgmQbYuARAEDAqRLCiQxBFhtTNWzDzxk1LcjgkFhuKIhLR2qJKcN5Al/q7reF/cXUHoA0MtA9Gh4klJIxz6ro+PZiVC0uOw1jimJEDWZbTDhw8lCi0+/3PtUeV696ePIPUnIwxAf3fOjG/7AK8e/e9ZH2K0uWdPRdivANm3NguED1OJBYWQunvDwgAXIqifO54+CC7/tSxMQELL11B/r6D3cnJybniQDis25Ikfn1wD2GdQLIMISkF5JFhudwgjwySkyCkpILkRER0wpf7d2FJkqSoapQRRPCYjoLDR+EY70VXbS2YxCC4nAARbAAQBJBlwTIMZJRsQN7W7eA6t9O8XkE0jRhWLV2y+Gdm9q0dT6rMhLw8dPn7EAoEMBSLIcpjCPUEEPD3gU1Kw+6qZ6TPKrizq3TbAjUUIkFRVYAIkkfG99bWp4P1b7Z0vq5BXtFGPN6zE6Zuo7SiAh01PkycV4jJRRt96VOmrOHhMESHiBEAgMkNlGwqmXC78mG1DXtQdruTgx/eF5g6x9Tly1pCmtYjMSnxatnFTeXXyn8wxiCMAgxz5EmcTjCXCynxblf1C9910eFwrl254nh/dDhqcQ5zeBgAwBiDIAr4NQAWJarVjshqqgAAAABJRU5ErkJggg=="
};
</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

//Element.prototype.addChildSVG = function(elementName, attributes, index){
//	var el = document.createElementNS('http://www.w3.org/2000/svg', elementName);
//	for ( var key in attributes){
//		el.setAttribute(key, attributes[key]);
//	}
//	
//	// insert child at requested index, or as last child if index is too high or no index is specified
//    if ( null == index ) {
//      this.appendChild( el );
//    }
//    else {
//      var targetIndex = index + 1;
//      if ( 0 == index ) {
//        targetIndex = 0;
//      }
//      var targetEl = this.childNodes[ targetIndex ];
//      if ( targetEl ) {
//        this.insertBefore( el, targetEl ); 
//      }
//      else {
//        this.appendChild( el );
//      }
//    }
//    return el;
//};
//Element.prototype.initSVG = function(attributes){
//	return this.addChildSVG("svg", attributes);
//};

var SVG = {
	
	create : function (elementName, attributes){
		var el = document.createElementNS('http://www.w3.org/2000/svg', elementName);
		for ( var key in attributes){
			el.setAttribute(key, attributes[key]);
		}
		return el;
	},

	addChild : function (parent, elementName, attributes, index){
		var el = document.createElementNS('http://www.w3.org/2000/svg', elementName);
		for ( var key in attributes){
			el.setAttribute(key, attributes[key]);
		}
		return this._insert(parent, el, index);
	},
	
	addChildImage : function (parent, attributes, index){
		var el = document.createElementNS('http://www.w3.org/2000/svg', "image");
		for ( var key in attributes){
			if(key == "xlink:href"){
				el.setAttributeNS('http://www.w3.org/1999/xlink','href',attributes[key]);
			}else{
			    el.setAttribute(key, attributes[key]);
            }
		}
		return this._insert(parent, el, index);
	},
	
	_insert : function (parent, el, index){
		// insert child at requested index, or as last child if index is too high or no index is specified
	    if ( null == index ) {
	    	parent.appendChild( el );
	    }
	    else {
	      var targetIndex = index + 1;
	      if ( 0 == index ) {
	        targetIndex = 0;
	      }
	      var targetEl = parent.childNodes[ targetIndex ];
	      if ( targetEl ) {
	    	  parent.insertBefore( el, targetEl ); 
	      }
	      else {
	    	  parent.appendChild( el );
	      }
	    }
	    return el;
	},

	init : function (parent, attributes){
		return this.addChild(parent, "svg", attributes);
	},



    //
    /* Functions to generate arcs with PATH element  */
    //

    _polarToCartesian : function (centerX, centerY, radius, angleInDegrees) {
        var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;

        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY + (radius * Math.sin(angleInRadians))
        };
    },

    describeArc : function (x, y, radius, startAngle, endAngle) {

        var start = this._polarToCartesian(x, y, radius, endAngle);
        var end = this._polarToCartesian(x, y, radius, startAngle);

        var arcSweep = endAngle - startAngle <= 180 ? "0" : "1";
        var d = [
            "M", start.x, start.y,
            "A", radius, radius, 0, arcSweep, 0, end.x, end.y
        ].join(" ");

        return d;
    }
};

//createSVG = function(elementName, attributes){
//	var el = document.createElementNS('http://www.w3.org/2000/svg', elementName);
//	for ( var key in attributes){
//		el.setAttribute(key, attributes[key]);
//	}
//	return el;
//};



//var SVG =
//{
//		svgns : 'http://www.w3.org/2000/svg',
//		xlinkns : "http://www.w3.org/1999/xlink",
//
////	createSVGCanvas: function(parentNode, attributes)
////	{
//////		attributes['xmlns'] = SVG.svgns;
//////		attributes['xmlns:xlink'] = SVG.xlinkns;
//////		attributes.push( ['xmlns', SVG.svgns], ['xmlns:xlink', 'http://www.w3.org/1999/xlink']);
////		var svg = document.createElementNS(SVG.svgns, "svg");
////		
////		for ( var key in attributes){
////			svg.setAttribute(key, attributes[key]);
////		}
////		
////		parentNode.appendChild(svg);
////		return svg;
////	}, 
//	
//	//Shape types : rect, circle, ellipse, line, polyline, polygon , path
//	createElement : function (svgNode, shapeName, attributes) {
//		try{
//			if(attributes.width < 0){
//				console.log("BIOINFO Warn: on SVG.createRectangle: width is negative, will be set to 0");
//				attributes.width=0;
//			}
//			if(attributes.height < 0){
//				console.log("BIOINFO Warn: on SVG.createRectangle: height is negative, will be set to 0");
//				attributes.height=0;
//			}
//			
//			var shape = document.createElementNS('http://www.w3.org/2000/svg', shapeName);
//			for ( var key in attributes){
//				shape.setAttribute(key, attributes[key]);
//			}
//			svgNode.appendChild(shape);
//		}
//		catch(e){
//			console.log("-------------------- ");
//			console.log("Error on drawRectangle " + e);
//			console.log(attributes);
//			console.log("-------------------- ");
//		}
//		return shape;
//	}
//};
//
//
//
//var CanvasToSVG = {
//		
//	convert: function(sourceCanvas, targetSVG, x, y, id, attributes) {
//		
//		var img = this._convert(sourceCanvas, targetSVG, x, y, id);
//		
//		for (var i=0; i< attributes.length; i++)
//		{
//			img.setAttribute(attributes[i][0], attributes[i][1]);
//		}
//	},
//	
//	_convert: function(sourceCanvas, targetSVG, x, y, id) {
//		var svgNS = "http://www.w3.org/2000/svg";
//		var xlinkNS = "http://www.w3.org/1999/xlink";
//		// get base64 encoded png from Canvas
//		var image = sourceCanvas.toDataURL();
//
//		// must be careful with the namespaces
//		var svgimg = document.createElementNS(svgNS, "image");
//
//		svgimg.setAttribute('id', id);
//	
//		//svgimg.setAttribute('class', class);
//		//svgimg.setAttribute('xlink:href', image);
//		svgimg.setAttributeNS(xlinkNS, 'xlink:href', image);
//		
//
//		svgimg.setAttribute('x', x ? x : 0);
//		svgimg.setAttribute('y', y ? y : 0);
//		svgimg.setAttribute('width', sourceCanvas.width);
//		svgimg.setAttribute('height', sourceCanvas.height);
//		//svgimg.setAttribute('cursor', 'pointer');
//		svgimg.imageData = image;
//	
//		targetSVG.appendChild(svgimg);
//		return svgimg;
//	},
//	
//	importSVG: function(sourceSVG, targetCanvas) {
//	    svg_xml = sourceSVG;//(new XMLSerializer()).serializeToString(sourceSVG);
//	    var ctx = targetCanvas.getContext('2d');
//
//	    var img = new Image();
//	    img.src = "data:image/svg+xml;base64," + btoa(svg_xml);
////	    img.onload = function() {
//	        ctx.drawImage(img, 0, 0);
////	    };
//	}
//	
//};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function Region(args) {

    this.chromosome = null;
    this.start = null;
    this.end = null;

    if (_.isObject(args)) {
        this.load(args);
    } else if (_.isString(args)) {
        this.parse(args);
    }
}

Region.prototype = {
    load: function (obj) {
        if (_.isString(obj)) {
            return this.parse(obj);
        }
        this.chromosome = this._checkChromosomeAlias(obj) || this.chromosome;

        if (typeof obj.position !== 'undefined') {
            obj.start = parseInt(obj.position);
            obj.end = obj.start;
        }

        (_.isUndefined(obj.start)) ? this.start = parseInt(this.start) : this.start = parseInt(obj.start);
        (_.isUndefined(obj.end)) ? this.end = parseInt(this.end) : this.end = parseInt(obj.end);
    },

    parse: function (str) {
        if (_.isObject(str)) {
            this.load(obj);
        }
        var pattern = /^([a-zA-Z0-9_])+\:([0-9])+\-([0-9])+$/;
        var pattern2 = /^([a-zA-Z0-9_])+\:([0-9])+$/;
        if (pattern.test(str) || pattern2.test(str)) {
            var splitDots = str.split(":");
            if (splitDots.length == 2) {
                var splitDash = splitDots[1].split("-");
                this.chromosome = splitDots[0];
                this.start = parseInt(splitDash[0]);
                if (splitDash.length == 2) {
                    this.end = parseInt(splitDash[1]);
                } else {
                    this.end = this.start;
                }
            }
            return true
        } else {
            return false;
        }
    },

    multiParse: function (str) {
        if (_.isObject(str)) {
            this.load(obj);
        }
        var pattern = /^([a-zA-Z0-9_])+\:([0-9])+\-([0-9])+(,([a-zA-Z0-9_])+\:([0-9])+\-([0-9])+)*$/;
        var pattern2 = /^\[([a-zA-Z0-9_])+\:([0-9])+\-([0-9])+(,([a-zA-Z0-9_])+\:([0-9])+\-([0-9])+)*\]$/;

        var withoutBrackets = str;
        if (pattern2.test(str)) {
            withoutBrackets = str.slice(1, str.length - 1);
        }

        var regions = [];
        if (pattern.test(withoutBrackets)) {
            var splitRegions = withoutBrackets.split(",");
            for (var i = 0; i < splitRegions.length; i++) {
                regions.push(new Region(splitRegions[i]));
            }
        }
        return regions;
    },

    center: function () {
        return this.start + Math.floor((this.length()) / 2);
    },

    length: function () {
        return this.end - this.start + 1;
    },

    equals: function (r) {
        if (this.chromosome === r.chromosome && this.start === r.start && this.end === r.end) {
            return true;
        }
        return false;
    },

    toString: function (formated) {
        var str;
        if (formated == true) {
            str = this.chromosome + ":" + Utils.formatNumber(this.start) + "-" + Utils.formatNumber(this.end);
        } else {
            str = this.chromosome + ":" + this.start + "-" + this.end;
        }
        return str;
    },

    _checkChromosomeAlias: function (obj) {
        for (var i = 0; i < Region.chromosomeAlias.length; i++) {
            var alias = Region.chromosomeAlias[i];
            if(alias in obj){
                return obj[alias];
            }
        }
    }
};

Region.chromosomeAlias = ['chromosome','sequenceName'];

</script>
<script>/*
 * Binary Search Tree implementation in JavaScript
 * Copyright (c) 2009 Nicholas C. Zakas
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * A binary search tree implementation in JavaScript. This implementation
 * does not allow duplicate values to be inserted into the tree, ensuring
 * that there is just one instance of each value.
 * @class BinarySearchTree
 * @constructor
 */
function FeatureBinarySearchTree() {
    
    /**
     * Pointer to root node in the tree.
     * @property _root
     * @type Object
     * @private
     */
    this._root = null;
}

FeatureBinarySearchTree.prototype = {

    //restore constructor
    constructor: FeatureBinarySearchTree,
    
    //-------------------------------------------------------------------------
    // Private members
    //-------------------------------------------------------------------------
    
    /**
     * Appends some data to the appropriate point in the tree. If there are no
     * nodes in the tree, the data becomes the root. If there are other nodes
     * in the tree, then the tree must be traversed to find the correct spot
     * for insertion. 
     * @param {variant} value The data to add to the list.
     * @return {Void}
     * @method add
     */
    add: function (v){
        //create a new item object, place data in
        var node = { 
                value: v, 
                left: null,
                right: null 
            },
            
            //used to traverse the structure
            current;
    
        //special case: no items in the tree yet
        if (this._root === null){
            this._root = node;
            return true;
        } 
        	//else
            current = this._root;
            
            while(true){
            
                //if the new value is less than this node's value, go left
                if (node.value.end < current.value.start){
                
                    //if there's no left, then the new node belongs there
                    if (current.left === null){
                        current.left = node;
                        return true;
//                        break;
                    } 
                    	//else                  
                        current = current.left;
                    
                //if the new value is greater than this node's value, go right
                } else if (node.value.start > current.value.end){
                
                    //if there's no right, then the new node belongs there
                    if (current.right === null){
                        current.right = node;
                        return true;
//                        break;
                    } 
                    	//else
                        current = current.right;
 
                //if the new value is equal to the current one, just ignore
                } else {
                	return false;
//                    break;
                }
            }        
        
    },
    
    contains: function (v){
        var node = { 
                value: v, 
                left: null,
                right: null 
            },
    	found = false,
    	current = this._root;
          
      //make sure there's a node to search
      while(!found && current){
      
          //if the value is less than the current node's, go left
          if (node.value.end < current.value.start){
              current = current.left;
              
          //if the value is greater than the current node's, go right
          } else if (node.value.start > current.value.end){
              current = current.right;
              
          //values are equal, found it!
          } else {
              found = true;
          }
      }
      
      //only proceed if the node was found
      return found;   
        
    }
};</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

var CellBaseManager = {
    host: (typeof window.CELLBASE_HOST === 'undefined') ? 'http://bioinfo.hpc.cam.ac.uk/cellbase' : window.CELLBASE_HOST,
    version: (typeof window.CELLBASE_VERSION === 'undefined') ? 'v3' : window.CELLBASE_VERSION,
    get: function(args) {
        var success = args.success;
        var error = args.error;
        var async = (args.async == false) ? false: true;

        // remove XMLHttpRequest keys
        var ignoreKeys = ['success', 'error', 'async'];
        var urlConfig = {};
        for (var prop in args) {
            if (hasOwnProperty.call(args, prop) && args[prop] != null && ignoreKeys.indexOf(prop) == -1) {
                urlConfig[prop] = args[prop];
            }
        }

        var url = CellBaseManager.url(urlConfig);
        if (typeof url === 'undefined') {
            return;
        }

        if (window.CELLBASE_LOG != null && CELLBASE_LOG === true) {
            console.log(url);
        }

        var d;
        var request = new XMLHttpRequest();
        request.onload = function() {
            var contentType = this.getResponseHeader('Content-Type');
            if (contentType === 'application/json') {
                var parsedResponse = JSON.parse(this.response);
                if (typeof success === "function") success(parsedResponse);
                d = parsedResponse;
            } else {
                console.log('Cellbase returned a non json object or list, please check the url.');
                console.log(url);
                console.log(this.response)
            }
        };
        request.onerror = function() {
            console.log("CellBaseManager: Ajax call returned " + this.statusText);
            if (typeof error === "function") error(this);
        };
        request.open("GET", url, async);
        request.send();
        return d;

    },
    url: function(args) {
        if (args == null) {
            args = {};
        }
        if (args.params == null) {
            args.params = {};
        }

        var version = this.version;
        if (args.version != null) {
            version = args.version
        }

        var host = this.host;
        if (args.host != null) {
            host = args.host;
        }

        delete args.host;
        delete args.version;

        var config = {
            host: host,
            version: version
        };

        for (var prop in args) {
            if (hasOwnProperty.call(args, prop) && args[prop] != null) {
                config[prop] = args[prop];
            }
        }

        var query = '';
        if (config.query != null) {
            query = '/' + config.query.toString();
        }

        //species can be the species code(String) or an object with text attribute
        if (config.species && config.species.id != null) {
            if (config.species.assembly != null) {
                config.params["assembly"] = config.species.assembly.name;
            }
            // TODO Remove temporary fix
            if (config.subCategory === 'chromosome') {
                delete config.params["assembly"]
            }
            config.species = Utils.getSpeciesCode(config.species.scientificName);
        }

        var url;
        if (config.category === 'meta') {
            url = config.host + '/webservices/rest/' + config.version + '/' + config.category + '/' + config.subCategory;
        } else {
            url = config.host + '/webservices/rest/' + config.version + '/' + config.species + '/' + config.category + '/' + config.subCategory + query + '/' + config.resource;
        }


        url = Utils.addQueryParamtersToUrl(config.params, url);
        return url;
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

var EnsemblManager = {
    host : 'http://beta.rest.ensembl.org',
//    http://beta.rest.ensembl.org/feature/region/human/7:140424943-140624564?feature=gene;feature=transcript;feature=exon;content-type=application/json
    get: function (args) {
        var success = args.success;
        var error = args.error;
        var async = (_.isUndefined(args.async) || _.isNull(args.async) ) ? true : args.async;
        var urlConfig = _.omit(args, ['success', 'error', 'async']);

        var url = EnsemblManager.url(urlConfig);
        if(typeof url === 'undefined'){
            return;
        }
        console.log(url);

        var d;
        $.ajax({
            type: "GET",
            url: url,
            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
            async: async,
            success: function (data, textStatus, jqXHR) {
                if($.isPlainObject(data) || $.isArray(data)){
//                    data.params = args.params;
//                    data.resource = args.resource;
//                    data.category = args.category;
//                    data.subCategory = args.subCategory;
                    if (_.isFunction(success)) success(data);
                    d = data;
                }else{
                    console.log('Cellbase returned a non json object or list, please check the url.');
                    console.log(url);
                    console.log(data)
                }
            },
            error: function (jqXHR, textStatus, errorThrown) {
                console.log("CellBaseManager: Ajax call returned : " + errorThrown + '\t' + textStatus + '\t' + jqXHR.statusText + " END");
                if (_.isFunction(error)) error(jqXHR, textStatus, errorThrown);
            }
        });
        return d;
    },
    url: function (args) {
        if (!$.isPlainObject(args)) args = {};
        if (!$.isPlainObject(args.params)) args.params = {};

        var host = EnsemblManager.host;
        if (typeof args.host !== 'undefined') {
            host =  args.host;
        }
        if(typeof host === 'undefined'){
            console.log("CELLBASE_HOST is not configured");
            return;
        }

        delete args.host;

        var config = {
            host: host
        };

        var params = {
            'content-type':'application/json'
        };

        _.extend(config, args);
        _.extend(config.params, params);

        //species can be the species code(String) or an object with text attribute
        if ($.isPlainObject(config.species)) {
            config.species = Utils.getSpeciesCode(config.species.text);
        }

        var url = config.host + '/' + config.category + '/' + config.subCategory + '/' + config.species + '/' +  config.query;
        url = Utils.addQueryParamtersToUrl(config.params, url);
        return url;
    }
};</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Composes an url with the given parameters.
 * resourceType: any of OpencgaManager.resourceTypes.
 * resourceId: id of the resource in catalog.
 * action: all actions are in OpencgaManager.actions, but some methods don't allow every action.
 * queryParams: Object with the query parameters.
 * args: Object with extra arguments, like the success callback function, or host override.
 *
 * examples of use:
 *
 * OpencgaManager.users.create({
 *      query:{
 *          userId: 'user1',
 *          name: 'User One',
 *          email: 'user@example.com',
 *          password: 'password_one'
 *      },
 *      request:{
 *          success:function(response){
 *              console.log(response);
 *          },
 *          error:function(){
 *              console.log('Server error');
 *          }
 *      }
 * });
 *
 * OpencgaManager.users.login({
 *      id:'user1',
 *      query:{
 *          password: 'password_one'
 *      },
 *      request:{
 *          success:function(response){
 *              console.log(response);
 *          },
 *          error:function(){
 *              console.log('Server error');
 *          }
 *      }
 * });
 *
 * OpencgaManager.users.info({
 *      id:'user1',
 *      query:{
 *          sid: Cookies('bioinfo_sid'),
 *          lastActivity: 'lastActivity'
 *      },
 *      request:{
 *          success:function(response){
 *              console.log(response);
 *          },
 *          error:function(){
 *              console.log('Server error');
 *          }
 *      }
 * });
 *
 *    http://cafetal:8080/opencga/rest/files/3/fetch?region=20:100-200&sid=nsrblm
 *    http://cafetal:8080/opencga/rest/files/17/fetch?sid=eUZtTdnA9EU89vjACyAe&region=20%3A80000-82000&view_as_pairs=false&include_coverage=true&process_differences=false
 *    http://cafetal:8080/opencga/rest/files/17/fetch?sid=eUZtTdnA9EU89vjACyAe&region=20%3A80000-82000&view_as_pairs=false&include_coverage=true&process_differences=false
 */
var OpencgaManager = {
    host: (typeof window.OPENCGA_HOST === 'undefined') ? 'http://ws1.babelomics.org/opencga-0.7' : window.OPENCGA_HOST,
    version: (typeof window.OPENCGA_VERSION === 'undefined') ? 'v1' : window.OPENCGA_VERSION,

    users: {
        login: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'login');
        },
        logout: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'logout');
        },
        info: function(args){
          return OpencgaManager._doRequest(args, 'users', 'info');
        },
        read: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'info');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'update');
        },
        updateEmail: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'change-email');
        },
        updatePassword: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'change-password');
        },
        resetPassword: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'reset-password');
        },
        create: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'create');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'users', 'delete');
        }
    },

    projects: {
        list: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'all-projects');
        },
        read: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'info');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'update');
        },
        create: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'create');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'delete');
        },
        studies: function (args) {
            return OpencgaManager._doRequest(args, 'projects', 'studies');
        }
    },

    studies: {
        list: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'all-studies');
        },
        info: function(args){
          return OpencgaManager._doRequest(args, 'studies', 'info');
        },
        read: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'info');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'update');
        },
        create: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'create');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'delete');
        },
        analysis: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'analysis');
        },
        jobs: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'jobs');
        },
        samples: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'samples');
        },
        variants: function (args) {
            return OpencgaManager._doRequest(args, 'studies', 'variants');
        },
        files: function (args){
          return OpencgaManager._doRequest(args, 'studies', 'files');
        }
    },
    cohorts: {
        create: function (args) {
            return OpencgaManager._doRequest(args, 'cohorts', 'create');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'cohorts', 'update');
        }
    },

    files: {
        list: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'list');
        },
        fetch: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'fetch');
        },
        alignments: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'alignments');
        },
        variants: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'variants');
        },
        read: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'info');
        },
        info: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'info');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'delete');
        },
        index: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'index');
        },
        search: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'search');
        },
        filesByFolder: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'files');
        },
        content: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'content');
        },
        contentGrep: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'content-grep');
        },
        createFolder: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'create-folder');
        },
        setHeader: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'set-header');
        },
        contentExample: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'content-example');
        },
        downloadExample: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'download-example');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'update');
        },
        download: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'download');
        },
        upload: function (args) {
            return OpencgaManager._doRequest(args, 'files', 'upload');
        },
        upload2: function (args) {
            /** Check if exists a file with the same name **/
            var query = {
                sid: Cookies('bioinfo_sid'),
                studyId: args.studyId,
            };
            // if (window.OPENCGA_OLD_URL_FORMAT != null && OPENCGA_OLD_URL_FORMAT === true) {
            //     var splitIndex = args.relativeFilePath.lastIndexOf("/") + 1;
            //     query.name = args.relativeFilePath.substring(splitIndex);
            //     query.directory = args.relativeFilePath.substring(0, splitIndex);
            // } else {
            // }
            query.path = args.relativeFilePath;
            OpencgaManager.files.search({
                query: query,
                request: {
                    success: function (response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            if (response.response[0].result.length == 0) {

                                /** No file found with the same name -> start upload **/
                                var url = OpencgaManager._url({
                                    query: {
                                        sid: args.sid
                                    },
                                    request: {}
                                }, 'files', 'upload');
                                args.url = url;
                                OpencgaManager._uploadFile(args);

                            } else {
                                args.error('File already exists', response.response[0].result);
                            }
                        } else {
                            args.error(response.response[0].errorMsg);
                        }
                    },
                    error: function () {
                        args.error('Server error, try again later.');
                    }
                }
            });
        }

    },
    jobs: {
        create: function (args) {
            return OpencgaManager._doRequest(args, 'jobs', 'create');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'jobs', 'delete');
        },
        info: function (args) {
            return OpencgaManager._doRequest(args, 'jobs', 'info');
        }
    },
    samples: {
        info: function (args) {
            return OpencgaManager._doRequest(args, 'samples', 'info');
        },
        search: function (args) {
            return OpencgaManager._doRequest(args, 'samples', 'search');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'samples', 'update');
        }
    },
    panels:{
      create: function (args) {
        return OpencgaManager._doRequest(args, 'panels', 'create');
      },
      info: function (args) {
        return OpencgaManager._doRequest(args, 'panels', 'info');
      }
    },
    util: {
        proxy: function (args) {
            return OpencgaManager._doRequest(args, 'util', 'proxy');
        }
    },
    tools: {
        search: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'search');
        },
        info: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'info');
        },
        help: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'help');
        },
        update: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'update');
        },
        delete: function (args) {
            return OpencgaManager._doRequest(args, 'tools', 'delete');
        }
    },
    //analysis: {
    //    jobs: function (args) {
    //        return OpencgaManager._doRequest(args, 'analysis', 'jobs');
    //    },
    //    create: function (args) {
    //        return OpencgaManager._doRequest(args, 'analysis', 'create');
    //},
    _url: function (args, api, action) {
        var host = OpencgaManager.host;
        if (typeof args.request.host !== 'undefined' && args.request.host != null) {
            host = args.request.host;
        }
        var version = OpencgaManager.version;
        if (typeof args.request.version !== 'undefined' && args.request.version != null) {
            version = args.request.version;
        }
        var id = '';
        if (typeof args.id !== 'undefined' && args.id != null) {
            id = '/' + args.id;
        }

        var url = host + '/webservices/rest/' + version + '/' + api + id + '/' + action;
        // if (window.OPENCGA_OLD_URL_FORMAT != null && OPENCGA_OLD_URL_FORMAT === true) {
        //     if (action == 'jobs') {
        //         action = 'job'
        //     }
        //     if (api == 'jobs') {
        //         api = 'job'
        //     }
        //     url = host + '/rest/' + api + id + '/' + action;
        // }
        url = Utils.addQueryParamtersToUrl(args.query, url);
        return url;
    },

    _doRequest: function (args, api, action) {
        var url = OpencgaManager._url(args, api, action);
        if (args.request.url === true) {
            return url;
        } else {
            var method = 'GET';
            if (typeof args.request.method !== 'undefined' && args.request.method != null) {
                method = args.request.method;
            }
            var async = true;
            if (typeof args.request.async !== 'undefined' && args.request.async != null) {
                async = args.request.async;
            }

            if (window.OPENCGA_LOG != null && OPENCGA_LOG === true) {
                console.log(url);
            }
            var request = new XMLHttpRequest();
            request.onload = function () {
                var contentType = this.getResponseHeader('Content-Type');
                if (contentType === 'application/json') {
                    var json = JSON.parse(this.response);
                    if (json.error === '' || json.error == null) {
                        args.request.success(json, this);
                    } else {
                        if (window.OPENCGA_LOG != null && OPENCGA_LOG === true) {
                            console.log('! ----    OpencgaManager -------');
                            console.log(json.error);
                            console.log(json);
                            console.log('! ----    OpencgaManager -------');
                        }
                        args.request.error(json, this);
                    }
                } else {
                    args.request.success(this.response, this);
                }
            };
            request.onerror = function (e) {
                args.request.error({
                    error: 'Request error.',
                    errorEvent: e
                }, this);
            };
            request.open(method, url, async);
            request.send();
            return url;
        }
    },
    _uploadFile: function (args) {
        var url = args.url;
        var inputFile = args.inputFile;
        var fileName = args.fileName;
        var userId = args.userId;
        var studyId = args.studyId;
        var relativeFilePath = args.relativeFilePath;
        var fileFormat = args.fileFormat;
        var bioFormat = args.bioFormat;
        var description = args.description;
        var callbackProgress = args.callbackProgress;

        /**/
        var resume = true;
        var resumeInfo = {};
        var chunkMap = {};
        var chunkId = 0;
        var blob = inputFile;
        var BYTES_PER_CHUNK = 2 * 1024 * 1024;
        var SIZE = blob.size;
        var NUM_CHUNKS = Math.max(Math.ceil(SIZE / BYTES_PER_CHUNK), 1);
        var start;
        var end;

        var getResumeInfo = function (formData) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, false); //false = sync call
            xhr.send(formData);
            var response = JSON.parse(xhr.responseText);
            return response.response[0];
        };
        var checkChunk = function (id, size, resumeInfo) {
            if (typeof resumeInfo[id] === 'undefined') {
                return false;
            } else if (resumeInfo[id].size != size /*|| resumeInfo[id].hash != hash*/ ) {
                return false;
            }
            return true;
        };
        var processChunk = function (c) {
            var chunkBlob = blob.slice(c.start, c.end);

            if (checkChunk(c.id, chunkBlob.size, resumeInfo) == false) {
                var formData = new FormData();
                formData.append('chunk_content', chunkBlob);
                formData.append('chunk_id', c.id);
                formData.append('chunk_size', chunkBlob.size);
                /*formData.append('chunk_hash', hash);*/
                formData.append("filename", fileName);
                formData.append('userId', userId);
                formData.append('studyId', studyId);
                formData.append('relativeFilePath', relativeFilePath);
                /*formData.append('chunk_gzip', );*/
                if (c.last) {
                    formData.append("last_chunk", true);
                    formData.append("total_size", SIZE);
                    formData.append("fileFormat", fileFormat);
                    formData.append("bioFormat", bioFormat);
                    console.log(bioFormat);
                    formData.append("description", description);
                }
                uploadChunk(formData, c, function (chunkResponse) {
                    /* FIX--------- Remove this "FIX block" after the server fix */
                    /* Bioformat is modified on server due to BioformatDetector bug */
                    /* https://github.com/opencb/opencga/blob/develop/opencga-analysis/src/main/java/org/opencb/opencga/analysis/files/FileMetadataReader.java#L123 */
                    /* Remove this ASAP, Server bioformatDetector should be invoked if no bioformat is provided. */
                    OpencgaManager.__fix_fileBioformat(chunkResponse, bioFormat, function (f) {
                        callbackProgress(c, NUM_CHUNKS, f);
                    });
                    /* FIX-END----- Remove this "FIX block" after the server fix */

                    /* SAVE the next line!! Uncomment this line after the FIX!!! */
                    // callbackProgress(c, NUM_CHUNKS, chunkResponse);
                    if (!c.last) {
                        processChunk(chunkMap[(c.id + 1)]);
                    } else {

                    }
                });
            } else {
                callbackProgress(c, NUM_CHUNKS);
                if (!c.last) {
                    processChunk(chunkMap[(c.id + 1)]);
                } else {

                }
            }

        };
        var uploadChunk = function (formData, chunk, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, true);
            xhr.onload = function (e) {
                chunk.done = true;
                console.log("chunk done");
                callback(JSON.parse(xhr.responseText));
            };
            xhr.send(formData);
        };

        /**/
        /**/

        if (resume) {
            var resumeFormData = new FormData();
            resumeFormData.append('resume_upload', resume);
            resumeFormData.append('filename', fileName);
            resumeFormData.append('userId', userId);
            resumeFormData.append('studyId', studyId);
            resumeFormData.append('relativeFilePath', relativeFilePath);
            resumeInfo = getResumeInfo(resumeFormData);
        }

        start = 0;
        end = BYTES_PER_CHUNK;
        while (start < SIZE) {
            var last = false;
            if (chunkId == (NUM_CHUNKS - 1)) {
                last = true;
            }
            chunkMap[chunkId] = {
                id: chunkId,
                start: start,
                end: end,
                done: false,
                last: last
            };
            start = end;
            end = start + BYTES_PER_CHUNK;
            chunkId++;
        }
        processChunk(chunkMap[0]);

    },
    __fix_fileBioformat: function (chunkResponse, bioFormat, cb) {
        // THIS IS A TEMPORAL FIX, REMOVE THIS FUNCTION ASAP
        if (chunkResponse.response[0].result != null) {
            var file = chunkResponse.response[0].result[0];
            OpencgaManager.files.update({
                id: file.id,
                query: {
                    sid: Cookies('bioinfo_sid'),
                    bioformat: bioFormat
                },
                request: {
                    success: function (response) {
                        var f = response.response[0].result[0];
                        chunkResponse.response[0].result[0] = f;
                        cb(chunkResponse);
                    },
                    error: function (response) {}
                }
            });
        } else {
            cb(chunkResponse);
        }
    }
};

/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
// resourceTypes: {
//     USERS: "users",
//     PROJECTS: "projects",
//     STUDIES: "studies",
//     FILES: "files",
//     ANALYSES: "analyses",
//     JOBS: "jobs"
// },
// actions: {
//     LOGIN: "login",
//     LOGOUT: "logout",
//     CREATE: "create",
//     UPLOAD: "upload",
//     INFO: "info",
//     LIST: "list",
//     FETCH: "fetch",
//     UPDATE: "update",
//     DELETE: "delete"
// },
// httpMethods: {}, // defined after OpencgaManager
//
// /**
//  * @param queryParams required: password, sid (sessionId)
//  * @return sid (sessionId)
//  */
// login: function(userId, queryParams, args) {
//     this._call(this.resourceTypes.USERS, userId, this.actions.LOGIN, queryParams, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// logout: function(userId, queryParams, args) {
//     this._call(this.resourceTypes.USERS, "", this.actions.LOGOUT, queryParams, args);
// },
// /**
//  * @param queryParams required: {resource}Id, password, sid (sessionId)
//  */
// create: function(resourceType, queryParams, args) {
//     this._call(resourceType, "", this.actions.CREATE, queryParam, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// upload: function(resourceType, queryParams, args) {
//     this._call(resourceType, "", this.actions.UPLOAD, queryParams, args);
// },
// /**
//  * @param action restricted to OpencgaManager.actions.INFO, OpencgaManager.actions.FETCH
//  * @param queryParams required: sid (sessionId)
//  */
// get: function(resourceType, resourceId, action, queryParams, args) {
//     //        resourceId = "7";
//     _.extend(queryParams, {
//         sid: "RNk4P0ttFGHyqLA3YGS8",
//         view_as_pairs: 'false',
//         include_coverage: 'true',
//         process_differences: 'false'
//     });
//     this._call(resourceType, resourceId, action, queryParams, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// list: function(resourceType, queryParams, args) {
//     this._call(resourceType, "", this.actions.LIST, queryParams, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// update: function(resourceType, resourceId, queryParams, args) {
//     this._call(resourceType, resourceId, this.actions.UPDATE, queryParams, args);
// },
// /**
//  * @param queryParams required: sid (sessionId)
//  */
// delete: function(resourceType, resourceId, queryParams, args) {
//     this._call(resourceType, resourceId, this.actions.DELETE, queryParams, args);
// },
//
// _call: function(resourceType, resourceId, action, queryParams, args) {
//     var url = this._url(resourceType, resourceId, action, queryParams, args);
//
//     if (typeof url === 'undefined' || url == null) {
//         return;
//     }
//     console.log(url);
//     var async = (_.isUndefined(args.async) || _.isNull(args.async)) ? true: args.async;
//     var success = args.success;
//     var error = args.error;
//
//     var d;
//     $.ajax({
//         type: OpencgaManager.httpMethods[resourceType],
//         url: url,
//         dataType: 'json', //still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//         async: async,
//         success: function(data, textStatus, jqXHR) {
//             if ($.isPlainObject(data) || $.isArray(data)) {
//                 //                    data.params = args.params;
//                 //                    data.resource = args.resource;
//                 //                    data.category = args.category;
//                 //                    data.subCategory = args.subCategory;
//                 if (_.isFunction(success)) {
//                     success(data);
//                 }
//                 d = data;
//             } else {
//                 console.log('Cellbase returned a non json object or list, please check the url.');
//                 console.log(url);
//                 console.log(data)
//             }
//         },
//         error: function(jqXHR, textStatus, errorThrown) {
//             console.log("CellBaseManager: Ajax call returned : " + errorThrown + '\t' + textStatus + '\t' + jqXHR.statusText + " END");
//             if (_.isFunction(error)) {
//                 error(jqXHR, textStatus, errorThrown);
//             }
//         }
//     });
//     return url;
// },
//
// _url2: function(resourceType, resourceId, action, queryParams, args) {
//     if (resourceId == undefined || resourceId == null) {
//         resourceId = "";
//     } else {
//         resourceId = resourceId + "/";
//     }
//     var host = this.host;
//     if (typeof args.host !== 'undefined' && args.host != null) {
//         host = args.host;
//     }
//     var opencga = this.opencga;
//     if (typeof args.opencga !== 'undefined' && args.opencga != null) {
//         opencga = args.opencga;
//     }
//     /* still no version in the REST api
//      var version = this.version;
//      if(typeof args.version !== 'undefined' && args.version != null){
//      version = args.version
//      }
//      */
//     var url = host + opencga + resourceType + '/' + resourceId + action;
//     /*
//      _.extend(queryParams, {
//      sid: 'RNk4P0ttFGHyqLA3YGS8',
//      view_as_pairs: 'false',
//      include_coverage: 'true',
//      process_differences: 'false'
//      });*/
//
//     url = Utils.addQueryParamtersToUrl(queryParams, url);
//     return url;
// }

/*
 get: function (args) {
 var success = args.success;
 var error = args.error;
 var async = (_.isUndefined(args.async) || _.isNull(args.async) ) ? true : args.async;
 var urlConfig = _.omit(args, ['success', 'error', 'async']);

 var url = OpencgaManager.url(urlConfig);
 if(typeof url === 'undefined'){
 return;
 }
 console.log(url);

 var d;
 $.ajax({
 type: "GET",
 url: url,
 dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
 async: async,
 success: function (data, textStatus, jqXHR) {
 if($.isPlainObject(data) || $.isArray(data)){
 //                    data.params = args.params;
 //                    data.resource = args.resource;
 //                    data.category = args.category;
 //                    data.subCategory = args.subCategory;
 if (_.isFunction(success)) {
 success(data);
 }
 d = data;
 }else{
 console.log('Cellbase returned a non json object or list, please check the url.');
 console.log(url);
 console.log(data)
 }
 },
 error: function (jqXHR, textStatus, errorThrown) {
 console.log("CellBaseManager: Ajax call returned : " + errorThrown + '\t' + textStatus + '\t' + jqXHR.statusText + " END");
 if (_.isFunction(error)) error(jqXHR, textStatus, errorThrown);
 }
 });
 return d;
 },*/
//////// old version
//    host: (typeof OPENCGA_HOST === 'undefined') ? 'http://ws.bioinfo.cipf.es/opencga/rest' : OPENCGA_HOST,
//    getHost: function () {
//        return OpencgaManager.host;
//    },
//    setHost: function (hostUrl) {
//        OpencgaManager.host = hostUrl;
//    },
//    doGet: function (url, successCallback, errorCallback) {
//        $.ajax({
//            type: "GET",
//            url: url,
//            success: successCallback,
//            error: errorCallback
//        });
//    },
//    doPost: function (url, formData, successCallback, errorCallback) {
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: formData,
//            processData: false,  // tell jQuery not to process the data
//            contentType: false,  // tell jQuery not to set contentType
//            success: successCallback,
//            error: errorCallback
//        });
//    },
//    getQuery: function (paramsWS) {
//        var query = "";
//        for (var key in paramsWS) {
//            if (paramsWS[key] != null)
//                query += key + '=' + paramsWS[key] + '&';
//        }
//        if (query != '')
//            query = "?" + query.slice(0, -1);
//        return query;
//    },
//
//
//    getAccountUrl: function (accountId) {
//        return OpencgaManager.getHost() + '/account/' + accountId;
//    },
//    getStorageUrl: function (accountId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/storage';
//    },
//    getAdminProfileUrl: function (accountId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/admin/profile';
//    },
//    getAdminBucketUrl: function (accountId, bucketId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/admin/bucket/' + bucketId;
//    },
//    getAdminProjectUrl: function (accountId, projectId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/admin/project/' + projectId;
//    },
//    getBucketUrl: function (accountId, bucketId) {
//        return OpencgaManager.getStorageUrl(accountId) + '/' + bucketId;
//    },
//    getObjectUrl: function (accountId, bucketId, objectId) {
//        return OpencgaManager.getStorageUrl(accountId) + '/' + bucketId + '/' + objectId;
//    },
//    getAnalysisUrl: function (accountId, analysis) {
//        return OpencgaManager.getAccountUrl(accountId) + '/analysis/' + analysis;
//    },
//    getJobAnalysisUrl: function (accountId, jobId) {
//        return OpencgaManager.getAccountUrl(accountId) + '/analysis/job/' + jobId;
//    },
//    getUtilsUrl: function () {
//        return OpencgaManager.getHost() + '/utils';
//    },
//    /*ACCOUNT METHODS*/
//    createAccount: function (args) {
////      accountId, email, name, password, suiteId
//        var queryParams = {
//            'name': args.name,
//            'email': args.email,
//            'password': args.password,
//            'suiteid': args.suiteId
//        };
//        var url = OpencgaManager.getAccountUrl(args.accountId) + '/create' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    login: function (args) {
////        accountId, password, suiteId
//        var queryParams = {
//            'password': args.password,
//            'suiteid': args.suiteId
//        };
//        var url = OpencgaManager.getAccountUrl(args.accountId) + '/login' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    logout: function (args) {
////        accountId, sessionId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAccountUrl(args.accountId) + '/logout' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    getAccountInfo: function (args) {
////        accountId, sessionId, lastActivity
////        console.log(args.lastActivity)
//        var queryParams = {
//            'last_activity': args.lastActivity,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAccountUrl(args.accountId) + '/info' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                if (data.response.errorMsg === '') {
//                    args.success(data.response.result[0]);
//                } else {
//                    $.cookie('bioinfo_sid', null);
//                    $.cookie('bioinfo_sid', null, {path: '/'});
//                    $.cookie('bioinfo_account', null);
//                    $.cookie('bioinfo_account', null, {path: '/'});
//                    console.log(data);
//                }
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    changePassword: function (args) {
////        accountId, sessionId, old_password, new_password1, new_password2
//        var queryParams = {
//            'old_password': args.old_password,
//            'new_password1': args.new_password1,
//            'new_password2': args.new_password2,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminProfileUrl(args.accountId) + '/change_password' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    resetPassword: function (args) {
////        accountId, email
//        var queryParams = {
//            'email': args.email
//        };
//        var url = OpencgaManager.getAdminProfileUrl(args.accountId) + '/reset_password' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    changeEmail: function (args) {
////        accountId, sessionId, new_email
//        var queryParams = {
//            'new_email': args.new_email,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminProfileUrl(args.accountId) + '/change_email' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    /* BUCKET METHODS */
//    getBuckets: function () {
//        return 'TODO';
//    },
//
//    createBucket: function (args) {
////        bucketId, description, accountId, sessionId
//        var queryParams = {
//            'description': args.description,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminBucketUrl(args.accountId, args.bucketId) + '/create' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    refreshBucket: function (args) {
////        accountId, bucketId, sessionId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminBucketUrl(args.accountId, args.bucketId) + '/refresh' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    renameBucket: function (args) {
////        accountId, bucketId, newBucketId, sessionId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getAdminBucketUrl(args.accountId, args.bucketId) + '/rename/' + args.newBucketId + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    deleteBucket: 'TODO',
//    shareBucket: 'TODO',
//
//    uploadObjectToBucket: function (args) {
////        accountId, sessionId, bucketId, objectId, formData, parents
//        var queryParams = {
//            'parents': (args.parents || false),
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/upload' + OpencgaManager.getQuery(queryParams);
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: args.formData,
//            processData: false,  // tell jQuery not to process the data
//            contentType: false,  // tell jQuery not to set contentType
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    createDirectory: function (args) {
////        accountId, sessionId, bucketId, objectId, parents
//        args.objectId = args.objectId.replace(new RegExp("/", "gi"), ":");
//        var queryParams = {
//            'parents': (args.parents || false),
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/create_directory' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    deleteObjectFromBucket: function (args) {
////        accountId, sessionId, bucketId, objectId
//        args.objectId = args.objectId.replace(new RegExp("/", "gi"), ":");
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/delete' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    pollObject: function (args) {
////       accountId, sessionId, bucketId, objectId
//        var queryParams = {
//            'start': args.start,
//            'limit': args.limit,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/poll' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            async: args.async,
//            success: function (data, textStatus, jqXHR) {
//                args.success(data);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    grepObject: function (args) {
////       accountId, sessionId, bucketId, objectId
//        var queryParams = {
//            'pattern': encodeURIComponent(args.pattern),
//            'ignoreCase': args.ignoreCase,
//            'multi': args.multi,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/grep' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            async: args.async,
//            success: function (data, textStatus, jqXHR) {
//                args.success(data);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    region: function (args) {
////        accountId, sessionId, bucketId, objectId, region, queryParams
//        args.objectId = args.objectId.replace(new RegExp("/", "gi"), ":");
//        args.queryParams["sessionid"] = args.sessionId;
//        args.queryParams["region"] = args.region;
//        args.queryParams["cellbasehost"] = CELLBASE_HOST + '/' + CELLBASE_VERSION;
//
//        if (OpencgaManager.host.indexOf("localhost") != -1) {
//            args.queryParams["region"] = args.region;
//            args.queryParams["filepath"] = args.objectId;
//            var url = OpencgaManager.host + '/storage/fetch' + OpencgaManager.getQuery(args.queryParams);
//        } else {
//            var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/fetch' + OpencgaManager.getQuery(args.queryParams);
//        }
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
////                args.success(data.response);
//
////               TODO fix
//                if (!(data.substr(0, 5).indexOf('ERROR') != -1)) {
//                    var jsonData = JSON.parse(data);
//                    var r = {response: []};
//                    for (var i = 0; i < args.region.length; i++) {
//                        var result = jsonData[i];
//                        // TODO temporal fix
//                        r.response.push({
//                            id: args.region[i],
//                            result: jsonData[i]
//                        });
//                    }
//                    args.success(r);
////                args.success({resource: args.queryParams["category"], response: JSON.parse(data), filename: args.objectId, query: args.region, params: args.queryParams});
//                }
//
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//
//        function success(data) {
//
//        }
//    },
//
//    /* JOB METHODS */
//    jobResult: function (args) {
////        accountId, sessionId, jobId, format
//        //@Path("/{accountid}/{bucketname}/job/{jobid}/result.{format}")
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/result.js' + OpencgaManager.getQuery(queryParams);
//        //var url = OpencgaManager.getHost() + '/job/'+jobId+'/result.'+format+'?incvisites=true&sessionid='+sessionId;
//
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//
////        function success(data) {
////            args.success(data);
////        }
////
////        function error(data) {
////            if (_.isFunction(args.error)) args.error(data);
////        }
////
////        OpencgaManager.doGet(url, success, error);
////        console.log(url);
//    },
//    jobResultUrl: function (args) {
////        accountId, sessionId, jobId, format
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        return OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/result.js' + OpencgaManager.getQuery(queryParams);
//    },
//    jobStatus: function (args) {
////        accountId, sessionId, jobId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/status' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    table: function (args) {
////        accountId, sessionId, jobId, filename, colNames, colVisibility
//        var queryParams = {
//            'filename': args.filename,
//            'colNames': args.colNames,
//            'colVisibility': args.colVisibility,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/table' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    tableurl: function (args) {
////        accountId, sessionId, jobId, filename, colNames, colVisibility
//        var queryParams = {
//            'filename': args.filename,
//            'colNames': args.colNames,
//            'colVisibility': args.colVisibility,
//            'sessionid': args.sessionId
//        };
//        return OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/table' + OpencgaManager.getQuery(queryParams);
//    },
//
//    poll: function (args) {
////        accountId, sessionId, jobId, filename, zip
//        var queryParams = {
//            'filename': args.filename,
//            'sessionid': args.sessionId
//        };
//        var url;
//        if (args.zip == true) {
//            url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/poll' + OpencgaManager.getQuery(queryParams);
//            open(url);
//        } else {
//            queryParams['zip'] = false;
//            url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/poll' + OpencgaManager.getQuery(queryParams);
//
//            $.ajax({
//                type: "GET",
//                url: url,
//                async: args.async,
//                success: function (data, textStatus, jqXHR) {
//                    args.success(data);
//                },
//                error: function (jqXHR, textStatus, errorThrown) {
//                    if (_.isFunction(args.error)) args.error(jqXHR);
//                }
//            });
//        }
//    },
//
//    jobFileGrep: function (args) {
////        accountId, sessionId, jobId, filename, zip
//        var queryParams = {
//            'pattern': encodeURIComponent(args.pattern),
//            'ignoreCase': args.ignoreCase,
//            'multi': args.multi,
//            'filename': args.filename,
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/grep' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            async: args.async,
//            success: function (data, textStatus, jqXHR) {
//                args.success(data);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//
//    pollurl: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'filename': args.filename,
//            'sessionid': args.sessionId,
//            'zip': false
//        };
//        return OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/poll' + OpencgaManager.getQuery(queryParams);
//        //debugger
//    },
//
//    deleteJob: function (args) {
////        accountId, sessionId, jobId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/delete' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    downloadJob: function (args) {
////        accountId, sessionId, jobId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        open(OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/download' + OpencgaManager.getQuery(queryParams));
//    },
//
//    jobInfo: function (args) {
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/info' + OpencgaManager.getQuery(queryParams);
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//
//    /* ANALYSIS */
//    runAnalysis: function (args) {
////        analysis, paramsWS
//        var accountId = args.paramsWS.accountid;
//        var queryParams = {
////            'projectId':'default'
//        };
//        var url = OpencgaManager.getAnalysisUrl(accountId, args.analysis) + '/run' + OpencgaManager.getQuery(queryParams);
//        console.log(url);
//
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: args.paramsWS,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    indexer: function (args) {
////        accountId, sessionId, bucketId, objectId
//        var queryParams = {
//            'sessionid': args.sessionId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/index' + OpencgaManager.getQuery(queryParams);
//        $.ajax({
//            type: "GET",
//            url: url,
//            dataType: 'json',//still firefox 20 does not auto serialize JSON, You can force it to always do the parsing by adding dataType: 'json' to your call.
//            success: function (data, textStatus, jqXHR) {
//                args.success(data.response);
//            },
//            error: function (jqXHR, textStatus, errorThrown) {
//                if (_.isFunction(args.error)) args.error(jqXHR);
//            }
//        });
//    },
//    indexerStatus: function (args) {
////        accountId, sessionId, bucketId, objectId, indexerId
//        var queryParams = {
//            'sessionid': args.sessionId,
//            'indexerid': args.indexerId
//        };
//        var url = OpencgaManager.getObjectUrl(args.accountId, args.bucketId, args.objectId) + '/index_status' + OpencgaManager.getQuery(queryParams);
//        console.log(url);
//
//        function success(data) {
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        OpencgaManager.doGet(url, success, error);
//    },
//
//    localFileList: function (args) {
//
//        var url = OpencgaManager.host + '/getdirs';
//        console.log(url);
//
//        function success(data) {
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        OpencgaManager.doGet(url, success, error);
//    },
//
//
//    /********/
//    /********/
//    /********/
//    /********/
//    /********/
//    // variation
//    variantsUrl: function (args) {
////        accountId, jobId
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variantsMongo'
//        return url
//    },
//    variantInfoMongo: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'sessionid': args.sessionId
////            'filename': args.filename
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variantInfoMongo' + OpencgaManager.getQuery(queryParams);
//
//        function success(data) {
//            console.log(data);
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        $.ajax({
//            type: "GET",
//            url: url,
//            async: args.async,
//            success: success,
//            error: error
//        });
//        //	console.log(url);
//    },
//
//
//    variant_effects: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'sessionid': args.sessionId,
//            'filename': args.filename
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variant_effects' + OpencgaManager.getQuery(queryParams);
//
//        function success(data) {
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: args.formData,
//            dataType: 'json',
//            success: success,
//            error: error
//        });
//
////        OpencgaManager.doPost(url, args.formData ,success, error);
//        //	console.log(url);
//    },
//    variantInfo: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'sessionid': args.sessionId,
//            'filename': args.filename
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variant_info' + OpencgaManager.getQuery(queryParams);
//
//        function success(data) {
//            console.log(data);
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        OpencgaManager.doGet(url, success, error);
//        //	console.log(url);
//    },
//    variantStats: function (args) {
////        accountId, sessionId, jobId, filename
//        var queryParams = {
//            'sessionid': args.sessionId,
//            'filename': args.fileName
//        };
//        var url = OpencgaManager.getJobAnalysisUrl(args.accountId, args.jobId) + '/variant_stats' + OpencgaManager.getQuery(queryParams);
//
//        function success(data) {
//            args.success(data);
//        }
//
//        function error(data) {
//            if (_.isFunction(args.error)) args.error(data);
//        }
//
//        $.ajax({
//            type: "POST",
//            url: url,
//            data: args.formData,
//            dataType: 'json',
//            success: success,
//            error: error
//        });
//
////        OpencgaManager.doPost(url, args.formData ,success, error);
//        //	console.log(url);
//    }
// };

// OpencgaManager.httpMethods[OpencgaManager.actions.LOGIN] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.LOGOUT] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.CREATE] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.UPLOAD] = "POST";
// OpencgaManager.httpMethods[OpencgaManager.actions.INFO] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.LIST] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.FETCH] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.UPDATE] = "GET";
// OpencgaManager.httpMethods[OpencgaManager.actions.DELETE] = "GET";
</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function FileFeatureCache(args) {
	this.args = args;
	this.id = Math.round(Math.random() * 10000000); // internal id for this class

	this.chunkSize = 50000;
	this.gzip = true;
	this.maxSize = 10*1024*1024;
	this.size = 0;
	
	if (args != null){
		if(args.chunkSize != null){
			this.chunkSize = args.chunkSize;
		}
		if(args.gzip != null){
			this.gzip = args.gzip;
		}
	}
	
	this.cache = {};
	this.chunksDisplayed = {};
	
	this.maxFeaturesInterval = 0;
	
	//XXX
	this.gzip = false;

};

FileFeatureCache.prototype._getChunk = function(position){
	return Math.floor(position/this.chunkSize);
};

FileFeatureCache.prototype.getChunkRegion = function(region){
	start = this._getChunk(region.start) * this.chunkSize;
	end = (this._getChunk(region.end) * this.chunkSize) + this.chunkSize-1;
	return {start:start,end:end};
};

FileFeatureCache.prototype.getFirstFeature = function(){
	var feature;
	if(this.gzip) {
		feature = JSON.parse(RawDeflate.inflate(this.cache[Object.keys(this.cache)[0]].data[0]));
	}else{
		feature = this.cache[Object.keys(this.cache)[0]].data[0];
	}
	return feature;
};


//new 
FileFeatureCache.prototype.getFeatureChunk = function(key){
	if(this.cache[key] != null) {
		return this.cache[key];
	}
	return null;
};
FileFeatureCache.prototype.getFeatureChunkByDataType = function(key,dataType){
	if(this.cache[key] != null) {
        if(this.cache[key][dataType] != null){
		    return this.cache[key][dataType];
        }
	}
	return null;
};
//new
FileFeatureCache.prototype.getFeatureChunksByRegion = function(region){
	var firstRegionChunk, lastRegionChunk,  chunks = [], key;
	firstRegionChunk = this._getChunk(region.start);
	lastRegionChunk = this._getChunk(region.end);
	for(var i=firstRegionChunk; i<=lastRegionChunk; i++){
		key = region.chromosome+":"+i;
		// check if this key exists in cache (features from files)
		if(this.cache[key] != null ){
			chunks.push(this.cache[key]);
		}
		
	}
	//if(chunks.length == 0){
		//return null;
	//}
	return chunks;
};


FileFeatureCache.prototype.putFeaturesByRegion = function(featureDataList, region, featureType, dataType){
	var key, firstRegionChunk, lastRegionChunk, firstChunk, lastChunk, feature, gzipFeature;


	//initialize region
	firstRegionChunk = this._getChunk(region.start);
	lastRegionChunk = this._getChunk(region.end);

	for(var i=firstRegionChunk; i<=lastRegionChunk; i++){
		key = region.chromosome+":"+i;
		if(this.cache[key]==null){
			this.cache[key] = {};
			this.cache[key].key = key;
		}
//        else{
//            // TODO
//            console.log(region.chromosome+region.start+region.end+'-'+featureType+'-'+dataType);
////            return;
//        }
		if(this.cache[key][dataType]==null){
			this.cache[key][dataType] = [];
		}
	}

    //Check if is a single object
    if(featureDataList.constructor != Array){
        featureDataList = [featureDataList];
    }

    //loop over features and set on corresponding chunks
	for(var index = 0, len = featureDataList.length; index<len; index++) {
		feature = featureDataList[index];
		feature.featureType = featureType;
		firstChunk = this._getChunk(feature.start);
		lastChunk = this._getChunk(feature.end);
		
		if(this.gzip) {
			gzipFeature = RawDeflate.deflate(JSON.stringify(feature));
		}else{
			gzipFeature = feature;
		}
		
		for(var i=firstChunk; i<=lastChunk; i++) {
			if(i >= firstRegionChunk && i<= lastRegionChunk){//only if is inside the called region
				key = region.chromosome+":"+i;
				this.cache[key][dataType].push(gzipFeature);
			}
		}
	}
//        console.log(this.cache[region.chromosome+":"+firstRegionChunk][dataType].length)
};


//used by BED, GFF, VCF
FileFeatureCache.prototype.putFeatures = function(featureDataList, dataType){
	var feature, key, firstChunk, lastChunk;

	//Check if is a single object
	if(featureDataList.constructor != Array){
		featureDataList = [featureDataList];
	}

	for(var index = 0, len = featureDataList.length; index<len; index++) {
		feature = featureDataList[index];
		firstChunk = this._getChunk(feature.start);
		lastChunk = this._getChunk(feature.end);
		for(var i=firstChunk; i<=lastChunk; i++) {
			key = feature.chromosome+":"+i;
			if(this.cache[key]==null){
				this.cache[key] = [];
				this.cache[key].key = key;
			}
			if(this.cache[key][dataType]==null){
				this.cache[key][dataType] = [];
			}
			if(this.gzip) {
				this.cache[key][dataType].push(RawDeflate.deflate(JSON.stringify(feature)));
			}else{
				this.cache[key][dataType].push(feature);
			}

		}
	}
};



FileFeatureCache.prototype.putChunk = function(key, item){
	this.cache[key] = item;
};

FileFeatureCache.prototype.getChunk = function(key){
	return this.cache[key];
};

FileFeatureCache.prototype.putCustom = function(f){
	f(this);
};

FileFeatureCache.prototype.getCustom = function(f){
	f(this);
};



FileFeatureCache.prototype.remove = function(region){
	var firstChunk = this._getChunk(region.start);
	var lastChunk = this._getChunk(region.end);
	for(var i=firstChunk; i<=lastChunk; i++){
		var key = region.chromosome+":"+i;
		this.cache[key] = null;
	}
};

FileFeatureCache.prototype.clear = function(){
		this.size = 0;		
		this.cache = {};
};


//END



//THOSE METHODS ARE NOT USED



/*
FileFeatureCache.prototype.getFeaturesByChunk = function(key, dataType){
	var features =  [];
	var feature, firstChunk, lastChunk;
	
	if(this.cache[key] != null && this.cache[key][dataType] != null) {
		for ( var i = 0, len = this.cache[key][dataType].length; i < len; i++) {
			if(this.gzip) {
				feature = JSON.parse(RawDeflate.inflate(this.cache[key][dataType][i]));
			}else{
				feature = this.cache[key][dataType][i];
			}
			
			//check if any feature chunk has been already displayed 
			var displayed = false;
			firstChunk = this._getChunk(feature.start);
			lastChunk = this._getChunk(feature.end);
			for(var f=firstChunk; f<=lastChunk; f++){
				var fkey = feature.chromosome+":"+f;
				if(this.chunksDisplayed[fkey+dataType]==true){
					displayed = true;
					break;
				}
			}
			
			if(!displayed){
				features.push(feature);
				returnNull = false;
			}
		}
		this.chunksDisplayed[key+dataType]=true;
		return features;
	}
	
	return null;
};


FileFeatureCache.prototype.getFeaturesByRegion = function(region, dataType){
	var firstRegionChunk, lastRegionChunk, firstChunk, lastChunk, features = [], feature, key, returnNull = true, displayed;
	firstRegionChunk = this._getChunk(region.start);
	lastRegionChunk = this._getChunk(region.end);
	for(var i=firstRegionChunk; i<=lastRegionChunk; i++){
		key = region.chromosome+":"+i;
		 //check if this key exists in cache (features from files)
		if(this.cache[key] != null && this.cache[key][dataType] != null){
			for ( var j = 0, len = this.cache[key][dataType].length; j < len; j++) {
				if(this.gzip) {
					try {
						feature = JSON.parse(RawDeflate.inflate(this.cache[key][dataType][j]));
					} catch (e) {
						//feature es "" 
						console.log(e)
						debugger
						
					}
					
				}else{
					feature = this.cache[key][dataType][j];
				}
				// we only get those features in the region AND check if chunk has been already displayed
				if(feature.end > region.start && feature.start < region.end){

			//		 check displayCheck argument 
					if(region.displayedCheck != false){
				//		check if any feature chunk has been already displayed 
						displayed = false;
						firstChunk = this._getChunk(feature.start);
						lastChunk = this._getChunk(feature.end);
						for(var f=firstChunk; f<=lastChunk; f++){
							var fkey = region.chromosome+":"+f;
							if(this.chunksDisplayed[fkey+dataType]==true){
								displayed = true;
								break;
							}
						}
						
						if(!displayed){
							features.push(feature);
							returnNull = false;
						}
					}else{
						features.push(feature);
						returnNull = false;
					}

					
				}
			}
		}
		 //check displayCheck argument 
		if(region.displayedCheck != false){
			this.chunksDisplayed[key+dataType]=true;//mark chunk as displayed
		}
	}
	if(returnNull){
		return null;
	}else{
		return features;
	}
};
*/




/*

FileFeatureCache.prototype.putChunk = function(featureDataList, chunkRegion, dataType){
	var feature, key, chunk;
	chunk = this._getChunk(chunkRegion.start);
	key = chunkRegion.chromosome+":"+chunk;

	if(this.cache[key]==null){
		this.cache[key] = [];
	}
	if(this.cache[key][dataType]==null){
		this.cache[key][dataType] = [];
	}

	if(featureDataList.constructor == Object){
		if(this.gzip) {
			this.cache[key][dataType].push(RawDeflate.deflate(JSON.stringify(featureDataList)));
		}else{
			this.cache[key][dataType].push(featureDataList);
		}
	}else{
		for(var index = 0, len = featureDataList.length; index<len; index++) {
			feature = featureDataList[index];
			if(this.gzip) {
				this.cache[key][dataType].push(RawDeflate.deflate(JSON.stringify(feature)));
			}else{
				this.cache[key][dataType].push(feature);
			}
		}
	}
	
};

*/


//NOT USED dev not tested
//FileFeatureCache.prototype.histogram = function(region, interval){
//
	//var intervals = (region.end-region.start+1)/interval;
	//var intervalList = [];
	//
	//for ( var i = 0; i < intervals; i++) {
		//var featuresInterval = 0;
		//
		//var intervalStart = i*interval;//deberia empezar en 1...
		//var intervalEnd = ((i+1)*interval)-1;
		//
		//var firstChunk = this._getChunk(intervalStart+region.start);
		//var lastChunk = this._getChunk(intervalEnd+region.start);
		//
		//console.log(this.cache);
		//for(var j=firstChunk; j<=lastChunk; j++){
			//var key = region.chromosome+":"+j;
			//console.log(key);
			//console.log(this.cache[key]);
			//for ( var k = 0, len = this.cache[key].length; k < len; k++) {
				//if(this.gzip) {
					//feature = JSON.parse(RawDeflate.inflate(this.cache[key][k]));
				//}else{
					//feature = this.cache[key][k];
				//}
				//if(feature.start > intervalStart && feature.start < intervalEnd);
				//featuresInterval++;
			//}
			//
		//}
		//intervalList[i]=featuresInterval;
		//
		//if(this.maxFeaturesInterval<featuresInterval){
			//this.maxFeaturesInterval = featuresInterval;
		//}
	//}
	//
	//for ( var inter in  intervalList) {
		//intervalList[inter]=intervalList[inter]/this.maxFeaturesInterval;
	//}
//};
</script>
<script>/**
 * Created with IntelliJ IDEA.
 * User: fsalavert
 * Date: 10/18/13
 * Time: 12:06 PM
 * To change this template use File | Settings | File Templates.
 */

function FeatureChunkCache(args) {
    _.extend(this, Backbone.Events);

    // Default values
    this.id = Utils.genId("FeatureChunkCache");

    this.defaultChunkSize = 50000;
    this.defaultCategory = "defaultCategory";
    this.limit;

    _.extend(this, args);

    if (this.storeType == "MemoryStore") {
        this.store = new MemoryStore({});
    } else {
        this.store = new IndexedDBStore({cacheId: this.cacheId});
    }

    this.verbose = false;
}


FeatureChunkCache.prototype = {
    /**
     *
     * @param region an object Region
     * @param categories approximately the table in the DB. May be an array
     * @param dataType another level of classification
     * @param chunkSize
     * @param callback receives two arguments: (cachedChunks, uncachedRegions) with this structure:
     * cachedChunks: {
     *     categories[0]: [chunk, chunk, chunk],
     *     categories[1]: [chunk, chunk, chunk],
     *     ...
     * }
     * uncachedRegions: {
     *     categories[0]: [region, region],
     *     categories[1]: [region, region],
     *     ...
     * }
     */
    get: function (region, categories, dataType, chunkSize, callback) {
        var _this = this;
        var temporalChunkSize = chunkSize ? chunkSize : this.defaultChunkSize;

        var firstChunkId = this.getChunkId(region.start, temporalChunkSize);
        var lastChunkId = this.getChunkId(region.end, temporalChunkSize);
        var keys = [];
        var chunksAndRegions = {cachedChunks: {}, uncachedRegions: {}};

        for (var chunkId = firstChunkId; chunkId <= lastChunkId; chunkId++) {
            keys.push(this.getChunkKey(region.chromosome, chunkId, dataType, temporalChunkSize));
        }

        if (!_.isArray(categories)) {
            categories = [categories];
        }
        var callbackCount = 0;
        for (var cat = 0; cat < categories.length; cat++) {
            callbackCount++;
            chunksAndRegions.cachedChunks[categories[cat]] = [];
            chunksAndRegions.uncachedRegions[categories[cat]] = [];
            this.getChunks(categories[cat], keys, function (iterCat) {
                return function (chunks) {
                    for (var i = 0; i < chunks.length; i++) {
                        var chunkRegionEnd = parseInt(((firstChunkId + i) * temporalChunkSize) + temporalChunkSize - 1);
                        var chunkRegionStart = parseInt((firstChunkId + i) * temporalChunkSize);
                        var chunkRegion = new Region({
                            chromosome: region.chromosome,
                            start: chunkRegionStart,
                            end: chunkRegionEnd
                        });

                        if (_.isUndefined(chunks[i])) {
                            chunksAndRegions.uncachedRegions[categories[iterCat]].push(chunkRegion);
                        } else {
                            chunksAndRegions.cachedChunks[categories[iterCat]].push(chunks[i]);
                        }
                    }
                    if (this.verbose) {
                        console.log(chunksAndRegions);
                    }
                    callbackCount--;
                    if (callbackCount == 0 && callback) {
                        callback(chunksAndRegions.cachedChunks, chunksAndRegions.uncachedRegions);
                    }
                }
            }(cat));     // to force the closure to have each value of cat, and not just the last one
        }
    },

    /*
     getChunk: function (chunkId) {
     return this.store.get(chunkId);
     },*/

    getChunk: function (category, chunkKey, callback) {
        if (!callback) {
            console.log("bad FeatureChunkCache usage: undefined callback");
        }
        if (!category) {
            category = this.defaultCategory;
        }
        this.store.get(category, chunkKey, callback);
    },

    getChunks: function (category, chunkKeysArray, callback) {
        if (!callback) {
            console.log("bad FeatureChunkCache usage: undefined callback");
        }
        if (!category) {
            category = this.defaultCategory;
        }
        this.store.getAll(category, chunkKeysArray, callback);
    },

    joinRegions: function (regions) {
        if (regions.length <= 1) {
            return regions;
        }
        // assert(regions.length >= 2)

        var joinedRegions = [];
        var regionStart = regions[0].start;
        var regionEnd = region[0].end;
        var regionChromosome = regions[0].chromosome;

        for (var i = 1; i < regions.length; i++) {
            if (regions[i].chromosome == regionChromosome && regions[i].start - 1 <= regionEnd) { // CAUTION: assuming inclusive intervals
                if (regions[i].end > regionEnd) {
                    regionEnd = regions[i].end;
                }
            } else {
                joinedRegions.push(new Region({chromosome: regionChromosome, start: regionStart, end: regionEnd}));
                regionChromosome = regions[i].chromosome;
                regionStart = regions[i].start;
                regionEnd = regions[i].end;
            }
        }

        joinedRegions.push(new Region({chromosome: regionChromosome, start: regionStart, end: regionEnd}));

        return joinedRegions;
    },

    /**
     * TODO: the regions must be equally long to the chunksize
     */
    putByRegions: function (regionArray, valueArray, category, dataType, chunkSize) { // encoded
        var temporalChunkSize = chunkSize ? chunkSize : this.defaultChunkSize;
        var chunkKeyArray = [];
        for (var i = 0; i < regionArray.length; i++) {
            var chunkId = this.getChunkId(regionArray[i].start, temporalChunkSize);
            var chunkKey = this.getChunkKey(regionArray[i].chromosome, chunkId, dataType, chunkSize);
            chunkKeyArray.push(chunkKey);
        }
        return this.putChunks(chunkKeyArray, regionArray, valueArray, category, false);
    },

    /** several chunks in one transaction. this is a fast put */
    putChunks: function (chunkKeyArray, regionArray, valueArray, category, encoded) {
        var valueStoredArray = [];
        for (var i = 0; i < valueArray.length; i++) {
            valueStoredArray.push(this.createEntryValue(chunkKeyArray[i], regionArray[i], valueArray[i], encoded));   // TODO add timestamp, last usage time, size, etc.
        }
        if (!category) {
            category = this.defaultCategory;
        }
        this.store.putAll(category, chunkKeyArray, valueStoredArray);
        return valueStoredArray;
    },

    createEntryValue: function (chunkKey, region, value, encoded) {
        var valueStored;
        if (encoded) {
            valueStored = {value: value, chunkKey: chunkKey, region: region, enc: encoded}; // TODO add timestamp, last usage time, size, etc.
        } else {
            valueStored = {value: value, chunkKey: chunkKey, region: region}; // TODO add timestamp, last usage time, size, etc.
        }
        return valueStored;
    },

    getChunkKey: function (chromosome, chunkId, dataType, chunkSize) {
        var keySuffix = dataType ? "_" + dataType : "";
        keySuffix += "_" + chunkSize;       // e.g. "_hist_1000"
        return chromosome + ":" + chunkId + keySuffix;
    },

    getChunkId: function (position, chunkSize) {
        return Math.floor(position / chunkSize);
    },


    getDefaultChunkSize: function () {
        return this.defaultChunkSize;
    },

    delete:function(){
        this.store.destroyDB();
    }

    /* TODO:
     visit: function (chunkKey) {
     var _this = this;
     this.getChunk(chunkKey, function(value){
     //            value.lastUsed = ...
     _this.putChunk(chunkKey, value);
     });
     },*/
};
</script>
<script>/**
 * Created with IntelliJ IDEA.
 * User: imedina
 * Date: 10/8/13
 * Time: 12:40 AM
 * To change this template use File | Settings | File Templates.
 */

/**
 * MemoryStore is a cache with items ordered with "least recently used" criterion (LRU). This allows to remove old data with the "shift" method.
 * The parameter "category" should be a string, and it is used as another level of classification.
 * "get", "getAll" and "foreach" methods can be used with callbacks or with return values.
 */
function MemoryStore(args) {

    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    // configurable parameters
    //    this.limit = 500;

    // Now we set the args parameters
    _.extend(this, args);

    this.init();
};

MemoryStore.prototype = {
    put: function (category, key, value) {
        if (typeof this.stores[category] === 'undefined') {
            this.init(category);
        }
        var item = {
            key: key,
            value: value
        };

        // a item can be overwritten
        this.stores[category][key] = item;

        if (this.tails[category]) {
            this.tails[category].newer = item;
            item.older = this.tails[category];
        } else {
            // the item is the first one
            this.heads[category] = item;
        }

        // add new item to the end of the linked list, it's now the freshest item.
        this.tails[category] = item;

        //        if (this.size === this.limit) {
        //            // we hit the limit, remove the head
        //            this.shift();
        //        } else {
        //            // increase the size counter
        //            this.size++;
        //        }
        this.sizes[category]++;

    },
    putAll: function (category, keyArray, valueArray) {
        for (var i = 0; i < keyArray.length; i++) {
            this.put(category, keyArray[i], valueArray[i]);
        }
    },

    shift: function (category) {
        if (typeof this.stores[category] === 'undefined') {
            this.init(category);
        }
        // todo: handle special case when limit == 1
        var item = this.heads[category];
        if (item) {
            if (this.heads[category].newer) {
                this.heads[category] = this.heads[category].newer;
                this.heads[category].older = undefined;
            } else {
                this.heads[category] = undefined;
            }
            // Remove last strong reference to <item> and remove links from the purged
            // item being returned:
            item.newer = item.older = undefined;
            // delete is slow, but we need to do this to avoid uncontrollable growth:
            delete this.stores[category][item.key];
        }
    },
    get: function (category, key, callback) {
        if (typeof this.stores[category] === 'undefined') {
            this.init(category);
        }
        // First, find our cache item
        var item = this.stores[category][key];
        if (item === undefined) {
            if (callback) {
                callback();
            }
            return; // Not cached. Sorry.
        }
        // As <key> was found in the cache, register it as being requested recently
        if (item === this.tails[category]) {
            // Already the most recenlty used item, so no need to update the list
            if (callback) {
                callback(item.value);
            }
            return item.value;
        }
        // HEAD--------------TAIL
        //   <.older   .newer>
        //  <--- add direction --
        //   A  B  C  <D>  E
        if (item.newer) {
            if (item === this.heads[category]) {
                this.heads[category] = item.newer;
            }
            item.newer.older = item.older; // C <-- E.
        }
        if (item.older) {
            item.older.newer = item.newer; // C. --\x3e E
        }
        item.newer = undefined; // D --x
        item.older = this.tails[category]; // D. --\x3e E
        if (this.tails[category])
            this.tails[category].newer = item; // E. <-- D
        this.tails[category] = item;
        if (callback) {
            callback(item.value);
        }
        return item.value;
    },

    getAll: function (category, keyArray, callback) {
        var valueArray = [];
        for (var i = 0; i < keyArray.length; i++) {
            valueArray[i] = this.get(category, keyArray[i]);
        }
        callback(valueArray);
    },

    foreach: function (category, keyArray, callback) {
        for (var i = 0; i < keyArray.length; i++) {
            callback(this.get(category, keyArray[i]), keyArray[i]);
        }
    },

    init: function (category) {
        if (category != undefined) {
            this.sizes[category] = 0;
            this.stores[category] = {};
            this.heads[category] = undefined;
            this.tails[category] = undefined;
        } else {
            this.sizes = {};
            this.stores = {};
            this.heads = {};
            this.tails = {};
        }
    },
    clear: function () {
        this.stores = null; // TODO delete?
        this.init();
    },
    
    delete: function () {
        this.clear();
    }

    //    get: function (key) {
    //        if (typeof this.dataStore === 'undefined') {
    //            return undefined;
    //        } else {
    //            var ms = this.counter++;
    //            this.dataStore[key].ms = ms;
    //            return this.dataStore[key].data;
    //        }
    //    },

    //    addCollection: function (key, featureArray) {
    //        // If 'featureArray' is an Array then we add all elements,
    //        // otherwise we call to add()
    //        if ($.isArray(featureArray)) {
    //            if (typeof this.dataStore === 'undefined') {
    //                this.dataStore = {};
    //            }
    //            for (var feature in featureArray) {
    //                this.dataStore[key] = feature;
    //                this.lru.push({key: key, ms: this.counter});
    //            }
    //        } else {
    //            this.add(key, featureArray);
    //        }
    //    },

    //    delete: function (key) {
    //        if (typeof this.dataStore !== 'undefined') {
    //            var aux = this.dataStore[key];
    //            delete this.dataStore[key];
    //            return aux;
    //        }
    //    },

    //    free: function () {
    //        this.lru = [];
    //        for (var i in this.dataStore) {
    //            this.lru.push({key: i, ms: this.dataStore[i].ms});
    //        }
    //        this.lru.sort(function (a, b) {
    //            return a.ms - b.ms;
    //        });
    //        this.delete(this.lru[0].key);
    //        this.lru.splice(0, 1);
    //    },
    //
    //    close: function () {
    //        this.dataStore = null;
    //    }
};
</script>
<script>/**
 * Created with IntelliJ IDEA.
 * User: imedina
 * Date: 10/8/13
 * Time: 12:42 AM
 *
 * This API is asynchronous. When a return value is expected, you must provide a callback function.
 *
 * This class works this way:
 *
 * before executing any request ( get, put, ...),
 * make sure the DataBase connection is alive (this.db) // TODO not yet
 * if the connection is dead: reconnect.
 * make the request to indexedDB.
 */


var iDBInstances = [];
var iDBVersion = 1;
function IndexedDBStore(args) {
    var _this = this;
    this.debug = false;
    this.profile = false;
//debugger
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    this.lru = [];

    this.cacheId = "DataBase";
//    this.objectStore = "ObjectStore";
    this.opening = false;
    this.timeout = 30;  // time to wait if the DB connection is being already opened
    // Now we set the args parameters
    // must be the last instruction in order to overwrite default attributes
    _.extend(this, args);

    window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
//    this.db = null;
    this.version = iDBVersion;

    if (!this.cacheId) {
        console.log("IndexedDBStore: not supplied cacheId to constructor. Using default DataBase...");
    }

    iDBInstances.push(this);
//        if (!window.indexedDB) {
//            window.alert("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
//        }
    /*
     this._getConnection(function (db) {
     console.log("obtained initial IndexedDB connection for " + _this.cacheId);
     console.log(db);
     });
     */
}

IndexedDBStore.prototype = {
    _getConnection: function (objectStoreName, callback, version) {
        var _this = this;
        if (_this.debug) {
            console.log(_this.cacheId + " opening? " + _this.opening);
            if (objectStoreName == undefined) {
                console.log("WARNING: requested to create objectStore 'undefined'");
                debugger
            }
//        debugger
        }
        if (_this.opening == true) {
            if (_this.debug) {
                console.log("Database " + _this.cacheId + " is already opening. To avoid block: waiting...");
            }
            setTimeout(_this._getConnection.bind(_this), _this.timeout * (1 + Math.random()*0.25), objectStoreName, callback, version);
            /*} else if (dbConnection && !dbConnection.closed && dbConnection.objectStoreNames.contains(objectStoreName)) { // recycle connections
             if (_this.debug) {
             console.log("Database already opened:", dbConnection);
             }
             callback(dbConnection);*/
        } else {
            try {
                if (_this.debug) {
                    console.log("trying opening Database:" + _this.cacheId);
                }
                var dbOpenRequest;
                _this.opening = true;
                if (_this.debug) {
                    console.log("lock:"+_this.cacheId + ", " + objectStoreName + " opening = "+ _this.opening + " version: " + version);
                }
                if (!_.isUndefined(version)) {
                    dbOpenRequest = window.indexedDB.open(_this.cacheId, version); // second parameter is the version. increase to modify tables.
                } else {
                    dbOpenRequest = window.indexedDB.open(_this.cacheId);
                }
                dbOpenRequest.onsuccess = function (event) {
                    _this.opening = false;
                    if (_this.debug) {
                        console.log("unlock:" + _this.cacheId + ", " + objectStoreName + " opening = " + _this.opening);
                    }
//                    if (dbConnection) {
//                        console.log("overwriting DB", dbConnection, " with", event.target.result);
//                        debugger;
//                        dbConnection.close();
//                        dbConnection.closed = true;
//                        dbConnection = undefined;
//                    }
                    var dbConnection = event.target.result;

                    dbConnection.onversionchange = function (e) {
                        if (_this.debug) {
                            console.log("Version change triggered, so closing database connection " + _this.cacheId + ", " + objectStoreName + " (old version, new version, db, event)", e.oldVersion, e.newVersion, dbConnection, e);
                        }
                        if (dbConnection) {
                            dbConnection.close();
                            dbConnection.closed = true;
                            dbConnection = undefined;
                        }
                    };

                    if (objectStoreName != "" && !dbConnection.objectStoreNames.contains(objectStoreName)) {
                        iDBVersion = Math.max(iDBVersion, dbConnection.version) + 1;
                        dbConnection.close();
                        dbConnection.closed = true;
                        dbConnection = undefined;
                        _this.version = iDBVersion;
                        if (_this.debug) {
                            console.log("needed ObjectStore " + objectStoreName + " in " + _this.cacheId + " creating version " + iDBVersion);
                        }
                        _this._getConnection(objectStoreName, callback, _this.version);
                    } else {
                        if (_this.debug) {
                            console.log("connection obtained for " + _this.cacheId + " and " + objectStoreName, dbConnection);
                        }
                        callback(dbConnection);
                    }
                };
                dbOpenRequest.onupgradeneeded = function (e) {
                    if (_this.debug) {
                        console.log("Database upgrade needed in " + _this.cacheId + ", " + objectStoreName);
                    }
                    dbConnection = e.target.result;

                    if (!dbConnection.objectStoreNames.contains(objectStoreName)) {
                        if (_this.debug) {
                            console.log("creating " + objectStoreName + " in Database " + _this.cacheId );
                        }
                        var objectStore = dbConnection.createObjectStore(objectStoreName);
                    }
                };
                dbOpenRequest.onerror = function (e) {
                    console.log("DB Open Request Error in " + _this.cacheId + ", " + objectStoreName);
                    console.log(e);
                };
                dbOpenRequest.onblocked = function (e) {
                    console.log("DB Open Request Blocked in " + _this.cacheId + ", " + objectStoreName, e);
//                    if (dbConnection) {
//                        dbConnection.close();
//                    }
                    _this._getConnection(objectStoreName, callback)
                };
            } catch (e) {
                console.log("catch error:");
                console.error(e);
            }
        }
    },

    clear: function (objectStoreName) {
//        this.db.deleteObjectStore(this.cacheId);

        var _this = this;
        _this._getConnection(objectStoreName, function(dbConnection){
            var transaction = dbConnection.transaction([objectStoreName], "readwrite");
            transaction.oncomplete = function(event) {
                console.log("IndexedDB " + _this.cacheId + ", " + objectStoreName + " clear success!");
            };
            var objectStore = transaction.objectStore(objectStoreName);
            var req = objectStore.clear();
            req.onerror = function (evt) {
                console.log("IndexedDB Error trying to clear the object store " + objectStoreName + " in " + _this.cacheId);
            }
        });
    },

    count: function (objectStoreName, callback) {
        var _this = this;
        _this._getConnection(objectStoreName, function(dbConnection){
            var transaction = dbConnection.transaction([objectStoreName], "readwrite");
            var objectStore = transaction.objectStore(objectStoreName);
            var req = objectStore.count();
            req.onerror = function (evt) {
                console.log("IndexedDB Error trying to count the object store " + objectStoreName + " in " + _this.cacheId);
            };
            req.onsuccess = function (event) {
                callback(event.target.result);
            }
        });
    },

    getObjectStoreNames: function (callback) {
        var _this = this;
        _this._getConnection("", function(dbConnection){
            callback(dbConnection.objectStoreNames);
        });
    },

    close: function () {
        var _this = this;
        _this._getConnection(objectStoreName, function(dbConnection){
            dbConnection.close();
            console.log("Database " + _this.cacheId + " closed");
            dbConnection.closed=true;
            dbConnection = undefined;
        });
    },

    destroyDB: function() {
        var _this = this;
        try {
            var dbDeleteRequest = window.indexedDB.deleteDatabase(_this.cacheId);
            dbDeleteRequest.onsuccess = function (e) {
                console.log("Database " + _this.cacheId + " successfully deleted");
            };
            dbDeleteRequest.onupgradeneeded = function (e) {
                var db = dbOpenRequest.result;
                console.log("Deleting Database upgrade needed");
                /* Code for ${db.upgrade} */
            };
            dbDeleteRequest.onerror = function (e) {
                console.log("Error deleting DB" + _this.cacheId);
                console.log(e);
            };
            dbDeleteRequest.onblocked = function (e) {
                console.log("Deleting DB Blocked. Try closing the database " + _this.cacheId + " and then deleting it");
            };
        } catch (e) {
            console.log(e);
        }

    },

    destroyDBs: function() {
        for (var i = 0; i < iDBInstances.length; i++){
            iDBInstances[i].close();
            iDBInstances[i].destroyDB();
        }
    },


    get: function(objectStoreName, key, callback) {
        var timeId;
        var _this = this;
        if (_this.debug) {
            timeId = "IndexedDBStore.get " + objectStoreName + key;
            console.time(timeId);
        }
        var result = null;
        _this._getConnection(objectStoreName, function (dbConnection) {
            var transaction = dbConnection.transaction([objectStoreName], "readonly");
            transaction.oncomplete = function(event) {
                if (_this.debug) {
                    console.timeEnd(timeId);
                }
                dbConnection.close();
                callback(result);
            };
            transaction.onerror = function (event) {
                console.log("There was an error in the transaction get (" + key + ")");
                console.log(event);
            };

            var objectStore = transaction.objectStore(objectStoreName);
            var request = objectStore.get(key);
            request.onsuccess = function (event) {
                result = event.target.result;
            };
        });
    },


    /**
     * Calls the callback ONCE. As a parameter there is an Array with all the values.
     * @param keyArray
     * @param callback (valuesArray) The order is the same as in the keyArray.
     */
    getAll: function(objectStoreName, keyArray, callback) {
        var _this = this;
        var timeId;
        if (_this.profile || _this.debug) {
            timeId = "IndexedDBStore.getAll " + objectStoreName + ", with " + keyArray.length + " keys.";
            console.time(timeId);
        }
        if (!(keyArray instanceof Array) || !callback) {
            console.error("Bad use of IndexedDBStore: getAll must receive an ObjectStoreName, an Array of keys and a callback function.");
            return;
        }
        var results = new Array(keyArray.length);

        _this._getConnection(objectStoreName, function (dbConnection) {
            var transaction = dbConnection.transaction([objectStoreName], "readonly");
            transaction.oncomplete = function(event) {
                if (_this.profile || _this.debug) {
                    console.timeEnd(timeId);
                }
                dbConnection.close();
                callback(results);
            };
            transaction.onerror = function (event) {
                console.log("There was an error in the transaction get (" + keyArray + ")");
                console.log(event);
            };

            var objectStore = transaction.objectStore(objectStoreName);

            for (var i = 0; i < keyArray.length; i++) {
                var request = objectStore.get(keyArray[i]);

                request.onsuccess = function (iteration) {
                    return function (event) {
                        results[iteration] = event.target.result;
                    };
                } (i);     // to force the closure to have each value of i, and not just the last one
            }
        });
    },

    /**
     * Calls the callback with the value of each key. The callback is called keyArray.length times.
     * @param callback (value, key, i) Receives as parameters the value, its key, and the position of the key in the keyArray.
     * @param whenCompletedCallback Optional. Receives no arguments. it is called when all callbacks have finished.
     */
    foreach: function(objectStoreName, keyArray, callback, whenCompletedCallback) {
        if (!(keyArray instanceof Array) || !callback) {
            console.error("Bad use of IndexedDBStore: foreach must receive an ObjectStoreName, an Array of keys and a callback function.");
            return;
        }
        var _this = this;
        var timeId;
        if (_this.profile || _this.debug) {
            timeId = "IndexedDBStore.getAll " + objectStoreName + ", with " + keyArray.length + " keys.";
            console.time(timeId);
        }

        _this._getConnection(objectStoreName, function (dbConnection) {
            var transaction = dbConnection.transaction([objectStoreName], "readonly");
            transaction.oncomplete = function(event) {
                dbConnection.close();
                if (_this.profile || _this.debug) {
                    console.timeEnd(timeId);
                }
                if (whenCompletedCallback) {
                    whenCompletedCallback();
                }
            };
            transaction.onerror = function (event) {
                console.log("There was an error in the transaction foreach (" + keyArray + ")");
                console.log(event);
            };

            var objectStore = transaction.objectStore(objectStoreName);

            for (var i = 0; i < keyArray.length; i++) {
                var request = objectStore.get(keyArray[i]);

                request.onsuccess = function (iteration) {
                    return function (event) {
                        callback(event.target.result, keyArray[iteration], iteration);
                    };
                } (i);     // to force the closure to have each value of i, and not just the last one
            }
        });
    },

    add: function(objectStoreName, key, value) {
        var _this = this;

        _this._getConnection(objectStoreName, function(dbConnection) {
            var transaction = dbConnection.transaction([objectStoreName], "readwrite");

            transaction.onerror = function (event) {
                console.log("There was an error in the transaction add (" + key + ", " + value + ")");
                console.log(event);
            };

            var objectStore = transaction.objectStore(objectStoreName);
            var request = objectStore.add(value, key);    // as the key is optional depending on the database scheme, it is the 2nd parameter
        });
    },

    put: function(objectStoreName, key, value) {
        var _this = this;
        var timeId;
        if (_this.debug) {
            timeId = "IndexedDBStore.put " + objectStoreName + key;
            console.time(timeId);
        }

        _this._getConnection(objectStoreName, function(dbConnection) {
            var transaction = dbConnection.transaction([objectStoreName], "readwrite");
            transaction.oncomplete = function(event) {
                if (_this.debug) {
                    console.timeEnd(timeId);
                }
                dbConnection.close();
                dbConnection.close = true;
            };
            transaction.onerror = function (event) {
                console.log("There was an error in the transaction put(" + key + ", ", value, ")");
                console.log(event);
            };

            var objectStore = transaction.objectStore(objectStoreName);
            var request = objectStore.put(value, key);    // as the key is optional depending on the database scheme, it is the 2nd parameter
        });
    },

    putAll: function(objectStoreName, keyArray, valueArray) {
        var _this = this;
        var timeId;
        if (_this.profile || _this.debug) {
            timeId = "IndexedDBStore.putAll " + objectStoreName + ", with " + keyArray.length;
            console.time(timeId);
        }

        if (!(keyArray instanceof Array) || !(valueArray instanceof Array) || (keyArray.length != valueArray.length)) {
            console.error("Bad use of IndexedDBStore: putAll must receive two Arrays of the same length.");
            return;
        }

        _this._getConnection(objectStoreName, function(dbConnection) {
            var transaction = dbConnection.transaction([objectStoreName], "readwrite");
            transaction.oncomplete = function(event) {
                if (_this.profile || _this.debug) {
                    console.timeEnd(timeId);
                }
                dbConnection.close();
                dbConnection.close = true;
            };
            transaction.onerror = function (event) {
                console.log("There was an error in the transaction put(" + key + ", ", value, ")");
                console.log(event);
            };

            var objectStore = transaction.objectStore(objectStoreName);

            for (var i = 0; i < keyArray.length; i++) {
                objectStore.put(valueArray[i], keyArray[i]);    // as the key is optional depending on the database scheme, it is the 2nd parameter
            }
        });
    },


    delete: function(objectStoreName, key) {
        var _this = this;

        _this._getConnection(objectStoreName, function(dbConnection) {
            var transaction = dbConnection.transaction([objectStoreName], "readwrite");
            transaction.onerror = function (event) {
                console.log("There was an error in the transaction delete (" + key + ")");
                console.log(event);
            };

            var objectStore = transaction.objectStore(objectStoreName);
            var request = objectStore.delete(key);    // as the key is optional depending on the database scheme, it is the 2nd parameter

        });
    }
};

IndexedDBTest = function () {
    var idb = new IndexedDBStore({cacheId: "test"});
    idb.put("os-a", "key-a", "value-a");
    idb.put("os-b", "key-b", "value-b");
};

IndexedDBTest();
//debugger
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

BamCache.prototype.putHistogramFeaturesByRegion = FileFeatureCache.prototype.putFeaturesByRegion;

function BamCache(args) {
	this.args = args;
	this.id = Math.round(Math.random() * 10000000); // internal id for this class

	this.chunkSize = 50000;
	this.gzip = true;
	this.maxSize = 10*1024*1024;
	this.size = 0;
	
	if (args != null){
		if(args.chunkSize != null){
			this.chunkSize = args.chunkSize;
		}
		if(args.gzip != null){
			this.gzip = args.gzip;
		}
	}
	
	this.cache = {};

	//deprecated trackSvg has this object now
	//this.chunksDisplayed = {};
	
	this.maxFeaturesInterval = 0;//for local histogram
	
	//XXX
	this.gzip = false;
};

BamCache.prototype._getChunk = function(position){
	return Math.floor(position/this.chunkSize);
};

//new 
BamCache.prototype.getFeatureChunk = function(key){
	if(this.cache[key] != null) {
		return this.cache[key];
	}
	return null;
};
//new
BamCache.prototype.getFeatureChunksByRegion = function(region){
	var firstRegionChunk, lastRegionChunk,  chunks = [], key;
	firstRegionChunk = this._getChunk(region.start);
	lastRegionChunk = this._getChunk(region.end);
	for(var i=firstRegionChunk; i<=lastRegionChunk; i++){
		key = region.chromosome+":"+i;
		// check if this key exists in cache (features from files)
		if(this.cache[key] != null ){
			chunks.push(this.cache[key]);
		}
		
	}
	//if(chunks.length == 0){
		//return null;
	//}
	return chunks;
};



BamCache.prototype.putFeaturesByRegion = function(resultObj, region, featureType, dataType){
	var key, firstChunk, lastChunk, firstRegionChunk, lastRegionChunk, read, gzipRead;
	var reads = resultObj.reads;
	var coverage = resultObj.coverage;
	
	//initialize region
	firstRegionChunk = this._getChunk(region.start);
	lastRegionChunk = this._getChunk(region.end);
	
	var chunkIndex = 0;
	console.time("BamCache.prototype.putFeaturesByRegion1")
	//TODO the region for now is a chunk region, so this for is always 1 loop
	for(var i=firstRegionChunk, c=0; i<=lastRegionChunk; i++, c++){
		key = region.chromosome+":"+i;
		if(this.cache[key]==null || this.cache[key][dataType] == null){
			this.cache[key] = {};
			this.cache[key][dataType] = [];
			this.cache[key].key = key;
			this.cache[key].start = parseInt(region.start)+(c*this.chunkSize);
			this.cache[key].end = parseInt(region.start)+((c+1)*this.chunkSize)-1;
		}
        if(dataType === 'data'){
            //divide the coverage array in multiple arrays of chunksize length
    //		var chunkCoverage = coverage.slice(chunkIndex,chunkIndex+this.chunkSize);
            var chunkCoverageAll = coverage.all.slice(chunkIndex,chunkIndex+this.chunkSize);
            var chunkCoverageA = coverage.a.slice(chunkIndex,chunkIndex+this.chunkSize);
            var chunkCoverageC = coverage.c.slice(chunkIndex,chunkIndex+this.chunkSize);
            var chunkCoverageG = coverage.g.slice(chunkIndex,chunkIndex+this.chunkSize);
            var chunkCoverageT = coverage.t.slice(chunkIndex,chunkIndex+this.chunkSize);
            var chunkCoverage = {
                "all":chunkCoverageAll,
                "a":chunkCoverageA,
                "c":chunkCoverageC,
                "g":chunkCoverageG,
                "t":chunkCoverageT
            };
        }

		if(this.gzip) {
			this.cache[key]["coverage"]=RawDeflate.deflate(JSON.stringify(chunkCoverage));
		}else{
			this.cache[key]["coverage"]=chunkCoverage;
		}
		chunkIndex+=this.chunkSize;
	}
	console.timeEnd("BamCache.prototype.putFeaturesByRegion1")
	console.time("BamCache.prototype.putFeaturesByRegion")
	var ssss = 0;


    if(dataType === 'data'){
        for(var index = 0, len = reads.length; index<len; index++) {
            read = reads[index];
            read.featureType = 'bam';
            firstChunk = this._getChunk(read.start);
            lastChunk = this._getChunk(read.end == 0?read.end=-1:read.end);//0 is not a position, i set to -1 to avoid enter in for
    //		Some reads has end = 0. So will not be drawn IGV does not draw those reads

            if(this.gzip) {
                gzipRead = RawDeflate.deflate(JSON.stringify(read));
                //ssss+= gzipRead.length;
            }else{
                gzipRead = read;
                //ssss+= JSON.stringify(gzipRead).length;
            }

            for(var i=firstChunk, c=0; i<=lastChunk; i++, c++) {
                if(i >= firstRegionChunk && i<= lastRegionChunk){//only if is inside the called region
                    key = read.chromosome+":"+i;
//                    if(this.cache[key].start==null){
//                        this.cache[key].start = parseInt(region.start)+(c*this.chunkSize);
//                    }
//                    if(this.cache[key].end==null){
//                        this.cache[key].end = parseInt(region.start)+((c+1)*this.chunkSize)-1;
//                    }
//                    if(this.cache[key][dataType] != null){
//                        this.cache[key][dataType] = [];
                        this.cache[key][dataType].push(gzipRead);
//                    }

                }
            }
        }
    }


	console.timeEnd("BamCache.prototype.putFeaturesByRegion");
	console.log("BamCache.prototype.putFeaturesByRegion"+ssss)
};

BamCache.prototype.clear = function(){
	this.size = 0;		
	this.cache = {};
	console.log("bamCache cleared")
};

/*
BamCache.prototype.getFeaturesByChunk = function(key, dataType){
	var features =  [];
	var feature, firstChunk, lastChunk, chunk;
	var chr = key.split(":")[0], chunkId = key.split(":")[1];
	var region = {chromosome:chr,start:chunkId*this.chunkSize,end:chunkId*this.chunkSize+this.chunkSize-1};
	
	if(this.cache[key] != null && this.cache[key][dataType] != null) {
		if(this.gzip) {
			coverage = JSON.parse(RawDeflate.inflate(this.cache[key]["coverage"]));
		}else{
			coverage = this.cache[key]["coverage"];
		}
		
		for ( var i = 0, len = this.cache[key]["data"].length; i < len; i++) {
			if(this.gzip) {
				feature = JSON.parse(RawDeflate.inflate(this.cache[key]["data"][i]));
			}else{
				feature = this.cache[key]["data"][i];
			}
			
			//check if any feature chunk has been already displayed 
			var displayed = false;
			firstChunk = this._getChunk(feature.start);
			lastChunk = this._getChunk(feature.end);
			for(var f=firstChunk; f<=lastChunk; f++){
				var fkey = feature.chromosome+":"+f;
				if(this.chunksDisplayed[fkey+dataType]==true){
					displayed = true;
					break;
				}
			}
			
			if(!displayed){
				features.push(feature);
				returnNull = false;
			}
		}
		this.chunksDisplayed[key+dataType]=true;
		chunk = {reads:features,coverage:coverage,region:region};
		return chunk;
	}
	
};

BamCache.prototype.getFeaturesByRegion = function(region, dataType){
	var firstRegionChunk, lastRegionChunk, firstChunk, lastChunk, chunks = [], feature, key, coverage, features = [], displayed;
	firstRegionChunk = this._getChunk(region.start);
	lastRegionChunk = this._getChunk(region.end);
	for(var i=firstRegionChunk; i<=lastRegionChunk; i++){
		key = region.chromosome+":"+i;
		if(this.cache[key] != null){
			if(this.gzip) {
				coverage = JSON.parse(RawDeflate.inflate(this.cache[key]["coverage"]));
			}else{
				coverage = this.cache[key]["coverage"];
			}

			for ( var j = 0, len = this.cache[key]["data"].length; j < len; j++) {
				if(this.gzip) {
					feature = JSON.parse(RawDeflate.inflate(this.cache[key]["data"][j]));
				}else{
					feature = this.cache[key]["data"][j];
				}
				
				
//				check if any feature chunk has been already displayed 
				displayed = false;
				firstChunk = this._getChunk(feature.start);
				lastChunk = this._getChunk(feature.end);
				for(var f=firstChunk; f<=lastChunk; f++){
					var fkey = region.chromosome+":"+f;
					if(this.chunksDisplayed[fkey+dataType]==true){
						displayed = true;
						break;
					}
				}
				
				if(!displayed){
					features.push(feature);
				}
				
			}
		}
		this.chunksDisplayed[key+dataType]=true;//mark chunk as displayed
		chunks.push({reads:features,coverage:coverage,region:region});
	}
	return chunks;
};
*/



//BamCache.prototype.remove = function(region){
//	var firstChunk = this._getChunk(region.start);
//	var lastChunk = this._getChunk(region.end);
//	for(var i=firstChunk; i<=lastChunk; i++){
//		var key = region.chromosome+":"+i;
//		this.cache[key] = null;
//	}
//};
//

//
//BamCache.prototype.clearType = function(dataType){
//	this.cache[dataType] = null;
//};
</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function CellBaseAdapter(args) {

    _.extend(this, Backbone.Events);

    _.extend(this, args);

    this.on(this.handlers);

    this.configureCache();

    this.debug = false;
}

CellBaseAdapter.prototype = {
    setSpecies: function(species) {
        this.species = species;
        this.configureCache();
    },
    setHost: function(host) {
        this.configureCache();
        this.host = host;
    },
    deleteCache:function(){
        this.cache.delete();
    },
    configureCache: function() {
        var host = this.host || CellBaseManager.host;
        var speciesString = this.species.id + this.species.assembly.name.replace(/[/_().\ -]/g, '');
        var cacheId = host + speciesString;
        if (!this.cacheConfig) {
            this.cacheConfig = {
                //    //subCacheId: this.resource + this.params.keys(),
                chunkSize: 3000
            }
        }
        this.cacheConfig.cacheId = cacheId;
        this.cache = new FeatureChunkCache(this.cacheConfig);
    },

    getData: function(args) {
        var _this = this;

        var params = {};
        //histogram: (dataType == 'histogram')
        _.extend(params, this.params);
        _.extend(params, args.params);

        /** 1 region check **/
        var region = args.region;
        if (region.start > 300000000 || region.end < 1) {
            return;
        }
        region.start = (region.start < 1) ? 1 : region.start;
        region.end = (region.end > 300000000) ? 300000000 : region.end;

        /** 2 category check **/
        var categories = [this.category + this.subCategory + this.resource + Utils.queryString(params)];

        /** 3 dataType check **/
        var dataType = args.dataType;
        if (_.isUndefined(dataType)) {
            console.log("dataType must be provided!!!");
        }

        /** 4 chunkSize check **/
        var chunkSize = params.interval ? params.interval : this.cacheConfig.chunkSize; // this.cache.defaultChunkSize should be the same
        if (this.debug) {
            console.log(chunkSize);
        }

        /**
         * Get the uncached regions (uncachedRegions) and cached chunks (cachedChunks).
         * Uncached regions will be used to query cellbase. The response data will be converted in chunks
         * by the Cache TODO????
         * Cached chunks will be returned by the args.dataReady Callback.
         */
        this.cache.get(region, categories, dataType, chunkSize, function(cachedChunks, uncachedRegions) {

            var category = categories[0];
            var categoriesName = "";
            for (var j = 0; j < categories.length; j++) {
                categoriesName += "," + categories[j];
            }
            categoriesName = categoriesName.slice(1);   // to remove first ','

            var chunks = cachedChunks[category];
            // TODO check how to manage multiple regions
            var queriesList = _this._groupQueries(uncachedRegions[category]);

            /** Uncached regions found **/
            if (queriesList.length > 0) {
                args.webServiceCallCount = 0;
                for (var i = 0; i < queriesList.length; i++) {
                    args.webServiceCallCount++;
                    var queryRegion = queriesList[i];

                    // Get CellBase data
                    CellBaseManager.get({
                        host: _this.host,
                        version: _this.version,
                        species: _this.species,
                        category: _this.category,
                        subCategory: _this.subCategory,
                        query: queryRegion.toString(),
                        resource: _this.resource,
                        params: params,
                        success: function(response) {
                            var responseChunks = _this._cellbaseSuccess(response, categories, dataType, chunkSize);
                            args.webServiceCallCount--;

                            chunks = chunks.concat(responseChunks);
                            if (args.webServiceCallCount === 0) {
                                chunks.sort(function(a, b) {
                                    return a.chunkKey.localeCompare(b.chunkKey)
                                });
                                args.done({
                                    items: chunks, dataType: dataType, chunkSize: chunkSize, sender: _this
                                });
                            }
                        },
                        error: function() {
                            console.log('Server error');
                            args.done();
                        }
                    });
                }
            } else
            /** All regions are cached **/
            {
                args.done({
                    items: chunks, dataType: dataType, chunkSize: chunkSize, sender: _this
                });
            }
        });
    },

    _cellbaseSuccess: function(data, categories, dataType, chunkSize) {
        var timeId = Utils.randomString(4) + this.resource + " save";
        console.time(timeId);
        /** time log **/

        var regions = [];
        var chunks = [];
        for (var i = 0; i < data.response.length; i++) {    // TODO test what do several responses mean
            var queryResult = data.response[i];
            if (dataType == "histogram") {
                for (var j = 0; j < queryResult.result.length; j++) {
                    var interval = queryResult.result[j];
                    var region = new Region(interval);
                    regions.push(region);
                    chunks.push(interval);
                }
            } else {
                regions.push(new Region(queryResult.id));
                chunks.push(queryResult.result);
            }
        }
        var items = this.cache.putByRegions(regions, chunks, categories, dataType, chunkSize);

        /** time log **/
        console.timeEnd(timeId);

        return items;
    },

    /**
     * Transform the list on a list of lists, to limit the queries
     * [ r1,r2,r3,r4,r5,r6,r7,r8 ]
     * [ [r1,r2,r3,r4], [r5,r6,r7,r8] ]
     */
    _groupQueries: function(uncachedRegions) {
        var groupSize = 50;
        var queriesLists = [];
        while (uncachedRegions.length > 0) {
            queriesLists.push(uncachedRegions.splice(0, groupSize).toString());
        }
        return queriesLists;
    },


};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function OpencgaAdapter(args) {

    _.extend(this, Backbone.Events);

    _.extend(this, args);

    this.on(this.handlers);

    this.configureCache();

    this.debug = false;
}

OpencgaAdapter.prototype = {
    setSpecies: function (species) {
        this.species = species;
    },
    configureCache: function () {
        var host = this.host || OpencgaManager.host;
        if (!this.cacheConfig) {
            this.cacheConfig = {
                // subCacheId: this.resource + this.params.keys(),
                chunkSize: 3000
            }
        }
        this.cacheConfig.cacheId = 'opencga' + this.resource.id;
        this.cache = new FeatureChunkCache(this.cacheConfig);
    },

    getData: function (args) {
        var _this = this;

        var params = {};
//                    histogram: (dataType == 'histogram')
        _.extend(params, this.params);
        _.extend(params, args.params);

        /** 1 region check **/
        var region = args.region;
        if (region.start > 300000000 || region.end < 1) {
            return;
        }
        region.start = (region.start < 1) ? 1 : region.start;
        region.end = (region.end > 300000000) ? 300000000 : region.end;


        /** 2 category check **/
        var categories = this.resource.id.toString().split(',');   // in this adapter each category is each file

        /** 3 dataType check **/
        var dataType = args.dataType;
        if (_.isUndefined(dataType)) {
            console.log("dataType must be provided!!!");
        }

        /** 4 chunkSize check **/
        var chunkSize = params.interval ? params.interval : this.cacheConfig.chunkSize; // this.cache.defaultChunkSize should be the same
        if (this.debug) {
            console.log(chunkSize);
        }

        /**
         * Get the uncached regions (uncachedRegions) and cached chunks (cachedChunks).
         * Uncached regions will be used to query OpenCGA. The response data will be converted in chunks
         * by the Cache TODO????
         * Cached chunks will be returned by the args.dataReady Callback.
         */
        this.cache.get(region, categories, dataType, chunkSize, function (cachedChunks, uncachedRegions) {

            var category = categories[0];
            var categoriesName = "";
            for (var j = 0; j < categories.length; j++) {
                categoriesName += "," + categories[j];
            }
            categoriesName = categoriesName.slice(1);   // to remove first ','

            var chunks = cachedChunks[category];
            // TODO check if OpenCGA allows multiple regions
            var queriesList = _this._groupQueries(uncachedRegions[category]);

            /** Uncached regions found **/
            if (queriesList.length > 0) {
                args.webServiceCallCount = 0;

                // TODO check how to manage multiple regions and multiple files ids
                for (var i = 0; i < queriesList.length; i++) {
                    args.webServiceCallCount++;
                    var queryRegion = queriesList[i];

                    params['region'] = queryRegion.toString();
                    params['interval'] = chunkSize;
                    params['histogram'] = (dataType == 'histogram');
                    params['process_differences'] = false;

                    OpencgaManager.files['fetch']({
                        id: categoriesName,
                        query: params,
                        request: {
                            success: function (response) {
                                var responseChunks = _this._opencgaSuccess(response, categories, dataType, chunkSize, args);
                                args.webServiceCallCount--;

                                chunks = chunks.concat(responseChunks);
                                if (args.webServiceCallCount === 0) {
                                    args.done({
                                        items: chunks, dataType: dataType, chunkSize: chunkSize, sender: _this
                                    });
                                }
                            },
                            error: function () {
                                console.log('Server error');
                                args.done();
                            }
                        }
                    });
                }

            }
            /** All regions are cached **/
            else {
                args.done({
                    items: chunks, dataType: dataType, chunkSize: chunkSize, sender: _this
                });
            }
        });
    },

    _opencgaSuccess: function (data, categories, dataType, chunkSize) {
        var timeId = this.cacheConfig.cacheId + " save " + data.response.length + " samples";
        console.time(timeId);
        /** time log **/

        if (categories.length != data.response.length) {
            console.log("ERROR: requested " + categories.length + "samples, but response has " + data.response.length);
            console.log(data);
//            debugger;
        }

        if (data.response[0] && data.response[0].result[0]) {
            var inferredChunkSize = data.response[0].result[0].end - data.response[0].result[0].start + 1;
            if (inferredChunkSize != chunkSize) {
                console.log("code smell: chunkSize requested: " + chunkSize + ", but obtained: " + inferredChunkSize);
//                chunkSize = inferredChunkSize;
            }
        }

        var responseItems = [];
        for (var i = 0; i < data.response.length; i++) {    // FIXME each response is a sample? in variant too?
            var queryResult = data.response[i];
            var items = this._adaptChunks(queryResult, categories[i], dataType, chunkSize);
            responseItems = responseItems.concat(items);
            //if (items.length > 0) {
            //    // if (data.encoded) {decrypt }
            //    args.dataReady({items: items, dataType: dataType, chunkSize: chunkSize, sender: this, category: categories[i]});
            //}
            //var decryptedChunks = this._decryptChunks(items, "mypassword");
        }

        /** time log **/
        console.timeEnd(timeId);

        return responseItems;

    },

    /**
     * Transform the list on a list of lists, to limit the queries
     * [ r1,r2,r3,r4,r5,r6,r7,r8 ]
     * [ [r1,r2,r3,r4], [r5,r6,r7,r8] ]
     */
    _groupQueries: function (uncachedRegions) {
        var groupSize = 50;
        var queriesLists = [];
        while (uncachedRegions.length > 0) {
            queriesLists.push(uncachedRegions.splice(0, groupSize).toString());
        }
        return queriesLists;
    },

    _decryptChunks: function (chunks, password) {
        var decryptedChunks = [];
        for (var i = 0; i < chunks.length; i++) {
            if (chunks[i].enc == true) {
                decryptedChunks.push(CryptoJS.AES.decrypt(chunks[i], password));
            } else {
                decryptedChunks.push(chunks[i]);
            }
        }
        return decryptedChunks;
    },

    _adaptChunks: function (queryResult, category, dataType, chunkSize) {
        var chunks;
        var regions;
        var items = [];
//        debugger
        if (queryResult.resultType == "org.opencb.biodata.models.variant.Variant") {
            chunks = [];
            regions = [];
            var keyToPair = {};
            for (var i = 0; i < queryResult.result.length; i++) {
                var variation = queryResult.result[i];
                var chunkId = this.cache.getChunkId(variation.start, chunkSize);
                var key = this.cache.getChunkKey(variation.chromosome,
                    chunkId,
                    dataType,
                    chunkSize);

                if (keyToPair[key] == undefined) {
                    keyToPair[key] = chunks.length;
                    regions.push(new Region({chromosome: variation.chromosome, start: chunkId * chunkSize, end: (chunkId + 1) * chunkSize - 1}));
                    chunks.push([]);
                }
                chunks[keyToPair[key]].push(variation);
            }

//            debugger
            items = this.cache.putByRegions(regions, chunks, category, dataType, chunkSize);
        } else { //if(queryResult.resultType == "org.opencb.biodata.models.alignment.AlignmentRegion") {
            regions = [];
            for (var j = 0; j < queryResult.result.length; j++) {
                regions.push(new Region(queryResult.result[j]));
            }
            chunks = queryResult.result;

//            if (data.response[i].result.length == 1) {
//            } else {
//                console.log("unexpected data structure");
//            }
            items = this.cache.putByRegions(regions, chunks, category, dataType, chunkSize);
        }
        return items;
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function EnsemblAdapter(args) {

    _.extend(this, Backbone.Events);

    _.extend(this, args);

    this.on(this.handlers);

    this.cache = new FeatureChunkCache(this.cacheConfig);
}

EnsemblAdapter.prototype = {

    getData: function (args) {
        var _this = this;
        args.webServiceCallCount = 0;

        var params = {};
//                    histogram: (dataType == 'histogram')
        _.extend(params, this.params);
        _.extend(params, args.params);

        /** 1 region check **/
        var region = args.region;
        if (region.start > 300000000 || region.end < 1) {
            return;
        }
        region.start = (region.start < 1) ? 1 : region.start;
        region.end = (region.end > 300000000) ? 300000000 : region.end;

        /** 3 dataType check **/
        var dataType = args.dataType;
        if (_.isUndefined(dataType)) {
            console.log("dataType must be provided!!!");
        }

        /** 2 category check **/
        var categories = [dataType];

        /** 4 chunkSize check **/
        var chunkSize = args.params.interval? args.params.interval : this.cacheConfig.chunkSize; // this.cache.defaultChunkSize should be the same
        if (this.debug) {
            console.log(chunkSize);
        }

        /**
         * Get the uncached regions (uncachedRegions) and cached chunks (cachedChunks).
         * Uncached regions will be used to query cellbase. The response data will be converted in chunks
         * by the Cache TODO????
         * Cached chunks will be returned by the args.dataReady Callback.
         */
        this.cache.get(region, categories, dataType, chunkSize, function (cachedChunks, uncachedRegions) {

            if (uncachedRegions.length > 0) {
                var queryRegionStrings = uncachedRegions;
                for (var i = 0; i < queryRegionStrings.length; i++) {
                    args.webServiceCallCount++;
                    _this._get(queryRegionStrings[i], params, categories, chunkSize, args);
                }
            }
            // Get chunks from cache
            if (cachedChunks.length > 0) {
                if (args.webServiceCallCount === 0) {
                    args.done();
                }
                _this.trigger('data:ready', {items: cachedChunks[categories[0]], dataType: dataType, chunkSize: chunkSize, sender: _this});
            }
        });
    },

    _get: function (query, params, categories, chunkSize, args) {
        var _this = this;
        EnsemblManager.get({
            host: _this.host,
            species: _this.species,
            category: _this.category,
            subCategory: _this.subCategory,
            query: query,
            params: params,
            success: function (data) {
                var transformedData = _this._transformResponse(data, query);
                _this._success(transformedData, categories, undefined, chunkSize, args);
            }
        });
    },

    _success: function (data, categories, dataType, chunkSize, args) {
        args.webServiceCallCount--;
        var timeId = Utils.randomString(4) + this.resource + " save";
        console.time(timeId);
        /** time log **/

        var regions = [];
        var chunks = [];
        for (var i = 0; i < data.response.length; i++) {
            var queryResult = data.response[i];
            regions.push(new Region(queryResult.id));
            chunks.push(queryResult.result);
        }
        var items = this.cache.putByRegions(regions, chunks, categories, dataType, chunkSize);

        /** time log **/
        console.timeEnd(timeId);

        if (args.webServiceCallCount === 0) {
            args.done();
        }

        if (items.length > 0) {
            this.trigger('data:ready', {items: items, dataType: dataType, chunkSize: chunkSize, sender: _this});
        }
    },

    _transformResponse: function (data, query) {
//        id: "ENSG00000189167"
//        source: "Ensembl"
//        name: "ZAR1L"
//        biotype: "protein_coding"
//        status: "KNOWN"
//        chromosome: "13"
//        start: 32877837
//        end: 32889481
//        strand: "-"
//        description: "zygote arrest 1-like [Source:HGNC Symbol;Acc:37116]"


//        ID: "ENSG00000073910"
//        source: "ensembl"
//        external_name: "FRY"
//        logic_name: "ensembl_havana_gene"
//        feature_type: "gene"
//        description: "furry homolog (Drosophila) [Source:HGNC Symbol;Acc:20367]"
//        biotype: "protein_coding"
//        end: 32870794
//        seq_region_name: "13"
//        strand: 1
//        start: 32605437

        for (var i = 0; i < data.length; i++) {
            var f = data[i];
            f.id = f.ID;
            delete f.ID;
            f.name = f.external_name;
            delete f.external_name;
            f.chromosome = f.seq_region_name;
            delete f.seq_region_name;
        }

        var r = {
            response: []
        };
        var result = {
            id: query,
            result: data
        };
        r.response.push(result);
        return  r;
    }
};

</script>
<script>/*
 * Copyright (c) 2015 Francisco Salavert (DCG-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * ** Generic adapter to any uri

 new FeatureTemplateAdapter({
    uriTemplate: 'http://host/webserver/{customVar}/{species}/{region}',
    templateVariables: {
        customVar: 'info',
    },
    species: genomeViewer.species,
    parse: function (response) {
        var itemsArray = [];
        for (var i = 0; i < response.response.length; i++) {
            var r = response.response[i];
            itemsArray.push(r.result);
        }
        return itemsArray;
    }
 })

 * ** templateVariables is used for custom variables in the uri. region and species will be ignored
 * ** as will be configured automatically

 * ** The species config is the current species should not appear in templateVariables
 * ** The region in the uriTemplate is provided by the track so should not appear in templateVariables
 * ** The parse function is used to adapt de features from the response

 */

function FeatureTemplateAdapter(args) {

    _.extend(this, Backbone.Events);

    this.templateVariables = {};
    this.multiRegions = true;
    this.histogramMultiRegions = true;
    this.chromosomeSizes;

    _.extend(this, args);

    this.configureCache();

    this.debug = false;
}

FeatureTemplateAdapter.prototype = {
    setSpecies: function (species) {
        this.species = species;
        this.configureCache();
    },
    setHost: function (host) {
        this.configureCache();
        this.host = host;
    },
    deleteCache:function(){
        this.cache.delete();
    },
    configureCache: function () {
        var speciesString = '';
        if (this.species != null) {
            var speciesString = this.species.id + this.species.assembly.name.replace(/[/_().\ -]/g, '');
        }
        var cacheId = this.uriTemplate + speciesString;
        if (!this.cacheConfig) {
            this.cacheConfig = {
                //    //subCacheId: this.resource + this.params.keys(),
                chunkSize: 3000
            }
        }
        this.cacheConfig.cacheId = cacheId;
        this.cache = new FeatureChunkCache(this.cacheConfig);
    },

    getData: function (args) {
        var _this = this;

        var params = {};
        //histogram: (dataType == 'histogram')
        _.extend(params, this.params);
        _.extend(params, args.params);

        /** 1 region check **/
        var region = args.region;
        var limitedRegion = this._computeLimitedRegion(region.chromosome);
        if (region.start > limitedRegion || region.end < 1) {
            return;
        }
        region.start = (region.start < 1) ? 1 : region.start;
        region.end = (region.end > limitedRegion) ? limitedRegion : region.end;

        /** 2 category check **/
        var categories = ["cat_" + Utils.queryString(this.templateVariables) + Utils.queryString(params)];

        /** 3 dataType check **/
        var dataType = args.dataType;
        if (_.isUndefined(dataType)) {
            console.log("dataType must be provided!!!");
        }

        /** 4 chunkSize check **/
        var chunkSize = params.interval ? params.interval : this.cacheConfig.chunkSize; // this.cache.defaultChunkSize should be the same
        if (this.debug) {
            console.log(chunkSize);
        }

        /**
         * Get the uncached regions (uncachedRegions) and cached chunks (cachedChunks).
         * Uncached regions will be used to query cellbase. The response data will be converted in chunks
         * by the Cache TODO????
         * Cached chunks will be returned by the args.dataReady Callback.
         */
        this.cache.get(region, categories, dataType, chunkSize, function (cachedChunks, uncachedRegions) {

            var category = categories[0];
            var categoriesName = "";
            for (var j = 0; j < categories.length; j++) {
                categoriesName += "," + categories[j];
            }
            categoriesName = categoriesName.slice(1); // to remove first ','

            var chunks = cachedChunks[category];
            // TODO check how to manage multiple regions

            var queriesList;
            if (dataType !== 'histogram') {
                if (_this.multiRegions === false) {
                    queriesList = _this._singleQueries(uncachedRegions[category]);
                } else {
                    queriesList = _this._groupQueries(uncachedRegions[category]);
                }
            } else {
                if (_this.histogramMultiRegions === false) {
                    queriesList = _this._singleQueries(uncachedRegions[category]);
                } else {
                    queriesList = _this._groupQueries(uncachedRegions[category]);
                }
            }

            /** Uncached regions found **/
            if (queriesList.length > 0) {
                args.webServiceCallCount = 0;
                for (var i = 0; i < queriesList.length; i++) {
                    args.webServiceCallCount++;
                    var queryRegion = queriesList[i];

                    var request = new XMLHttpRequest();

                    /** Temporal fix save queried region **/
                    request._queryRegion = queryRegion;
                    request._originalRegion = region;

                    request.onload = function () {
                        args.webServiceCallCount--;
                        if (request.status !== 400 && request.status !== 500) {
                            var response;
                            try {
                                response = JSON.parse(this.response);
                            } catch (e) {
                                console.log('Warning: Response is not JSON');
                                response = this.response;
                            }

                            /** Process response **/
                            var responseChunks = _this._success(response, categories, dataType, this._queryRegion, this._originalRegion, chunkSize);
                            chunks = chunks.concat(responseChunks);
                        } else {
                            console.log("request.status: " + request.status);
                        }
                        if (args.webServiceCallCount === 0) {
                            chunks.sort(function (a, b) {
                                return a.chunkKey.localeCompare(b.chunkKey)
                            });
                            args.done({
                                items: chunks,
                                dataType: dataType,
                                chunkSize: chunkSize,
                                sender: _this
                            });
                        }
                    };
                    request.onerror = function () {
                        console.log('Server error');
                        args.done();
                    };
                    var uriTemplate = new URITemplate(_this.uriTemplate);
                    _this.templateVariables['region'] = queryRegion.toString();
                    _this.templateVariables['species'] = _this._getSpeciesQueryString(_this.species);

                    var url = uriTemplate.expand(_this.templateVariables);
                    url = Utils.addQueryParamtersToUrl(params, url);
                    request.open('GET', url, true);
                    console.log(url);
                    request.send();

                }
            } else
            /** All regions are cached **/
            {
                args.done({
                    items: chunks,
                    dataType: dataType,
                    chunkSize: chunkSize,
                    sender: _this
                });
            }
        });
    },

    _success: function (response, categories, dataType, queryRegion, originalRegion, chunkSize) {
        //var timeId = Utils.randomString(4) + this.resource + " save";
        //console.time(timeId);
        /** time log **/

        var regions = [];
        var chunks = [];
        if (dataType !== 'histogram') {
            if (typeof this.parse === 'function') {
                chunks = this.parse(response, dataType);
            } else {
                chunks = response;
            }
            regions = this._getRegionsFromQueryRegions(queryRegion);
        } else {
            if (typeof this.parseHistogram === 'function') {
                chunks = this.parseHistogram(response);
            } else {
                chunks = response;
            }
            regions = this._getRegionsFromHistogramChunks(chunks, originalRegion.chromosome);
        }

        var items = this.cache.putByRegions(regions, chunks, categories, dataType, chunkSize);

        /** time log **/
        //console.timeEnd(timeId);

        return items;
    },

    /**
     * Transform the list on a list of lists, to limit the queries
     * [ r1,r2,r3,r4,r5,r6,r7,r8 ]
     * [ [r1,r2,r3,r4], [r5,r6,r7,r8] ]
     */
    _groupQueries: function (uncachedRegions) {
        // modify region end to chromosome length.
        for (var i = 0; i < uncachedRegions.length; i++) {
            var r = uncachedRegions[i];
            this._computeRegionSize(r);
        }

        var groupSize = 50;
        var queriesLists = [];
        while (uncachedRegions.length > 0) {
            queriesLists.push(uncachedRegions.splice(0, groupSize).toString());
        }
        return queriesLists;
    },
    _singleQueries: function (uncachedRegions) {
        // modify region end to chromosome length.
        for (var i = 0; i < uncachedRegions.length; i++) {
            var r = uncachedRegions[i];
            this._computeRegionSize(r);
        }

        var queriesLists = [];
        for (var i = 0; i < uncachedRegions.length; i++) {
            var region = uncachedRegions[i];
            queriesLists.push(region.toString());
        }
        return queriesLists;
    },

    _getSpeciesQueryString: function (species) {
        if (species == null) {
            return '';
        }
        if (this.speciesParse != null) {
            return this.speciesParse(species);
        } else {
            return Utils.getSpeciesCode(species.scientificName)
        }
    },

    _getRegionsFromQueryRegions: function (queryRegion) {
        var regions = [];
        var regionSplit = queryRegion.split(',');
        for (var i = 0; i < regionSplit.length; i++) {
            var regionStr = regionSplit[i];
            regions.push(new Region(regionStr));
        }
        return regions;
    },

    _getRegionsFromHistogramChunks: function (intervals, chromosome) {
        var regions = [];
        for (var i = 0; i < intervals.length; i++) {
            var interval = intervals[i];
            var region = new Region(interval);
            region.chromosome = chromosome;
            regions.push(region);
        }
        return regions;
    },

    _computeLimitedRegion: function (chromosome) {
        var regionLimit = 300000000;

        if (this.species != null && this.species.chromosomes[chromosome] != null) {
            regionLimit = this.species.chromosomes[chromosome].end;
        }

        if (this.chromosomeSizes != null &&
            this.chromosomeSizes[chromosome] != null &&
            !isNaN(this.chromosomeSizes[chromosome])
        ) {
            regionLimit = this.chromosomeSizes[chromosome];
        }

        return regionLimit;
    },
    _computeRegionSize: function (region) {
        var limitedRegion = this._computeLimitedRegion(region.chromosome);
        if (region.end > limitedRegion) {
            region.end = limitedRegion;
        }
    }
};
</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function BamAdapter(args){

    _.extend(this, Backbone.Events);

    if(typeof args != 'undefined'){
        this.host = args.host || this.host;
        this.category = args.category || this.category;
		this.resource = args.resource || this.resource;
		this.params = args.params || this.params;
		this.filters = args.filters || this.filters;
		this.options = args.options || this.options;
        this.species = args.species || this.species;
        var argsFeatureCache = args.featureCache || {};
    }
	if (args != null){
		if(args.featureConfig != null){
			if(args.featureConfig.filters != null){
				this.filtersConfig = args.featureConfig.filters;
			}
			if(args.featureConfig.options != null){//apply only check boxes
				this.optionsConfig = args.featureConfig.options;
				for(var i = 0; i < this.optionsConfig.length; i++){
					if(this.optionsConfig[i].checked == true){
						this.options[this.optionsConfig[i].name] = true;
						this.params[this.optionsConfig[i].name] = true;
					}				
				}
			}
		}
	}

	this.featureCache = new BamCache(argsFeatureCache);
//	this.onGetData = new Event();
}

BamAdapter.prototype = {
    host : null,
    gzip : true,
    params : {}
};

BamAdapter.prototype.clearData = function(){
	this.featureCache.clear();
};

BamAdapter.prototype.setFilters = function(filters){
	this.clearData();
	this.filters = filters;
	for(filter in filters){
		var value = filters[filter].toString();
		delete this.params[filter];
		if(value != ""){
			this.params[filter] = value;
		}
	}
};
BamAdapter.prototype.setOption = function(opt, value){
	if(opt.fetch){
		this.clearData();
	}
	this.options[opt.name] = value;
	for(option in this.options){
		if(this.options[opt.name] != null){
			this.params[opt.name] = this.options[opt.name];
		}else{
			delete this.params[opt.name];
		}
	}
};


BamAdapter.prototype.getData = function(args){
	var _this = this;
	//region check
	this.params["histogram"] = args.histogram;
	this.params["histogramLogarithm"] = args.histogramLogarithm;
	this.params["histogramMax"] = args.histogramMax;
	this.params["interval"] = args.interval;
	this.params["transcript"] = args.transcript;
	this.params["chromosome"] = args.chromosome;
	this.params["resource"] = this.resource.id;
	this.params["category"] = this.category;
	this.params["species"] = Utils.getSpeciesCode(this.species.text);


	if(args.start<1){
		args.start=1;
	}
	if(args.end>300000000){
		args.end=300000000;
	}
	
	var dataType = "data";
	if(args.histogram){
		dataType = "histogram"+args.interval;
	}

	this.params["dataType"] = dataType;
	
	var firstChunk = this.featureCache._getChunk(args.start);
	var lastChunk = this.featureCache._getChunk(args.end);
	var chunks = [];
	var itemList = [];
	for(var i=firstChunk; i<=lastChunk; i++){
		var key = args.chromosome+":"+i;
		if(this.featureCache.cache[key] == null || this.featureCache.cache[key][dataType] == null) {
			chunks.push(i);
		}else{
			var item = this.featureCache.getFeatureChunk(key);
			itemList.push(item);
		}
	}

    var regionSuccess = function (data) {
		var splitDots = data.query.split(":");
		var splitDash = splitDots[1].split("-");
		var query = {chromosome:splitDots[0],start:splitDash[0],end:splitDash[1]};


		var dataType = "data";
		if(data.params.histogram){
			dataType = "histogram"+data.params.interval;
		    _this.featureCache.putHistogramFeaturesByRegion(data.result, query, data.resource, dataType);
		}else{
		    _this.featureCache.putFeaturesByRegion(data.result, query, data.resource, dataType);
        }

		var items = _this.featureCache.getFeatureChunksByRegion(query, dataType);
		itemList = itemList.concat(items);
		if(itemList.length > 0){
            _this.trigger('data:ready',{items:itemList, params:_this.params, cached:false, sender:_this});
//			_this.onGetData.notify({items:itemList, params:_this.params, cached:false});
		}
	};

	var querys = [];
	var updateStart = true;
	var updateEnd = true;
	if(chunks.length > 0){//chunks needed to retrieve
//		console.log(chunks);
		
		for ( var i = 0; i < chunks.length; i++) {
			
			if(updateStart){
				var chunkStart = parseInt(chunks[i] * this.featureCache.chunkSize);
				updateStart = false;
			}
			if(updateEnd){
				var chunkEnd = parseInt((chunks[i] * this.featureCache.chunkSize) + this.featureCache.chunkSize-1);
				updateEnd = false;
			}
			
			if(chunks[i+1]!=null){
				if(chunks[i]+1==chunks[i+1]){
					updateEnd =true;
				}else{
					var query = args.chromosome+":"+chunkStart+"-"+chunkEnd;
					querys.push(query);
					updateStart = true;
					updateEnd = true;
				}
			}else{
				var query = args.chromosome+":"+chunkStart+"-"+chunkEnd;
				querys.push(query);
				updateStart = true;
				updateEnd = true;
			}
		}
//		console.log(querys);
		for ( var i = 0, li = querys.length; i < li; i++) {
			console.time("dqs");
			//accountId, sessionId, bucketname, objectname, region,
            var cookie = $.cookie("bioinfo_sid");
            cookie = ( cookie != '' && cookie != null ) ?  cookie : 'dummycookie';
            OpencgaManager.region({
                accountId: this.resource.account,
                sessionId: cookie,
                bucketId: this.resource.bucketId,
                objectId: this.resource.oid,
                region: querys[i],
                queryParams: this.params,
                success:regionSuccess
            });
		}
	}else{//no server call
		if(itemList.length > 0){
            _this.trigger('data:ready',{items:itemList, params:this.params, cached:false, sender:this});
//			this.onGetData.notify({items:itemList, params:this.params});
		}
	}
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function DasAdapter(args){

    var _this=this;

    _.extend(this, Backbone.Events);

    this.id = Utils.genId('DasAdapter');

	this.gzip = true;
	this.proxy = CELLBASE_HOST+"/latest/utils/proxy?url=";
	this.url;
	this.species;
	this.featureCache;
	this.params = {};

    _.extend(this, args);
    
    this.on(this.handlers);

	this.featureCache =  new FeatureCache(this.featureCache);
};

DasAdapter.prototype.getData = function(args){
//	console.time("all");
	var _this = this;
	//region check
	
	this.params["histogram"] = args.histogram;
	this.params["interval"] = args.interval;
	this.params["transcript"] = args.transcript;
	
	if(args.start<1){
		args.start=1;
	}
	if(args.end>300000000){
		args.end=300000000;
	}
	
	var dataType = "data";
	if(args.histogram){
		dataType = "histogram"+args.interval;
	}

	this.params["dataType"] = dataType;
	
	var firstChunk = this.featureCache._getChunk(args.start);
	var lastChunk = this.featureCache._getChunk(args.end);

	var chunks = [];
	var itemList = [];
	for(var i=firstChunk; i<=lastChunk; i++){
		var key = args.chromosome+":"+i;
		if(this.featureCache.cache[key] == null || this.featureCache.cache[key][dataType] == null) {
			chunks.push(i);
		}else{
			var item = this.featureCache.getFeatureChunk(key);
//			console.time("concat");
			itemList.push(item);
//			console.timeEnd("concat");
		}
	}
//	//notify all chunks
	if(itemList.length>0){
		this.trigger('data:ready',{items:itemList, params:this.params, cached:true});
	}
	
	
	//data process
	var updateStart = true;
	var updateEnd = true;
	if(chunks.length > 0){
//		console.log(chunks);
		
		for ( var i = 0; i < chunks.length; i++) {
			var query = null;
			
			if(updateStart){
				var chunkStart = parseInt(chunks[i] * this.featureCache.chunkSize);
				updateStart = false;
			}
			if(updateEnd){
				var chunkEnd = parseInt((chunks[i] * this.featureCache.chunkSize) + this.featureCache.chunkSize-1);
				updateEnd = false;
			}
			
			if(chunks[i+1]!=null){
				if(chunks[i]+1==chunks[i+1]){
					updateEnd =true;
				}else{
					query = args.chromosome+":"+chunkStart+","+chunkEnd;
					updateStart = true;
					updateEnd = true;
				}
			}else{
				query = args.chromosome+":"+chunkStart+","+chunkEnd;
				updateStart = true;
				updateEnd = true;
			}

			if(query){
				var fullURL = this.proxy + this.url + "?segment=" + query;
				console.log("fullURL: "+fullURL);

				$.ajax({
					url: fullURL,
					type: 'GET',
					dataType:"xml",
					error: function(){
						alert("error");
						_this.trigger('error',"It is not allowed by Access-Control-Allow-Origin " );
					},

					success: function(data){
						_this.xml =   (new XMLSerializer()).serializeToString(data);
						var xmlStringified =  (new XMLSerializer()).serializeToString(data); //data.childNodes[2].nodeValue;
						var data = xml2json.parser(xmlStringified);

						if(data.dasgff != null){//Some times DAS server does not respond
							var result = new Array();
								
							if (typeof(data.dasgff.gff.segment)  != 'undefined'){
								if (typeof(data.dasgff.gff.segment.feature)  != 'undefined'){	  
									result = data.dasgff.gff.segment.feature;	
								}
								else if (typeof(data.dasgff.gff.segment[0])  != 'undefined'){
									if (data.dasgff.gff.segment[0].feature != null){
										for ( var i = 0; i < data.dasgff.gff.segment.length; i++) {
											for ( var j = 0; j < data.dasgff.gff.segment[i].feature.length; j++) {
												data.dasgff.gff.segment[i].feature[j]["chromosome"] = args.chromosome;
												result.push(data.dasgff.gff.segment[i].feature[j]);
											}
										}
									}
									else{
										result.push([]);
									}
								}
							}
							var region = {chromosome:args.chromosome, start:chunkStart, end:chunkEnd};
							var resource = "das";
							_this.featureCache.putFeaturesByRegion(result, region, resource, dataType);
							console.log(_this.featureCache.cache);
							var items = _this.featureCache.getFeatureChunksByRegion(region);
							if(items != null){
								_this.trigger('data:ready',{items:items, params:_this.params, cached:false});
							}
						}
					}
				});
			}
		}
	}
};

DasAdapter.prototype.checkUrl = function(){
	var _this = this;
	var fullURL = this.proxy + this.url + "?segment=1:1,1";
	console.log("Checking URL: "+fullURL);

	$.ajax({
		url: fullURL,
		type: 'GET',
		dataType:"xml",
		error: function(){
			alert("error");
			_this.trigger('error',"It is not allowed by Access-Control-Allow-Origin " );
		},
		success: function(data){
			_this.xml = (new XMLSerializer()).serializeToString(data);
			_this.trigger('url:check',{data:_this.xml});
		}
	});
};
</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function FeatureDataAdapter(dataSource, args) {
    var _this = this;
    _.extend(this, Backbone.Events);

    this.dataSource = dataSource;
    this.gzip = true;

    this.params = {};
    if (args != null) {
        if (args.gzip != null) {
            this.gzip = args.gzip;
        }
        if (args.species != null) {
            this.species = args.species;
        }
        if (args.params != null) {
            this.params = args.params;
        }
    }

    this.featureCache = new FileFeatureCache({chunkSize: 10000, gzip: this.gzip});

//	this.onLoad = new Event();
//	this.onGetData = new Event();

    //chromosomes loaded
    this.chromosomesLoaded = {};
}

FeatureDataAdapter.prototype.getData = function (args) {
    console.log("TODO comprobar histograma");
    console.log(args.region);
    this.params["dataType"] = "data";
    this.params["chromosome"] = args.region.chromosome;

    //check if the chromosome has been already loaded
    if (this.chromosomesLoaded[args.region.chromosome] != true) {
        this._fetchData(args.region);
        this.chromosomesLoaded[args.region.chromosome] = true;
    }

    var itemList = this.featureCache.getFeatureChunksByRegion(args.region);
    if (itemList != null) {
        this.trigger('data:ready', {items: itemList, params: this.params, chunkSize: this.featureCache.chunkSize, cached: true, sender: this});
    }
    args.done();
};

FeatureDataAdapter.prototype._fetchData = function (region) {
    var _this = this;
    if (this.dataSource != null) {//could be null in expression genomic attributer widget 59
        if (this.async) {
            this.dataSource.on('success', function (data) {
                _this.parse(data, region);
//				_this.onLoad.notify();
                _this.trigger('file:load', {sender: _this});


                var itemList = _this.featureCache.getFeatureChunksByRegion(region);
                if (itemList != null) {
                    _this.trigger('data:ready', {items: itemList, params: _this.params, chunkSize: _this.featureCache.chunkSize, cached: true, sender: _this});
                }

            });
            this.dataSource.fetch(this.async);
        } else {
            var data = this.dataSource.fetch(this.async);
            this.parse(data, region);
        }
    }
}

FeatureDataAdapter.prototype.addFeatures = function (features) {
    this.featureCache.putFeatures(features, "data");
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

VCFDataAdapter.prototype.getData = FeatureDataAdapter.prototype.getData;
VCFDataAdapter.prototype._fetchData = FeatureDataAdapter.prototype._fetchData;

function VCFDataAdapter(dataSource, args) {
    FeatureDataAdapter.prototype.constructor.call(this, dataSource, args);
    var _this = this;

    this.async = true;
    //stat atributes
    this.featuresCount = 0;
    this.featuresByChromosome = {};

    this.header = "";
    this.samples = [];

    if (args != null) {
        if (args.async != null) {
            this.async = args.async;
        }
    }
}

VCFDataAdapter.prototype.parse = function (data, region) {
//	console.log(data);
    var _this = this;
    var dataType = "value";
    var lines = data.split("\n");
//    debugger
//	console.log("creating objects");
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].replace(/^\s+|\s+$/g, "");
        if ((line != null) && (line.length > 0)) {

            var fields = line.split("\t");

            if (line.substr(0, 1) === "#") {
                if (line.substr(1, 1) === "#") {
                    this.header += line.replace(/</gi, "&#60;").replace(/>/gi, "&#62;") + "<br>";
                } else {
                    this.samples = fields.slice(9);
                }
            } else {

                var chrom = fields[0].replace(/chr/gi, "");
                if (chrom == region.chromosome) {// load only one chromosome on the cache

                    //				_this.addQualityControl(fields[5]);

                    var samples = [];
                    if(fields[9]){
                        samples = fields.slice(9);
                    }

                    var feature = {
                        "chromosome": chrom,
                        "position": parseInt(fields[1]),
                        "start": parseInt(fields[1]),//added
                        "end": parseInt(fields[1]),//added
                        "id": fields[2],
                        "reference": fields[3],
                        "alternate": fields[4],
                        "quality": fields[5],
                        "filter": fields[6],
                        "info": fields[7].replace(/;/gi, "<br>"),
                        "format": fields[8],
                        "sampleData": line,
                        "samples": samples,
                        //						"record":		fields,
                        //						"label": 		fields[2] + " " +fields[3] + "/" + fields[4] + " Q:" + fields[5],
                        "featureType": "vcf"
                    };

                    this.featureCache.putFeatures(feature, dataType);

                    if (this.featuresByChromosome[chrom] == null) {
                        this.featuresByChromosome[chrom] = 0;
                    }
                    this.featuresByChromosome[chrom]++;
                    this.featuresCount++;
                }
            }
        }
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

GFF2DataAdapter.prototype.getData = FeatureDataAdapter.prototype.getData;
GFF2DataAdapter.prototype._fetchData = FeatureDataAdapter.prototype._fetchData;

function GFF2DataAdapter(dataSource, args){
	FeatureDataAdapter.prototype.constructor.call(this, dataSource, args);
	var _this = this;
	
	this.async = true;
	
	//stat atributes
	this.featuresCount = 0;
	this.featuresByChromosome = {};

	if (args != null){
		if(args.async != null){
			this.async = args.async;
		}
	}
};

GFF2DataAdapter.prototype.parse = function(data, region){
	var _this = this;
	var dataType = "value";
	var lines = data.split("\n");
//	console.log("creating objects");
	for (var i = 0; i < lines.length; i++){
		var line = lines[i].replace(/^\s+|\s+$/g,"");
		if ((line != null)&&(line.length > 0)){
			var fields = line.split("\t");
			var chromosome = fields[0].replace("chr", "");
			if(chromosome == region.chromosome){// load only one chromosome on the cache

				//NAME  SOURCE  TYPE  START  END  SCORE  STRAND  FRAME  GROUP
				var feature = {
						"chromosome": chromosome, 
						"label": fields[2], 
						"start": parseInt(fields[3]), 
						"end": parseInt(fields[4]), 
						"score": fields[5],
						"strand": fields[6], 
						"frame": fields[7],
						"group": fields[8],
						"featureType":	"gff2"
				} ;

				this.featureCache.putFeatures(feature, dataType);
				
				if (this.featuresByChromosome[chromosome] == null){
					this.featuresByChromosome[chromosome] = 0;
				}
				this.featuresByChromosome[chromosome]++;
				this.featuresCount++;
			}
		}
	}
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

GFF3DataAdapter.prototype.getData = FeatureDataAdapter.prototype.getData;
GFF3DataAdapter.prototype._fetchData = FeatureDataAdapter.prototype._fetchData;

function GFF3DataAdapter(dataSource, args){
	FeatureDataAdapter.prototype.constructor.call(this, dataSource, args);
	var _this = this;
	
	this.async = true;

	//stat atributes
	this.featuresCount = 0;
	this.featuresByChromosome = {};

	if (args != null){
		if(args.async != null){
			this.async = args.async;
		}
	}
};

GFF3DataAdapter.prototype.parse = function(data, region){
	var _this = this;
	
	//parse attributes column
	var getAttr = function(column){
		var obj = {};
        if(typeof column !== 'undefined'){
            var arr = column.replace(/ /g,'').split(";");
            for (var i = 0, li = arr.length; i<li ; i++){
                var item = arr[i].split("=");
                obj[item[0]] = item[1];
            }
        }
		return obj;
	};
	var dataType = "value";
	var lines = data.split("\n");
//	console.log("creating objects");
	for (var i = 0; i < lines.length; i++){
		var line = lines[i].replace(/^\s+|\s+$/g,"");
		if ((line != null)&&(line.length > 0)){
			var fields = line.split("\t");
			var chromosome = fields[0].replace("chr", "");
			if(chromosome == region.chromosome){// load only one chromosome on the cache

				//NAME  SOURCE  TYPE  START  END  SCORE  STRAND  FRAME  GROUP
				var feature = {
						"chromosome": chromosome, 
						"label": fields[2], 
						"start": parseInt(fields[3]), 
						"end": parseInt(fields[4]), 
						"score": fields[5],
						"strand": fields[6], 
						"frame": fields[7],
						"attributes": getAttr(fields[8]),
						"featureType":	"gff3"
				} ;

				this.featureCache.putFeatures(feature, dataType);
				if (this.featuresByChromosome[chromosome] == null){
					this.featuresByChromosome[chromosome] = 0;
				}
				this.featuresByChromosome[chromosome]++;
				this.featuresCount++;

			}
		}
	}
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

BEDDataAdapter.prototype.getData = FeatureDataAdapter.prototype.getData;
BEDDataAdapter.prototype._fetchData = FeatureDataAdapter.prototype._fetchData;

function BEDDataAdapter(dataSource, args) {
    FeatureDataAdapter.prototype.constructor.call(this, dataSource, args);
    var _this = this;

    this.async = true;

    this.parseFunction;
    if (args != null) {
        if (args.parseFunction != null) {
            this.parseFunction = args.parseFunction;
        }
    }

    //stat atributes
    this.featuresCount = 0;
    this.featuresByChromosome = {};

    if (args != null) {
        if (args.async != null) {
            this.async = args.async;
        }
    }
};

BEDDataAdapter.prototype.parse = function (data, region) {
    if (this.parseFunction){
        this.parseFunction(data, region);
    }else{
        this._defaultParse(data, region);
    }
};

BEDDataAdapter.prototype._defaultParse = function (data, region) {

    var _this = this;
    var dataType = "value";
    var lines = data.split("\n");
//	console.log("creating objects");
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].replace(/^\s+|\s+$/g, "");
        if ((line != null) && (line.length > 0)) {
            var fields = line.split("\t");
            var chromosome = fields[0].replace("chr", "");
            if (chromosome == region.chromosome) {// load only one chromosome on the cache

                var feature = {
                    "label": fields[3],
                    "chromosome": chromosome,
                    "start": parseFloat(fields[1]),
                    "end": parseFloat(fields[2]),
                    "score": fields[4],
                    "strand": fields[5],
                    "thickStart": fields[6],
                    "thickEnd": fields[7],
                    "itemRgb": fields[8],
                    "blockCount": fields[9],
                    "blockSizes": fields[10],
                    "blockStarts": fields[11],
                    "featureType": "bed"
                };

                this.featureCache.putFeatures(feature, dataType);

                if (this.featuresByChromosome[chromosome] == null) {
                    this.featuresByChromosome[chromosome] = 0;
                }
                this.featuresByChromosome[chromosome]++;
                this.featuresCount++;
            }
        }
    }
};
</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function DataSource() {
	
};

DataSource.prototype.fetch = function(){

};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

StringDataSource.prototype.fetch = DataSource.prototype.fetch;

function StringDataSource(str) {
	DataSource.prototype.constructor.call(this);

    _.extend(this, Backbone.Events);
	this.str = str;
};

StringDataSource.prototype.fetch = function(async){
	if(async){
		this.trigger('success',this.str);
	}else{
		return this.str;
	}
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

FileDataSource.prototype.fetch = DataSource.prototype.fetch;

function FileDataSource(args) {
    DataSource.prototype.constructor.call(this);

    _.extend(this, Backbone.Events);

    this.file;
    this.maxSize = 500 * 1024 * 1024;
    this.type = 'text';

    //set instantiation args, must be last
    _.extend(this, args);
};

FileDataSource.prototype.error = function () {
    alert("File is too big. Max file size is " + this.maxSize + " bytes");
};

FileDataSource.prototype.fetch = function (async) {
    var _this = this;
    if (this.file.size <= this.maxSize) {
        if (async) {
            var reader = new FileReader();
            reader.onload = function (evt) {
                _this.trigger('success', evt.target.result);
            };
            return this.readAs(this.type, reader);
        } else {
            // FileReaderSync web workers only
            var reader = new FileReaderSync();
            return this.readAs(this.type, reader);
        }
    } else {
        _this.error();
        _this.trigger('error', {sender: this});
    }
};


FileDataSource.prototype.readAs = function (type, reader) {
    switch (type) {
        case 'binary':
            return reader.readAsBinaryString(this.file);
            break;
        case 'text':
        default:
            return reader.readAsText(this.file, "UTF-8");
    }
};</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function NavigationBar(args) {

    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    var _this = this;

    this.id = Utils.genId("NavigationBar");

    this.target;
    this.autoRender = true;

    this.cellBaseHost = 'http://bioinfo.hpc.cam.ac.uk/cellbase';
    this.cellBaseVersion = 'v3';

    this.species = 'Homo sapiens';
    this.increment = 3;
    this.componentsConfig = {
        menuButton: false,
        leftSideButton: false,
        restoreDefaultRegionButton: true,
        regionHistoryButton: true,
        speciesButton: true,
        chromosomesButton: true,
        karyotypeButtonLabel: true,
        chromosomeButtonLabel: true,
        regionButtonLabel: true,
        zoomControl: true,
        windowSizeControl: true,
        positionControl: true,
        moveControl: true,
        autoheightButton: true,
        compactButton: true,
        searchControl: true
    };
    this.zoom = 100;

    this.quickSearchDisplayKey = 'name';


    _.extend(this.componentsConfig, args.componentsConfig);
    delete args.componentsConfig;

    //set instantiation args, must be last
    _.extend(this, args);


    //set new region object
    this.region = new Region(this.region);

    this.currentChromosomeList = [];

    this.on(this.handlers);


    this.els = {};
    this.zoomChanging = false;
    this.regionChanging = false;

    this.rendered = false;
    if (this.autoRender) {
        this.render();
    }
};

NavigationBar.prototype = {

    render: function() {
        var _this = this;


        var HTML = '' +
            '<div title="Restore previous region" style="margin-right: 5px;" id="leftSideButton" class="ocb-ctrl"><i class="fa fa-navicon"></i></div>' +
            '<div id="restoreDefaultRegionButton" class="ocb-ctrl"><i class="fa fa-repeat"></i></div>' +

            '<div title="Region history" class="ocb-dropdown" style="margin-left: 5px">' +
            '   <div tabindex="-1" id="regionHistoryButton" class="ocb-ctrl"><i class="fa fa-history"></i> <i class="fa fa-caret-down"></i></div>' +
            '   <ul id="regionHistoryMenu"></ul>' +
            '</div>' +

            '<div title="Species menu" class="ocb-dropdown" style="margin-left: 5px">' +
            '   <div tabindex="-1" id="speciesButton" class="ocb-ctrl"><span id="speciesText"></span> <i class="fa fa-caret-down"></i></div>' +
            '   <ul id="speciesMenu"></ul>' +
            '</div>' +

            '<div title="Chromosomes menu" class="ocb-dropdown" style="margin-left: 5px">' +
            '   <div tabindex="-1" id="chromosomesButton" class="ocb-ctrl"><span id="chromosomesText"></span> <i class="fa fa-caret-down"></i></div>' +
            '   <ul id="chromosomesMenu" style="height: 200px; overflow-y: auto;"></ul>' +
            '</div>' +

            '<div style="margin-left: 5px; float: left; " >' +
            '   <label title="Toggle karyotype panel" class="ocb-ctrl" id="karyotypeButtonLabel"><input id="karyotypeButton" type="checkbox"><span style="border-right: none"><span class="ocb-icon ocb-icon-karyotype"></span></span></label>' +
            '   <label title="Toggle chromosome panel" class="ocb-ctrl" id="chromosomeButtonLabel"><input id="chromosomeButton" type="checkbox"><span style="border-right: none"><span class="ocb-icon ocb-icon-chromosome"></span></span></label>' +
            '   <label title="Toggle overview panel" class="ocb-ctrl" id="regionButtonLabel"><input id="regionButton" type="checkbox"><span><span class="ocb-icon ocb-icon-region"></span></span></label>' +
            '</div>' +


            '<div id="zoomControl" style="float:left;">' +
            '<div title="Minimum window size" id="zoomMinButton" class="ocb-ctrl" style="margin-left: 5px;border-right: none;">Min</div>' +
            '<div title="Decrease window size" id="zoomOutButton" class="ocb-ctrl"><span class="fa fa-minus"></span></div>' +
            '<div id="progressBarCont" class="ocb-zoom-bar">' +
            '   <div id="progressBar" class="back"></div>' +
            '   <div id="progressBar" class="rect" style="width: ' + this.zoom + '%"></div>' +
            '   <div id="progressBarBall" class="ball" style="left: ' + this.zoom + '%"></div>' +
            '</div>' +
            '<div title="Increase window size" id="zoomInButton" class="ocb-ctrl" style="border-right: none;"><span class="fa fa-plus"></span></div>' +
            '<div title="Maximum window size" id="zoomMaxButton" class="ocb-ctrl">Max</div>' +
            '</div>' +


            '<div title="Window size (Nucleotides)" id="windowSizeControl" style="float:left;margin-left: 5px;">' +
                //'<div class="ocb-ctrl-label" style="border-right: none;">Window size:</div>' +
            '<input id="windowSizeField" class="ocb-ctrl"  type="text" style="width: 70px;">' +
            '</div>' +


            '<div title="Position" id="positionControl" style="float:left;margin-left: 5px">' +
                //'<div class="ocb-ctrl-label" id="regionLabel" style="border-right: none;margin-left: 5px;transition:all 0.5s">Position:</div>' +
            '<input id="regionField" class="ocb-ctrl" placeholder="1:10000-20000" type="text" style="width: 170px;">' +
            '<div id="goButton" class="ocb-ctrl" style="border-left: none;">Go!</div>' +
            '</div>' +


            '<div id="moveControl" style="float:left;font-size:18px;">' +
            '<div id="moveFurtherLeftButton" class="ocb-ctrl" style="border-right: none;margin-left: 5px;"><i class="fa fa-angle-double-left"></i></div>' +
            '<div id="moveLeftButton" class="ocb-ctrl" style="border-right: none;"><i class="fa fa-angle-left"></i></div>' +
            '<div id="moveRightButton" class="ocb-ctrl" style="border-right: none;"><i class="fa fa-angle-right"></i></div>' +
            '<div id="moveFurtherRightButton" class="ocb-ctrl"><i class="fa fa-angle-double-right"></i></div>' +
            '</div>' +


//            '<div id="autoheightButton" class="ocb-ctrl" style="margin-left: 5px;font-size:18px;"><i class="fa fa-compress"></i></div>' +
            '<label class="ocb-ctrl"><input type="checkbox" id="autoheightButton"><span style="margin-left: 5px;font-size:18px;"><i class="fa fa-compress"></i></span></label>' +
//            '<div id="compactButton" class="ocb-ctrl" style="margin-left: 5px;font-size:18px;"><i class="fa fa-expand"></i></div>' +


            '<div id="searchControl" style="float:left;">' +
            //'<div class="ocb-ctrl-label" style="border-right: none;margin-left: 5px;"></div>' +
            '<input id="searchField" class="ocb-ctrl"  list="searchDataList"  placeholder="gene" type="text" style="width: 90px;margin-left: 5px;">' +
            '       <datalist id="searchDataList">' +
            '       </datalist>' +
            '<div id="quickSearchButton" class="ocb-ctrl" style="border-left: none;"><i class="fa fa-search"></i></div>' +
            '</div>' +


            '<div style="float:right;margin-right:10px;" id="menuButton" class="ocb-ctrl"><i class="fa fa-navicon"></i> Configure</div>' +
            '';

        /**************/
        this.div = document.createElement('div');
        this.div.setAttribute('class', "ocb-gv-navigation-bar unselectable");
        this.div.innerHTML = HTML;

        var els = this.div.querySelectorAll('[id]');
        for (var i = 0; i < els.length; i++) {
            var elid = els[i].getAttribute('id');
            if (elid) {
                this.els[elid] = els[i];
            }
        }
        /**************/


        /**Check components config**/
        for (var key in this.componentsConfig) {
            if (!this.componentsConfig[key]) {
                this.els[key].classList.add('hidden');
            }
        }
        /*****/

        this.els.karyotypeButton.checked = (this.karyotypePanelConfig.hidden) ? false : true;
        this.els.chromosomeButton.checked = (this.chromosomePanelConfig.hidden) ? false : true;
        this.els.regionButton.checked = (this.regionPanelConfig.hidden) ? false : true;


        /*** ***/

        this.els.menuButton.addEventListener('click', function(e) {
            _this.trigger('menuButton:click', {clickEvent: e, sender: {}})
        });

        this.els.leftSideButton.addEventListener('click', function(e) {
            _this.trigger('leftSideButton:click', {clickEvent: e, sender: {}})
        });

        this.els.restoreDefaultRegionButton.addEventListener('click', function(e) {
            _this.trigger('restoreDefaultRegion:click', {clickEvent: e, sender: {}})
        });


        this._addRegionHistoryMenuItem(this.region);
        this._setChromosomeMenu();
        this._setSpeciesMenu();
        this.els.chromosomesText.textContent = this.region.chromosome;
        this.els.speciesText.textContent = this.species.scientificName;


        this.els.karyotypeButton.addEventListener('click', function() {
            _this.trigger('karyotype-button:change', {selected: this.checked, sender: _this});
        });
        this.els.chromosomeButton.addEventListener('click', function() {
            _this.trigger('chromosome-button:change', {selected: this.checked, sender: _this});
        });
        this.els.regionButton.addEventListener('click', function() {
            _this.trigger('region-button:change', {selected: this.checked, sender: _this});
        });


        this.els.zoomOutButton.addEventListener('click', function() {
            _this._handleZoomOutButton();
        });
        this.els.zoomInButton.addEventListener('click', function() {
            _this._handleZoomInButton();
        });
        this.els.zoomMaxButton.addEventListener('click', function() {
            _this._handleZoomSlider(100);
        });
        this.els.zoomMinButton.addEventListener('click', function() {
            _this._handleZoomSlider(0);
        });


        var zoomBarMove = function(e) {
            var progressBarCont = _this.els.progressBarCont;
            var br = progressBarCont.getBoundingClientRect();
            var offsetX = e.clientX - br.left;
            var zoom = 100 / parseInt(getComputedStyle(progressBarCont).width) * offsetX;
            if (zoom > 0 && zoom < 100) {
                _this.els.progressBarBall.style.left = zoom + '%';
            }
        };
        this.els.progressBarCont.addEventListener('click', function(e) {
            var br = this.getBoundingClientRect();
            var offsetX = e.clientX - br.left;
            var zoom = 100 / parseInt(getComputedStyle(this).width) * offsetX;
            _this._handleZoomSlider(zoom);

            this.removeEventListener('mousemove', zoomBarMove);
        });
        this.els.progressBarBall.addEventListener('mousedown', function(e) {
            _this.els.progressBarCont.addEventListener('mousemove', zoomBarMove);
        });
        this.els.progressBarBall.addEventListener('mouseleave', function(e) {
            _this.els.progressBarCont.removeEventListener('mousemove', zoomBarMove);
            _this.els.progressBarBall.style.left = _this.zoom + '%';
        });

        this.els.regionField.value = this.region.toString();
        this.els.regionField.addEventListener('keyup', function(event) {
            if (_this._checkRegion(this.value) && event.which === 13) {
                _this._triggerRegionChange({region: new Region(this.value), sender: this});
            }
        });
        this.els.goButton.addEventListener('click', function() {
            var value = _this.els.regionField.value;
            if (_this._checkRegion(value)) {
                _this._triggerRegionChange({region: new Region(value), sender: this});
            }
        });

        this.els.moveFurtherLeftButton.addEventListener('click', function() {
            _this._handleMoveRegion(10);
        });

        this.els.moveFurtherRightButton.addEventListener('click', function() {
            _this._handleMoveRegion(-10);
        });

        this.els.moveLeftButton.addEventListener('click', function() {
            _this._handleMoveRegion(1);
        });

        this.els.moveRightButton.addEventListener('click', function() {
            _this._handleMoveRegion(-1);
        });

//        this.els.autoheightButton.addEventListener('click', function (e) {
//            _this.trigger('autoHeight-button:click', {clickEvent: e, sender: _this});
//        });
        this.els.autoheightButton.addEventListener('click', function() {
            _this.trigger('autoHeight-button:change', {selected: this.checked, sender: _this});
        });

//        this.els.compactButton.addEventListener('click', function (e) {
//        });


        var lastQuery = '';
        this.els.searchField.addEventListener('keyup', function(event) {
            this.classList.remove('error');
            var query = this.value;
            if (query.length > 2 && lastQuery !== query && event.which !== 13) {
                _this._setQuickSearchMenu(query);
                lastQuery = query;
            }
            if (event.which === 13) {
                var item = _this.quickSearchDataset[query];
                if (item) {
                    _this.trigger('quickSearch:select', {item: item, sender: _this});
                } else {
                    this.classList.add('error');
                }
            }
        });

        this.els.quickSearchButton.addEventListener('click', function() {
            _this.els.searchField.classList.remove('error');
            var query = _this.els.searchField.value;
            var item = _this.quickSearchDataset[query];
            if (item) {
                _this.trigger('quickSearch:go', {item: item, sender: _this});
            } else {
                _this.els.searchField.classList.add('error');
            }
        });

        this.els.windowSizeField.value = this.region.length();
        this.els.windowSizeField.addEventListener('keyup', function(event) {
            var value = this.value;
            var pattern = /^([0-9])+$/;
            if (pattern.test(value)) {
                this.classList.remove('error');
                if (event.which === 13) {
                    var regionSize = parseInt(value);
                    var haflRegionSize = Math.floor(regionSize / 2);
                    var region = new Region({
                        chromosome: _this.region.chromosome,
                        start: _this.region.center() - haflRegionSize,
                        end: _this.region.center() + haflRegionSize
                    });
                    _this._triggerRegionChange({region: region, sender: _this})
                }
            } else {
                this.classList.add('error');
            }
        });
        this.rendered = true;
    },
    draw: function() {
        this.targetDiv = (this.target instanceof HTMLElement ) ? this.target : document.querySelector('#' + this.target);
        if (!this.targetDiv) {
            console.log('target not found');
            return;
        }
        this.targetDiv.appendChild(this.div);
    },

    _addRegionHistoryMenuItem: function(region) {
        var _this = this;
        var menuEntry = document.createElement('li');
        menuEntry.textContent = region.toString();
        this.els.regionHistoryMenu.appendChild(menuEntry);
        menuEntry.addEventListener('click', function() {
            _this._triggerRegionChange({region: new Region(this.textContent), sender: _this})
        });
    },

    _setQuickSearchMenu: function(query) {
        if (typeof this.quickSearchResultFn === 'function') {
            while (this.els.searchDataList.firstChild) {
                this.els.searchDataList.removeChild(this.els.searchDataList.firstChild);
            }
            this.quickSearchDataset = {};
            var items = this.quickSearchResultFn(query);
//            for (var i = 0; i < items.length; i++) {
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var value = item[this.quickSearchDisplayKey];
                this.quickSearchDataset[value] = item;
                var menuEntry = document.createElement('option');
                menuEntry.setAttribute('value', value);
                this.els.searchDataList.appendChild(menuEntry);
            }
        } else {
            console.log('the quickSearchResultFn function is not valid');
        }
    },

    _setChromosomeMenu: function() {
        var _this = this;

        while (this.els.chromosomesMenu.firstChild) {
            this.els.chromosomesMenu.removeChild(this.els.chromosomesMenu.firstChild);
        }

        //find species object
        //var list = [];
        //for (var i = 0; i < this.availableSpecies.items.length; i++) {
        //    for (var j = 0; j < this.availableSpecies.items[i].items.length; j++) {
        //        var species = this.availableSpecies.items[i].items[j];
        //        if (species.text === this.species.text) {
        //            list = species.chromosomes;
        //            break;
        //        }
        //    }

        //}
        //for (var i in this.availableSpecies.items) {
        //    for (var j in this.availableSpecies.items[i].items) {
        //        var species = this.availableSpecies.items[i].items[j];
        //        if (species.text === this.species.text) {
        //            list = species.chromosomes;
        //            break;
        //        }
        //    }
        //}

        var list = [];
        for (var chr in this.species.chromosomes) {
            list.push(chr);


            var menuEntry = document.createElement('li');
            menuEntry.textContent = chr;
            this.els.chromosomesMenu.appendChild(menuEntry);

            menuEntry.addEventListener('click', function() {
                var region = new Region({
                    chromosome: this.textContent,
                    start: _this.region.start,
                    end: _this.region.end
                });
                _this._triggerRegionChange({region: region, sender: _this})
            });

        }
        this.currentChromosomeList = list;


        //for (var i in list) {
        //    var menuEntry = document.createElement('li');
        //    menuEntry.textContent = list[i];
        //    this.els.chromosomesMenu.appendChild(menuEntry);
        //
        //    menuEntry.addEventListener('click', function () {
        //        var region = new Region({
        //            chromosome: this.textContent,
        //            start: _this.region.start,
        //            end: _this.region.end
        //        });
        //        _this._triggerRegionChange({region: region, sender: _this})
        //    });
        //}
    },

//    _setSpeciesMenu: function () {
//        var _this = this;
//
//        var createEntry = function (species) {
//            var menuEntry = document.createElement('li');
//            menuEntry.textContent = species.text;
//            _this.els.speciesMenu.appendChild(menuEntry);
//
//            menuEntry.addEventListener('click', function () {
//                _this.species = species;
//                _this.els.speciesText.textContent = this.textContent;
//                _this._setChromosomeMenu();
//                _this.trigger('species:change', {species: species, sender: _this});
//            });
//        };
//        //find species object
//        var list = [];
//        for (var i in this.availableSpecies.items) {
//            for (var j in this.availableSpecies.items[i].items) {
//                var species = this.availableSpecies.items[i].items[j];
//                createEntry(species);
//            }
//        }
//    },
    _setSpeciesMenu: function() {
        var _this = this;

        var createSpeciesEntry = function(species, ul) {
            var menuEntry = document.createElement('li');
            menuEntry.textContent = species.scientificName + ' (' + species.assembly.name + ')';
            ul.appendChild(menuEntry);

            menuEntry.addEventListener('click', function() {
                _this.trigger('species:change', {species: species, sender: _this});
            });
        };

        //var createAssemblyEntry = function(assembly, ul, species) {
        //    var menuEntry = document.createElement('li');
        //    menuEntry.textContent = assembly.name;
        //    ul.appendChild(menuEntry);
        //
        //    menuEntry.addEventListener('click', function() {
        //        _this.trigger('species:change', {species: species, sender: _this});
        //    });
        //};

        var createTaxonomy = function(taxonomy) {
            var menuEntry = document.createElement('li');
            menuEntry.setAttribute('data-sub', true);
            menuEntry.textContent = taxonomy;
            _this.els.speciesMenu.appendChild(menuEntry);

            var ul = document.createElement('ul');
            menuEntry.appendChild(ul);

            return ul;
        };

        //find species object
        //var list = [];
        for (var taxonomy in this.availableSpecies) {
            var taxUl = createTaxonomy(taxonomy);
            for (var i = 0; i < this.availableSpecies[taxonomy].length; i++) {
                var species = this.availableSpecies[taxonomy][i];
                createSpeciesEntry(species, taxUl);
            }
        }
        //for (var i = 0; i < this.availableSpecies.items.length; i++) {
        //    var taxonomy = this.availableSpecies.items[i];
        //    var taxUl = createTaxonomy(taxonomy);
        //
        //    for (var j = 0; j < taxonomy.items.length; j++) {
        //        var species = taxonomy.items[j];
        //        createEntry(species, taxUl);
        //    }
        //}
    },
    _checkRegion: function(value) {
        var reg = new Region(value);
        if (!reg.parse(value) || reg.start < 0 || reg.end < 0 || _.indexOf(this.currentChromosomeList, reg.chromosome) == -1) {
            this.els.regionField.classList.add('error');
            return false;
        } else {
            this.els.regionField.classList.remove('error');
            return true;
        }
    },

    _handleZoomOutButton: function() {
        this._handleZoomSlider(Math.max(0, this.zoom - 5));
    },
    _handleZoomSlider: function(value) {
        var _this = this;
        if (!_this.zoomChanging) {
            _this.zoomChanging = true;
            /**/
            _this.zoom = 5 * (Math.round(value / 5));
            _this.trigger('zoom:change', {zoom: _this.zoom, sender: _this});
            /**/
            setTimeout(function() {
                _this.zoomChanging = false;
            }, 700);
        }
    },
    _handleZoomInButton: function() {
        this._handleZoomSlider(Math.min(100, this.zoom + 5));
    },

    _handleMoveRegion: function(positions) {
        var pixelBase = (this.width - this.svgCanvasWidthOffset) / this.region.length();
        var disp = Math.round((positions * 10) / pixelBase);
        this.region.start -= disp;
        this.region.end -= disp;
        this.els.regionField.value = this.region.toString();
        this.trigger('region:move', {region: this.region, disp: disp, sender: this});
    },

    setVisible: function(obj) {
        for (key in obj) {
            var el = this.els[key];
            if (obj[key]) {
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        }
    },

    setRegion: function(region, zoom) {
        this.region.load(region);
        if (zoom) {
            this.zoom = 5 * (Math.round(zoom / 5));
        }
        this.updateRegionControls();
        this._addRegionHistoryMenuItem(region);
    },
    moveRegion: function(region) {
        this.region.load(region);
        this.els.chromosomesText.textContent = this.region.chromosome;
        this.els.regionField.value = this.region.toString()
    },

    setSpecies: function(species) {
        this.species = species;
        this.els.speciesText.textContent = this.species.scientificName;
        this._setChromosomeMenu();
    },

    setWidth: function(width) {
        this.width = width;
    },
    _triggerRegionChange: function(event) {
        var _this = this;
        if (!this.regionChanging) {
            this.regionChanging = true;
            /**/
            this.trigger('region:change', event);
            /**/
            setTimeout(function() {
                _this.regionChanging = false;
            }, 700);
        } else {
            this.updateRegionControls();
        }
    },
    updateRegionControls: function() {
        this.els.chromosomesText.textContent = this.region.chromosome;
        this.els.regionField.value = this.region.toString();
        this.els.windowSizeField.value = this.region.length();
        this.els.regionField.classList.remove('error');
        this.els.progressBar.style.width = this.zoom + '%';
        this.els.progressBarBall.style.left = this.zoom + '%';
    },
    setCellBaseHost: function(host) {
        this.cellBaseHost = host;
    }

}
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function ChromosomePanel(args) {

    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    this.id = Utils.genId('ChromosomePanel');

    this.target;
    this.autoRender = true;
    this.cellBaseHost = 'http://bioinfo.hpc.cam.ac.uk/cellbase';
    this.cellBaseVersion = 'v3';

    this.pixelBase;
    this.species = 'hsapiens';
    this.width = 600;
    this.height = 75;
    this.collapsed = false;
    this.collapsible = false;
    this.hidden = false;

    //set instantiation args, must be last
    _.extend(this, args);

    //set own region object
    this.region = new Region(this.region);


    this.lastChromosome = "";
    this.data;

    this.on(this.handlers);

    this.regionChanging = false;

    this.rendered = false;
    if (this.autoRender) {
        this.render();
    }
};

ChromosomePanel.prototype = {
    show: function () {
        $(this.div).css({display: 'block'});
        this.hidden = false;
    },
    hide: function () {
        $(this.div).css({display: 'none'});
        this.hidden = true;
    },
    setVisible: function (bool) {
        if (bool) {
            this.show()
        } else {
            this.hide()
        }
    },
    showContent: function () {
        $(this.svg).css({display: 'inline'});
        this.collapsed = false;
        $(this.collapseDiv).removeClass('active');
        $(this.collapseDiv).children().first().removeClass('fa-plus');
        $(this.collapseDiv).children().first().addClass('fa-minus');
    },
    hideContent: function () {
        $(this.svg).css({display: 'none'});
        this.collapsed = true;
        $(this.collapseDiv).addClass('active');
        $(this.collapseDiv).children().first().removeClass('fa-minus');
        $(this.collapseDiv).children().first().addClass('fa-plus');
    },
    setTitle: function (title) {
        if ('titleDiv' in this) {
            $(this.titleTextDiv).html(title);
        }
    },
    setWidth: function (width) {
        this.width = width;
        this.svg.setAttribute("width", width);
//        this.tracksViewedRegion = this.width / Utils.getPixelBaseByZoom(this.zoom);

        if (typeof this.data !== 'undefined') {
            this.clean();
            this._drawSvg(this.data);
        }
    },

    render: function () {
        var _this = this;

        this.div = $('<div id="chromosome-panel"></div>')[0];

        if ('title' in this && this.title !== '') {
            var titleDiv = $('<div id="tl-title" class="ocb-gv-panel-title unselectable"></div>')[0];
            $(this.div).append(titleDiv);

            if (this.collapsible == true) {
                this.collapseDiv = $('<div class="ocb-gv-panel-collapse-control"><span class="fa fa-minus"></span></div>');
                $(titleDiv).dblclick(function () {
                    if (_this.collapsed) {
                        _this.showContent();
                    } else {
                        _this.hideContent();
                    }
                });
                $(this.collapseDiv).click(function () {
                    if (_this.collapsed) {
                        _this.showContent();
                    } else {
                        _this.hideContent();
                    }
                });
                $(titleDiv).append(this.collapseDiv);
            }

            this.titleTextDiv = $('<div class="ocb-gv-panel-text">' + this.title + '</div>');
            $(titleDiv).append(this.titleTextDiv);
        }

        this.svg = SVG.init(this.div, {
            "width": this.width,
            "height": this.height
        });
        $(this.div).addClass('unselectable');

        this.colors = {gneg: "#eeeeee", stalk: "#666666", gvar: "#CCCCCC", gpos25: "silver", gpos33: "lightgrey", gpos50: "gray", gpos66: "dimgray", gpos75: "darkgray", gpos100: "black", gpos: "gray", acen: "blue", clementina: '#ffc967'};


        this.setVisible(!this.hidden);
        this.rendered = true;
    },

    setSpecies: function (species) {
        this.species = species;
    },
    clean: function () {
        $(this.svg).empty();
    },
    draw: function () {
        var _this = this;
        this.targetDiv = ( this.target instanceof HTMLElement ) ? this.target : document.querySelector('#' + this.target);
        if (!this.targetDiv) {
            console.log('target not found');
            return;
        }
        this.targetDiv.appendChild(this.div);

        this.clean();

        CellBaseManager.get({
            host: this.cellBaseHost,
            version: this.cellBaseVersion,
            species: this.species,
            category: 'genomic',
            subCategory: 'chromosome',
            query: this.region.chromosome,
            resource: 'info',
            async: false,
            success: function (data) {
                _this.data = data.response[0].result[0].chromosomes[0];
                _this.data.cytobands.sort(function (a, b) {
                    return (a.start - b.start);
                });
                _this._drawSvg(_this.data);
            }
        });

        this.lastChromosome = this.region.chromosome;

        if (this.collapsed) {
            _this.hideContent();
        }
    },
    _drawSvg: function (chromosome) {
        // This method uses less svg elements
        var _this = this;
        var offset = 20;
        var group = SVG.addChild(_this.svg, "g", {"cursor": "pointer"});
        this.chromosomeLength = chromosome.size;
        this.pixelBase = (this.width - 40) / this.chromosomeLength;

        /**/
        /*Draw Chromosome*/
        /**/
        var backrect = SVG.addChild(group, 'rect', {
            'x': offset,
            'y': 39,
            'width': this.width - 40 + 1,
            'height': 22,
            'fill': '#555555'
        });

        var cytobandsByStain = {};
        var textDrawingOffset = offset;
        for (var i = 0; i < chromosome.cytobands.length; i++) {
            var cytoband = chromosome.cytobands[i];
            cytoband.pixelStart = cytoband.start * this.pixelBase;
            cytoband.pixelEnd = cytoband.end * this.pixelBase;
            cytoband.pixelSize = cytoband.pixelEnd - cytoband.pixelStart;

            if (typeof cytobandsByStain[cytoband.stain] == 'undefined') {
                cytobandsByStain[cytoband.stain] = [];
            }
            cytobandsByStain[cytoband.stain].push(cytoband);

            var middleX = textDrawingOffset + (cytoband.pixelSize / 2);
            var textY =35;
            var text = SVG.addChild(group, "text", {
                "x": middleX,
                "y": textY,
                "font-size": 10,
                "transform": "rotate(-90, " + middleX + ", " + textY + ")",
                "fill": "black"
            });
            text.textContent = cytoband.name;
            textDrawingOffset += cytoband.pixelSize;
        }

        for (var cytobandStain in cytobandsByStain) {
            var cytobands_d = '';
            if (cytobandStain != 'acen') {
                for (var j = 0; j < cytobandsByStain[cytobandStain].length; j++) {
                    var cytoband = cytobandsByStain[cytobandStain][j];
                    cytobands_d += 'M' + (cytoband.pixelStart + offset + 1) + ',50' + ' L' + (cytoband.pixelEnd + offset) + ',50 ';
                }
                var path = SVG.addChild(group, 'path', {
                    "d": cytobands_d,
                    "stroke": this.colors[cytobandStain],
//                "stroke": 'red',
                    "stroke-width": 20,
                    "fill": 'none'
                });
            }
        }

        if (typeof cytobandsByStain['acen'] !== 'undefined') {
            var firstStain = cytobandsByStain['acen'][0];
            var lastStain = cytobandsByStain['acen'][1];
            var backrect = SVG.addChild(group, 'rect', {
                'x': (firstStain.pixelStart + offset + 1),
                'y': 39,
                'width': (lastStain.pixelEnd + offset) - (firstStain.pixelStart + offset + 1),
                'height': 22,
                'fill': 'white'
            });
            var firstStainXStart = (firstStain.pixelStart + offset + 1);
            var firstStainXEnd = (firstStain.pixelEnd + offset);
            var lastStainXStart = (lastStain.pixelStart + offset + 1);
            var lastStainXEnd = (lastStain.pixelEnd + offset);
            var path = SVG.addChild(group, 'path', {
                'd': 'M' + firstStainXStart + ',39' + ' L' + (firstStainXEnd - 5) + ',39 ' + ' L' + firstStainXEnd + ',50 ' + ' L ' + (firstStainXEnd - 5) + ',61 ' + ' L ' + firstStainXStart + ',61 z',
                'fill': this.colors['acen']
            });
            var path = SVG.addChild(group, 'path', {
                'd': 'M' + lastStainXStart + ',50' + ' L' + (lastStainXStart + 5) + ',39 ' + ' L' + lastStainXEnd + ',39 ' + ' L ' + lastStainXEnd + ',61 ' + ' L ' + (lastStainXStart + 5) + ',61 z',
                'fill': this.colors['acen']
            });
        }


        /**/
        /* Resize elements and events*/
        /**/
        var status = '';
        var centerPosition = _this.region.center();
        var pointerPosition = (centerPosition * _this.pixelBase) + offset;
        $(this.svg).on('mousedown', function (event) {
            status = 'setRegion';
        });

        // selection box, will appear when selection is detected
        this.selBox = SVG.addChild(this.svg, "rect", {
            "x": 0,
            "y": 2,
            "stroke-width": "2",
            "stroke": "deepskyblue",
            "opacity": "0.5",
            "fill": "honeydew"
        });


        var positionBoxWidth = _this.region.length() * _this.pixelBase;
        var positionGroup = SVG.addChild(group, 'g');
        this.positionBox = SVG.addChild(positionGroup, 'rect', {
            'x': pointerPosition - (positionBoxWidth / 2),
            'y': 2,
            'width': positionBoxWidth,
            'height': _this.height - 3,
            'stroke': 'orangered',
            'stroke-width': 2,
            'opacity': 0.5,
            'fill': 'navajowhite',
            'cursor': 'move'
        });
        $(this.positionBox).on('mousedown', function (event) {
            status = 'movePositionBox';
        });


        this.resizeLeft = SVG.addChild(positionGroup, 'rect', {
            'x': pointerPosition - (positionBoxWidth / 2),
            'y': 2,
            'width': 7,
            'height': _this.height - 3,
            'opacity': 0.5,
            'fill': 'orangered',
            'visibility': 'hidden'
        });
        $(this.resizeLeft).on('mousedown', function (event) {
            status = 'resizePositionBoxLeft';
        });

        this.resizeRight = SVG.addChild(positionGroup, 'rect', {
            'x': positionBoxWidth - 5,
            'y': 2,
            'width': 7,
            'height': _this.height - 3,
            'opacity': 0.5,
            'fill': 'orangered',
            'visibility': 'hidden'
        });
        $(this.resizeRight).on('mousedown', function (event) {
            status = 'resizePositionBoxRight';
        });

        $(this.positionBox).off('mouseenter');
        $(this.positionBox).off('mouseleave');

        $(positionGroup).mouseenter(function (event) {
            _this._recalculateResizeControls();
            _this._showResizeControls();
        });
        $(positionGroup).mouseleave(function (event) {
            _this._hideResizeControls();
        });


        /*Remove event listeners*/
        $(this.svg).off('contextmenu');
        $(this.svg).off('mousedown');
        $(this.svg).off('mouseup');
        $(this.svg).off('mousemove');
        $(this.svg).off('mouseleave');

        //Prevent browser context menu
        $(this.svg).contextmenu(function (e) {
            e.preventDefault();
        });
        var downY, downX, moveX, moveY, lastX, increment;

        $(this.svg).mousedown(function (event) {

            downX = (event.clientX - $(this).parent().offset().left); //using parent offset works well on firefox and chrome. Could be because it is a div instead of svg
            _this.selBox.setAttribute("x", downX);
            lastX = _this.positionBox.getAttribute("x");
            if (status == '') {
                status = 'setRegion'
            }
            _this._hideResizeControls();
            $(this).mousemove(function (event) {
                moveX = (event.clientX - $(this).parent().offset().left); //using parent offset works well on firefox and chrome. Could be because it is a div instead of svg
                _this._hideResizeControls();
                switch (status) {
                    case 'resizePositionBoxLeft' :
                        var inc = moveX - downX;
                        var newWidth = parseInt(_this.positionBox.getAttribute("width")) - inc;
                        if (newWidth > 0) {
                            _this.positionBox.setAttribute("x", parseInt(_this.positionBox.getAttribute("x")) + inc);
                            _this.positionBox.setAttribute("width", newWidth);
                        }
                        downX = moveX;
                        break;
                    case 'resizePositionBoxRight' :
                        var inc = moveX - downX;
                        SVG
                        var newWidth = parseInt(_this.positionBox.getAttribute("width")) + inc;
                        if (newWidth > 0) {
                            _this.positionBox.setAttribute("width", newWidth);
                        }
                        downX = moveX;
                        break;
                    case 'movePositionBox' :
                        var inc = moveX - downX;
                        _this.positionBox.setAttribute("x", parseInt(_this.positionBox.getAttribute("x")) + inc);
                        downX = moveX;
                        break;
                    case 'setRegion':
                    case 'selectingRegion' :
                        status = 'selectingRegion';
                        if (moveX < downX) {
                            _this.selBox.setAttribute("x", moveX);
                        }
                        _this.selBox.setAttribute("width", Math.abs(moveX - downX));
                        _this.selBox.setAttribute("height", _this.height - 3);
                        break;
                }

            });
        });


        $(this.svg).mouseup(function (event) {

            $(this).off('mousemove');
            if (downX != null) {

                switch (status) {
                    case 'resizePositionBoxLeft' :
                    case 'resizePositionBoxRight' :
                    case 'movePositionBox' :
                        if (moveX != null) {
                            var w = parseInt(_this.positionBox.getAttribute("width"));
                            var x = parseInt(_this.positionBox.getAttribute("x"));

                            var pixS = x;
                            var pixE = x + w;
                            var bioS = (pixS - offset) / _this.pixelBase;
                            var bioE = (pixE - offset) / _this.pixelBase;

                            _this._triggerRegionChange({region: new Region({chromosome: _this.region.chromosome, start: bioS, end: bioE}), sender: _this});
                        }
                        break;
                    case 'setRegion' :
                        if (downX > offset && downX < (_this.width - offset)) {
                            var w = _this.positionBox.getAttribute("width");

                            var pixS = downX - (w / 2);
                            var pixE = downX + (w / 2);
                            var bioS = (pixS - offset) / _this.pixelBase;
                            var bioE = (pixE - offset) / _this.pixelBase;

                            _this._triggerRegionChange({region: new Region({chromosome: _this.region.chromosome, start: bioS, end: bioE}), sender: _this});
                        }
                        break;
                    case 'selectingRegion' :
                        var bioS = (downX - offset) / _this.pixelBase;
                        var bioE = (moveX - offset) / _this.pixelBase;
                        var start = Math.min(bioS, bioE);
                        var end = Math.max(bioS, bioE);

                        _this.selBox.setAttribute("width", 0);
                        _this.selBox.setAttribute("height", 0);
                        _this._triggerRegionChange({region: new Region({chromosome: _this.region.chromosome, start: start, end: end}), sender: _this});
                        break;
                }
                status = '';

            }
            downX = null;
            moveX = null;
            lastX = _this.positionBox.getAttribute("x");
        });
        $(this.svg).mouseleave(function (event) {
            $(this).off('mousemove')
            if (lastX != null) {
                _this.positionBox.setAttribute("x", lastX);
            }
            _this.selBox.setAttribute("width", 0);
            _this.selBox.setAttribute("height", 0);
            downX = null;
            moveX = null;
            lastX = null;
            overPositionBox = false;
            movingPositionBox = false;
            selectingRegion = false;
        });
    },

    _triggerRegionChange: function (event) {
        var _this = this;
        if (!this.regionChanging) {
            this.regionChanging = true;

            /**/
            this._limitRegionToChromosome(event.region);
            this.trigger('region:change', event);
            /**/
            setTimeout(function () {
                _this.regionChanging = false;
            }, 700);
        } else {
            this.updateRegionControls();
        }
    },


    _recalculatePositionBox: function (region) {
        var genomicLength = region.length();
        var pixelWidth = genomicLength * this.pixelBase;
        var x = (region.start * this.pixelBase) + 20;//20 is the margin
        this.positionBox.setAttribute("x", x);
        this.positionBox.setAttribute("width", pixelWidth);
    },
    _recalculateSelectionBox: function (region) {
        var genomicLength = region.length();
        var pixelWidth = genomicLength * this.pixelBase;
        var x = (region.start * this.pixelBase) + 20;//20 is the margin
        this.selBox.setAttribute("x", x);
        this.selBox.setAttribute("width", pixelWidth);
    },
    _recalculateResizeControls: function () {
        var postionBoxX = parseInt(this.positionBox.getAttribute('x'));
        var postionBoxWidth = parseInt(this.positionBox.getAttribute('width'));
        this.resizeLeft.setAttribute('x', postionBoxX - 5);
        this.resizeRight.setAttribute('x', (postionBoxX + postionBoxWidth));
        $(this.resizeLeft).css({"cursor": "ew-resize"});
        $(this.resizeRight).css({"cursor": "ew-resize"});
    },
    _hideResizeControls: function () {
        this.resizeLeft.setAttribute('visibility', 'hidden');
        this.resizeRight.setAttribute('visibility', 'hidden');
    },
    _showResizeControls: function () {
        this.resizeLeft.setAttribute('visibility', 'visible');
        this.resizeRight.setAttribute('visibility', 'visible');
    },
    _limitRegionToChromosome: function (region) {
        region.start = (region.start < 1) ? 1 : region.start;
        region.end = (region.end > this.chromosomeLength) ? this.chromosomeLength : region.end;
    },

    updateRegionControls: function () {
        this.selBox.setAttribute("width", 0);
        this.selBox.setAttribute("height", 0);
        this._recalculatePositionBox(this.region);
        this._recalculateResizeControls();
    },

    setRegion: function (region) {//item.chromosome, item.region

        console.log('region modified chromosome')
        this.region.load(region);
        var needDraw = false;

        if (this.lastChromosome != this.region.chromosome) {
            needDraw = true;
        }
        if (needDraw) {
            this.draw();
        }

        this.updateRegionControls();
    },
    setCellBaseHost: function (host) {
        this.cellBaseHost = host;
    }
};</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function KaryotypePanel(args) {
    // Using Underscore 'extend' function to extend and add Backbone Events

    _.extend(this, Backbone.Events);

    this.target;
    this.autoRender = true;
    this.id = Utils.genId('KaryotypePanel');

    this.cellBaseHost = 'http://bioinfo.hpc.cam.ac.uk/cellbase';
    this.cellBaseVersion = 'v3';

    this.pixelBase;
    this.species;
    this.width = 600;
    this.height = 75;
    this.collapsed = false;
    this.collapsible = true;
    this.hidden = false;


//set instantiation args, must be last
    _.extend(this, args);

    //set own region object
    this.region = new Region(this.region);

    this.lastSpecies = this.species;

    this.chromosomeList;
    this.data2;

    this.on(this.handlers);

    this.regionChanging = false;

    this.rendered = false;
    if (this.autoRender) {
        this.render();
    }
};

KaryotypePanel.prototype = {
    show: function () {
        $(this.div).css({display: 'block'});
        this.hidden = false;
    },
    hide: function () {
        $(this.div).css({display: 'none'});
        this.hidden = true;
    },
    setVisible: function (bool) {
        if (bool) {
            this.show()
        } else {
            this.hide()
        }
    },
    showContent: function () {
        $(this.svg).css({display: 'inline'});
        this.collapsed = false;
        $(this.collapseDiv).removeClass('active');
        $(this.collapseDiv).children().first().removeClass('fa-plus');
        $(this.collapseDiv).children().first().addClass('fa-minus');
    },
    hideContent: function () {
        $(this.svg).css({display: 'none'});
        this.collapsed = true;
        $(this.collapseDiv).addClass('active');
        $(this.collapseDiv).children().first().removeClass('fa-minus');
        $(this.collapseDiv).children().first().addClass('fa-plus');
    },
    setTitle: function (title) {
        if ('titleDiv' in this) {
            $(this.titleTextDiv).html(title);
        }
    },
    setWidth: function (width) {
        this.width = width;
        this.svg.setAttribute("width", width);


        if (typeof this.chromosomeList !== 'undefined') {
            this.clean();
            this._drawSvg(this.chromosomeList, this.data2);
        }
    },

    render: function () {
        var _this = this;

        this.div = $('<div id="karyotype-panel"></div>')[0];

        if ('title' in this && this.title !== '') {

            var titleDiv = $('<div id="tl-title" class="ocb-gv-panel-title unselectable"></div>')[0];
            $(this.div).append(titleDiv);

            if (this.collapsible == true) {
                this.collapseDiv = $('<div class="ocb-gv-panel-collapse-control"><span class="fa fa-minus"></span></div>');
                $(titleDiv).dblclick(function () {
                    if (_this.collapsed) {
                        _this.showContent();
                    } else {
                        _this.hideContent();
                    }
                });
                $(this.collapseDiv).click(function () {
                    if (_this.collapsed) {
                        _this.showContent();
                    } else {
                        _this.hideContent();
                    }
                });
                $(titleDiv).append(this.collapseDiv);
            }

            this.titleTextDiv = $('<div class="ocb-gv-panel-text">' + this.title + '</div>');
            $(titleDiv).append(this.titleTextDiv);
        }

        this.svg = SVG.init(this.div, {
            "width": this.width,
            "height": this.height
        });
        this.markGroup = SVG.addChild(this.svg, "g", {"cursor": "pointer"});
        $(this.div).addClass('unselectable');

        this.colors = {gneg: "white", stalk: "#666666", gvar: "#CCCCCC", gpos25: "silver", gpos33: "lightgrey", gpos50: "gray", gpos66: "dimgray", gpos75: "darkgray", gpos100: "black", gpos: "gray", acen: "blue"};


        this.setVisible(!this.hidden);

        this.rendered = true;
    },

    setSpecies: function (species) {
        this.lastSpecies = this.species;
        this.species = species;
    },
    clean: function () {
        $(this.svg).empty();
    },
    draw: function () {
        var _this = this;
        this.targetDiv = ( this.target instanceof HTMLElement ) ? this.target : document.querySelector('#' + this.target);
        if (!this.targetDiv) {
            console.log('target not found');
            return;
        }
        this.targetDiv.appendChild(this.div);

        this.clean();

        var sortfunction = function (a, b) {
            var IsNumber = true;
            for (var i = 0; i < a.name.length && IsNumber == true; i++) {
                if (isNaN(a.name[i])) {
                    IsNumber = false;
                }
            }
            if (!IsNumber) return 1;
            return (a.name - b.name);
        };

        CellBaseManager.get({
            host: this.cellBaseHost,
            version: this.cellBaseVersion,
            species: this.species,
            category: 'genomic',
            subCategory: 'chromosome',
            resource: 'search',
            // resource: 'all',
            async: false,
            success: function (data) {
                _this.chromosomeList = data.response[0].result[0].chromosomes;
                _this.chromosomeList.sort(sortfunction);
                _this._drawSvg(_this.chromosomeList);
            }
        });

        if (this.collapsed) {
            _this.hideContent();
        }
    },

    _drawSvg: function (chromosomeList) {
        var _this = this;

        var x = 20;
        var xOffset = _this.width / chromosomeList.length;
        var yMargin = 2;

        ///////////
        var biggerChr = 0;
        for (var i = 0, len = chromosomeList.length; i < len; i++) {
            var size = chromosomeList[i].size;
            if (size > biggerChr) {
                biggerChr = size;
            }
        }
        _this.pixelBase = (_this.height - 10) / biggerChr;
        _this.chrOffsetY = {};
        _this.chrOffsetX = {};

        for (var i = 0, len = chromosomeList.length; i < len; i++) { //loop over chromosomes
            var chromosome = chromosomeList[i];

            var chrSize = chromosome.size * _this.pixelBase;
            var y = yMargin + (biggerChr * _this.pixelBase) - chrSize;
            _this.chrOffsetY[chromosome.name] = y;
            var firstCentromere = true;


            var group = SVG.addChild(_this.svg, "g", {"cursor": "pointer", "chr": chromosome.name});
            $(group).click(function (event) {
                var chrClicked = this.getAttribute("chr");
                //			for ( var k=0, len=chromosomeList.length; k<len; k++) {
                //			var offsetX = (event.pageX - $(_this.svg).offset().left);
                //			if(offsetX > _this.chrOffsetX[chromosomeList[k]]) chrClicked = chromosomeList[k];
                //			}

                var offsetY = (event.pageY - $(_this.svg).offset().top);
                //			var offsetY = event.originalEvent.layerY - 3;

                var clickPosition = parseInt((offsetY - _this.chrOffsetY[chrClicked]) / _this.pixelBase);
                var region = new Region({
                    chromosome: chrClicked,
                    start: clickPosition,
                    end: clickPosition
                });
                _this._triggerRegionChange({region: region, sender: _this});
            });

            for (var j = 0, lenJ = chromosome.cytobands.length; j < lenJ; j++) { //loop over chromosome objects
                var cytoband = chromosome.cytobands[j];
                var height = _this.pixelBase * (cytoband.end - cytoband.start);
                var width = 13;

                var color = _this.colors[cytoband.stain];
                if (color == null) color = "purple";

                if (cytoband.stain == "acen") {
                    var points = "";
                    var middleX = x + width / 2;
                    var middleY = y + height / 2;
                    var endX = x + width;
                    var endY = y + height;
                    if (firstCentromere) {
                        points = x + "," + y + " " + endX + "," + y + " " + endX + "," + middleY + " " + middleX + "," + endY + " " + x + "," + middleY;
                        firstCentromere = false;
                    } else {
                        points = x + "," + endY + " " + x + "," + middleY + " " + middleX + "," + y + " " + endX + "," + middleY + " " + endX + "," + endY;
                    }
                    SVG.addChild(group, "polyline", {
                        "points": points,
                        "stroke": "black",
                        "opacity": 0.8,
                        "fill": color
                    });
                } else {
                    SVG.addChild(group, "rect", {
                        "x": x,
                        "y": y,
                        "width": width,
                        "height": height,
                        "stroke": "grey",
                        "opacity": 0.8,
                        "fill": color
                    });
                }

                y += height;
            }
            var text = SVG.addChild(_this.svg, "text", {
                "x": x + 1,
                "y": _this.height,
                "font-size": 9,
                "fill": "black"
            });
            text.textContent = chromosome.name;

            _this.chrOffsetX[chromosome.name] = x;
            x += xOffset;
        }


        this.positionBox = SVG.addChild(this.svg, "line", {
            "x1": 0,
            "y1": 0,
            "x2": 0,
            "y2": 0,
            "stroke": "orangered",
            "stroke-width": 2,
            "opacity": 0.5
        });
        this._recalculatePositionBox(this.region);


        this.rendered = true;
        this.trigger('after:render', {sender: this});
    },


    _triggerRegionChange: function (event) {
        var _this = this;
        if (!this.regionChanging) {
            this.regionChanging = true;
            /**/
            this.trigger('region:change', event);
            /**/
            setTimeout(function () {
                _this.regionChanging = false;
            }, 700);
        } else {
            this.updateRegionControls();
        }
    },
    _recalculatePositionBox: function (region) {
        var centerPosition = region.center();
        var pointerPosition = centerPosition * this.pixelBase + this.chrOffsetY[region.chromosome];
        this.positionBox.setAttribute("x1", this.chrOffsetX[region.chromosome] - 10);
        this.positionBox.setAttribute("x2", this.chrOffsetX[region.chromosome] + 23);
        this.positionBox.setAttribute("y1", pointerPosition);
        this.positionBox.setAttribute("y2", pointerPosition);
    },
    updateRegionControls: function () {
        this._recalculatePositionBox(this.region);
    },

    setRegion: function (region) {//item.chromosome, item.position, item.species
        this.region.load(region);
        var needDraw = false;

        if (this.lastSpecies != this.species) {
            needDraw = true;
            this.lastSpecies = this.species;
        }
        if (needDraw) {
            this.draw();
        }

        this.updateRegionControls();
    },


//    updatePositionBox: function () {
//        this.positionBox.setAttribute("x1", this.chrOffsetX[this.region.chromosome] - 10);
//        this.positionBox.setAttribute("x2", this.chrOffsetX[this.region.chromosome] + 23);
//
//        var centerPosition = Utils.centerPosition(this.region);
//        var pointerPosition = centerPosition * this.pixelBase + this.chrOffsetY[this.region.chromosome];
//        this.positionBox.setAttribute("y1", pointerPosition);
//        this.positionBox.setAttribute("y2", pointerPosition);
//    },

    addMark: function (item) {//item.chromosome, item.position
        var _this = this;

        var mark = function () {
            if (_this.region.chromosome != null && _this.region.start != null) {
                if (_this.chrOffsetX[_this.region.chromosome] != null) {
                    var x1 = _this.chrOffsetX[_this.region.chromosome] - 10;
                    var x2 = _this.chrOffsetX[_this.region.chromosome];
                    var y1 = (_this.region.start * _this.pixelBase + _this.chrOffsetY[_this.region.chromosome]) - 4;
                    var y2 = _this.region.start * _this.pixelBase + _this.chrOffsetY[_this.region.chromosome];
                    var y3 = (_this.region.start * _this.pixelBase + _this.chrOffsetY[_this.region.chromosome]) + 4;
                    var points = x1 + "," + y1 + " " + x2 + "," + y2 + " " + x1 + "," + y3 + " " + x1 + "," + y1;
                    SVG.addChild(_this.markGroup, "polyline", {
                        "points": points,
                        "stroke": "black",
                        "opacity": 0.8,
                        "fill": "#33FF33"
                    });
                }
            }
        };

        if (this.rendered) {
            mark();
        } else {
            _this.on('after:render', function (e) {
                mark();
            });
        }
    },

    unmark: function () {
        $(this.markGroup).empty();
    },

    setCellBaseHost: function (host) {
        this.cellBaseHost = host;
    }

}
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function StatusBar(args) {

    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    var _this = this;

    this.id = Utils.genId("StatusBar");

    this.target;
    this.autoRender = true;

    //set instantiation args, must be last
    _.extend(this, args);

    //set new region object
    this.region = new Region(this.region);

    this.rendered = false;
    if (this.autoRender) {
        this.render();
    }
};

StatusBar.prototype = {
    render: function () {

        this.div = $('<div id="' + this.id + '" class="ocb-gv-status-bar"></div>')[0];

        this.rightDiv = $('<div class="ocb-gv-status-right" id="' + this.id + 'position"</div>')[0];
        this.leftDiv = $('<div class="ocb-gv-status-left" id="' + this.id + 'position"></div>')[0];
        $(this.div).append(this.leftDiv);
        $(this.div).append(this.rightDiv);

        this.mousePositionEl = $('<span id="' + this.id + 'position"></span>')[0];
        this.mousePositionBase = document.createElement('span');
        this.mousePositionBase.style.marginRight = '5px';
        this.mousePositionRegion = document.createElement('span');
        this.mousePositionEl.appendChild(this.mousePositionBase);
        this.mousePositionEl.appendChild(this.mousePositionRegion);

        this.versionEl = $('<span id="' + this.id + 'version">' + this.version + '</span>')[0];
        $(this.rightDiv).append(this.mousePositionEl);
        $(this.leftDiv).append(this.versionEl);

        this.rendered = true;
    },
    draw: function () {
        var _this = this;
        this.targetDiv = (this.target instanceof HTMLElement) ? this.target : document.querySelector('#' + this.target);
        if (!this.targetDiv) {
            console.log('target not found');
            return;
        }
        this.targetDiv.appendChild(this.div);
    },
    setRegion: function (event) {
        this.region.load(event.region);
        this.mousePositionBase.textContent = "";
        this.mousePositionRegion.textContent = this.region.chromosome + ':' + Utils.formatNumber(event.region.center());
    },
    setMousePosition: function (event) {
        this.mousePositionBase.style.color = SEQUENCE_COLORS[event.base];
        this.mousePositionBase.textContent = event.base;

        this.mousePositionRegion.textContent = this.region.chromosome + ':' + Utils.formatNumber(event.mousePos);
    }

}
</script>

<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function TrackListPanel(args) { //parent is a DOM div element
    var _this = this;

    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    this.cellBaseHost = 'http://bioinfo.hpc.cam.ac.uk/cellbase';
    this.cellBaseVersion = 'v3';

    //set default args
    this.target;
    this.autoRender = true;
    this.id = Utils.genId("TrackListPanel");
    this.collapsed = false;
    this.collapsible = false;
    this.hidden = false;

    this.tracks = [];
    this.tracksIndex = {};

    this.parentLayout;
    this.mousePosition;
    this.windowSize;

    this.zoomMultiplier = 1;
    this.showRegionOverviewBox = false;


    this.height = 0;

    //set instantiation args, must be last
    _.extend(this, args);

    //set new region object
    this.region = new Region(this.region);
    this.width -= 18;


    this.status;

    //this region is used to do not modify original region, and will be used by trackSvg
    this.visualRegion = new Region(this.region);

    /********/
    this._setPixelBase();
    /********/

    this.on(this.handlers);

    this.regionChanging = false;

    this.rendered = false;
    if (this.autoRender) {
        this.render();
    }

};

TrackListPanel.prototype = {
    show: function() {
        $(this.div).css({
            display: 'block'
        });
        this.hidden = false;
    },

    hide: function() {
        $(this.div).css({
            display: 'none'
        });
        this.hidden = true;
    },
    setVisible: function(bool) {
        if (bool) {
            this.show()
        } else {
            this.hide()
        }
    },
    setTitle: function(title) {
        if ('titleDiv' in this) {
            $(this.titleDiv).html(title);
        }
    },
    showContent: function() {
        $(this.tlHeaderDiv).css({
            display: 'block'
        });
        $(this.panelDiv).css({
            display: 'block'
        });
        this.collapsed = false;
        $(this.collapseDiv).removeClass('active');
        $(this.collapseDiv).children().first().removeClass('fa-plus');
        $(this.collapseDiv).children().first().addClass('fa-minus');
    },
    hideContent: function() {
        $(this.tlHeaderDiv).css({
            display: 'none'
        });
        $(this.panelDiv).css({
            display: 'none'
        });
        this.collapsed = true;
        $(this.collapseDiv).addClass('active');
        $(this.collapseDiv).children().first().removeClass('fa-minus');
        $(this.collapseDiv).children().first().addClass('fa-plus');
    },
    render: function() {
        var _this = this;

        this.div = document.createElement('div');
        this.div.classList.add('ocb-gv-tracklist')

        this.windowSizeDiv = document.createElement('div');
        this.windowSizeDiv.classList.add('ocb-gv-tracklist-windowsize');

        if ('title' in this && this.title !== '') {

            var titleDiv = document.createElement('div');
            titleDiv.classList.add('ocb-gv-panel-title', 'unselectable');

            titleDiv.appendChild(this.windowSizeDiv);

            if (this.collapsible == true) {
                this.collapseDiv = document.createElement('div');
                this.collapseDiv.classList.add('ocb-gv-panel-collapse-control');

                var collapseSpan = document.createElement('span');
                collapseSpan.classList.add('fa', 'fa-minus');

                this.collapseDiv.appendChild(collapseSpan);

                $(titleDiv).dblclick(function() {
                    if (_this.collapsed) {
                        _this.showContent();
                    } else {
                        _this.hideContent();
                    }
                });
                $(this.collapseDiv).click(function() {
                    if (_this.collapsed) {
                        _this.showContent();
                    } else {
                        _this.hideContent();
                    }
                });
                titleDiv.appendChild(this.collapseDiv);
            }

            var titleTextDiv = document.createElement('div');
            titleTextDiv.classList.add('ocb-gv-panel-text');
            titleTextDiv.textContent = this.title;
            titleDiv.appendChild(titleTextDiv);


            this.div.appendChild(titleDiv);
        }

        var tlHeaderDiv = $('<div id="tl-header" class="unselectable"></div>')[0];

        var panelDiv = $('<div id="tl-panel"></div>')[0];
        $(panelDiv).css({
            position: 'relative',
            width: '100%'
        });


        this.tlTracksDiv = $('<div id="tl-tracks"></div>')[0];
        $(this.tlTracksDiv).css({
            position: 'relative',
            'z-index': 3
        });


        $(this.div).append(tlHeaderDiv);
        $(this.div).append(panelDiv);

        $(panelDiv).append(this.tlTracksDiv);


        //Main SVG and its events

        //Position div
        this.positionDiv = document.createElement('div');
        this.positionDiv.classList.add('ocb-gv-tracklist-position');

        this.positionLeftDiv = document.createElement('div');
        this.positionLeftDiv.classList.add('ocb-gv-tracklist-position-left');
        this.positionNucleotidDiv = document.createElement('div');
        this.positionNucleotidDiv.classList.add('ocb-gv-tracklist-position-mid-nt');
        this.positionMidPosDiv = document.createElement('div');
        this.positionMidPosDiv.classList.add('ocb-gv-tracklist-position-mid-pos');
        this.positionMidDiv = document.createElement('div');
        this.positionMidDiv.classList.add('ocb-gv-tracklist-position-mid');
        this.positionRightDiv = document.createElement('div');
        this.positionRightDiv.classList.add('ocb-gv-tracklist-position-right');

        this.positionDiv.appendChild(this.positionLeftDiv);
        this.positionDiv.appendChild(this.positionNucleotidDiv);
        this.positionMidDiv.appendChild(this.positionNucleotidDiv);
        this.positionMidDiv.appendChild(this.positionMidPosDiv);
        this.positionDiv.appendChild(this.positionMidDiv);
        this.positionDiv.appendChild(this.positionRightDiv);
        tlHeaderDiv.appendChild(this.positionDiv);


        var mid = this.width / 2;
        this._setTextPosition();


        this.centerLine = $('<div id="' + this.id + 'centerLine"></div>')[0];
        $(panelDiv).append(this.centerLine);
        $(this.centerLine).css({
            'z-index': 2,
            'position': 'absolute',
            'left': mid - 1,
            'top': 0,
            'width': Math.floor(this.pixelBase), //this.pixelBase + 1,
            //            'height': '100%',
            'height': 'calc(100% - 8px)',
            'opacity': 0.5,
            'border': '1px solid orangered',
            'background-color': 'orange'
        });


        this.mouseLine = $('<div id="' + this.id + 'mouseLine"></div>')[0];
        $(panelDiv).append(this.mouseLine);
        $(this.mouseLine).css({
            'z-index': 1,
            'position': 'absolute',
            'left': -20.5,
            'top': 0,
            'width': Math.floor(this.pixelBase), //this.pixelBase + 2,
            'height': 'calc(100% - 8px)',
            'border': '1px solid gray',
            'opacity': 0.7,
            'visibility': 'hidden',
            'background-color': 'gainsboro'
        });

        //allow selection in trackSvgLayoutOverview


        var selBox = $('<div id="' + this.id + 'selBox"></div>')[0];
        $(panelDiv).append(selBox);
        $(selBox).css({
            'z-index': 0,
            'position': 'absolute',
            'left': 0,
            'top': 0,
            'height': '100%',
            'border': '2px solid deepskyblue',
            'opacity': 0.5,
            'visibility': 'hidden',
            'background-color': 'honeydew'
        });

        if (this.showRegionOverviewBox) {
            var regionOverviewBoxLeft = $('<div id="' + this.id + 'regionOverviewBoxLeft"></div>')[0];
            var regionOverviewBoxRight = $('<div id="' + this.id + 'regionOverviewBoxRight"></div>')[0];
            $(panelDiv).append(regionOverviewBoxLeft);
            $(panelDiv).append(regionOverviewBoxRight);
            var regionOverviewBoxWidth = this.region.length() * this.pixelBase;
            var regionOverviewDarkBoxWidth = (this.width - regionOverviewBoxWidth) / 2;
            $(regionOverviewBoxLeft).css({
                'z-index': 0,
                'position': 'absolute',
                'left': 1,
                'top': 0,
                'width': regionOverviewDarkBoxWidth,
                'height': 'calc(100% - 8px)',
                //                'border': '1px solid gray',
                'opacity': 0.5,
                //            'visibility': 'hidden',
                'background-color': 'lightgray'
            });
            $(regionOverviewBoxRight).css({
                'z-index': 0,
                'position': 'absolute',
                'left': (regionOverviewDarkBoxWidth + regionOverviewBoxWidth),
                'top': 0,
                'width': regionOverviewDarkBoxWidth,
                'height': 'calc(100% - 8px)',
                //                'border': '1px solid gray',
                'opacity': 0.5,
                //            'visibility': 'hidden',
                'background-color': 'lightgray'
            });
            this.regionOverviewBoxLeft = regionOverviewBoxLeft;
            this.regionOverviewBoxRight = regionOverviewBoxRight;
        }


        $(this.div).mousemove(function(event) {
            var centerPosition = _this.region.center();
            var mid = _this.width / 2;
            var mouseLineOffset = _this.pixelBase / 2;
            var offsetX = (event.clientX - _this.tlTracksDiv.getBoundingClientRect().left);
            //debugger
            var cX = offsetX - mouseLineOffset;
            var rcX = (cX / _this.pixelBase) | 0;
            var pos = (rcX * _this.pixelBase) + (mid % _this.pixelBase) - 1;
            $(_this.mouseLine).css({
                'left': pos
            });
            //
            var posOffset = (mid / _this.pixelBase) | 0;
            _this.mousePosition = centerPosition + rcX - posOffset;
            _this.trigger('mousePosition:change', {
                mousePos: _this.mousePosition,
                chromosome: _this.region.chromosome,
                base: _this.getMousePosition(_this.mousePosition)
            });
        });

        $(this.tlTracksDiv).dblclick(function(event) {
            if (!_this.regionChanging) {
                _this.regionChanging = true;
                /**/
                /**/
                /**/
                var halfLength = _this.region.length() / 2;
                var mouseRegion = new Region({
                    chromosome: _this.region.chromosome,
                    start: _this.mousePosition - halfLength,
                    end: _this.mousePosition + halfLength
                })
                _this.trigger('region:change', {
                    region: mouseRegion,
                    sender: _this
                });
                /**/
                /**/
                /**/
                setTimeout(function() {
                    _this.regionChanging = false;
                }, 700);
            }
        });

        var downX, moveX;
        $(this.tlTracksDiv).mousedown(function(event) {
            $('html').addClass('unselectable');
            //                            $('.qtip').qtip('hide').qtip('disable'); // Hide AND disable all tooltips
            $(_this.mouseLine).css({
                'visibility': 'hidden'
            });

            var mouseState = event.which;
            if (event.ctrlKey) {
                mouseState = 'ctrlKey' + event.which;
            }
            switch (mouseState) {
                case 1: //Left mouse button pressed
                    $(this).css({
                        "cursor": "move"
                    });
                    downX = event.clientX;
                    var lastX = 0;
                    $(this).mousemove(function(event) {
                        var newX = (downX - event.clientX) / _this.pixelBase | 0; //truncate always towards zero
                        if (newX != lastX) {
                            var disp = lastX - newX;
                            var centerPosition = _this.region.center();
                            var p = centerPosition - disp;
                            if (p > 0) { //avoid 0 and negative positions
                                _this.region.start -= disp;
                                _this.region.end -= disp;
                                _this._setTextPosition();
                                //						_this.onMove.notify(disp);
                                _this.trigger('region:move', {
                                    region: _this.region,
                                    disp: disp,
                                    sender: _this
                                });
                                _this.trigger('trackRegion:move', {
                                    region: _this.region,
                                    disp: disp,
                                    sender: _this
                                });
                                lastX = newX;
                                //_this.setNucleotidPosition(p);
                            }
                        }
                    });

                    break;
                case 2: //Middle mouse button pressed
                case 'ctrlKey1': //ctrlKey and left mouse button
                    $(selBox).css({
                        'visibility': 'visible'
                    });
                    $(selBox).css({
                        'width': 0
                    });
                    downX = (event.pageX - $(_this.tlTracksDiv).offset().left);
                    $(selBox).css({
                        "left": downX
                    });
                    $(this).mousemove(function(event) {
                        moveX = (event.pageX - $(_this.tlTracksDiv).offset().left);
                        if (moveX < downX) {
                            $(selBox).css({
                                "left": moveX
                            });
                        }
                        $(selBox).css({
                            "width": Math.abs(moveX - downX)
                        });
                    });


                    break;
                case 3: //Right mouse button pressed
                    break;
                default: // other button?
            }


        });

        $(this.tlTracksDiv).mouseup(function(event) {
            $('html').removeClass("unselectable");
            $(this).css({
                "cursor": "default"
            });
            $(_this.mouseLine).css({
                'visibility': 'visible'
            });
            $(this).off('mousemove');

            var mouseState = event.which;
            if (event.ctrlKey) {
                mouseState = 'ctrlKey' + event.which;
            }
            switch (mouseState) {
                case 1: //Left mouse button pressed

                    break;
                case 2: //Middle mouse button pressed
                case 'ctrlKey1': //ctrlKey and left mouse button
                    $(selBox).css({
                        'visibility': 'hidden'
                    });
                    $(this).off('mousemove');
                    if (downX != null && moveX != null) {
                        var ss = downX / _this.pixelBase;
                        var ee = moveX / _this.pixelBase;
                        ss += _this.visualRegion.start;
                        ee += _this.visualRegion.start;
                        _this.region.start = parseInt(Math.min(ss, ee));
                        _this.region.end = parseInt(Math.max(ss, ee));
                        _this.trigger('region:change', {
                            region: _this.region,
                            sender: _this
                        });
                        moveX = null;
                    } else if (downX != null && moveX == null) {
                        var mouseRegion = new Region({
                            chromosome: _this.region.chromosome,
                            start: _this.mousePosition,
                            end: _this.mousePosition
                        })
                        _this.trigger('region:change', {
                            region: mouseRegion,
                            sender: _this
                        });
                    }
                    break;
                case 3: //Right mouse button pressed
                    break;
                default: // other button?
            }

        });

        $(this.tlTracksDiv).mouseleave(function(event) {
            $(this).css({
                "cursor": "default"
            });
            $(_this.mouseLine).css({
                'visibility': 'hidden'
            });
            $(this).off('mousemove');
            $("body").off('keydown.genomeViewer');

            $(selBox).css({
                'visibility': 'hidden'
            });
            downX = null;
            moveX = null;
        });

        $(this.tlTracksDiv).mouseenter(function(e) {
            //            $('.qtip').qtip('enable'); // To enable them again ;)
            $(_this.mouseLine).css({
                'visibility': 'visible'
            });
            $("body").off('keydown.genomeViewer');
            enableKeys();
        });

        var enableKeys = function() {
            //keys
            $("body").bind('keydown.genomeViewer', function(e) {
                var disp = 0;
                switch (e.keyCode) {
                    case 37: //left arrow
                        if (e.ctrlKey) {
                            disp = Math.round(100 / _this.pixelBase);
                        } else {
                            disp = Math.round(10 / _this.pixelBase);
                        }
                        break;
                    case 39: //right arrow
                        if (e.ctrlKey) {
                            disp = Math.round(-100 / _this.pixelBase)
                        } else {
                            disp = Math.round(-10 / _this.pixelBase);
                        }
                        break;
                }
                if (disp != 0) {
                    _this.region.start -= disp;
                    _this.region.end -= disp;
                    _this._setTextPosition();
                    //					_this.onMove.notify(disp);
                    _this.trigger('region:move', {
                        region: _this.region,
                        disp: disp,
                        sender: _this
                    });
                    _this.trigger('trackRegion:move', {
                        region: _this.region,
                        disp: disp,
                        sender: _this
                    });
                }
            });
        };

        this.tlHeaderDiv = tlHeaderDiv;
        this.panelDiv = panelDiv;


        this.setVisible(!this.hidden);
        this.rendered = true;
    },

    setHeight: function(height) {
        //        this.height=Math.max(height,60);
        //        $(this.tlTracksDiv).css('height',height);
        //        //this.grid.setAttribute("height",height);
        //        //this.grid2.setAttribute("height",height);
        //        $(this.centerLine).css("height",parseInt(height));//25 es el margen donde esta el texto de la posicion
        //        $(this.mouseLine).css("height",parseInt(height));//25 es el margen donde esta el texto de la posicion
    },

    setWidth: function(width) {
        console.log('trackListPanel setWidth ------\x3e '+ width);
        this.width = width - 18;
    },

    highlight: function(event) {
        this.trigger('trackFeature:highlight', event)
    },


    moveRegion: function(event) {
        this.region.load(event.region);
        this.visualRegion.load(event.region);
        this._setTextPosition();
        this.trigger('trackRegion:move', event);
    },

    setSpecies: function(species) {
        this.species = species;
        //        this.trigger('trackSpecies:change', {species: species, sender: this});

        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            track.setSpecies(this.species);

        }
    },

    setRegion: function(region) { //item.chromosome, item.position, item.species
        console.log('trackListPanel setRegion region ------\x3e '+ region);
        console.log('trackListPanel setRegion width ------\x3e '+ this.width);
        var _this = this;
        var mid = this.width / 2;
        this.region.load(region);
        this.visualRegion.load(region);
        this._setPixelBase();
        //get pixelbase by Region


        $(this.centerLine).css({
            'left': mid - 1,
            'width': this.pixelBase
        });
        $(this.mouseLine).css({
            'width': this.pixelBase
        });

        this._setTextPosition();

        if (this.showRegionOverviewBox) {
            var regionOverviewBoxWidth = this.region.length() * this.pixelBase;
            var regionOverviewDarkBoxWidth = (this.width - regionOverviewBoxWidth) / 2;
            $(this.regionOverviewBoxLeft).css({
                'width': regionOverviewDarkBoxWidth
            });
            $(this.regionOverviewBoxRight).css({
                'left': (regionOverviewDarkBoxWidth + regionOverviewBoxWidth),
                'width': regionOverviewDarkBoxWidth
            });
        }


        this.trigger('window:size', {
            windowSize: this.windowSize
        });

        //        if (region.species != null) {
        //            //check species and modify CellBaseAdapter, clean cache
        //            for (i in this.tracks) {
        //                if (this.tracks[i].trackData.adapter instanceof CellBaseAdapter ||
        //                    this.tracks[i].trackData.adapter instanceof SequenceAdapter
        //                    ) {
        //                    this.tracks[i].trackData.adapter.species = region.species;
        //                    //this.tracks[i].trackData.adapter.featureCache.clear();
        //
        //                    this.tracks[i].trackData.adapter.clearData();
        //                }
        //            }
        //        }
        this.trigger('trackRegion:change', {
            region: this.visualRegion,
            sender: this
        })

        this.positionNucleotidDiv.textContent = ""; //remove base char, will be drawn later if needed

        this.status = 'rendering';

        //        this.onRegionChange.notify();

        //this.minRegionRect.setAttribute("width",this.minRectWidth);
        //this.minRegionRect.setAttribute("x",(this.width/2)-(this.minRectWidth/2)+6);
    },

    draw: function() {
        var _this = this;
        this.targetDiv = (this.target instanceof HTMLElement) ? this.target : document.querySelector('#' + this.target);
        if (!this.targetDiv) {
            console.log('target not found');
            return;
        }
        this.targetDiv.appendChild(this.div);

        this.trigger('track:draw', {
            sender: this
        });
    },
    _checkAllTrackStatus: function(status) {
        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            if (track.status != status) return false;
        }
        return true;
    },
    checkTracksReady: function() {
        return this._checkAllTrackStatus('ready');
        //        if (this._checkAllTrackStatus('ready')) {
        //            this.status = 'ready';
        //            console.log('all ready')
        //            this.trigger('tracks:ready', {sender: this});
        //        }
        //        var checkStatus = function () {
        //            if (checkAllTrackStatus('ready')) {
        //                _this.trigger('tracks:ready', {sender: _this});
        //            } else {
        //                setTimeout(checkStatus, 100);
        //            }
        //        };
        //        setTimeout(checkStatus, 10);
    },
    addTrack: function(track) {
        if (_.isArray(track)) {
            for (var i in track) {
                this._addTrack(track[i]);
            }
        } else {
            this._addTrack(track);
        }
    },
    _addTrack: function(track) {
        if (!this.rendered) {
            console.info(this.id + ' is not rendered yet');
            return;
        }
        var _this = this;

        if (track == null) {
            return false
        }
        // Check if already exists
        if (this.containsTrack(track)) {
            return false;
        }


        var length = this.tracks.push(track);
        var insertPosition = length - 1;
        this.tracksIndex[track.id] = insertPosition;


        if (typeof track.dataAdapter.host === 'undefined') {
            track.dataAdapter.host = this.cellBaseHost;
        }
        if (typeof track.dataAdapter.version === 'undefined') {
            track.dataAdapter.version = this.cellBaseVersion;
        }
        track.set('pixelBase', this.pixelBase);
        track.set('region', this.visualRegion);
        track.set('width', this.width);
        track.setSpecies(this.species);

        track.set('trackListPanel', this);

        // Track must be initialized after we have created
        // de DIV element in order to create the elements in the DOM
        if (!track.rendered) {
            track.render(this.tlTracksDiv);
        }

        // Once tack has been initialize we can call draw() function
        track.draw();


        //trackEvents
        track.set('track:draw', function(event) {
            track.draw();
        });


        //        track.set('trackSpecies:change', function (event) {
        //            track.setSpecies(event.species);
        //        });


        track.set('trackRegion:change', function(event) {
          console.log('trackListPanel trackRegion:change region ------\x3e '+ event.region);
          console.log('trackListPanel trackRegion:change width ------\x3e '+ _this.width);
            track.setWidth(_this.width);
            track.set('pixelBase', _this.pixelBase);
            track.set('region', event.region);
            track.draw();
        });


        track.set('trackRegion:move', function(event) {
            track.set('region', event.region);
            track.set('pixelBase', _this.pixelBase);
            track.move(event.disp);
        });


        //track.set('trackWidth:change', function (event) {
        //    track.setWidth(event.width);
        //    track.set('pixelBase', _this.pixelBase);
        //    track.draw();
        //});


        track.set('trackFeature:highlight', function(event) {
            var attrName = event.attrName || 'feature_id';
            if ('attrValue' in event) {
                event.attrValue = ($.isArray(event.attrValue)) ? event.attrValue : [event.attrValue];
                for (var key in event.attrValue) {
                    var queryStr = attrName + '~=' + event.attrValue[key];
                    var group = $(track.div).find('g[' + queryStr + ']')
                    $(group).each(function() {
                        var animation = $(this).find('animate');
                        if (animation.length == 0) {
                            animation = SVG.addChild(this, 'animate', {
                                'attributeName': 'opacity',
                                'attributeType': 'XML',
                                'begin': 'indefinite',
                                'from': '0.0',
                                'to': '1',
                                'begin': '0s',
                                'dur': '0.5s',
                                'repeatCount': '5'
                            });
                        } else {
                            animation = animation[0];
                        }
                        var y = $(group).find('rect').attr("y");
                        $(track.div).scrollTop(y);
                        animation.beginElement();
                    });
                }
            }
        });

        track.on('track:close', function(event) {
            _this.removeTrack(event.sender);
        });
        track.on('track:up', function(event) {
            _this._reallocateAbove(event.sender);
        });
        track.on('track:down', function(event) {
            _this._reallocateUnder(event.sender);
        });

        this.on('track:draw', track.get('track:draw'));
        //        this.on('trackSpecies:change', track.get('trackSpecies:change'));
        this.on('trackRegion:change', track.get('trackRegion:change'));
        this.on('trackRegion:move', track.get('trackRegion:move'));
        //this.on('trackWidth:change', track.get('trackWidth:change'));
        this.on('trackFeature:highlight', track.get('trackFeature:highlight'));

        //        track.on('track:ready', function () {
        //            _this.checkTracksReady();
        //        });
    },
    toggleAutoHeight: function(bool) {
        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            track.toggleAutoHeight(bool);
        }
    },
    updateHeight: function() {
        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            track.updateHeight(true);
        }
    },

    containsTrack: function(track) {
        if (typeof this.tracksIndex[track.id] !== 'undefined') {
            return true;
        } else {
            return false;
        }
    },
    getTrackIndex: function(track) {
        return this.tracksIndex[track.id];
    },
    _updateTracksIndex: function() {
        //update index with correct index after splice
        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            this.tracksIndex[track.id] = i;
        }
    },
    refreshTracksDom: function() {
        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            $(track.div).detach();
            $(this.tlTracksDiv).append(track.div);
        }
        this.trigger('tracks:refresh', {
            sender: this
        });
    },
    removeTrack: function(track) {
        if (!this.containsTrack(track)) {
            return false;
        }
        // first hide the track
        this.hideTrack(track);
        track.remove();

        var index = this.getTrackIndex(track);
        // remove track from list and hash data
        this.tracks.splice(index, 1)[0];
        delete this.tracksIndex[track.id];
        this._updateTracksIndex();

        // delete listeners

        track.off('track:close');
        track.off('track:up');
        track.off('track:down');


        this.off('track:draw', track.get('track:draw'));
        //        this.off('trackSpecies:change', track.get('trackSpecies:change'));
        this.off('trackRegion:change', track.get('trackRegion:change'));
        this.off('trackRegion:move', track.get('trackRegion:move'));
        //this.off('trackWidth:change', track.set('trackWidth:change'));
        this.off('trackFeature:highlight', track.get('trackFeature:highlight'));

        this.refreshTracksDom();
        return track;
    },

    restoreTrack: function(track, index) {
        if (this.containsTrack((track))) {
            return false;
        }

        this.addTrack(track);
        if (typeof index !== 'undefined') {
            this.setTrackIndex(track, index);
        }
        track.show();
        this.refreshTracksDom();
    },


    //This routine is called when track order is modified
    _reallocateAbove: function(track) {
        if (!this.containsTrack((track))) {
            return false;
        }

        var i = this.getTrackIndex(track);
        console.log(i + " wants to move up");
        if (i > 0) {
            var aboveTrack = this.tracks[i - 1];
            var underTrack = this.tracks[i];

            this.tracks[i] = aboveTrack;
            this.tracks[i - 1] = underTrack;
            this.tracksIndex[aboveTrack.id] = i;
            this.tracksIndex[underTrack.id] = i - 1;
            this.refreshTracksDom();
        } else {
            console.log("is at top");
        }
    },

    //This routine is called when track order is modified
    _reallocateUnder: function(track) {
        if (!this.containsTrack((track))) {
            return false;
        }

        var i = this.getTrackIndex(track);
        console.log(i + " wants to move down");
        if (i + 1 < this.tracks.length) {
            var aboveTrack = this.tracks[i];
            var underTrack = this.tracks[i + 1];

            this.tracks[i] = underTrack;
            this.tracks[i + 1] = aboveTrack;
            this.tracksIndex[underTrack.id] = i;
            this.tracksIndex[aboveTrack.id] = i + 1;
            this.refreshTracksDom();
        } else {
            console.log("is at bottom");
        }
    },

    setTrackIndex: function(track, newIndex) {
        if (!this.containsTrack((track))) {
            return false;
        }

        var oldIndex = this.getTrackIndex(track);

        //remove track from old index
        this.tracks.splice(oldIndex, 1)[0];

        //add track at new Index
        this.tracks.splice(newIndex, 0, track);

        this._updateTracksIndex();

        //update track div positions
        this.refreshTracksDom();
    },
    swapTracks: function(t1, t2) {
        if (!this.containsTrack((t1))) {
            return false;
        }
        if (!this.containsTrack((t2))) {
            return false;
        }
        var oldIndex1 = this.getTrackIndex(t1);
        var oldIndex2 = this.getTrackIndex(t2);

        this.tracks[oldIndex1] = t2;
        this.tracks[oldIndex2] = t1;
        this.tracksIndex[t1.id] = oldIndex2;
        this.tracksIndex[t2.id] = oldIndex1;
        this.refreshTracksDom();
    },

    scrollToTrack: function(track) {
        if (!this.containsTrack((track))) {
            return false;
        }

        var y = $(track.div).position().top;
        $(this.tlTracksDiv).scrollTop(y);
    },


    hideTrack: function(track) {
        if (!this.containsTrack((track))) {
            return false;
        }
        track.hide();
        this.refreshTracksDom();
    },

    showTrack: function(track) {
        if (!this.containsTrack((track))) {
            return false;
        }
        track.show();
        this.refreshTracksDom();
    },
    _setPixelBase: function() {
        this.pixelBase = this.width / this.region.length();
        this.pixelBase = this.pixelBase / this.zoomMultiplier;
        this.halfVirtualBase = (this.width * 3 / 2) / this.pixelBase;
    },

    _setTextPosition: function() {
        var centerPosition = this.region.center();
        var baseLength = parseInt(this.width / this.pixelBase); //for zoom 100
        var aux = Math.ceil((baseLength / 2) - 1);
        this.visualRegion.start = Math.floor(centerPosition - aux);
        this.visualRegion.end = Math.floor(centerPosition + aux);

        this.positionMidPosDiv.textContent = Utils.formatNumber(centerPosition);
        this.positionLeftDiv.textContent = Utils.formatNumber(this.visualRegion.start);
        this.positionRightDiv.textContent = Utils.formatNumber(this.visualRegion.end);


        this.windowSize = 'Window size: ' + Utils.formatNumber(this.visualRegion.length()) + ' nts';
        this.windowSizeDiv.innerHTML = this.windowSize;
    },

    getTrackById: function(trackId) {
        if (typeof this.tracksIndex[trackId] !== 'undefined') {
            var i = this.tracksIndex[trackId];
            return this.tracks[i];
        }
    },
    getSequenceTrack: function() {
        //if multiple, returns the first found
        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            if (track.renderer instanceof SequenceRenderer) {
                return track;
            }
        }
        return;
    },

    getMousePosition: function(position) {
        var base = '';
        if (position > 0) {
            base = this.getSequenceNucleotid(position);
        }
        //        this.mouseLine.setAttribute('stroke',SEQUENCE_COLORS[base]);
        //        this.mouseLine.setAttribute('fill',SEQUENCE_COLORS[base]);
        return base;
    },

    getSequenceNucleotid: function(position) {
        var seqTrack = this.getSequenceTrack();
        if (seqTrack) {
            var el = seqTrack.svgCanvasFeatures.querySelector('text[data-pos="' + position + '"]');
            if (el) {
                return el.textContent;
            }
        }
        return '';
    },

    setNucleotidPosition: function(position) {
        var base = this.getSequenceNucleotid(position);
        this.positionNucleotidDiv.style.color = SEQUENCE_COLORS[base];
        this.positionNucleotidDiv.textContent = base;
    },

    setCellBaseHost: function(host) {
        this.cellBaseHost = host;
        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            if (track.dataAdapter instanceof CellBaseAdapter) {
                track.dataAdapter.setHost(this.cellBaseHost);
            }
        }
    },
    deleteTracksCache:function(){
        for (var i = 0; i < this.tracks.length; i++) {
            var track = this.tracks[i];
            if(track.dataAdapter.deleteCache != null){
                track.dataAdapter.deleteCache()
            }
        }
    }

};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function Track(args) {

    this.id = Utils.genId('track');
    this.dataAdapter;
    this.renderer;
    this.histogramRendererName = "HistogramRenderer";
    this.resizable = true;
    this.autoHeight = false;
    this.targetId;
    this.title;
    this.minHistogramRegionSize = 300000000;
    this.maxLabelRegionSize = 300000000;
    this.width = 200;
    this.height = 100;
    this.visibleRegionSize;
    this.visible = true;
    this.contentVisible = true;
    this.closable = false;
    this.fontClass = 'ocb-font-roboto ocb-font-size-14';
    this.externalLink = '';

    _.extend(this, args);

    this.pixelBase;
    this.svgCanvasWidth = 500000; //mesa
    this.pixelPosition = this.svgCanvasWidth / 2;
    this.svgCanvasOffset;
    //    this.svgCanvasFeatures;
    this.status;
    this.histogram;
    this.histogramLogarithm;
    this.histogramMax;
    this.interval;

    this.svgCanvasLeftLimit;
    this.svgCanvasRightLimit;


    this.invalidZoomText;

    this.renderedArea = {}; //used for renders to store binary trees
    this.chunksDisplayed = {}; //used to avoid painting multiple times features contained in more than 1 chunk

    if ('handlers' in this) {
        for (eventName in this.handlers) {
            this.on(eventName, this.handlers[eventName]);
        }
    }

    this.rendered = false;
    if (this.autoRender) {
        this.render();
    }
};

Track.prototype = {

    get: function(attr) {
        return this[attr];
    },

    set: function(attr, value) {
        this[attr] = value;
    },
    hide: function() {
        this.visible = false;
        this.div.classList.add('hidden');
    },
    show: function() {
        this.visible = true;
        this.div.classList.remove('hidden');
        this.updateHeight();
    },
    toggle: function() {
        if (this.visible) {
            this.hide();
        } else {
            this.show();

        }
    },
    remove: function() {
        $(this.div).remove();
    },
    hideContent: function() {
        this.contentVisible = false;
        this.contentDiv.classList.add('hidden');
        this.resizeDiv.classList.add('hidden');

        this.iToggleEl.classList.remove('fa-minus');
        this.iToggleEl.classList.add('fa-plus');
    },
    showContent: function() {
        this.contentVisible = true;
        this.contentDiv.classList.remove('hidden');
        this.resizeDiv.classList.remove('hidden');

        this.iToggleEl.classList.remove('fa-plus');
        this.iToggleEl.classList.add('fa-minus');
        this.updateHeight();
    },
    toggleContent: function() {
        if (this.contentVisible) {
            this.hideContent();
        } else {
            this.showContent();

        }
    },
    close: function() {
        this.trigger('track:close', {
            sender: this
        });
    },
    up: function() {
        this.trigger('track:up', {
            sender: this
        });
    },
    down: function() {
        this.trigger('track:down', {
            sender: this
        });
    },
    setSpecies: function(species) {
        this.species = species;
        this.dataAdapter.setSpecies(this.species);
    },

    setWidth: function(width) {
        this._setWidth(width);
    },
    _setWidth: function(width) {
        this.width = width;
    },

    updateHeight: function() {
        this._updateHeight();
    },
    _updateHeight: function() {
        $(this.contentDiv).css({
            'height': this.height + 10
        });
    },
    enableAutoHeight: function() {
        console.log('enable autoHeigth');
        this.autoHeight = true;
        this.updateHeight();
    },
    disableAutoHeight: function() {
        console.log('disable autoHeigth');
        this.autoHeight = false;
        this.updateHeight();
    },
    toggleAutoHeight: function(bool) {
        if (bool == true) {
            this.enableAutoHeight();
            return;
        } else if (bool == false) {
            this.disableAutoHeight();
            return;
        }
        if (this.autoHeight == true) {
            this.disableAutoHeight();
            return;
        } else if (this.autoHeight == false) {
            this.enableAutoHeight();
            return;
        }
    },
    setTitle: function(title) {
        $(this.titleText).html(title);
    },

    setLoading: function(bool) {
        if (bool) {
            this.status = "rendering";
            $(this.loadingEl).html('&nbsp; &nbsp;<i class="fa fa-spinner fa-spin"></i> Loading...</span>');
        } else {
            this.status = "ready";
            $(this.loadingEl).html('');
        }
    },

    updateHistogramParams: function() {
        if (this.region.length() > this.minHistogramRegionSize) {
            this.histogram = true;
            this.histogramLogarithm = true;
            this.histogramMax = 500;
            this.interval = Math.ceil(10 / this.pixelBase); //server interval limit 512
            $(this.histogramEl).html('&nbsp;<i class="fa fa-signal"></i>');
        } else {
            this.histogram = undefined;
            this.histogramLogarithm = undefined;
            this.histogramMax = undefined;
            this.interval = undefined;
            $(this.histogramEl).html('');
        }

        //        if (this.histogramRenderer) {
        //            if (this.zoom <= this.histogramZoom) {
        //                this.histogramGroup.setAttribute('visibility', 'visible');
        //            } else {
        //                this.histogramGroup.setAttribute('visibility', 'hidden');
        //            }
        //        }
    },
    clean: function() {
        this._clean();
    },
    _clean: function() {
        //Must be called on child clean method
        this.chunksDisplayed = {};
        this.renderedArea = {};
    },
    initializeDom: function(targetId) {
        this._initializeDom(targetId);
    },
    _initializeDom: function(targetId) {

        var _this = this;
        var div = $('<div id="' + this.id + '-div"></div>')[0];
        div.classList.add('ocb-gv-track');
        var titleBarHtml = '';
        titleBarHtml += '   <div class="ocb-gv-track-title">';
        //      titleBarHtml+=       '   <button id="configBtn" type="button" class="btn btn-xs btn-primary"><span class="glyphicon glyphicon-cog"></span></button>' ;
        titleBarHtml += '   <div class="ocb-gv-track-title-el">';
        titleBarHtml += '       <span class="ocb-gv-track-title-text">' + this.title + '</span>';
        titleBarHtml += '       <span class="ocb-gv-track-title-histogram"></span>';
        titleBarHtml += '       <span class="ocb-gv-track-title-toggle"><i class="fa fa-minus"></i></span>';
        titleBarHtml += '       <span class="ocb-gv-track-title-down"><i class="fa fa-chevron-down"></i></span>';
        titleBarHtml += '       <span class="ocb-gv-track-title-up"><i class="fa fa-chevron-up"></i></span>';

        if (this.closable == true) {
            titleBarHtml += '       <span class="ocb-gv-track-title-close"><i class="fa fa-times"></i></span>';
        }

        if (this.externalLink !== '') {
            titleBarHtml += '       <span class="ocb-gv-track-title-external-link"><i class="fa fa-external-link"></i></span>';
        }

        titleBarHtml += '       <span class="ocb-gv-track-title-loading"></span>';
        titleBarHtml += '   </div>';
        titleBarHtml += '   </div>';


        var titleBardiv = $(titleBarHtml)[0];


        if (typeof this.title === 'undefined') {
            $(titleBardiv).addClass("hidden");
        }

        var titlediv = titleBardiv.querySelector('.ocb-gv-track-title');
        this.titleEl = titleBardiv.querySelector('.ocb-gv-track-title-el');

        this.titleText = titleBardiv.querySelector('.ocb-gv-track-title-text');
        this.histogramEl = titleBardiv.querySelector('.ocb-gv-track-title-histogram');
        this.toggleEl = titleBardiv.querySelector('.ocb-gv-track-title-toggle');
        this.iToggleEl = this.toggleEl.querySelector('i');
        this.loadingEl = titleBardiv.querySelector('.ocb-gv-track-title-loading');
        this.closeEl = titleBardiv.querySelector('.ocb-gv-track-title-close');
        this.upEl = titleBardiv.querySelector('.ocb-gv-track-title-up');
        this.downEl = titleBardiv.querySelector('.ocb-gv-track-title-down');
        this.externalLinkEl = titleBardiv.querySelector('.ocb-gv-track-title-external-link');

        var contentDiv = $('<div id="' + this.id + '-svgdiv"></div>')[0];
        $(contentDiv).css({
            'position': 'relative',
            'box-sizing': 'boder-box',
            'z-index': 3,
            'height': this.height,
            'overflow-y': (this.resizable) ? 'auto' : 'hidden',
            'overflow-x': 'hidden'
        });

        var resizediv = $('<div id="' + this.id + '-resizediv" class="ocb-track-resize"></div>')[0];

        $(targetId).addClass("unselectable");
        $(targetId).append(div);
        $(div).append(titleBardiv);
        $(div).append(contentDiv);
        $(div).append(resizediv);


        /** title div **/
        $(titleBardiv).css({
                'padding': '4px'
            })
            .on('dblclick', function(e) {
                e.stopPropagation();
            });
        //        $(this.titleText).click(function (e) {
        //            _this.toggleContent();
        //        });
        $(this.toggleEl).click(function(e) {
            _this.toggleContent();
        });
        $(this.closeEl).click(function(e) {
            _this.close();
        });
        $(this.upEl).click(function(e) {
            _this.up();
        });
        $(this.downEl).click(function(e) {
            _this.down();
        });
        $(this.externalLinkEl).click(function(e) {
            window.open(_this.externalLink);
        });

        if (this.resizable) {
            $(resizediv).mousedown(function(event) {
                $('html').addClass('unselectable');
                event.stopPropagation();
                var downY = event.clientY;
                $('html').bind('mousemove.genomeViewer', function(event) {
                    var despY = (event.clientY - downY);
                    var actualHeight = $(contentDiv).outerHeight();
                    var newHeight = actualHeight + despY;
                    if (newHeight > 0) {
                        _this.height = newHeight;
                        $(contentDiv).css({
                            height: _this.height
                        });
                    }
                    downY = event.clientY;
                    //                    _this.autoHeight = false;
                });
            });
            $('html').bind('mouseup.genomeViewer', function(event) {
                $('html').removeClass('unselectable');
                $('html').off('mousemove.genomeViewer');
            });
            $(contentDiv).closest(".trackListPanels").mouseup(function(event) {
                _this.updateHeight();
            });
        }


        //        var hoverRect = SVG.addChild(this.svgGroup, 'rect', {
        //            'x': 0,
        //            'y': 0,
        //            'width': this.width,
        //            'height': this.height,
        //            'opacity': '0.6',
        //            'fill': 'transparent'
        //        });

        //        this.fnTitleMouseEnter = function () {
        //            hoverRect.setAttribute('opacity', '0.1');
        //            hoverRect.setAttribute('fill', 'lightblue');
        //        };
        //        this.fnTitleMouseLeave = function () {
        //            hoverRect.setAttribute('opacity', '0.6');
        //            hoverRect.setAttribute('fill', 'transparent');
        //        };

        //        $(this.svgGroup).off('mouseenter');
        //        $(this.svgGroup).off('mouseleave');
        //        $(this.svgGroup).mouseenter(this.fnTitleMouseEnter);
        //        $(this.svgGroup).mouseleave(this.fnTitleMouseLeave);


        //        this.invalidZoomText = SVG.addChild(this.svgGroup, 'text', {
        //            'x': 154,
        //            'y': 18,
        //            'opacity': '0.6',
        //            'fill': 'black',
        //            'visibility': 'hidden',
        //            'class': this.fontClass
        //        });
        //        this.invalidZoomText.textContent = "No information available at this zoom";

        this.div = div;
        this.contentDiv = contentDiv;
        this.titlediv = titlediv;
        this.resizeDiv = resizediv;
        //        this.configBtn = configBtn;

        //        this.main = main;
        //        this.hoverRect = hoverRect;
        //        this.titleText = titleText;


        //        if (this.histogramRenderer) {
        //            this._drawHistogramLegend();
        //        }

        this.rendered = true;
        this.status = "ready";

    },
    _drawHistogramLegend: function() {
        var histogramHeight = this.histogramRenderer.histogramHeight;
        var multiplier = this.histogramRenderer.multiplier;

        this.histogramGroup = SVG.addChild(this.svgGroup, 'g', {
            'class': 'histogramGroup',
            'visibility': 'hidden'
        });
        var text = SVG.addChild(this.histogramGroup, "text", {
            "x": 21,
            "y": histogramHeight + 4,
            "font-size": 12,
            "opacity": "0.9",
            "fill": "orangered",
            'class': this.fontClass
        });
        text.textContent = "0-";
        var text = SVG.addChild(this.histogramGroup, "text", {
            "x": 14,
            "y": histogramHeight + 4 - (Math.log(10) * multiplier),
            "font-size": 12,
            "opacity": "0.9",
            "fill": "orangered",
            'class': this.fontClass
        });
        text.textContent = "10-";
        var text = SVG.addChild(this.histogramGroup, "text", {
            "x": 7,
            "y": histogramHeight + 4 - (Math.log(100) * multiplier),
            "font-size": 12,
            "opacity": "0.9",
            "fill": "orangered",
            'class': this.fontClass
        });
        text.textContent = "100-";
        var text = SVG.addChild(this.histogramGroup, "text", {
            "x": 0,
            "y": histogramHeight + 4 - (Math.log(1000) * multiplier),
            "font-size": 12,
            "opacity": "0.9",
            "fill": "orangered",
            'class': this.fontClass
        });
        text.textContent = "1000-";
    },

    //    showInfoWidget: function (args) {
    //        if (this.dataAdapter.species == "orange") {
    //            //data.resource+="orange";
    //            if (args.featureType.indexOf("gene") != -1)
    //                args.featureType = "geneorange";
    //            if (args.featureType.indexOf("transcript") != -1)
    //                args.featureType = "transcriptorange";
    //        }
    //        switch (args.featureType) {
    //            case "gene":
    //                new GeneInfoWidget(null, this.dataAdapter.species).draw(args);
    //                break;
    //            case "geneorange":
    //                new GeneOrangeInfoWidget(null, this.dataAdapter.species).draw(args);
    //                break;
    //            case "transcriptorange":
    //                new TranscriptOrangeInfoWidget(null, this.dataAdapter.species).draw(args);
    //                break;
    //            case "transcript":
    //                new TranscriptInfoWidget(null, this.dataAdapter.species).draw(args);
    //                break;
    //            case "snp" :
    //                new SnpInfoWidget(null, this.dataAdapter.species).draw(args);
    //                break;
    //            case "vcf" :
    //                new VCFVariantInfoWidget(null, this.dataAdapter.species).draw(args);
    //                break;
    //            default:
    //                break;
    //        }
    //    },

    draw: function() {

    },

    getFeaturesToRenderByChunk: function(response, filters) {
        //Returns an array avoiding already drawn features in this.chunksDisplayed

        var getChunkId = function(position) {
            return Math.floor(position / response.chunkSize);
        };
        var getChunkKey = function(chromosome, chunkId) {
            return chromosome + ":" + chunkId + "_" + response.dataType + "_" + response.chunkSize;
        };

        var chunks = response.items;
        var features = [];


        var feature, displayed, featureFirstChunk, featureLastChunk, features = [];
        for (var i = 0, leni = chunks.length; i < leni; i++) {
            if (this.chunksDisplayed[chunks[i].chunkKey] != true) { //check if any chunk is already displayed and skip it

                for (var j = 0, lenj = chunks[i].value.length; j < lenj; j++) {
                    feature = chunks[i].value[j];

                    //check if any feature has been already displayed by another chunk
                    displayed = false;
                    featureFirstChunk = getChunkId(feature.start);
                    featureLastChunk = getChunkId(feature.end);
                    for (var chunkId = featureFirstChunk; chunkId <= featureLastChunk; chunkId++) {
                        var chunkKey = getChunkKey(feature.chromosome, chunkId);
                        if (this.chunksDisplayed[chunkKey] == true) {
                            displayed = true;
                            break;
                        }
                    }
                    if (!displayed) {
                        //apply filter
                        // if(filters != null) {
                        //		var pass = true;
                        // 		for(filter in filters) {
                        // 			pass = pass && filters[filter](feature);
                        //			if(pass == false) {
                        //				break;
                        //			}
                        // 		}
                        //		if(pass) features.push(feature);
                        // } else {
                        features.push(feature);
                    }
                }
                this.chunksDisplayed[chunks[i].chunkKey] = true;
            }
        }
        return features;
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

FeatureTrack.prototype = new Track({});

function FeatureTrack(args) {
    Track.call(this, args);

    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    //set default args

    //save default render reference;
    this.defaultRenderer = this.renderer;
    //    this.histogramRenderer = new FeatureClusterRenderer();
    this.histogramRenderer = new window[this.histogramRendererName](args);

    this.featureType = 'Feature';
    //set instantiation args, must be last
    _.extend(this, args);

    this.resource = this.dataAdapter.resource;
    this.species = this.dataAdapter.species;

    this.dataType = 'features';
};

FeatureTrack.prototype.clean = function () {
    this._clean();

    //    console.time("-----------------------------------------empty");
    while (this.svgCanvasFeatures.firstChild) {
        this.svgCanvasFeatures.removeChild(this.svgCanvasFeatures.firstChild);
    }
    //    console.timeEnd("-----------------------------------------empty");
};

FeatureTrack.prototype.updateHeight = function () {
    //this._updateHeight();
    if (this.histogram) {
        this.contentDiv.style.height = this.histogramRenderer.histogramHeight + 5 + 'px';
        this.main.setAttribute('height', this.histogramRenderer.histogramHeight);
        return;
    }

    var renderedHeight = this.height;
    var heightKeys = Object.keys(this.renderedArea);
    heightKeys.sort(function (a, b) {
        return parseInt(b) - parseInt(a);
    });
    if (heightKeys.length > 0) {
        renderedHeight = parseInt(heightKeys[0]) + 30;
    }
    renderedHeight = Math.max(renderedHeight,this.height);
    this.main.setAttribute('height', renderedHeight);

    if (this.resizable) {
        if (this.autoHeight == false) {
            this.contentDiv.style.height = this.height + 10 + 'px';
        } else if (this.autoHeight == true) {
            var x = this.pixelPosition;
            var width = this.width;
            var lastContains = 0;
            for (var i in this.renderedArea) {
                if (this.renderedArea[i].contains({
                        start: x,
                        end: x + width
                    })) {
                    lastContains = i;
                }
            }
            var visibleHeight = Math.max(parseInt(lastContains) + 30 , this.height);
            this.contentDiv.style.height = visibleHeight + 10 + 'px';
            this.main.setAttribute('height', visibleHeight);
        }
    }
};

FeatureTrack.prototype.setWidth = function (width) {
    this._setWidth(width);
    this.main.setAttribute("width", this.width);
};

FeatureTrack.prototype.initializeDom = function (targetId) {
    this._initializeDom(targetId);

    this.main = SVG.addChild(this.contentDiv, 'svg', {
        'class': 'trackSvg',
        'x': 0,
        'y': 0,
        'width': this.width
    });
    this.svgCanvasFeatures = SVG.addChild(this.main, 'svg', {
        'class': 'features',
        'x': -this.pixelPosition,
        'width': this.svgCanvasWidth
    });
    this.updateHeight();
};

FeatureTrack.prototype.render = function (targetId) {
    this.initializeDom(targetId);

    this.svgCanvasOffset = (this.width * 3 / 2) / this.pixelBase;
    this.svgCanvasLeftLimit = this.region.start - this.svgCanvasOffset * 2;
    this.svgCanvasRightLimit = this.region.start + this.svgCanvasOffset * 2
};

FeatureTrack.prototype.getDataHandler = function (event) {
    var features;
    if (event.dataType == 'histogram') {
        this.renderer = this.histogramRenderer;
        features = event.items;
    } else {
        this.renderer = this.defaultRenderer;
        features = this.getFeaturesToRenderByChunk(event);
    }
    this.renderer.render(features, {
        cacheItems: event.items,
        svgCanvasFeatures: this.svgCanvasFeatures,
        featureTypes: this.featureTypes,
        renderedArea: this.renderedArea,
        pixelBase: this.pixelBase,
        position: this.region.center(),
        regionSize: this.region.length(),
        maxLabelRegionSize: this.maxLabelRegionSize,
        width: this.width,
        pixelPosition: this.pixelPosition,
        resource: this.resource,
        species: this.species,
        featureType: this.featureType
    });
    this.updateHeight();
};

FeatureTrack.prototype.draw = function () {
    var _this = this;

    this.svgCanvasOffset = (this.width * 3 / 2) / this.pixelBase;
    this.svgCanvasLeftLimit = this.region.start - this.svgCanvasOffset * 2;
    this.svgCanvasRightLimit = this.region.start + this.svgCanvasOffset * 2;

    this.updateHistogramParams();
    this.clean();

    this.dataType = 'features';
    if (this.histogram) {
        this.dataType = 'histogram';
    }

    if (typeof this.visibleRegionSize === 'undefined' || this.region.length() < this.visibleRegionSize) {
        this.setLoading(true);
        this.dataAdapter.getData({
            dataType: this.dataType,
            region: new Region({
                chromosome: this.region.chromosome,
                start: this.region.start - this.svgCanvasOffset * 2,
                end: this.region.end + this.svgCanvasOffset * 2
            }),
            params: {
                histogram: this.histogram,
                histogramLogarithm: this.histogramLogarithm,
                histogramMax: this.histogramMax,
                interval: this.interval
            },
            done: function (event) {
                _this.getDataHandler(event);
                _this.setLoading(false);
            }
        });

        //        this.invalidZoomText.setAttribute("visibility", "hidden");
    } else {
        //        this.invalidZoomText.setAttribute("visibility", "visible");
    }
    this.updateHeight();
};

FeatureTrack.prototype.move = function (disp) {
    var _this = this;

    this.dataType = 'features';
    if (this.histogram) {
        this.dataType = 'histogram';
    }

    _this.region.center();
    var pixelDisplacement = disp * _this.pixelBase;
    this.pixelPosition -= pixelDisplacement;

    //parseFloat important
    var move = parseFloat(this.svgCanvasFeatures.getAttribute("x")) + pixelDisplacement;
    this.svgCanvasFeatures.setAttribute("x", move);

    var virtualStart = parseInt(this.region.start - this.svgCanvasOffset);
    var virtualEnd = parseInt(this.region.end + this.svgCanvasOffset);

    if (typeof this.visibleRegionSize === 'undefined' || this.region.length() < this.visibleRegionSize) {

        if (disp > 0 && virtualStart < this.svgCanvasLeftLimit) {
            this.dataAdapter.getData({
                dataType: this.dataType,
                region: new Region({
                    chromosome: _this.region.chromosome,
                    start: parseInt(this.svgCanvasLeftLimit - this.svgCanvasOffset),
                    end: this.svgCanvasLeftLimit
                }),
                params: {
                    histogram: this.histogram,
                    histogramLogarithm: this.histogramLogarithm,
                    histogramMax: this.histogramMax,
                    interval: this.interval
                },
                done: function (event) {
                    _this.getDataHandler(event);
                }
            });
            this.svgCanvasLeftLimit = parseInt(this.svgCanvasLeftLimit - this.svgCanvasOffset);
        }

        if (disp < 0 && virtualEnd > this.svgCanvasRightLimit) {
            this.dataAdapter.getData({
                dataType: this.dataType,
                region: new Region({
                    chromosome: _this.region.chromosome,
                    start: this.svgCanvasRightLimit,
                    end: parseInt(this.svgCanvasRightLimit + this.svgCanvasOffset)
                }),
                params: {
                    histogram: this.histogram,
                    histogramLogarithm: this.histogramLogarithm,
                    histogramMax: this.histogramMax,
                    interval: this.interval
                },
                done: function (event) {
                    _this.getDataHandler(event);
                }

            });
            this.svgCanvasRightLimit = parseInt(this.svgCanvasRightLimit + this.svgCanvasOffset);
        }
    }

    if (this.autoHeight == true) {
        this.updateHeight();
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

GeneTrack.prototype = new Track({});

function GeneTrack(args) {
    Track.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    //set default args
    this.minTranscriptRegionSize;

    //save default render reference;
    this.defaultRenderer = this.renderer;
    //    this.histogramRenderer = new FeatureClusterRenderer();
    this.histogramRenderer = new HistogramRenderer(args);

    //set instantiation args, must be last
    _.extend(this, args);

    this.exclude;
};

GeneTrack.prototype.clean = function () {
    //    console.time("-----------------------------------------empty");
    while (this.svgCanvasFeatures.firstChild) {
        this.svgCanvasFeatures.removeChild(this.svgCanvasFeatures.firstChild);
    }
    //    console.timeEnd("-----------------------------------------empty");
    this._clean();
};

GeneTrack.prototype.updateHeight = function () {
    //    this._updateHeight();

    if (this.histogram) {
        this.contentDiv.style.height = this.histogramRenderer.histogramHeight + 5 + 'px';
        this.main.setAttribute('height', this.histogramRenderer.histogramHeight);
        return;
    }

    var renderedHeight = this.height;
    var heightKeys = Object.keys(this.renderedArea);
    heightKeys.sort(function (a, b) {
        return parseInt(b) - parseInt(a);
    });
    if (heightKeys.length > 0) {
        renderedHeight = parseInt(heightKeys[0]) + 30;
    }
    this.main.setAttribute('height', renderedHeight);

    if (this.resizable) {
        if (this.autoHeight == false) {
            this.contentDiv.style.height = this.height + 10 + 'px';
        } else if (this.autoHeight == true) {
            var x = this.pixelPosition;
            var width = this.width;
            var lastContains = 0;
            for (var i in this.renderedArea) {
                if (this.renderedArea[i].contains({
                        start: x,
                        end: x + width
                    })) {
                    lastContains = i;
                }
            }
            var visibleHeight = parseInt(lastContains) + 30;
            this.contentDiv.style.height = visibleHeight + 10 + 'px';
            this.main.setAttribute('height', visibleHeight);
        }
    }
};

GeneTrack.prototype.setWidth = function (width) {
    this._setWidth(width);
    this.main.setAttribute("width", this.width);
};

GeneTrack.prototype.initializeDom = function (targetId) {
    this._initializeDom(targetId);

    this.main = SVG.addChild(this.contentDiv, 'svg', {
        'class': 'trackSvg',
        'x': 0,
        'y': 0,
        'width': this.width
    });
    this.svgCanvasFeatures = SVG.addChild(this.main, 'svg', {
        'class': 'features',
        'x': -this.pixelPosition,
        'width': this.svgCanvasWidth
    });
    this.updateHeight();
};

GeneTrack.prototype.render = function (targetId) {
    this.initializeDom(targetId);

    this.svgCanvasOffset = (this.width * 3 / 2) / this.pixelBase;
    this.svgCanvasLeftLimit = this.region.start - this.svgCanvasOffset * 2;
    this.svgCanvasRightLimit = this.region.start + this.svgCanvasOffset * 2
};

GeneTrack.prototype.getDataHandler = function (event) {
    var features;
    if (event.dataType == 'histogram') {
        this.renderer = this.histogramRenderer;
        features = event.items;
    } else {
        this.renderer = this.defaultRenderer;
        features = this.getFeaturesToRenderByChunk(event);
    }
    this.renderer.render(features, {
        cacheItems: event.items,
        svgCanvasFeatures: this.svgCanvasFeatures,
        renderedArea: this.renderedArea,
        pixelBase: this.pixelBase,
        position: this.region.center(),
        regionSize: this.region.length(),
        maxLabelRegionSize: this.maxLabelRegionSize,
        width: this.width,
        pixelPosition: this.pixelPosition

    });
    this.updateHeight();
};

GeneTrack.prototype.updateTranscriptParams = function () {
    if (this.region.length() < this.minTranscriptRegionSize) {
        this.exclude = this.dataAdapter.params.exclude;
    } else {
        this.exclude = 'transcripts,chunkIds';
    }
};

GeneTrack.prototype.draw = function () {
    var _this = this;

    this.svgCanvasOffset = (this.width * 3 / 2) / this.pixelBase;
    this.svgCanvasLeftLimit = this.region.start - this.svgCanvasOffset * 2;
    this.svgCanvasRightLimit = this.region.start + this.svgCanvasOffset * 2;

    this.updateTranscriptParams();
    this.updateHistogramParams();
    this.clean();

    var dataType = 'features';
    /*
     if (!_.isUndefined(this.exclude)) {
     dataType = 'features' + this.exclude.replace(/[,.]/gi,'');
     }*/

    if (this.histogram) {
        dataType = 'histogram';
    }

    if (typeof this.visibleRegionSize === 'undefined' || this.region.length() < this.visibleRegionSize) {
        this.setLoading(true);
        var data = this.dataAdapter.getData({
            dataType: dataType,
            region: new Region({
                chromosome: this.region.chromosome,
                start: this.region.start - this.svgCanvasOffset * 2,
                end: this.region.end + this.svgCanvasOffset * 2
            }),
            params: {
                histogram: this.histogram,
                histogramLogarithm: this.histogramLogarithm,
                histogramMax: this.histogramMax,
                interval: this.interval,
                exclude: this.exclude
            },
            done: function (event) {
                _this.getDataHandler(event);
                _this.setLoading(false);
            }
        });

        //        this.invalidZoomText.setAttribute("visibility", "hidden");
    } else {
        //        this.invalidZoomText.setAttribute("visibility", "visible");
    }
    this.updateHeight();
};

GeneTrack.prototype.move = function (disp) {
    var _this = this;

    this.dataType = 'features';

    if (!_.isUndefined(this.exclude)) {
        dataType = 'features' + this.exclude;
    }

    if (this.histogram) {
        this.dataType = 'histogram';
    }

    //    trackSvg.position = _this.region.center();
    _this.region.center();
    var pixelDisplacement = disp * _this.pixelBase;
    this.pixelPosition -= pixelDisplacement;

    //parseFloat important
    var move = parseFloat(this.svgCanvasFeatures.getAttribute("x")) + pixelDisplacement;
    this.svgCanvasFeatures.setAttribute("x", move);

    var virtualStart = parseInt(this.region.start - this.svgCanvasOffset);
    var virtualEnd = parseInt(this.region.end + this.svgCanvasOffset);
    // check if track is visible in this zoom

    //    console.log(virtualStart+'  ----  '+virtualEnd)
    //    console.log(this.svgCanvasLeftLimit+'  ----  '+this.svgCanvasRightLimit)
    //    console.log(this.svgCanvasOffset)

    if (typeof this.visibleRegionSize === 'undefined' || this.region.length() < this.visibleRegionSize) {

        if (disp > 0 && virtualStart < this.svgCanvasLeftLimit) {
            //          left
            this.dataAdapter.getData({
                dataType: this.dataType,
                region: new Region({
                    chromosome: _this.region.chromosome,
                    start: parseInt(this.svgCanvasLeftLimit - this.svgCanvasOffset),
                    end: this.svgCanvasLeftLimit
                }),
                params: {
                    histogram: this.histogram,
                    histogramLogarithm: this.histogramLogarithm,
                    histogramMax: this.histogramMax,
                    interval: this.interval,
                    exclude: this.exclude
                },
                done: function (event) {
                    _this.getDataHandler(event);
                }
            });
            this.svgCanvasLeftLimit = parseInt(this.svgCanvasLeftLimit - this.svgCanvasOffset);
        }

        if (disp < 0 && virtualEnd > this.svgCanvasRightLimit) {
            //          right
            this.dataAdapter.getData({
                dataType: this.dataType,
                region: new Region({
                    chromosome: _this.region.chromosome,
                    start: this.svgCanvasRightLimit,
                    end: parseInt(this.svgCanvasRightLimit + this.svgCanvasOffset)
                }),
                params: {
                    histogram: this.histogram,
                    histogramLogarithm: this.histogramLogarithm,
                    histogramMax: this.histogramMax,
                    interval: this.interval,
                    exclude: this.exclude
                },
                done: function (event) {
                    _this.getDataHandler(event);
                }
            });
            this.svgCanvasRightLimit = parseInt(this.svgCanvasRightLimit + this.svgCanvasOffset);
        }
    }

    if (this.autoHeight == true) {
        this.updateHeight();
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

AlignmentTrack.prototype = new Track({});

function AlignmentTrack(args) {
    Track.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    //set default args

    //save default render reference;
    this.defaultRenderer = this.renderer;
    this.histogramRenderer = new window[this.histogramRendererName](args);

    this.dataType = 'features';

    //set instantiation args, must be last
    _.extend(this, args);

};

AlignmentTrack.prototype.clean = function () {
    this._clean();

    //    console.time("-----------------------------------------empty");
    while (this.svgCanvasFeatures.firstChild) {
        this.svgCanvasFeatures.removeChild(this.svgCanvasFeatures.firstChild);
    }
    //    console.timeEnd("-----------------------------------------empty");
};

AlignmentTrack.prototype.updateHeight = function () {
    //    this._updateHeight();
    if (this.histogram) {
        this.contentDiv.style.height = this.histogramRenderer.histogramHeight + 5 + 'px';
        this.main.setAttribute('height', this.histogramRenderer.histogramHeight);
        return;
    }

    var renderedHeight = this.height;
    var heightKeys = Object.keys(this.renderedArea);
    heightKeys.sort(function (a, b) {
        return parseInt(b) - parseInt(a);
    });
    if (heightKeys.length > 0) {
        renderedHeight = parseInt(heightKeys[0]) + 30;
    }
    this.main.setAttribute('height', renderedHeight);

    if (this.resizable) {
        if (this.autoHeight == false) {
            this.contentDiv.style.height = this.height + 10 + 'px';
        } else if (this.autoHeight == true) {
            var x = this.pixelPosition;
            var width = this.width;
            var lastContains = 0;
            for (var i in this.renderedArea) {
                if (this.renderedArea[i].contains({
                        start: x,
                        end: x + width
                    })) {
                    lastContains = i;
                }
            }
            var visibleHeight = parseInt(lastContains) + 30;
            this.contentDiv.style.height = visibleHeight + 10 + 'px';
            this.main.setAttribute('height', visibleHeight);
        }
    }
};

AlignmentTrack.prototype.setWidth = function (width) {
    this._setWidth(width);
    this.main.setAttribute("width", this.width);
};

AlignmentTrack.prototype.initializeDom = function (targetId) {
    this._initializeDom(targetId);

    this.main = SVG.addChild(this.contentDiv, 'svg', {
        'class': 'trackSvg',
        'x': 0,
        'y': 0,
        'width': this.width
    });
    this.svgCanvasFeatures = SVG.addChild(this.main, 'svg', {
        'class': 'features',
        'x': -this.pixelPosition,
        'width': this.svgCanvasWidth
    });
    this.updateHeight();
};

AlignmentTrack.prototype.render = function (targetId) {
    this.initializeDom(targetId);

    this.svgCanvasOffset = (this.width * 3 / 2) / this.pixelBase;
    this.svgCanvasLeftLimit = this.region.start - this.svgCanvasOffset * 2;
    this.svgCanvasRightLimit = this.region.start + this.svgCanvasOffset * 2
};

AlignmentTrack.prototype.getDataHandler = function (event) {
    var features;
    if (event.dataType == 'histogram') {
        this.renderer = this.histogramRenderer;
        features = event.items;
    } else {
        this.renderer = this.defaultRenderer;
        features = this._removeDisplayedChunks(event);
        //features = this.getFeaturesToRenderByChunk(event);
    }
    this.renderer.render(features, {
        cacheItems: event.items,
        svgCanvasFeatures: this.svgCanvasFeatures,
        featureTypes: this.featureTypes,
        renderedArea: this.renderedArea,
        pixelBase: this.pixelBase,
        position: this.region.center(),
        regionSize: this.region.length(),
        maxLabelRegionSize: this.maxLabelRegionSize,
        width: this.width,
        pixelPosition: this.pixelPosition,
        region: this.region,
        trackListPanel: this.trackListPanel
    });
    this.updateHeight();
};

AlignmentTrack.prototype.draw = function () {
    var _this = this;

    this.svgCanvasOffset = (this.width * 3 / 2) / this.pixelBase;
    this.svgCanvasLeftLimit = this.region.start - this.svgCanvasOffset * 2;
    this.svgCanvasRightLimit = this.region.start + this.svgCanvasOffset * 2

    this.updateHistogramParams();
    this.clean();

    this.dataType = 'features';
    if (this.histogram) {
        this.dataType = 'histogram';
    }

    if (typeof this.visibleRegionSize === 'undefined' || this.region.length() < this.visibleRegionSize) {
        this.setLoading(true);
        this.dataAdapter.getData({
            dataType: this.dataType,
            region: new Region({
                chromosome: this.region.chromosome,
                start: this.region.start - this.svgCanvasOffset * 2,
                end: this.region.end + this.svgCanvasOffset * 2
            }),
            params: {
                histogram: this.histogram,
                histogramLogarithm: this.histogramLogarithm,
                histogramMax: this.histogramMax,
                interval: this.interval
            },
            done: function (event) {
                _this.getDataHandler(event);
                _this.setLoading(false);
            }
        });
        //this.invalidZoomText.setAttribute("visibility", "hidden");
    } else {
        //this.invalidZoomText.setAttribute("visibility", "visible");
    }
    _this.updateHeight();
};

AlignmentTrack.prototype.move = function (disp) {
    var _this = this;

    this.dataType = 'features';
    if (this.histogram) {
        this.dataType = 'histogram';
    }

    _this.region.center();
    var pixelDisplacement = disp * _this.pixelBase;
    this.pixelPosition -= pixelDisplacement;

    //parseFloat important
    var move = parseFloat(this.svgCanvasFeatures.getAttribute("x")) + pixelDisplacement;
    this.svgCanvasFeatures.setAttribute("x", move);

    var virtualStart = parseInt(this.region.start - this.svgCanvasOffset);
    var virtualEnd = parseInt(this.region.end + this.svgCanvasOffset);

    if (typeof this.visibleRegionSize === 'undefined' || this.region.length() < this.visibleRegionSize) {

        if (disp > 0 && virtualStart < this.svgCanvasLeftLimit) {
            this.dataAdapter.getData({
                dataType: this.dataType,
                region: new Region({
                    chromosome: _this.region.chromosome,
                    start: parseInt(this.svgCanvasLeftLimit - this.svgCanvasOffset),
                    end: this.svgCanvasLeftLimit
                }),
                params: {
                    histogram: this.histogram,
                    histogramLogarithm: this.histogramLogarithm,
                    histogramMax: this.histogramMax,
                    interval: this.interval
                },
                done: function (event) {
                    _this.getDataHandler(event);
                }
            });
            this.svgCanvasLeftLimit = parseInt(this.svgCanvasLeftLimit - this.svgCanvasOffset);
        }

        if (disp < 0 && virtualEnd > this.svgCanvasRightLimit) {
            this.dataAdapter.getData({
                dataType: this.dataType,
                region: new Region({
                    chromosome: _this.region.chromosome,
                    start: this.svgCanvasRightLimit,
                    end: parseInt(this.svgCanvasRightLimit + this.svgCanvasOffset)
                }),
                params: {
                    histogram: this.histogram,
                    histogramLogarithm: this.histogramLogarithm,
                    histogramMax: this.histogramMax,
                    interval: this.interval
                },
                done: function (event) {
                    _this.getDataHandler(event);
                }
            });
            this.svgCanvasRightLimit = parseInt(this.svgCanvasRightLimit + this.svgCanvasOffset);
        }

    }

};

AlignmentTrack.prototype._removeDisplayedChunks = function (response) {
    //Returns an array avoiding already drawn features in this.chunksDisplayed

    var getChunkId = function (position) {
        return Math.floor(position / response.chunkSize);
    };
    var getChunkKey = function (chromosome, chunkId) {
        return chromosome + ":" + chunkId + "_" + response.dataType + "_" + response.chunkSize;
    };

    var chunks = response.items;
    var newChunks = [];

    var feature, displayed, featureFirstChunk, featureLastChunk, features = [];
    for (var i = 0, leni = chunks.length; i < leni; i++) { //loop over chunks
        if (this.chunksDisplayed[chunks[i].chunkKey] != true) { //check if any chunk is already displayed and skip it

            features = []; //initialize array, will contain features not drawn by other drawn chunks
            var alignments = chunks[i].value.alignments;
            if (alignments == null) {
                alignments = chunks[i].value;
            }
            for (var j = 0, lenj = alignments.length; j < lenj; j++) {
                feature = alignments[j];

                //check if any feature has been already displayed by another chunk
                displayed = false;
                featureFirstChunk = getChunkId(feature.start);
                featureLastChunk = getChunkId(feature.end);
                for (var chunkId = featureFirstChunk; chunkId <= featureLastChunk; chunkId++) { //loop over chunks touched by this feature
                    var chunkKey = getChunkKey(feature.chromosome, chunkId);
                    if (this.chunksDisplayed[chunkKey] == true) {
                        displayed = true;
                        break;
                    }
                }
                if (!displayed) {
                    features.push(feature);
                }
            }
            this.chunksDisplayed[chunks[i].chunkKey] = true;
            chunks[i].value.alignments = features; //update features array
            newChunks.push(chunks[i]);
        }
    }
    response.items = newChunks;
    return response;
};
</script>


<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

//Parent class for all renderers
function Renderer(args) {


};

Renderer.prototype = {

    render: function (items) {

    },

    getFeatureX: function (start, args) {//returns svg feature x value from feature genomic position
        var middle = args.width / 2;
        var x = args.pixelPosition + middle - ((args.position - start) * args.pixelBase);
        return x;
    },

    getDefaultConfig: function (type) {
        return FEATURE_TYPES[type];
    },
    getLabelWidth: function (label, args) {
        /* insert in dom to get the label width and then remove it*/
        var svgLabel = SVG.create("text", {
            'font-weight': 400,
            'class':this.fontClass
        });
        svgLabel.textContent = label;
        $(args.svgCanvasFeatures).append(svgLabel);
        var svgLabelWidth = $(svgLabel).width();
        $(svgLabel).remove();
        return svgLabelWidth;
    }
}
;</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

//any item with chromosome start end
FeatureRenderer.prototype = new Renderer({});

function FeatureRenderer(args) {
    Renderer.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    this.fontClass = 'ocb-font-roboto ocb-font-size-11';
    this.toolTipfontClass = 'ocb-tooltip-font';

    if (args == null) {
        args = FEATURE_TYPES.undefined;
    }

    if (_.isObject(args)) {
        _.extend(this, args);
    }

    this.on(this.handlers);
};


FeatureRenderer.prototype.render = function (features, args) {
    var _this = this;
    var draw = function (feature, svgGroup) {

        if ('featureType' in feature) {
            _.extend(_this, FEATURE_TYPES[feature.featureType]);
        }
        if ('featureClass' in feature) {
            _.extend(_this, FEATURE_TYPES[feature.featureClass]);
        }

        //Temporal fix for clinical
        if (args.featureType == 'clinical') {
            if ('clinvarSet' in feature) {
                _.extend(_this, FEATURE_TYPES['Clinvar'])
            } else if ('mutationID' in feature) {
                _.extend(_this, FEATURE_TYPES['Cosmic'])
            }else{
                _.extend(_this, FEATURE_TYPES['GWAS'])
            }
        }


        ////check feature class
        //if (feature.featureClass != null) {//regulatory
        //    _.extend(_this, FEATURE_TYPES[feature.featureClass]);
        //} else if (feature.source != null) {//clinical
        //    _.extend(_this, FEATURE_TYPES[feature.source]);
        //}

        //get feature render configuration
        var color = _.isFunction(_this.color) ? _this.color(feature) : _this.color;
        var strokeColor = _.isFunction(_this.strokeColor) ? _this.color(feature) : _this.strokeColor;
        var label = _.isFunction(_this.label) ? _this.label(feature) : _this.label;
        var height = _.isFunction(_this.height) ? _this.height(feature) : _this.height;
        var tooltipTitle = _.isFunction(_this.tooltipTitle) ? _this.tooltipTitle(feature) : _this.tooltipTitle;
        var tooltipText = _.isFunction(_this.tooltipText) ? _this.tooltipText(feature) : _this.tooltipText;
        var infoWidgetId = _.isFunction(_this.infoWidgetId) ? _this.infoWidgetId(feature) : _this.infoWidgetId;

        //get feature genomic information
        var start = feature.start;
        var end = feature.end;
        var length = (end - start) + 1;

        //check genomic length
        length = (length < 0) ? Math.abs(length) : length;
        length = (length == 0) ? 1 : length;

        //transform to pixel position
        var width = length * args.pixelBase;

//        var svgLabelWidth = _this.getLabelWidth(label, args);
        var svgLabelWidth = label.length * 6.4;

        //calculate x to draw svg rect
        var x = _this.getFeatureX(start, args);

        var maxWidth = Math.max(width, 2);
        var textHeight = 0;
        if (args.maxLabelRegionSize > args.regionSize) {
            textHeight = 9;
            maxWidth = Math.max(width, svgLabelWidth);
        }


        var rowY = 0;
        var textY = textHeight + height;
        var rowHeight = textHeight + height + 2;

        while (true) {
            if (!(rowY in args.renderedArea)) {
                args.renderedArea[rowY] = new FeatureBinarySearchTree();
            }
            var foundArea = args.renderedArea[rowY].add({start: x, end: x + maxWidth - 1});

            if (foundArea) {
                var featureGroup = SVG.addChild(svgGroup, "g", {'feature_id': feature.id});
                var rect = SVG.addChild(featureGroup, "rect", {
                    'x': x,
                    'y': rowY,
                    'width': width,
                    'height': height,
                    'stroke': strokeColor,
                    'stroke-width': 1,
                    'stroke-opacity': 0.7,
                    'fill': color,
                    'cursor': 'pointer'
                });
                if (args.maxLabelRegionSize > args.regionSize) {
                    var text = SVG.addChild(featureGroup, "text", {
                        'i': i,
                        'x': x,
                        'y': textY,
                        'font-weight': 400,
                        'opacity': null,
                        'fill': 'black',
                        'cursor': 'pointer',
                        'class': _this.fontClass
                    });
                    text.textContent = label;
                }

                if ('tooltipText' in _this) {
                    $(featureGroup).qtip({
                        content: {text: tooltipText, title: tooltipTitle},
//                        position: {target: "mouse", adjust: {x: 15, y: 0}, effect: false},
                        position: {viewport: $(window), target: "mouse", adjust: {x: 25, y: 15}},
                        style: {width: true, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
                        show: {delay: 300},
                        hide: {delay: 300}
                    });
                }

                $(featureGroup).mouseover(function (event) {
                    _this.trigger('feature:mouseover', {
                        query: feature[infoWidgetId],
                        feature: feature,
                        featureType: feature.featureType,
                        mouseoverEvent: event
                    })
                });

                $(featureGroup).click(function (event) {
                    _this.trigger('feature:click', {
                        query: feature[infoWidgetId],
                        feature: feature,
                        featureType: feature.featureType,
                        clickEvent: event
                    })
                });
                break;
            }
            rowY += rowHeight;
            textY += rowHeight;
        }
    };


    /****/
    var timeId = "write dom " + Utils.randomString(4);
    console.time(timeId);
    console.log(features.length);
    /****/


    var svgGroup = SVG.create('g');
    for (var i = 0, leni = features.length; i < leni; i++) {
        draw(features[i], svgGroup);
    }
    args.svgCanvasFeatures.appendChild(svgGroup);


    /****/
    console.timeEnd(timeId);
    /****/
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

SequenceRenderer.prototype = new Renderer({});

function SequenceRenderer(args) {
    Renderer.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    this.fontClass = 'ocb-font-ubuntumono ocb-font-size-16';
    this.toolTipfontClass = 'ocb-tooltip-font';

    _.extend(this, args);

};


SequenceRenderer.prototype.render = function (chunks, args) {
    for (var i = 0; i < chunks.length; i++) {
        this._paintSequenceChunk(chunks[i], args);
    }
};


SequenceRenderer.prototype._paintSequenceChunk = function (chunk, args) {
    /* Time */
    var timeId = new Region(chunk).toString();
    console.time("Sequence render " + timeId);
    /**/

    var middle = args.width / 2;

    var start = chunk.start;
    var seqStart = chunk.start;
    var seqString = chunk.sequence;

    for (var i = 0; i < seqString.length; i++) {
        var x = args.pixelPosition + middle - ((args.position - start) * args.pixelBase);
        var text = SVG.addChild(args.svgCanvasFeatures, "text", {
            'x': x + 1,
            'y': 12,
            'fill': SEQUENCE_COLORS[seqString.charAt(i)],
            'data-pos': start,
            'class': this.fontClass
        });
        start++;
        text.textContent = seqString.charAt(i);
        $(text).qtip({
            content: seqString.charAt(i) + " " + (seqStart + i).toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,")/*+'<br>'+phastCons[i]+'<br>'+phylop[i]*/,
            position: {target: "mouse", adjust: {x: 25, y: 15}},
            style: {width: true, classes: this.toolTipfontClass + ' qtip-light qtip-shadow'},
            show: {delay: 300},
            hide: {delay: 300}
        });
    }

//    this.trackSvgLayout.setNucleotidPosition(this.position);

    /* Time */
    console.timeEnd("Sequence render " + timeId);
    /**/

};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

ConservedRenderer.prototype = new Renderer({});

function ConservedRenderer(args) {
    Renderer.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    //set default args
    //set instantiation args
    _.extend(this, args);

};

ConservedRenderer.prototype.render = function (chunks, args) {
    for (var i = 0; i < chunks.length; i++) {
        this._paintChunk(chunks[i], args);
    }
};

ConservedRenderer.prototype._paintChunk = function (chunk, args) {
    var middle = args.width / 2;
    var multiplier = 15;
    var histogramHeight = 75;
    var points = '';
    var width = args.pixelBase;

    var x = args.pixelPosition + middle - ((args.position - parseInt(chunk.start)) * args.pixelBase);

    for (var i = 0, len = chunk.values.length; i < len; i++) {
        var value = chunk.values[i];
        var height = value * multiplier;
        var s = chunk.start + i;
        var x = args.pixelPosition + middle - ((args.position - s) * args.pixelBase);
        points += (x) + "," + 0 + " ";
        points += (x) + "," + (histogramHeight - height) + " ";
        points += (x + width) + "," + (histogramHeight - height) + " ";
        points += (x + width) + "," + 0 + " ";
    }

    var pol = SVG.addChild(args.svgCanvasFeatures, "polyline", {
        "points": points,
        "stroke": "#000000",
        "stroke-width": 0.2,
        "fill": 'salmon',
        "cursor": "pointer"
    });


};

</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

FeatureClusterRenderer.prototype = new Renderer({});

function FeatureClusterRenderer(args) {
    Renderer.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    //set default args
    this.histogramHeight = 75;
    this.multiplier = 7;



//    this.maxValue = 100;
//    if (args != null) {
//        if (args.height != null) {
//            this.histogramHeight = args.height * 0.95;
//        }
//        if (args.histogramMaxFreqValue != null) {
//            this.maxValue = args.histogramMaxFreqValue;
//        }
//    }
//    this.multiplier = this.histogramHeight / this.maxValue;

    this.fontClass = 'ocb-font-roboto ocb-font-size-11';
    this.toolTipfontClass = 'ocb-tooltip-font';

    //set instantiation args
    _.extend(this, args);

};


FeatureClusterRenderer.prototype.render = function (features, args) {
    var _this = this;
    var middle = args.width / 2;
    var maxValue = 0;

    var drawFeature = function (feature) {
        var d = '';

        feature.start = parseInt(feature.start);
        feature.end = parseInt(feature.end);
        var width = (feature.end - feature.start);

        width = width * args.pixelBase;
        var x = _this.getFeatureX(feature.start, args);

        if (feature.features_count == null) {
//            var height = Math.log(features[i].absolute);
            if (feature.absolute != 0) {
                feature.features_count = Math.log(features[i].absolute);
            } else {
                feature.features_count = 0;
            }
        }

        var height = feature.features_count * _this.multiplier;

        var rect = SVG.addChild(args.svgCanvasFeatures, "rect", {
            'x': x + 1,
            'y': 0,
            'width': width - 1,
            'height': height,
            'stroke': 'smokewhite',
            'stroke-width': 1,
            'fill': '#9493b1',
            'cursor': 'pointer'
        });

        var getInfo = function (feature) {
            var resp = '';
            return resp += Math.round(Math.exp(feature.features_count));
        };


        var url = CellBaseManager.url({
            species: args.species,
            category: 'genomic',
            subCategory: 'region',
            query: new Region(feature).toString(),
            resource: args.resource,
            params: {
                include: 'chromosome,start,end,id',
                limit: 20
            },
            async: false
//            success:function(data){
//                str+=data.response[0].result.length+' cb';
//            }
        });

        $(rect).qtip({
            content: {
                text: 'Loading...', // The text to use whilst the AJAX request is loading
                ajax: {
                    url: url, // URL to the local file
                    type: 'GET', // POST or GET
                    success: function (data, status) {
                        var items = data.response[0].result;
                        var ids = '';
                        for (var i = 0; i < items.length; i++) {
                            var f = items[i];
                            var r = new Region(f);
                            ids += '<span class="emph">' + f.id + '</span> <span class="info">' + r.toString() + '</span><br>';
                        }
                        var fc = Math.round(Math.exp(feature.features_count));
                        if (fc <= 20) {
                            this.set('content.title', 'Count: ' + items.length);
                            this.set('content.text', ids);
                        } else {
                            this.set('content.title', 'Count: ' + fc);
                            this.set('content.text', ids + '...');
                        }
                    }
                }
            },
            position: {target: 'mouse', adjust: {x: 25, y: 15}},
            style: { width: true, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
            show: {delay: 300},
            hide: {delay: 300}
        });

//        $(rect).qtip({
//            content: {text: getInfo(feature), title: 'Count'},
//
//        });

//        $(rect).mouseenter(function(){
//            var str = '';
////            $(rect).qtip({
////                content: {text: str, title: 'Info'},
//////                position: {target: "mouse", adjust: {x: 25, y: 15}},
////                style: { width: true, classes: 'ui-tooltip ui-tooltip-shadow'}
////            });
//        });

    };

    for (var i = 0, len = features.length; i < len; i++) {
        drawFeature(features[i].value);
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

HistogramRenderer.prototype = new Renderer({});

function HistogramRenderer(args) {
    Renderer.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    //set default args
    this.histogramHeight = 75;
    this.histogramColor = '#428bca';
    //    this.multiplier = 7;

    this.maxValue = 10;
    this.updateScale(args);
    //set instantiation args
    _.extend(this, args);

};

HistogramRenderer.prototype._checkFeatureValue = function (feature) {
    if (feature.features_count == null) {
        //            var height = Math.log(features[i].absolute);
        if (feature.absolute != 0 && feature.absolute > 0) {
            // take care of feature.absolute==1 counts and set scaled value to 0.2 as log(2) ~= 0.3
            feature.features_count = Math.max(0.2, Math.log(feature.absolute));
        } else {
            feature.features_count = 0;
        }
    }

    //        var height = features[i].features_count;
    //        if (height == null) {
    //            height = features[i].value;
    //            height = this.histogramHeight * height;
    //        } else {
    //        }
}

/**
 * updates "this.multiplier" using "histogramMaxFreqValue" and "height"
 * @param args
 */
HistogramRenderer.prototype.updateScale = function (args) {
    if (args != null) {
        if (args.height != null) {
            this.histogramHeight = args.height * 0.95;
        }
        if (args.histogramMaxFreqValue != null) {
            this.maxValue = args.histogramMaxFreqValue;
        }
    }
    //this.multiplier = 7;
    this.multiplier = this.histogramHeight / this.maxValue;
};

HistogramRenderer.prototype.render = function (features, args) {
    features.sort(function (a, b) {
        return a.value.start - b.value.start;
    });

    var middle = args.width / 2;
    //console.log(middle);
    var points = '';

    this.updateScale(args);

    if (features.length > 0) {
        var firstFeature = features[0].value;
        var width = (firstFeature.end - firstFeature.start + 1) * args.pixelBase;
        var x = args.pixelPosition + middle - ((args.position - parseInt(firstFeature.start)) * args.pixelBase);

        this._checkFeatureValue(firstFeature);
        var height = firstFeature.features_count * this.multiplier;

        points = (x - (width / 2)).toFixed(1) + ',' + this.histogramHeight.toFixed(1) + ' ';
        points += (x - (width / 2)).toFixed(1) + ',' + (this.histogramHeight - height).toFixed(1) + ' ';
    }
    for (var i = 0, len = features.length; i < len; i++) {
        var feature = features[i].value;
        feature.start = parseInt(feature.start);
        feature.end = parseInt(feature.end);
        var width = (feature.end - feature.start + 1) * args.pixelBase;
        var x = args.pixelPosition + middle - ((args.position - feature.start) * args.pixelBase);

        this._checkFeatureValue(feature);
        var height = feature.features_count * this.multiplier;

        points += (x + (width / 2)).toFixed(1) + "," + (this.histogramHeight - height).toFixed(1) + " ";
    }
    if (features.length > 0) {
        var lastFeature = features[features.length - 1].value;
        var width = (lastFeature.end - lastFeature.start + 1) * args.pixelBase;
        var x = args.pixelPosition + middle - ((args.position - parseInt(lastFeature.start)) * args.pixelBase);

        this._checkFeatureValue(lastFeature);
        var height = lastFeature.features_count * this.multiplier;

        points += (x + (width)).toFixed(1) + ',' + (this.histogramHeight - height).toFixed(1) + ' ';
        points += (x + (width)).toFixed(1) + ',' + this.histogramHeight.toFixed(1) + ' ';
    }

    if (points !== '') {
        SVG.addChild(args.svgCanvasFeatures, "polyline", {
            "points": points,
            //        "stroke": "#000000",
            //        "stroke-width": 0.2,
            "fill": this.histogramColor,
            "cursor": "pointer"
        });

    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

//any item with chromosome start end
GeneRenderer.prototype = new Renderer({});

function GeneRenderer(args) {
    Renderer.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    this.fontClass = 'ocb-font-roboto ocb-font-size-11';
    this.toolTipfontClass = 'ocb-tooltip-font';

    if (_.isObject(args)) {
        _.extend(this, args);
    }

    this.on(this.handlers);
};

GeneRenderer.prototype.setFeatureConfig = function (configObject) {
    _.extend(this, configObject);
};

GeneRenderer.prototype.render = function (features, args) {
    var _this = this;
    var draw = function (feature) {
        //get feature render configuration

        //get feature render configuration
        _this.setFeatureConfig(FEATURE_TYPES.gene);
        var color = _.isFunction(_this.color) ? _this.color(feature) : _this.color;
        var label = _.isFunction(_this.label) ? _this.label(feature) : _this.label;
        var height = _.isFunction(_this.height) ? _this.height(feature) : _this.height;
        var tooltipTitle = _.isFunction(_this.tooltipTitle) ? _this.tooltipTitle(feature) : _this.tooltipTitle;
        var tooltipText = _.isFunction(_this.tooltipText) ? _this.tooltipText(feature) : _this.tooltipText;
        var infoWidgetId = _.isFunction(_this.infoWidgetId) ? _this.infoWidgetId(feature) : _this.infoWidgetId;


        //get feature genomic information
        var start = feature.start;
        var end = feature.end;
        var length = (end - start) + 1;

        //transform to pixel position
        var width = length * args.pixelBase;


        // var svgLabelWidth = _this.getLabelWidth(label, args);
        var svgLabelWidth = label.length * 6.4;

        //calculate x to draw svg rect
        var x = _this.getFeatureX(start, args);

        var maxWidth = Math.max(width, 2);
        var textHeight = 0;
        if (args.maxLabelRegionSize > args.regionSize) {
            textHeight = 9;
            maxWidth = Math.max(width, svgLabelWidth);
        }

        var rowY = 0;
        var textY = textHeight + height + 1;
        var rowHeight = textHeight + height + 5;

        while (true) {
            if (!(rowY in args.renderedArea)) {
                args.renderedArea[rowY] = new FeatureBinarySearchTree();
            }

            var foundArea;//if true, i can paint

            //check if gene transcripts can be painted
            var checkRowY = rowY;
            var foundTranscriptsArea = true;
            if (!_.isEmpty(feature.transcripts)) {
                for (var i = 0, leni = feature.transcripts.length + 1; i < leni; i++) {
                    if (!(checkRowY in args.renderedArea)) {
                        args.renderedArea[checkRowY] = new FeatureBinarySearchTree();
                    }
                    if (args.renderedArea[checkRowY].contains({start: x, end: x + maxWidth - 1})) {
                        foundTranscriptsArea = false;
                        break;
                    }
                    checkRowY += rowHeight;
                }
                if (foundTranscriptsArea == true) {
                    foundArea = args.renderedArea[rowY].add({start: x, end: x + maxWidth - 1});
                }
            } else {
                foundArea = args.renderedArea[rowY].add({start: x, end: x + maxWidth - 1});
            }

            //paint genes
            if (foundArea) {
                var featureGroup = SVG.addChild(args.svgCanvasFeatures, "g", {
                    'feature_id': feature.id
                });
                var rect = SVG.addChild(featureGroup, 'rect', {
                    'x': x,
                    'y': rowY,
                    'width': width,
                    'height': height,
                    'stroke': '#3B0B0B',
                    'stroke-width': 0.5,
                    'fill': color,
                    'cursor': 'pointer'
                });

                if (args.maxLabelRegionSize > args.regionSize) {
                    var text = SVG.addChild(featureGroup, 'text', {
                        'i': i,
                        'x': x,
                        'y': textY,
                        'fill': 'black',
                        'cursor': 'pointer',
                        'class': _this.fontClass
                    });
                    text.textContent = label;
                }

                $(featureGroup).qtip({
                    content: {text: tooltipText, title: tooltipTitle},
                    // position: {target: "mouse", adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
                    position: {target: "mouse", adjust: {x: 25, y: 15}},
                    style: {width: true, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
                    show: {delay: 300},
                    hide: {delay: 300}
                });


                featureGroup.addEventListener('click', function (e) {
                    _this.trigger('feature:click', {
                        query: feature[infoWidgetId],
                        feature: feature,
                        featureType: 'gene',
                        clickEvent: e
                    });
                });

                //paint transcripts
                var checkRowY = rowY + rowHeight;
                var checkTextY = textY + rowHeight;
                if (!_.isEmpty(feature.transcripts)) {
                    for (var i = 0, leni = feature.transcripts.length; i < leni; i++) { /*Loop over transcripts*/
                        if (!(checkRowY in args.renderedArea)) {
                            args.renderedArea[checkRowY] = new FeatureBinarySearchTree();
                        }
                        var transcript = feature.transcripts[i];
                        var transcriptX = _this.getFeatureX(transcript.start, args);
                        var transcriptWidth = (transcript.end - transcript.start + 1) * ( args.pixelBase);

                        //get type settings object
                        _this.setFeatureConfig(FEATURE_TYPES.transcript);
                        var transcriptColor = _.isFunction(_this.color) ? _this.color(transcript) : _this.color;
                        var label = _.isFunction(_this.label) ? _this.label(transcript) : _this.label;
                        var height = _.isFunction(_this.height) ? _this.height(transcript) : _this.height;
                        var tooltipTitle = _.isFunction(_this.tooltipTitle) ? _this.tooltipTitle(transcript) : _this.tooltipTitle;
                        var tooltipText = _.isFunction(_this.tooltipText) ? _this.tooltipText(transcript) : _this.tooltipText;
                        var infoWidgetId = _.isFunction(_this.infoWidgetId) ? _this.infoWidgetId(transcript) : _this.infoWidgetId;

                        //  se resta el trozo del final del gen hasta el principio del transcrito y se le suma el texto del transcrito
                        // var svgLabelWidth = _this.getLabelWidth(label, args);
                        var svgLabelWidth = label.length * 6.4;
                        var maxWidth = Math.max(width, width - ((feature.end - transcript.start) * ( args.pixelBase)) + svgLabelWidth);


                        //add to the tree the transcripts size
                        args.renderedArea[checkRowY].add({start: x, end: x + maxWidth - 1});


                        var transcriptGroup = SVG.addChild(args.svgCanvasFeatures, 'g', {
                            "data-widget-id": transcript[infoWidgetId],
                            "data-transcript-idx": i
                        });


                        var rect = SVG.addChild(transcriptGroup, 'rect', {//this rect its like a line
                            'x': transcriptX,
                            'y': checkRowY + 1,
                            'width': transcriptWidth,
                            'height': height,
                            'fill': 'gray',
                            'cursor': 'pointer',
                            'feature_id': transcript.id
                        });
                        var text = SVG.addChild(transcriptGroup, 'text', {
                            'x': transcriptX,
                            'y': checkTextY,
                            'fill': 'black',
                            'cursor': 'pointer',
                            'class': _this.fontClass
                        });
                        text.textContent = label;


                        $(transcriptGroup).qtip({
                            content: {text: tooltipText, title: tooltipTitle},
                            // position: {target: 'mouse', adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
                            position: {target: "mouse", adjust: {x: 25, y: 15}},
                            style: {width: true, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
                            show: {delay: 300},
                            hide: {delay: 300}
                        });
                        transcriptGroup.addEventListener('click', function (e) {
                            var query = this.getAttribute('data-widget-id');
                            var idx = this.getAttribute("data-transcript-idx");
                            _this.trigger('feature:click', {
                                query: query,
                                feature: feature.transcripts[idx],
                                featureType: 'transcript',
                                clickEvent: event
                            });
                        });


                        //paint exons
                        for (var e = 0, lene = feature.transcripts[i].exons.length; e < lene; e++) {
                            var exon = feature.transcripts[i].exons[e];
                            var exonStart = parseInt(exon.start);
                            var exonEnd = parseInt(exon.end);
                            var middle = args.width / 2;

                            var exonX = args.pixelPosition + middle - ((args.position - exonStart) * args.pixelBase);
                            var exonWidth = (exonEnd - exonStart + 1) * ( args.pixelBase);


                            _this.setFeatureConfig(FEATURE_TYPES.exon);
                            var color = _.isFunction(_this.color) ? _this.color(exon) : _this.color;
                            var label = _.isFunction(_this.label) ? _this.label(exon) : _this.label;
                            var height = _.isFunction(_this.height) ? _this.height(exon) : _this.height;
                            var tooltipTitle = _.isFunction(_this.tooltipTitle) ? _this.tooltipTitle(exon) : _this.tooltipTitle;
                            var tooltipText = _.isFunction(_this.tooltipText) ? _this.tooltipText(exon, transcript) : _this.tooltipText;
                            var infoWidgetId = _.isFunction(_this.infoWidgetId) ? _this.infoWidgetId(exon) : _this.infoWidgetId;

                            var exonGroup = SVG.addChild(args.svgCanvasFeatures, "g", {
                                "class": "ocb-coding",
                                "data-id": exon.id
                            });

                            $(exonGroup).qtip({
                                content: {text: tooltipText, title: tooltipTitle},
                                // position: {target: 'mouse', adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
                                position: {target: "mouse", adjust: {x: 25, y: 15}},
                                style: {width: true, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
                                show: {delay: 300},
                                hide: {delay: 300}
                            });
                            exonGroup.addEventListener('click', function (e) {
                                // console.log(this.dataset.id);
                            });


                            // Paint exons in white without coding region
                            var eRect = SVG.addChild(exonGroup, "rect", {
                                "i": i,
                                "x": exonX,
                                "y": checkRowY - 1,
                                "width": exonWidth,
                                "height": height,
                                "stroke": "gray",
                                "stroke-width": 1,
                                "fill": "white",
                                "cursor": "pointer"
                            });

                            var codingLength = exon.genomicCodingEnd - exon.genomicCodingStart;
                            var codingX = args.pixelPosition + middle - ((args.position - exon.genomicCodingStart) * args.pixelBase);
                            var codingReverseX = args.pixelPosition + middle - ((args.position - exon.genomicCodingEnd) * args.pixelBase);
                            var codingWidth = (codingLength + 1) * (args.pixelBase);
                            if (codingLength > 0) {
                                var cRect = SVG.addChild(exonGroup, "rect", {
                                    "i": i,
                                    "x": codingX,
                                    "y": checkRowY - 1,
                                    "width": codingWidth,
                                    "height": height,
                                    "stroke": transcriptColor,
                                    "stroke-width": 1,
                                    "fill": transcriptColor,
                                    "cursor": "pointer"
                                });
                                if (args.pixelBase > 9.5 && transcript.proteinSequence != null && exon.phase != null) {
                                    if (exon.strand == '+') {
                                        var proteinString = transcript.proteinSequence.substring(Math.floor(exon.cdsStart / 3), Math.floor(exon.cdsEnd / 3));
                                        var proteinPhaseOffset = codingX - (((3 - exon.phase) % 3) * args.pixelBase);
                                        var sign = 1;

                                    } else if (exon.strand == '-') {
                                        var proteinString = transcript.proteinSequence.substring(Math.floor(exon.cdsStart / 3), Math.ceil(exon.cdsEnd / 3));
                                        var proteinPhaseOffset = codingReverseX - (args.pixelBase * 2) - (exon.phase * args.pixelBase);
                                        var sign = -1;
                                    }
                                    for (var j = 0; j < proteinString.length; j++) {
                                        var codonRect = SVG.addChild(exonGroup, "rect", {
                                            "x": proteinPhaseOffset + (sign * args.pixelBase * 3 * j ),
                                            "y": checkRowY - 1,
                                            "width": (args.pixelBase * 3),
                                            "height": height,
                                            'stroke': '#3B0B0B',
                                            'stroke-width': 0.5,
                                            "fill": CODON_CONFIG[proteinString.charAt(j)].color,
                                            "class": 'ocb-codon'
                                        });
                                        var codonText = SVG.addChild(exonGroup, "text", {
                                            "x": proteinPhaseOffset + (sign * args.pixelBase * j * 3) + args.pixelBase / 3,
                                            "y": checkRowY - 3,
                                            "width": (args.pixelBase * 3),
                                            "class": 'ocb-font-ubuntumono ocb-font-size-16 ocb-codon'
                                        });
                                        codonText.textContent = CODON_CONFIG[proteinString.charAt(j)].text;
                                    }
                                }

                                // Draw phase only at zoom 100, where this.pixelBase < 11
                                //if (args.pixelBase < 11 && exon.phase != null && exon.phase != -1) {
                                //    for (var p = 0, lenp = 3 - exon.phase; p < lenp; p++) {
                                //        SVG.addChild(exonGroup, "rect", {
                                //            "i": i,
                                //            "x": codingX + (p * args.pixelBase),
                                //            "y": checkRowY - 1,
                                //            "width": args.pixelBase,
                                //            "height": height,
                                //            "stroke": color,
                                //            "stroke-width": 1,
                                //            "fill": 'white',
                                //            "cursor": "pointer"
                                //        });
                                //    }
                                //}
                            }
                        }
                        checkRowY += rowHeight;
                        checkTextY += rowHeight;
                    }
                }// if transcrips != null
                break;
            }
            rowY += rowHeight;
            textY += rowHeight;
        }
    };

    //process features
    for (var i = 0, leni = features.length; i < leni; i++) {
        draw(features[i]);
    }
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

//any item with chromosome start end
VcfMultisampleRenderer.prototype = new Renderer({});

function VcfMultisampleRenderer(args) {
    Renderer.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    this.fontClass = 'ocb-font-roboto ocb-font-size-11';
    this.toolTipfontClass = 'ocb-tooltip-font';

    _.extend(this, FEATURE_TYPES.variant);

    this.on(this.handlers);
};


VcfMultisampleRenderer.prototype.render = function (features, args) {
    for (var i = 0, leni = features.length; i < leni; i++) {
        this._drawFeature(features[i], args);
    }
};

VcfMultisampleRenderer.prototype._drawFeature = function (feature, args) {
    var _this = this;

    var color = _.isFunction(_this.color) ? _this.color(feature) : _this.color;
    var label = _.isFunction(_this.label) ? _this.label(feature) : _this.label;
    var height = _.isFunction(_this.height) ? _this.height(feature) : _this.height;
    var tooltipTitle = _.isFunction(_this.tooltipTitle) ? _this.tooltipTitle(feature) : _this.tooltipTitle;
    var tooltipText = _.isFunction(_this.tooltipText) ? _this.tooltipText(feature) : _this.tooltipText;
    var infoWidgetId = _.isFunction(_this.infoWidgetId) ? _this.infoWidgetId(feature) : _this.infoWidgetId;

    //get feature genomic information
    var start = feature.start;
    var end = feature.end;
    var length = (end - start) + 1;

    //check genomic length
    length = (length < 0) ? Math.abs(length) : length;
    length = (length == 0) ? 1 : length;

    //transform to pixel position
    var width = length * args.pixelBase;

    var svgLabelWidth = label.length * 6.4;

    //calculate x to draw svg rect
    var x = _this.getFeatureX(start, args);

    var maxWidth = Math.max(width, 2);
    var textHeight = 0;
    if (args.maxLabelRegionSize > args.regionSize) {
        textHeight = 9;
        maxWidth = Math.max(width, svgLabelWidth);
    }

    var rowY = 0;
    var textY = textHeight + height;
    var rowHeight = textHeight + height + 2;

    while (true) {
        if (!(rowY in args.renderedArea)) {
            args.renderedArea[rowY] = new FeatureBinarySearchTree();
        }
        var foundArea = args.renderedArea[rowY].add({start: x, end: x + maxWidth - 1});

        if (foundArea) {
            var featureGroup = SVG.addChild(args.svgCanvasFeatures, "g", {'feature_id': feature.id});
            var rect = SVG.addChild(featureGroup, "rect", {
                'x': x,
                'y': rowY,
                'width': width,
                'height': height,
                'stroke': '#3B0B0B',
                'stroke-width': 1,
                'stroke-opacity': 0.7,
                'fill': color,
                'cursor': 'pointer'
            });
            if (args.maxLabelRegionSize > args.regionSize) {
                var text = SVG.addChild(featureGroup, "text", {
                    'x': x,
                    'y': textY,
                    'font-weight': 400,
                    'opacity': null,
                    'fill': 'black',
                    'cursor': 'pointer',
                    'class': _this.fontClass
                });
                text.textContent = label;
            }

            if ('tooltipText' in _this) {
                $(featureGroup).qtip({
                    content: {text: tooltipText, title: tooltipTitle},
//                        position: {target: "mouse", adjust: {x: 15, y: 0}, effect: false},
                    position: {target: "mouse", adjust: {x: 25, y: 15}},
                    style: {width: true, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
                    show: {delay: 300},
                    hide: {delay: 300}
                });
            }

            $(featureGroup).mouseover(function (event) {
                _this.trigger('feature:mouseover', {
                    query: feature[infoWidgetId],
                    feature: feature,
                    featureType: feature.featureType,
                    mouseoverEvent: event
                })
            });

            $(featureGroup).click(function (event) {
                _this.trigger('feature:click', {
                    query: feature[infoWidgetId],
                    feature: feature,
                    featureType: feature.featureType,
                    clickEvent: event
                })
            });
            break;
        }
        rowY += rowHeight;
        textY += rowHeight;
    }
};

VcfMultisampleRenderer.prototype._drawFeatureMultiSample = function (feature, args) {
    //TODO fix with new data structure
    var _this = this;
    //get feature render configuration
    var color = _.isFunction(_this.color) ? _this.color(feature) : _this.color;
    var label = _.isFunction(_this.label) ? _this.label(feature) : _this.label;
    var height = _.isFunction(_this.height) ? _this.height(feature) : _this.height;
    var tooltipTitle = _.isFunction(_this.tooltipTitle) ? _this.tooltipTitle(feature) : _this.tooltipTitle;
    var tooltipText = _.isFunction(_this.tooltipText) ? _this.tooltipText(feature) : _this.tooltipText;
    var infoWidgetId = _.isFunction(_this.infoWidgetId) ? _this.infoWidgetId(feature) : _this.infoWidgetId;

    //get feature genomic information
    var start = feature.start;
    var end = feature.end;
    var length = (end - start) + 1;

    //check genomic length
    length = (length < 0) ? Math.abs(length) : length;
    length = (length == 0) ? 1 : length;

    //transform to pixel position
    var width = length * args.pixelBase;

    var svgLabelWidth = _this.getLabelWidth(label, args);

    //calculate x to draw svg rect
    var x = _this.getFeatureX(start, args);

    var maxWidth = Math.max(width, 2);
    var textHeight = 0;
    if (args.regionSize < args.maxLabelRegionSize) {
        textHeight = 9;
        maxWidth = Math.max(width, svgLabelWidth);
    }


    var rowY = 0;
    var textY = textHeight + height;
    var rowHeight = textHeight + height + 2;


//        azul osucuro: 0/0
//        negro: ./.
//        rojo: 1/1
//        naranja 0/1

    var d00 = '';
    var dDD = '';
    var d11 = '';
    var d01 = '';
    var xs = x; // x start
    var xe = x + width; // x end
    var ys = 1; // y
    var yi = 6; //y increment
    var yi2 = 10; //y increment
    for (var i = 0, leni = feature.samples.length; i < leni; i++) {
        args.renderedArea[ys] = new FeatureBinarySearchTree();
        args.renderedArea[ys].add({start: xs, end: xe});
        var genotype = feature.samples[i].split(':')[0];
        switch (genotype) {
            case '0|0':
            case '0/0':
                d00 += 'M' + xs + ',' + ys + ' L' + xe + ',' + ys + ' ';
                d00 += 'L' + xe + ',' + (ys + yi) + ' L' + xs + ',' + (ys + yi) + ' z ';
                break;
            case '.|.':
            case './.':
                dDD += 'M' + xs + ',' + ys + ' L' + xe + ',' + ys + ' ';
                dDD += 'L' + xe + ',' + (ys + yi) + ' L' + xs + ',' + (ys + yi) + ' z ';
                break;
            case '1|1':
            case '1/1':
                d11 += 'M' + xs + ',' + ys + ' L' + xe + ',' + ys + ' ';
                d11 += 'L' + xe + ',' + (ys + yi) + ' L' + xs + ',' + (ys + yi) + ' z ';
                break;
            case '0|1':
            case '0/1':
            case '1|0':
            case '1/0':
                d01 += 'M' + xs + ',' + ys + ' L' + xe + ',' + ys + ' ';
                d01 += 'L' + xe + ',' + (ys + yi) + ' L' + xs + ',' + (ys + yi) + ' z ';
                break;
        }
        ys += yi2;
    }
    var featureGroup = SVG.addChild(args.svgCanvasFeatures, "g", {'feature_id': feature.id});
    var dummyRect = SVG.addChild(featureGroup, "rect", {
        'x': xs,
        'y': 1,
        'width': width,
        'height': ys,
        'fill': 'transparent',
        'cursor': 'pointer'
    });
    if (d00 != '') {
        var path = SVG.addChild(featureGroup, "path", {
            'd': d00,
            'fill': 'blue',
            'cursor': 'pointer'
        });
    }
    if (dDD != '') {
        var path = SVG.addChild(featureGroup, "path", {
            'd': dDD,
            'fill': 'black',
            'cursor': 'pointer'
        });
    }
    if (d11 != '') {
        var path = SVG.addChild(featureGroup, "path", {
            'd': d11,
            'fill': 'red',
            'cursor': 'pointer'
        });
    }
    if (d01 != '') {
        var path = SVG.addChild(featureGroup, "path", {
            'd': d01,
            'fill': 'orange',
            'cursor': 'pointer'
        });
    }


    var lastSampleIndex = 0;
    $(featureGroup).qtip({
        content: {text: tooltipText + '<br>' + feature.samples[lastSampleIndex], title: tooltipTitle},
//                        position: {target: "mouse", adjust: {x: 15, y: 0}, effect: false},
        position: {target: "mouse", adjust: {x: 25, y: 15}},
        style: {width: true, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
        show: {delay: 300},
        hide: {delay: 300}
    });
    $(featureGroup).mousemove(function (event) {
        var sampleIndex = parseInt(event.offsetY / yi2);
        if (sampleIndex != lastSampleIndex) {
            console.log(sampleIndex);
            $(featureGroup).qtip('option', 'content.text', tooltipText + '<br>' + feature.samples[sampleIndex]);
        }
        lastSampleIndex = sampleIndex;
    });
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

//any item with chromosome start end
AlignmentRenderer.prototype = new Renderer({});

function AlignmentRenderer(args) {
    Renderer.call(this, args);
    // Using Underscore 'extend' function to extend and add Backbone Events
    _.extend(this, Backbone.Events);

    this.fontClass = 'ocb-font-roboto ocb-font-size-11';
    this.toolTipfontClass = 'ocb-tooltip-font';

    if (_.isObject(args)) {
        _.extend(this, args);
    }

    this.on(this.handlers);
};


AlignmentRenderer.prototype.render = function (response, args) {
    var _this = this;

    var sequenceDataAdapter = args.trackListPanel.getSequenceTrack().dataAdapter;

    //CHECK VISUALIZATON MODE
    if (_.isUndefined(response.params)) {
        response.params = {};
    }

    var viewAsPairs = false;
    if (response.params["view_as_pairs"] != null) {
        viewAsPairs = true;
    }
    console.log("viewAsPairs " + viewAsPairs);
    var insertSizeMin = 0;
    var insertSizeMax = 0;
    var variantColor = "orangered";
    if (response.params["insert_size_interval"] != null) {
        insertSizeMin = response.params["insert_size_interval"].split(",")[0];
        insertSizeMax = response.params["insert_size_interval"].split(",")[1];
    }
    console.log("insertSizeMin " + insertSizeMin);
    console.log("insertSizeMin " + insertSizeMax);

    //Prevent browser context menu
    $(args.svgCanvasFeatures).contextmenu(function (e) {
        console.log("click derecho")
        //e.preventDefault();
    });

    console.time("BamRender " + response.params.resource);

    var chunkList = response.items;

//    var middle = this.width / 2;

    var bamCoverGroup = SVG.addChild(args.svgCanvasFeatures, "g", {
        "class": "bamCoverage",
        "cursor": "pointer"
    });
    var bamReadGroup = SVG.addChild(args.svgCanvasFeatures, "g", {
        "class": "bamReads",
        "cursor": "pointer"
    });

    var drawCoverage = function (chunk) {
        //var coverageList = chunk.coverage.all;
        var coverageList = chunk.coverage.all;
        var coverageListA = chunk.coverage.a;
        var coverageListC = chunk.coverage.c;
        var coverageListG = chunk.coverage.g;
        var coverageListT = chunk.coverage.t;
        var start = parseInt(chunk.start);
        var end = parseInt(chunk.end);
        var pixelWidth = (end - start + 1) * args.pixelBase;

        var middle = args.width / 2;
        var points = "", pointsA = "", pointsC = "", pointsG = "", pointsT = "";
        var baseMid = (args.pixelBase / 2) - 0.5;//4.5 cuando pixelBase = 10

        var x, y, p = parseInt(chunk.start);
        var lineA = "", lineC = "", lineG = "", lineT = "";
        var coverageNorm = 200, covHeight = 50;
        for (var i = 0; i < coverageList.length; i++) {
            //x = _this.pixelPosition+middle-((_this.position-p)*_this.pixelBase)+baseMid;
            x = args.pixelPosition + middle - ((args.position - p) * args.pixelBase);
            xx = args.pixelPosition + middle - ((args.position - p) * args.pixelBase) + args.pixelBase;

            lineA += x + "," + coverageListA[i] / coverageNorm * covHeight + " ";
            lineA += xx + "," + coverageListA[i] / coverageNorm * covHeight + " ";
            lineC += x + "," + (coverageListC[i] + coverageListA[i]) / coverageNorm * covHeight + " ";
            lineC += xx + "," + (coverageListC[i] + coverageListA[i]) / coverageNorm * covHeight + " ";
            lineG += x + "," + (coverageListG[i] + coverageListC[i] + coverageListA[i]) / coverageNorm * covHeight + " ";
            lineG += xx + "," + (coverageListG[i] + coverageListC[i] + coverageListA[i]) / coverageNorm * covHeight + " ";
            lineT += x + "," + (coverageListT[i] + coverageListG[i] + coverageListC[i] + coverageListA[i]) / coverageNorm * covHeight + " ";
            lineT += xx + "," + (coverageListT[i] + coverageListG[i] + coverageListC[i] + coverageListA[i]) / coverageNorm * covHeight + " ";

            p++;
        }

        //reverse to draw the polylines(polygons) for each nucleotid
        var rlineC = lineC.split(" ").reverse().join(" ").trim();
        var rlineG = lineG.split(" ").reverse().join(" ").trim();
        var rlineT = lineT.split(" ").reverse().join(" ").trim();

        var firstPoint = args.pixelPosition + middle - ((args.position - parseInt(chunk.start)) * args.pixelBase) + baseMid;
        var lastPoint = args.pixelPosition + middle - ((args.position - parseInt(chunk.end)) * args.pixelBase) + baseMid;

        var polA = SVG.addChild(bamCoverGroup, "polyline", {
            "points": firstPoint + ",0 " + lineA + lastPoint + ",0",
            //"opacity":"1",
            //"stroke-width":"1",
            //"stroke":"gray",
            "fill": "green"
        });
        var polC = SVG.addChild(bamCoverGroup, "polyline", {
            "points": lineA + " " + rlineC,
            //"opacity":"1",
            //"stroke-width":"1",
            //"stroke":"black",
            "fill": "blue"
        });
        var polG = SVG.addChild(bamCoverGroup, "polyline", {
            "points": lineC + " " + rlineG,
            //"opacity":"1",
            //"stroke-width":"1",
            //"stroke":"black",
            "fill": "gold"
        });
        var polT = SVG.addChild(bamCoverGroup, "polyline", {
            "points": lineG + " " + rlineT,
            //"opacity":"1",
            //"stroke-width":"1",
            //"stroke":"black",
            "fill": "red"
        });

        var dummyRect = SVG.addChild(bamCoverGroup, "rect", {
            "x": args.pixelPosition + middle - ((args.position - start) * args.pixelBase),
            "y": 0,
            "width": pixelWidth,
            "height": covHeight,
            "opacity": "0.5",
            "fill": "lightgray",
            "cursor": "pointer"
        });


        $(dummyRect).qtip({
            content: " ",
            position: {target: 'mouse', adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
            style: {width: true, classes: _this.toolTipfontClass + ' ui-tooltip-shadow'},
            show: {delay: 300},
            hide: {delay: 300}
        });


        args.trackListPanel.on('mousePosition:change', function (e) {
            var pos = e.mousePos - parseInt(chunk.start);
            //if(coverageList[pos]!=null){
            var str = 'depth: <span class="ssel">' + coverageList[pos] + '</span><br>' +
                '<span style="color:green">A</span>: <span class="ssel">' + chunk.coverage.a[pos] + '</span><br>' +
                '<span style="color:blue">C</span>: <span class="ssel">' + chunk.coverage.c[pos] + '</span><br>' +
                '<span style="color:darkgoldenrod">G</span>: <span class="ssel">' + chunk.coverage.g[pos] + '</span><br>' +
                '<span style="color:red">T</span>: <span class="ssel">' + chunk.coverage.t[pos] + '</span><br>';
            $(dummyRect).qtip('option', 'content.text', str);
            //}
        });
    };

    var drawSingleRead = function (feature) {
        //var start = feature.start;
        //var end = feature.end;
        var start = feature.unclippedStart;
        var end = feature.unclippedEnd;
        if (feature.end == 0) {
            end = start + feature.length - 1;
        }
        var length = (end - start) + 1;
        var differences = feature.differences;

        //get feature render configuration
        var color = _.isFunction(_this.color) ? _this.color(feature, args.region.chromosome) : _this.color;
        var strokeColor = _.isFunction(_this.strokeColor) ? _this.strokeColor(feature, args.region.chromosome) : _this.strokeColor;
        var label = _.isFunction(_this.label) ? _this.label(feature) : _this.label;
        var height = _.isFunction(_this.height) ? _this.height(feature) : _this.height;
        var tooltipTitle = _.isFunction(_this.tooltipTitle) ? _this.tooltipTitle(feature) : _this.tooltipTitle;
        var tooltipText = _.isFunction(_this.tooltipText) ? _this.tooltipText(feature) : _this.tooltipText;
        var strand = _.isFunction(_this.strand) ? _this.strand(feature) : _this.strand;
        var mateUnmappedFlag = _.isFunction(_this.mateUnmappedFlag) ? _this.mateUnmappedFlag(feature) : _this.mateUnmappedFlag;
        var infoWidgetId = _.isFunction(_this.infoWidgetId) ? _this.infoWidgetId(feature) : _this.infoWidgetId;

        if (insertSizeMin != 0 && insertSizeMax != 0 && !mateUnmappedFlag) {
            if (Math.abs(feature.inferredInsertSize) > insertSizeMax) {
                color = 'maroon';
            }
            if (Math.abs(feature.inferredInsertSize) < insertSizeMin) {
                color = 'navy';
            }
        }

        //transform to pixel position
        var width = length * args.pixelBase;
        //calculate x to draw svg rect
        var x = _this.getFeatureX(start, args);
//		try{
//			var maxWidth = Math.max(width, /*settings.getLabel(feature).length*8*/0); //XXX cuidado : text.getComputedTextLength()
//		}catch(e){
//			var maxWidth = 72;
//		}
        maxWidth = width;
        //if(length <0){
        //    debugger
        //}
        console.log(length + ' in px: ' + width);


        var rowHeight = 16;
        var rowY = 70;
//		var textY = 12+settings.height;
        while (true) {
            if (args.renderedArea[rowY] == null) {
                args.renderedArea[rowY] = new FeatureBinarySearchTree();
            }
            var enc = args.renderedArea[rowY].add({start: x, end: x + maxWidth - 1});
            if (enc) {
                var featureGroup = SVG.addChild(bamReadGroup, "g", {'feature_id': feature.name});
                var points = {
                    "Reverse": x + "," + (rowY + (height / 2)) + " " + (x + 5) + "," + rowY + " " + (x + width) + "," + rowY + " " + (x + width) + "," + (rowY + height) + " " + (x + 5) + "," + (rowY + height),
                    "Forward": (x - 1) + "," + rowY + " " + (x + width - 5) + "," + rowY + " " + (x + width) + "," + (rowY + (height / 2)) + " " + (x + width - 5) + "," + (rowY + height) + " " + (x - 1) + "," + (rowY + height)
                }
                var poly = SVG.addChild(featureGroup, "polygon", {
                    "points": points[strand],
                    "stroke": color,
                    "stroke-width": 1,
                    "fill": color,
                    "cursor": "pointer"
                });

                $(featureGroup).qtip({
                    content: {text: tooltipText, title: tooltipTitle},
                    position: {target: "mouse", adjust: {x: 25, y: 15}},
                    style: {width: 300, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
                    show: 'mouseenter',
                    hide: 'mousedown mouseup mouseleave'
                });

                featureGroup.addEventListener('click', function (event) {
                    console.log(feature);
                    _this.trigger('feature:click', {
                        query: feature[infoWidgetId],
                        feature: feature,
                        featureType: feature.featureType,
                        clickEvent: event
                    })
                });

                //var rect = SVG.addChild(featureGroup,"rect",{
                //"x":x+offset[strand],
                //"y":rowY,
                //"width":width-4,
                //"height":settings.height,
                //"stroke": "white",
                //"stroke-width":1,
                //"fill": color,
                //"clip-path":"url(#"+_this.id+"cp)",
                //"fill": 'url(#'+_this.id+'bamStrand'+strand+')',
                //});
                //readEls.push(rect);

                //PROCESS differences
                if (differences != null && args.regionSize < 400) {
                    var region = new Region({chromosome: args.region.chromosome, start: start, end: end});
                    sequenceDataAdapter.getData({
                        region: region,
                        done: function (event) {
                            var referenceString = AlignmentRenderer._getReferenceString(event.items, region);
                            featureGroup.appendChild(AlignmentRenderer.drawBamDifferences(referenceString, differences, args.pixelBase, x, rowY + height));
                        }
                    });
                }

                break;
            }
            rowY += rowHeight;
//			textY += rowHeight;
        }
    };

    var drawPairedReads = function (read, mate) {
        var readStart = read.unclippedStart;
        var readEnd = read.unclippedEnd;
        var mateStart = mate.unclippedStart;
        var mateEnd = mate.unclippedEnd;
        var readDiff = read.diff;
        var mateDiff = mate.diff;
        /*get type settings object*/
        var readSettings = _this.types[read.featureType];
        var mateSettings = _this.types[mate.featureType];
        var readColor = readSettings.getColor(read, _this.region.chromosome);
        var mateColor = mateSettings.getColor(mate, _this.region.chromosome);
        var readStrand = readSettings.getStrand(read);
        var matestrand = mateSettings.getStrand(mate);

        if (insertSizeMin != 0 && insertSizeMax != 0) {
            if (Math.abs(read.inferredInsertSize) > insertSizeMax) {
                readColor = 'maroon';
                mateColor = 'maroon';
            }
            if (Math.abs(read.inferredInsertSize) < insertSizeMin) {
                readColor = 'navy';
                mateColor = 'navy';
            }
        }

        var pairStart = readStart;
        var pairEnd = mateEnd;
        if (mateStart <= readStart) {
            pairStart = mateStart;
        }
        if (readEnd >= mateEnd) {
            pairEnd = readEnd;
        }

        /*transform to pixel position*/
        var pairWidth = ((pairEnd - pairStart) + 1) * _this.pixelBase;
        var pairX = _this.pixelPosition + middle - ((_this.position - pairStart) * _this.pixelBase);

        var readWidth = ((readEnd - readStart) + 1) * _this.pixelBase;
        var readX = _this.pixelPosition + middle - ((_this.position - readStart) * _this.pixelBase);

        var mateWidth = ((mateEnd - mateStart) + 1) * _this.pixelBase;
        var mateX = _this.pixelPosition + middle - ((_this.position - mateStart) * _this.pixelBase);

        var rowHeight = 12;
        var rowY = 70;
//		var textY = 12+settings.height;

        while (true) {
            if (args.renderedArea[rowY] == null) {
                args.renderedArea[rowY] = new FeatureBinarySearchTree();
            }
            var enc = args.renderedArea[rowY].add({start: pairX, end: pairX + pairWidth - 1});
            if (enc) {
                var readEls = [];
                var mateEls = [];
                var readPoints = {
                    "Reverse": readX + "," + (rowY + (readSettings.height / 2)) + " " + (readX + 5) + "," + rowY + " " + (readX + readWidth - 5) + "," + rowY + " " + (readX + readWidth - 5) + "," + (rowY + readSettings.height) + " " + (readX + 5) + "," + (rowY + readSettings.height),
                    "Forward": readX + "," + rowY + " " + (readX + readWidth - 5) + "," + rowY + " " + (readX + readWidth) + "," + (rowY + (readSettings.height / 2)) + " " + (readX + readWidth - 5) + "," + (rowY + readSettings.height) + " " + readX + "," + (rowY + readSettings.height)
                }
                var readPoly = SVG.addChild(bamReadGroup, "polygon", {
                    "points": readPoints[readStrand],
                    "stroke": readSettings.getStrokeColor(read),
                    "stroke-width": 1,
                    "fill": readColor,
                    "cursor": "pointer"
                });
                readEls.push(readPoly);
                var matePoints = {
                    "Reverse": mateX + "," + (rowY + (mateSettings.height / 2)) + " " + (mateX + 5) + "," + rowY + " " + (mateX + mateWidth - 5) + "," + rowY + " " + (mateX + mateWidth - 5) + "," + (rowY + mateSettings.height) + " " + (mateX + 5) + "," + (rowY + mateSettings.height),
                    "Forward": mateX + "," + rowY + " " + (mateX + mateWidth - 5) + "," + rowY + " " + (mateX + mateWidth) + "," + (rowY + (mateSettings.height / 2)) + " " + (mateX + mateWidth - 5) + "," + (rowY + mateSettings.height) + " " + mateX + "," + (rowY + mateSettings.height)
                }
                var matePoly = SVG.addChild(bamReadGroup, "polygon", {
                    "points": matePoints[matestrand],
                    "stroke": mateSettings.getStrokeColor(mate),
                    "stroke-width": 1,
                    "fill": mateColor,
                    "cursor": "pointer"
                });
                mateEls.push(matePoly);

                var line = SVG.addChild(bamReadGroup, "line", {
                    "x1": (readX + readWidth),
                    "y1": (rowY + (readSettings.height / 2)),
                    "x2": mateX,
                    "y2": (rowY + (readSettings.height / 2)),
                    "stroke-width": "1",
                    "stroke": "gray",
                    //"stroke-color": "black",
                    "cursor": "pointer"
                });

                if (args.regionSize < 400) {
                    if (readDiff != null) {
                        var readPath = SVG.addChild(bamReadGroup, "path", {
                            "d": Utils.genBamVariants(readDiff, _this.pixelBase, readX, rowY),
                            "fill": variantColor
                        });
                        readEls.push(readPath);
                    }
                    if (mateDiff != null) {
                        var matePath = SVG.addChild(bamReadGroup, "path", {
                            "d": Utils.genBamVariants(mateDiff, _this.pixelBase, mateX, rowY),
                            "fill": variantColor
                        });
                        mateEls.push(matePath);
                    }
                }

                $(readEls).qtip({
                    content: {text: readSettings.getTipText(read), title: readSettings.getTipTitle(read)},
                    position: {target: "mouse", adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
                    style: {width: 280, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
                    show: 'click',
                    hide: 'click mouseleave'
                });
                $(readEls).click(function (event) {
                    console.log(read);
                    _this.showInfoWidget({
                        query: read[readSettings.infoWidgetId],
                        feature: read,
                        featureType: read.featureType,
                        adapter: _this.trackData.adapter
                    });
                });
                $(mateEls).qtip({
                    content: {text: mateSettings.getTipText(mate), title: mateSettings.getTipTitle(mate)},
                    position: {target: "mouse", adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
                    style: {width: 280, classes: _this.toolTipfontClass + ' ui-tooltip ui-tooltip-shadow'},
                    show: 'click',
                    hide: 'click mouseleave'
                });
                $(mateEls).click(function (event) {
                    console.log(mate);
                    _this.showInfoWidget({
                        query: mate[mateSettings.infoWidgetId],
                        feature: mate,
                        featureType: mate.featureType,
                        adapter: _this.trackData.adapter
                    });
                });
                break;
            }
            rowY += rowHeight;
//			textY += rowHeight;
        }
    };

    var drawChunk = function (chunk) {
        drawCoverage(chunk.value);
        var alignments = chunk.value.alignments;
        for (var i = 0, li = alignments.length; i < li; i++) {
            var alignment = alignments[i];
            if (viewAsPairs) {
                var nextRead = alignments[i + 1];
                if (nextRead != null) {
                    if (alignment.name == nextRead.name) {
                        drawPairedReads(alignment, nextRead);
                        i++;
                    } else {
                        drawSingleRead(alignment);
                    }
                }
            } else {
                drawSingleRead(alignment);
            }
        }
    };

    //process features
    if (chunkList.length > 0) {
        for (var i = 0, li = chunkList.length; i < li; i++) {
            drawChunk(chunkList[i]);
        }
//        var newHeight = Object.keys(this.renderedArea).length * 24;
//        if (newHeight > 0) {
//            this.setHeight(newHeight + /*margen entre tracks*/10 + 70);
//        }
        //TEST
//        this.setHeight(200);
    }
    console.timeEnd("BamRender " + response.params.resource);
};

/**
 * @Deprecated
 * **/
AlignmentRenderer.genBamVariants = function (differences, size, mainX, y) {

    var s = size / 6;
    var d = "";
    for (var i = 0; i < differences.length; i++) {
        var difference = differences[i];

        switch (difference.op) {
            case "S" :
                var x = mainX + (size * difference.pos);
                for (var j = 0; j < difference.length; j++) {
                    var char = difference.seq[j];
                    switch (char) {
                        case "A" :
                            d += "M" + ((2.5 * s) + x) + "," + (y) +
                                "l-" + (2.5 * s) + "," + (6 * s) +
                                "l" + s + ",0" +
                                "l" + (0.875 * s) + ",-" + (2 * s) +
                                "l" + (2.250 * s) + ",0" +
                                "l" + (0.875 * s) + "," + (2 * s) +
                                "l" + s + ",0" +
                                "l-" + (2.5 * s) + ",-" + (6 * s) +
                                "l-" + (0.5 * s) + ",0" +
                                "l0," + s +
                                "l" + (0.75 * s) + "," + (2 * s) +
                                "l-" + (1.5 * s) + ",0" +
                                "l" + (0.75 * s) + ",-" + (2 * s) +
                                "l0,-" + s +
                                " ";
                            break;
                        case "T" :
                            d += "M" + ((0.5 * s) + x) + "," + (y) +
                                "l0," + s +
                                "l" + (2 * s) + ",0" +
                                "l0," + (5 * s) +
                                "l" + s + ",0" +
                                "l0,-" + (5 * s) +
                                "l" + (2 * s) + ",0" +
                                "l0,-" + s +
                                " ";
                            break;
                        case "C" :
                            d += "M" + ((5 * s) + x) + "," + ((0 * s) + y) +
                                "l-" + (2 * s) + ",0" +
                                "l-" + (1.5 * s) + "," + (0.5 * s) +
                                "l-" + (0.5 * s) + "," + (1.5 * s) +
                                "l0," + (2 * s) +
                                "l" + (0.5 * s) + "," + (1.5 * s) +
                                "l" + (1.5 * s) + "," + (0.5 * s) +
                                "l" + (2 * s) + ",0" +
                                "l0,-" + s +
                                "l-" + (2 * s) + ",0" +
                                "l-" + (0.75 * s) + ",-" + (0.25 * s) +
                                "l-" + (0.25 * s) + ",-" + (0.75 * s) +
                                "l0,-" + (2 * s) +
                                "l" + (0.25 * s) + ",-" + (0.75 * s) +
                                "l" + (0.75 * s) + ",-" + (0.25 * s) +
                                "l" + (2 * s) + ",0" +
                                " ";
                            break;
                        case "G" :
                            d += "M" + ((5 * s) + x) + "," + ((0 * s) + y) +
                                "l-" + (2 * s) + ",0" +
                                "l-" + (1.5 * s) + "," + (0.5 * s) +
                                "l-" + (0.5 * s) + "," + (1.5 * s) +
                                "l0," + (2 * s) +
                                "l" + (0.5 * s) + "," + (1.5 * s) +
                                "l" + (1.5 * s) + "," + (0.5 * s) +
                                "l" + (2 * s) + ",0" +
                                "l0,-" + (3 * s) +
                                "l-" + (s) + ",0" +
                                "l0," + (2 * s) +
                                "l-" + (s) + ",0" +
                                "l-" + (0.75 * s) + ",-" + (0.25 * s) +
                                "l-" + (0.25 * s) + ",-" + (0.75 * s) +
                                "l0,-" + (2 * s) +
                                "l" + (0.25 * s) + ",-" + (0.75 * s) +
                                "l" + (0.75 * s) + ",-" + (0.25 * s) +
                                "l" + (2 * s) + ",0" +
                                " ";
//                d += "M" + ((5 * s) + x) + "," + ((0 * s) + y) +
//                    "l-" + (2 * s) + ",0" +
//                    "l-" + (2 * s) + "," + (2 * s) +
//                    "l0," + (2 * s) +
//                    "l" + (2 * s) + "," + (2 * s) +
//                    "l" + (2 * s) + ",0" +
//                    "l0,-" + (3 * s) +
//                    "l-" + (1 * s) + ",0" +
//                    "l0," + (2 * s) +
//                    "l-" + (0.5 * s) + ",0" +
//                    "l-" + (1.5 * s) + ",-" + (1.5 * s) +
//                    "l0,-" + (1 * s) +
//                    "l" + (1.5 * s) + ",-" + (1.5 * s) +
//                    "l" + (1.5 * s) + ",0" +
//                    " ";
                            break;
                        case "N" :
                            d += "M" + ((0.5 * s) + x) + "," + ((0 * s) + y) +
                                "l0," + (6 * s) +
                                "l" + s + ",0" +
                                "l0,-" + (4.5 * s) +
                                "l" + (3 * s) + "," + (4.5 * s) +
                                "l" + s + ",0" +
                                "l0,-" + (6 * s) +
                                "l-" + s + ",0" +
                                "l0," + (4.5 * s) +
                                "l-" + (3 * s) + ",-" + (4.5 * s) +
                                " ";
                            break;
                        case "d" :
                            d += "M" + ((0 * s) + x) + "," + ((2.5 * s) + y) +
                                "l" + (6 * s) + ",0" +
                                "l0," + (s) +
                                "l-" + (6 * s) + ",0" +
                                "l0,-" + (s) +
                                " ";
                            break;
                        default:
                            d += "M0,0";
                            break;
                    }
                    x += size;
                }
                break;
        }

    }

    return d;
};

AlignmentRenderer.drawBamDifferences = function (refString, differences, size, mainX, y) {
    var text = SVG.create("text", {
        "x": mainX,
        "y": y - 2,
        "class": 'ocb-font-ubuntumono ocb-font-size-15'
    });
    for (var i = 0; i < differences.length; i++) {
        var difference = differences[i];

        switch (difference.op) {
            // M 0 alignment match (can be a sequence match or mismatch)
            // I 1 insertion to the reference
            // D 2 deletion from the reference
            // N 3 skipped region from the reference
            // S 4 soft clipping (clipped sequences present in SEQ)
            // H 5 hard clipping (clipped sequences NOT present in SEQ)
            //P 6 padding (silent deletion from padded reference)
            //= 7 sequence match
            // X 8 sequence mismatch

            case "I" :
                var x = mainX + (size * difference.pos) - size / 2;
                var t = SVG.addChild(text, "tspan", {
                    "x": x,
                    "font-weight": 'bold',
                    "textLength": size
                });
                t.textContent = '';
                $(t).qtip({
                    content: {text: difference.seq, title: 'Insertion'},
                    position: {target: "mouse", adjust: {x: 25, y: 15}},
                    style: {classes: this.toolTipfontClass + ' qtip-dark qtip-shadow'}
                });
                break;
            case "D" :
                var x = mainX + (size * difference.pos);
                for (var j = 0; j < difference.length; j++) {
                    var t = SVG.addChild(text, "tspan", {
                        "x": x,
                        "font-weight": 'bold',
                        "textLength": size
                    });
                    t.textContent = '';
                    x += size;
                }
                break;
            case "N" :
                var x = mainX + (size * difference.pos);
                for (var j = 0; j < difference.length; j++) {
                    var t = SVG.addChild(text, "tspan", {
                        "x": x,
                        "fill": "#888",
                        "textLength": size
                    });
                    t.textContent = '';
                    x += size;
                }
                break;
            case "S" :
                var x = mainX + (size * difference.pos);
                for (var j = 0; j < difference.length; j++) {
                    var char = difference.seq[j];
                    var t = SVG.addChild(text, "tspan", {
                        "x": x,
                        "fill": "#aaa",
                        "textLength": size
                    });
                    t.textContent = char;
                    x += size;
                }
                break;
            case "H" :
                var x = mainX + (size * difference.pos);
                for (var j = 0; j < difference.length; j++) {
                    var t = SVG.addChild(text, "tspan", {
                        "x": x,
                        "fill": "#aaa",
                        "textLength": size
                    });
                    t.textContent = 'H';
                    x += size;
                }
                break;
            case "X" :
            case "M" :
                var x = mainX + (size * difference.pos);
                for (var j = 0; j < difference.length; j++) {
                    var char = difference.seq[j];
                    var refPos = difference.pos + j;
                    // console.log("ref:"+ refString.charAt(refPos)+" - "+"seq:"+char);
                    if (char != refString.charAt(refPos)) {
                        var t = SVG.addChild(text, "tspan", {
                            "x": x,
                            "fill": SEQUENCE_COLORS[char],
                            "textLength": size
                        });
                        t.textContent = char;
                    }
                    x += size;
                }
                break;
        }

    }

    return text;
};

AlignmentRenderer._getReferenceString = function (chunks, region) {
    var sequenceItems = [];
    var chunk;
    for (var i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        for (var j = 0; j < chunk.value.length; j++) {
            sequenceItems.push(chunk.value[j]);
        }
    }
    sequenceItems.sort(function (a, b) {
        return a.start - b.start;
    });
    var aux = [];
    var s = sequenceItems[0].start;
    var e = sequenceItems[sequenceItems.length - 1].end;
    for (var i = 0; i < sequenceItems.length; i++) {
        aux.push(sequenceItems[i].sequence);
    }
    var str = aux.join("");
    var i1 = region.start - s;
    var i2 = i1 + region.length();
    var substr = str.substring(i1, i2);

    return substr;
};
</script>


<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function UrlWidget(args) {
    var _this = this;

    _.extend(this, Backbone.Events);

    this.id = Utils.genId("UrlWidget");

    this.targetId = null;
    this.title = "Custom url";
    this.width = 500;
    this.height = 400;

    _.extend(this, args);
    this.on(this.handlers);

};

UrlWidget.prototype.draw = function () {
    if (this.panel == null) {
        this.render();
    }
    this.panel.show();
};

UrlWidget.prototype.render = function () {
    var _this = this;

    this.urlField = Ext.create('Ext.form.field.Text', {
        margin: "0 2 2 0",
        labelWidth: 30,
        width: this.width - 55,
        fieldLabel: 'URL',
        emptyText: 'enter a valid url',
//		value : "http://das.sanger.ac.uk/das/grc_region_GRCh37/features",
        value: "http://www.ensembl.org/das/Homo_sapiens.GRCh37.gene/features",
        listeners: { change: {fn: function () {
            var dasName = this.value.split('/das/')[1].split('/')[0];
            _this.trackNameField.setValue(dasName);
        }}
        }
    });
    this.checkButton = Ext.create('Ext.button.Button', {
        text: 'Check',
        handler: function () {
            _this.form.setLoading();
//			var dasDataAdapter = new DasRegionDataAdapter({
//				url : _this.urlField.getValue()
//			});
//			dasDataAdapter.successed.addEventListener(function() {
//				_this.contentArea.setValue(dasDataAdapter.xml);
//				_this.form.setLoading(false);
//			});
//
//			dasDataAdapter.onError.addEventListener(function() {
//				_this.contentArea.setValue("XMLHttpRequest cannot load. This server is not allowed by Access-Control-Allow-Origin");
//				_this.form.setLoading(false);
//			});
//			dasDataAdapter.fill(1, 1, 1);

            var dasAdapter = new DasAdapter({
                url: _this.urlField.getValue(),
                featureCache: {
                    gzip: false,
                    chunkSize: 10000
                },
                handlers: {
                    'url:check': function (event) {
                        console.log(event.data);
                        _this.contentArea.setValue(event.data);
                        _this.form.setLoading(false);

                    },
                    'error': function () {
                        _this.contentArea.setValue("XMLHttpRequest cannot load. This server is not allowed by Access-Control-Allow-Origin");
                        _this.form.setLoading(false);

                    }
                }
            });

            dasAdapter.checkUrl();
        }
    });
    this.trackNameField = Ext.create('Ext.form.field.Text', {
        name: 'file',
//        fieldLabel: 'Track name',
        allowBlank: false,
        value: _this.urlField.value.split('/das/')[1].split('/')[0],
        emptyText: 'Choose a name',
        flex: 1
    });
    this.panelSettings = Ext.create('Ext.panel.Panel', {
        layout: 'hbox',
        border: false,
        title: 'Track name',
        cls: "panel-border-top",
        bodyPadding: 10,
        width: this.width - 2,
        items: [this.trackNameField]
    });
    this.contentArea = Ext.create('Ext.form.field.TextArea', {
        margin: "-1",
        width: this.width,
        height: this.height
    });
    this.infobar = Ext.create('Ext.toolbar.Toolbar', {
        height: 28,
        cls: "bio-border-false",
        items: [this.urlField, this.checkButton]
    });
    this.form = Ext.create('Ext.panel.Panel', {
        border: false,
        items: [this.infobar, this.contentArea, this.panelSettings]
    });

    this.panel = Ext.create('Ext.ux.Window', {
        title: this.title,
        layout: 'fit',
        resizable: false,
        items: [this.form],
        buttons: [
            {
                text: 'Add',
                handler: function () {
                    _this.trigger('addButton:click', {name: _this.trackNameField.getValue(), url: _this.urlField.getValue()});
                    _this.panel.close();
                }
            },
            {text: 'Cancel', handler: function () {
                _this.panel.close();
            }}
        ],
        listeners: {
            destroy: function () {
                delete _this.panel;
            }
        }
    });
};</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

function FileWidget(args){
	var _this=this;

    _.extend(this, Backbone.Events);

    this.id = Utils.genId("FileWidget");
	this.targetId;
	this.wum = true;
	this.tags = [];
    this.viewer;
    this.title;
	this.dataAdapter;

    this.args = args;

    _.extend(this, args);


    this.on(this.handlers);

//	this.browserData = new BrowserDataWidget();
	/** Events i listen **/
//	this.browserData.onSelect.addEventListener(function (sender, data){
//		_this.trackNameField.setValue(data.filename);
//		_this.fileNameLabel.setText('<span class="emph">'+ data.filename +'</span> <span class="info">(server)</span>',false);
//		_this.panel.setLoading();
//	});
//    this.browserData.adapter.onReadData.addEventListener(function (sender, data){
//    	console.log(data)
//    	_this.trackNameField.setValue(data.filename);
//    	_this.fileNameLabel.setText('<span class="emph">'+ data.filename +'</span> <span class="info">(server)</span>',false);
//    	_this.loadFileFromServer(data);
//    	_this.panel.setLoading(false);
//	});
    
//    this.chartWidgetByChromosome = new ChartWidget({height:200,width:570});
};

FileWidget.prototype.getTitleName = function(){
	return this.trackNameField.getValue();
};


FileWidget.prototype.getFileFromServer = function(){
	//abstract method
};

FileWidget.prototype.loadFileFromLocal = function(){
	//abstract method
};

//FileWidget.prototype.getChartItems = function(){
//	return [this.chartWidgetByChromosome.getChart(["features","chromosome"])];
//};

FileWidget.prototype.getFileUpload = function(){
	var _this = this;
	this.uploadField = Ext.create('Ext.form.field.File', {
		msgTarget : 'side',
		flex:1,
        padding:1,
//		width:75,
		emptyText: 'Choose a file',
        allowBlank: false,
        anchor: '100%',
		buttonText : 'Browse local',
//		buttonOnly : true,
		listeners : {
			change : {
				fn : function() {
					_this.panel.setLoading();
					var file = document.getElementById(_this.uploadField.fileInputEl.id).files[0];

					_this.trackNameField.setValue(file.name);
					_this.fileNameLabel.setText('<span class="emph">'+ file.name +'</span> <span class="info">(local)</span>',false);
					_this.loadFileFromLocal(file);
					_this.panel.setLoading(false);

				}
			}
		}
	});
	return this.uploadField;
};


FileWidget.prototype.draw = function(){
	var _this = this;
	
	if (this.openDialog == null){
	
		/** Bar for the chart **/
		var featureCountBar = Ext.create('Ext.toolbar.Toolbar');
		this.featureCountLabel = Ext.create('Ext.toolbar.TextItem', {
			text:'<span class="dis">No file loaded</span>'
		});
		featureCountBar.add([this.featureCountLabel]);
		
		/** Bar for the file upload browser **/
		var browseBar = Ext.create('Ext.toolbar.Toolbar');
		browseBar.add(this.getFileUpload());
		
		this.panel = Ext.create('Ext.panel.Panel', {
			border: false,
	//		padding: "0 0 10 0",
			height:230,
			title: "Previsualization",
//		    items : this.getChartItems(),
		    bbar:featureCountBar
		});
		
	//	var colorPicker = Ext.create('Ext.picker.Color', {
	//	    value: '993300',  // initial selected color
	//	    listeners: {
	//	        select: function(picker, selColor) {
	//	            alert(selColor);
	//	        }
	//	    }
	//	});
		this.trackNameField = Ext.create('Ext.form.field.Text',{
			name: 'file',
            fieldLabel: 'Track Name',
            allowBlank: false,
            value: 'New track from '+this.title+' file',
            emptyText: 'Choose a name',
            flex:1
		});
		
		var panelSettings = Ext.create('Ext.panel.Panel', {
			border: false,
			layout: 'hbox',
			bodyPadding: 10,
		    items : [this.trackNameField]	 
		});
		
		
		if(this.wum){
//			this.btnBrowse = Ext.create('Ext.button.Button', {
//		        text: 'Browse server',
//		        disabled:true,
////		        iconCls:'icon-local',
////		        cls:'x-btn-default-small',
//		        handler: function (){
//	    	   		_this.browserData.draw($.cookie('bioinfo_sid'),_this.tags);
//	       		}
//			});
			
//			browseBar.add(this.btnBrowse);
			
			if(Cookies('bioinfo_sid') != null){
				this.sessionInitiated();
			}else{
				this.sessionFinished();
			}
		}
		
		this.fileNameLabel = Ext.create('Ext.toolbar.TextItem', {
//			text:'<span class="emph">Select a <span class="info">local</span> file or a <span class="info">server</span> file from your account.</span>'
		});
//		browseBar.add(['->',this.fileNameLabel]);
		
		
		
		this.btnOk = Ext.create('Ext.button.Button', {
			text:'Ok',
			disabled:true,
			handler: function(){
				_this.trigger('okButton:click',{fileName:_this.file.name, adapter:_this.adapter});
				_this.openDialog.close();
			}
		});
		
		this.openDialog = Ext.create('Ext.window.Window', {
			title : 'Open '+this.title+' file',
//			taskbar:Ext.getCmp(this.args.viewer.id+'uxTaskbar'),
			width : 600,
	//		bodyPadding : 10,
			resizable:false,
			items : [browseBar, /*this.panel,*/ panelSettings],
			buttons:[this.btnOk, 
			         {text:'Cancel', handler: function(){_this.openDialog.close();}}],
			listeners: {
			    	scope: this,
			    	minimize:function(){
						this.openDialog.hide();
			       	},
			      	destroy: function(){
			       		delete this.openDialog;
			      	}
		    	}
		});
		
	}
	this.openDialog.show();
};

//FileWidget.prototype._loadChartInfo = function(){
//
//	var datastore = new Array();
// 	for ( var chromosome in this.adapter.featuresByChromosome) {
//		datastore.push({ features: this.adapter.featuresByChromosome[chromosome], chromosome: chromosome });
//	}
// 	this.chartWidgetByChromosome.getStore().loadData(datastore);
//
// 	this.panel.setLoading(false);
// 	this.featureCountLabel.setText("Features count: " + this.adapter.featuresCount, false);
//};



FileWidget.prototype.sessionInitiated = function (){
//	if(this.btnBrowse!=null){
//		this.btnBrowse.enable();
//	}
};
FileWidget.prototype.sessionFinished = function (){
//	if(this.btnBrowse!=null){
//		this.btnBrowse.disable();
//	}
};</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

VCFFileWidget.prototype.getTitleName = FileWidget.prototype.getTitleName;
VCFFileWidget.prototype.getFileUpload = FileWidget.prototype.getFileUpload;
VCFFileWidget.prototype.draw = FileWidget.prototype.draw;
VCFFileWidget.prototype.sessionInitiated = FileWidget.prototype.sessionInitiated;
VCFFileWidget.prototype.sessionFinished = FileWidget.prototype.sessionFinished;
VCFFileWidget.prototype.getChartItems = FileWidget.prototype.getChartItems;
VCFFileWidget.prototype._loadChartInfo = FileWidget.prototype._loadChartInfo;

function VCFFileWidget(args){
	if (args == null){
		args = new Object();
	}
	args.title = "VCF";
	args.tags = ["vcf"];
	FileWidget.prototype.constructor.call(this, args);
};

VCFFileWidget.prototype.loadFileFromLocal = function(file){
	var _this = this;
	this.file = file;
	this.adapter = new VCFDataAdapter(new FileDataSource({file:file}),{species:this.viewer.species});
	this.adapter.on('file:load',function(sender){
		console.log(_this.adapter.featuresByChromosome);
//		_this._loadChartInfo();
	});
	_this.btnOk.enable();
};

VCFFileWidget.prototype.loadFileFromServer = function(data){
	this.file = {name:data.filename};
	this.adapter = new VCFDataAdapter(new StringDataSource(data.data),{async:false,species:this.viewer.species});
//	this._loadChartInfo();
	this.btnOk.enable();
};

</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

GFFFileWidget.prototype.getTitleName = FileWidget.prototype.getTitleName;
GFFFileWidget.prototype.getFileUpload = FileWidget.prototype.getFileUpload;
GFFFileWidget.prototype.draw = FileWidget.prototype.draw;
GFFFileWidget.prototype.sessionInitiated = FileWidget.prototype.sessionInitiated;
GFFFileWidget.prototype.sessionFinished = FileWidget.prototype.sessionFinished;
GFFFileWidget.prototype.getChartItems = FileWidget.prototype.getChartItems;
GFFFileWidget.prototype._loadChartInfo = FileWidget.prototype._loadChartInfo;

function GFFFileWidget(args){
	if (args == null){
		args = {};
	}
	this.version = "2";
    if (args.version!= null){
    	this.version = args.version;       
    }
	args.title = "GFF"+this.version;
	args.tags = ["gff"];
	FileWidget.prototype.constructor.call(this, args);
};



GFFFileWidget.prototype.loadFileFromLocal = function(file){
	var _this = this;
	this.file = file;
	switch(this.version){
	case "2":
	case 2:
		this.adapter = new GFF2DataAdapter(new FileDataSource({file:file}),{species:this.viewer.species});
		break;
	case "3":
	case 3:
		this.adapter = new GFF3DataAdapter(new FileDataSource({file:file}),{species:this.viewer.species});
		break;
	default :
		this.adapter = new GFF2DataAdapter(new FileDataSource({file:file}),{species:this.viewer.species});
		break;
	}
	
	this.adapter.on('file:load',function(e){
//		_this._loadChartInfo();
	});
	_this.btnOk.enable();
};


GFFFileWidget.prototype.loadFileFromServer = function(data){
	this.file = {name:data.filename};
	switch(this.version){
	case "2":
	case 2:
		this.adapter = new GFF2DataAdapter(new StringDataSource(data.data),{async:false,species:this.viewer.species});
		break;
	case "3":
	case 3:
		this.adapter = new GFF3DataAdapter(new StringDataSource(data.data),{async:false,species:this.viewer.species});
		break;
	default :
		this.adapter = new GFF2DataAdapter(new StringDataSource(data.data),{async:false,species:this.viewer.species});
		break;
	}
	
	this._loadChartInfo();
	this.btnOk.enable();
};
</script>
<script>/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see <http://www.gnu.org/licenses/>.
 */

BEDFileWidget.prototype.getTitleName = FileWidget.prototype.getTitleName;
BEDFileWidget.prototype.getFileUpload = FileWidget.prototype.getFileUpload;
BEDFileWidget.prototype.draw = FileWidget.prototype.draw;
BEDFileWidget.prototype.sessionInitiated = FileWidget.prototype.sessionInitiated;
BEDFileWidget.prototype.sessionFinished = FileWidget.prototype.sessionFinished;
BEDFileWidget.prototype.getChartItems = FileWidget.prototype.getChartItems;
BEDFileWidget.prototype._loadChartInfo = FileWidget.prototype._loadChartInfo;

function BEDFileWidget(args){
	if (args == null){
		args = new Object();
	}
	args.title = "BED";
	args.tags = ["bed"];
	FileWidget.prototype.constructor.call(this, args);
	
};


BEDFileWidget.prototype.loadFileFromLocal = function(file){
	var _this = this;
	this.file = file;
	this.adapter = new BEDDataAdapter(new FileDataSource({file:file}),{species:this.viewer.species});
    this.adapter.on('file:load',function(e){
//		_this._loadChartInfo();
    });
	_this.btnOk.enable();
};


BEDFileWidget.prototype.loadFileFromServer = function(data){
	this.file = {name:data.filename};
	this.adapter = new BEDDataAdapter(new StringDataSource(data.data),{async:false,species:this.viewer.species});
	this._loadChartInfo();
	this.btnOk.enable();
};
</script>



<style>
html.ocb, body.ocb {
    font-family: 'Lato', 'Roboto', 'Helvetica Neue', Helvetica, Arial, 'sans-serif' !important;
}
.hidden {
    display: none !important;
    visibility: hidden !important
}
.unselectable {
    user-select: none;
    -o-user-select: none;
    -ms-user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
    cursor: default
}

/*ocb header*/

.ocb-header-widget {
    background-color: #FFFFFF;
}
ul.ocb-help-menu, ul.ocb-app-menu, ul.ocb-header {
    margin: 0;
    padding: 0;
    background: white;
    color: #435f7a;
    list-style: none;
    text-transform: none;
    line-height: 60px;
    font-size: 16px;
}
ul.ocb-header > li {
    display: block;
    float: left;
    /*border-right: 1px solid #c6d0da;*/
    text-align: center;
    padding: 0 1vw;
}
ul.ocb-header > li#logout {
    margin-right: 1.1vw;
}
ul.ocb-header > li#menu {
    margin-left: 5vw;
}
ul.ocb-header > li.title {
    font-size: 30px;
    padding-left: 4vw;
}
ul.ocb-header li.description {
    color: #6599FF;
    font-size: 20px;
}
ul.ocb-header > li.menu {
    font-size: 16px;
    padding: 0 1vw;
}
ul.ocb-header > li.active {
    color: #6599FF;
}
ul.ocb-header > li.right {
    float: right;
    border-right: none;
    /*border-left: 1px solid #c6d0da;*/
}
ul.ocb-header > li.text:hover, ul.ocb-header > li.title:hover {
    background: none;
    color: #435f7a;
}
ul.ocb-header > li.description:hover {
    background: white;
    color: #6599FF;
}
ul.ocb-help-menu > li:hover, ul.ocb-header > li:hover {
    background: #435f7a;
    color: white;
}
ul.ocb-help-menu {
    position: absolute;
    z-index: 60000;
    top: 60px;
    right: 0px;
    width: 200px;
    visibility: hidden;
    opacity: 0;
    /*display:none;*/
    border-top: 1px solid #c6d0da;
    transition: all 0.2s;
}
ul.ocb-app-menu {
    line-height: 40px;
    position: absolute;
    z-index: 60000;
    top: 60px;
    left: -150px;
    width: 150px;
    visibility: hidden;
    /*display:none;*/
    border-top: 1px solid #c6d0da;
    transition: all 0.2s;
}
ul.ocb-help-menu-shown {
    visibility: visible !important;
    opacity: 1 !important;
}
ul.ocb-app-menu-shown {
    left: 0px !important;
    visibility: visible !important;
    /*display: block;*/
}
ul.ocb-help-menu > li {
    border-bottom: 1px solid #c6d0da;
    border-left: 1px solid #c6d0da;
    padding: 0 10px;
}
ul.ocb-app-menu > li {
    border-bottom: 1px solid #c6d0da;
    border-right: 1px solid #c6d0da;
    padding: 0 10px;
}
ul.ocb-app-menu > li.active {
    background: #d1d9e3;
    color: #435f7a;
}
ul.ocb-app-menu > li:hover {
    background: #d1d9e3;
    color: #435f7a;
}
.ocb-h-panel {
    line-height: 20px;
    font-size: 14px;
    background: #f5f5f5;
    color: #435f7a;
    padding: 4px 10px;
    border: 1px solid #c6d0da;
}

/* top Message*/

.ocb-msg-hidden {
    position: absolute;
    z-index: 50000;
    top: -200px;
    left: 45%;
    background: white;
    border: 1px solid #435f7a;
    transition: top 0.9s;
    margin: 5px;
    min-width: 150px;
}
.ocb-msg-hidden:first-child {
    padding: 5px;
    color: white;
    background-color: #435f7a;
}
.ocb-msg-hidden:last-child {
    padding: 7px;
    color: #435f7a;
    background-color: white;
}
.ocb-msg-shown {
    top: 0px;
}

/*Table*/

.ocb-attributes-table {
    cellspacing: 0;
    border-collapse: collapse;
    border: 1px solid #d3d3d3;
}
.ocb-attributes-table tr {
    border-collapse: collapse;
    border: 1px solid #d3d3d3;
}
.ocb-attributes-table td {
    border-collapse: collapse;
    border: 1px solid #d3d3d3;
    padding: 5px;
    max-width: 200px;
    overflow: hidden;
}
.ocb-attributes-table td.header {
    border-collapse: collapse;
    border: 1px solid #d3d3d3;
    padding: 5px;
    background-color: whiteSmoke;
    color: steelblue;
    font-weight: bold;
}
.ocb-stats-table {
    cellspacing: 0;
    border-collapse: collapse;
}
.ocb-stats-table tr {
    border-collapse: collapse;
}
.ocb-stats-table td {
    border-collapse: collapse;
    padding: 5px;
}
.ocb-stats-table td.header {
    border-collapse: collapse;
    padding: 5px;
    color: steelblue;
    /*font-weight:bold;*/
}

/*Network viewer*/

.ocb-nv-editionbar {
    box-sizing: border-box;
    height: 32px;
    font-size: 13px;
    padding: 4px 8px;
    background-color: #FAFAFA;
    border-bottom: 1px solid #D9D9D9;
}
.ocb-nv-toolbar {
    box-sizing: border-box;
    height: 32px;
    font-size: 13px;
    padding: 4px 8px;
    background-color: #FAFAFA;
    border-bottom: 1px solid #D9D9D9;
}
.ocb-nv-statusbar {
    box-sizing: border-box;
    border-top: 1px solid #D9D9D9;
    height: 32px;
    line-height: 32px;
    font-size: 14px;
    padding-left: 10px;
    background-color: #FAFAFA;
}
.ocb-nv-context {
    font-size: 13px;
}

/**/


/* Genome viewer */

.ocb-gv {
    position: relative;
    background-color: white;
}
.ocb-gv-right-side {
    position: absolute;
    z-index: 50;
    right: 0px;
}
.ocb-gv-left-side {
    position: absolute;
    z-index: 50;
    left: 0px;
}
.ocb-warn {
    color: orangered;
}
.ocb-light {
    color: gray;
}
.ocb-gv-track-resize {
    background-color: lightgray;
    background-image: url("bower_components/jsorolla/styles/img/ocb-grab-track-resize.png") !important;
    background-repeat: no-repeat;
    background-position: center;
    height: 7px;
    opacity: 0.3;
    border-top: 1px solid gray;
    border-bottom: 1px solid gray;
    box-sizing: border-box;
}
.ocb-feature-mark {
    fill: yellow;
}
.ocb-gv-navigation-bar {
    font-size: 13px;
    background-image: linear-gradient(to bottom, #ffffff, #f2f2f2);
    background-image: -webkit-linear-gradient(top, #ffffff, #f2f2f2);
    background-repeat: repeat-x;
    padding: 0 5px 5px 5px;
    box-sizing: border-box;
    height: 33px;
    /*white-space: nowrap;
    overflow: hidden;
    text-overflow: clip;*/
}
.ocb-gv-navigation-bar > * {
    margin-top: 5px !important;
}
.ocv-gv-status-bar {
    font-size: 13px;
    color: #333;
    padding: 3px 0 5px 5px;
    border-top: 1px solid #d4d4d4;
    background-image: linear-gradient(to bottom, #ffffff, #f2f2f2);
    background-image: -webkit-linear-gradient(top, 3 ffffff, #f2f2f2);
    background-repeat: repeat-x;
    line-height: normal;
    position: relative;
}
.ocb-gv-panel-title {
    font-size: 13px;
    color: #333;
    background-image: linear-gradient(to bottom, #ffffff, #f2f2f2);
    background-image: -webkit-linear-gradient(top, #ffffff, #f2f2f2);
    background-repeat: repeat-x;
    border-top: 1px solid #d4d4d4;
    border-bottom: 1px solid #d4d4d4;
    position: relative;
    height: 26px;
}
.ocb-gv-panel-text {
    position: absolute;
    left: 0;
    line-height: 24px;
    margin-left: 5px;
}
.ocb-gv-tracklist {
    height: 100%;
    position: relative;
}
.ocb-gv-tracklist-windowsize {
    position: absolute;
    line-height: 24px;
    left: 0;
    right: 0;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
}
.ocb-gv-panel-collapse-control {
    line-height: 24px;
    position: absolute;
    right: 0;
    margin-right: 5px;
    height: 16px;
}
.ocb-gv-tracklist-position {
    height: 14px;
    color: steelblue;
    font-family: 'Ubuntu Mono', 'Helvetica Neue', Helvetica, Arial, 'sans-serif';
    font-size: 14px;
    position: relative;
}
.ocb-gv-tracklist-position > div {
    line-height: 14px;
    color: steelblue;
    position: absolute;
}
.ocb-gv-tracklist-position-left {
    left: 0;
}
.ocb-gv-tracklist-position-mid {
    left: 0;
    right: 0;
    margin-left: auto;
    margin-right: auto;
    text-align: center;
}
.ocb-gv-tracklist-position-mid-pos {
    display: inline-block;
}
.ocb-gv-tracklist-position-mid-nt {
    display: inline-block;
    margin-right: 10px;
}
.ocb-gv-tracklist-position-right {
    right: 0;
}
.ocb-gv-track {
    border-bottom: 1px solid lightgray;
}
.ocb-gv-track:last-child {
    border-bottom-width: 0;
}
.ocb-gv-track-title-el {
    font-size: 13px;
    line-height: 20px;
    border: 1px solid lightgray;
    padding-left: 5px;
    padding-right: 5px;
    display: inline-block;
    background-image: linear-gradient(to bottom, #ffffff, #f2f2f2);
    background-image: -webkit-linear-gradient(top, #ffffff, #f2f2f2);
}

/*.ocb-gv-track-title-el:hover {*/


/*background-image: linear-gradient(to bottom, #f2f2f2, #e4e4e4);*/


/*background-image: -webkit-linear-gradient(top, #f2f2f2, #e4e4e4);*/


/*}*/

.ocb-gv-track-title-el:focus {
    background-image: linear-gradient(to bottom, #f2f2f2, #e4e4e4);
    background-image: -webkit-linear-gradient(top, #f2f2f2, #e4e4e4);
    border: 1px solid gray;
}
.ocb-gv-track-title-histogram {
    margin-right: 10px;
}
.ocb-gv-track-title-toggle {
    margin-right: 5px;
}
.ocb-gv-track-title-close {
    margin-left: 5px;
}
.ocb-gv-track-title-external-link {
    margin-left: 5px;
}
.ocb-gv-track-title-text:hover {
    /*color: steelblue;*/
    /*text-decoration: underline;*/
    /*cursor:pointer;*/
}
.ocb-gv-track-title-close:hover {
    color: darkred;
}
.ocb-gv-track-title-up:hover {
    color: steelblue;
}
.ocb-gv-track-title-down:hover {
    color: steelblue;
}
.ocb-gv-track-title-toggle:hover {
    color: steelblue;
}
.ocb-gv-track-title-external-link:hover {
    color: #1d9d74;
}
.ocb-gv-track-title-loading {
    /*color: #6599FF;*/
    color: orangered;
}
.ocb-track-resize {
    cursor: default;
    background-color: #f1f1f1;
    background-image: url("bower_components/jsorolla/styles/img/ocb-grab-track-resize.png") !important;
    background-repeat: no-repeat;
    background-position: center;
    height: 7px;
    opacity: 0.3;
    border-top: 1px solid gray;
    box-sizing: border-box;
}
.ocb-track-resize:hover {
    border-top-color: lightgray;
    background-color: #f5f5f5;
    cursor: ns-resize;
    opacity: 1;
}
.ocb-gv-status-bar {
    color: #333;
    background-image: linear-gradient(to bottom, #ffffff, #f2f2f2);
    background-image: -webkit-linear-gradient(top, #ffffff, #f2f2f2);
    background-repeat: repeat-x;
    padding: 3px;
    border-top: 1px solid lightgray;
    position: relative;
}
.ocb-gv-status-right {
    position: relative;
    font-size: 13px;
    display: inline-block;
    line-height: 24px;
    margin-left: 5px;
    margin-right: 5px;
    float: right;
}
.ocb-gv-status-left {
    position: relative;
    font-size: 13px;
    display: inline-block;
    line-height: 24px;
    margin-left: 5px;
    margin-right: 5px;
}
.ocb-gm-navigation-bar {
    background-image: linear-gradient(to bottom, #ffffff, #eeeeee);
    background-image: -webkit-linear-gradient(top, #ffffff, #eeeeee);
    background-repeat: repeat-x;
}
.ocb-codon {
    display: none;
}
.ocb-coding:hover .ocb-codon {
    display: inherit;
    cursor: pointer;
}

/**/

.ocb-pointer {
    cursor: pointer;
}
.ocb-job-list-widget-item {
    border: 1px solid #fff;
    margin-top: 1px;
    padding: 4px;
    cursor: pointer;
}
.ocb-job-list-widget-item-hover {
    border: 1px solid #b2becf;
    background-color: #f1f3f6;
}
.ocb-title-1 {
    color: #435F7A;
    font-size: 160%;
    padding: 4px 6px;
    margin-bottom: 5px;
    border: none;
}
.ocb-title-2 {
    color: #435F7A;
    font-size: 16px;
    line-height: 22px;
    padding: 4px 6px;
    border: none;
}

/*
CONTROLS
*/

.ocb-ctrl {
    position: relative;
    margin: 0px;
    display: block;
    float: left;
    user-select: none;
}
.ocb-ctrl-label, .ocb-ctrl-text {
    display: block;
    float: left;
    box-sizing: border-box;
    line-height: 21px;
    border: 1px solid #ccc;
    padding: 0px 5px;
    color: #333;
    background-color: #f2f2f2;
    font-size: inherit;
}
.ocb-ctrl-text {
    border-color: transparent;
    background-color: transparent;
}
label.ocb-ctrl > input[type=radio], label.ocb-ctrl > input[type=checkbox] {
    display: none;
}

/*label.ocb-ctrl {*/


/*display: block;*/


/*float: left;*/


/*}*/

div.ocb-ctrl, input.ocb-ctrl[type=text], label.ocb-ctrl > input[type=radio] + span, label.ocb-ctrl > input[type=checkbox] + span {
    display: block;
    float: left;
    outline: 0;
    box-sizing: border-box;
    line-height: 21px;
    border: 1px solid #ccc;
    padding: 0px 5px;
    color: #333;
    background-color: #fff;
    font-size: inherit;
}
label.ocb-ctrl > input[type=radio]:checked + span, label.ocb-ctrl > input[type=checkbox]:checked + span {
    box-shadow: inset 0 3px 5px rgba(0, 0, 0, .125);
    background-color: #ebebeb;
}
div.ocb-ctrl:hover, label.ocb-ctrl > input[type=radio] + span:hover, label.ocb-ctrl > input[type=checkbox]:hover + span:hover {
    background-color: #ebebeb;
}
input.ocb-ctrl[type=text] {
    transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
}
input.ocb-ctrl[type=text]:focus {
    border-color: #66afe9;
    box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6);
}
input.ocb-ctrl[type=text].error {
    border-color: #e32b2b;
    box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(227, 43, 43, .6);
}

/******* Infinite drop down *****************/


/*
  data-divider: add li with boolean attribute data-divider to add a space between li
  data-sub: add attribute data-sub to add the angle icon for sub ul
*/

div.ocb-dropdown {
    position: relative;
    display: block;
    float: left;
    color: #333;
}
div.ocb-dropdown ul, ul.ocb-context {
    visibility: hidden;
    opacity: 0;
    position: absolute;
    list-style: none;
    text-decoration: none;
    z-index: 100000;
    border: 1px solid #afafaf;
    background-color: #fff;
    line-height: 22px;
    min-width: 100px;
    margin: 1px 0 0 0;
    padding: 5px 0;
    box-shadow: 4px 4px 4px rgba(0, 0, 0, 0.2);
    /*box-shadow: 0px 1px 6px 0px rgb(136, 136, 136);*/
    transition: all 0.35s;
}
div.ocb-dropdown ul, ul.ocb-context ul {
    left: 0;
    top: 100%;
}
div.ocb-dropdown ul[data-right] {
    right: 0;
    left: auto;
}
div.ocb-dropdown ul[data-upward] {
    top: inherit;
    bottom: 100%;
    margin-bottom: 2px;
    left: 0;
}
div.ocb-dropdown ul[data-upward][data-right] {
    top: inherit;
    bottom: 100%;
    margin-bottom: 2px;
    left: auto;
    right: 0;
}
div.ocb-dropdown ul ul {
    top: 0px;
    left: 100%;
}
div.ocb-dropdown ul li, ul.ocb-context li {
    position: relative;
    text-align: left;
    padding: 2px 30px 2px 10px;
    white-space: nowrap;
    color: #333;
}
div.ocb-dropdown ul li[data-divider], ul.ocb-context li[data-divider] {
    height: 1px;
    margin: 3px 0;
    padding: 0;
    overflow: hidden;
    background-color: #DEDEDE;
}
div.ocb-dropdown ul li[data-sub]:after, ul.ocb-context li[data-sub]:after {
    font-family: FontAwesome;
    content: '\f105';
    /* > */
    /*content:'\f0da';*/
    position: absolute;
    right: 10px;
}
div.ocb-dropdown ul li.active, div.ocb-dropdown ul li:active, ul.ocb-context li:active {
    background-color: #DEDEDE;
}
div.ocb-dropdown ul li:hover, ul.ocb-context li:hover {
    background-color: #2F65F4;
    color: #fff;
}
div.ocb-dropdown ul li[data-text]:hover, ul.ocb-context li[data-text]:hover {
    background-color: inherit;
    color: inherit;
}
div.ocb-dropdown > div:focus + ul, div.ocb-dropdown > div:focus + ul li:hover > ul {
    visibility: visible;
    opacity: 1;
}
.ocb-zoom-bar {
    position: relative;
    float: left;
    width: 100px;
    height: 23px;
    box-sizing: border-box;
    /*border-top: 1px solid #ccc;*/
    /*border-bottom: 1px solid #ccc;*/
    margin-left: 10px;
    margin-right: 10px;
}
.ocb-zoom-bar > div.back {
    position: absolute;
    background-color: #aaa;
    box-sizing: border-box;
    height: 5px;
    top: 8px;
    width: 100%;
}
.ocb-zoom-bar > div.rect {
    position: absolute;
    background-color: #2F65F4;
    /*background-color: #DCDCDC;*/
    box-sizing: border-box;
    height: 5px;
    top: 8px;
    transition: all 0.1s;
}
.ocb-zoom-bar > div.ball {
    position: absolute;
    background-color: #2046aa;
    top: 3px;
    margin-left: -8px;
    width: 16px;
    height: 16px;
    border-radius: 50%;
}

/*
END CONTROLS
*/

@font-face {
    font-family: 'Ubuntu';
    font-style: normal;
    font-weight: 400;
    src: local('Ubuntu'), url("bower_components/jsorolla/styles/fonts/ubuntu.woff") format('woff');
}
@font-face {
    font-family: 'Ubuntu Mono';
    font-style: normal;
    font-weight: 400;
    src: local('Ubuntu Mono'), local('UbuntuMono-Regular'), url("bower_components/jsorolla/styles/fonts/ubuntumono.woff") format('woff');
}
@font-face {
    font-family: 'Oxygen';
    font-style: normal;
    font-weight: 400;
    src: local('Oxygen'), local('oxygen'), local('Oxygen-Regular'), url("bower_components/jsorolla/styles/fonts/oxygen.woff") format('woff');
}
@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 300;
    src: local('Lato Light'), local('Lato-Light'), url("bower_components/jsorolla/styles/fonts/Lato-Light.woff") format('woff');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    src: local('Lato Regular'), local('Lato-Regular'), url("bower_components/jsorolla/styles/fonts/Lato-Regular.woff") format('woff');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
@font-face {
    font-family: 'Roboto';
    font-style: normal;
    font-weight: 300;
    src: local('Roboto Light'), local('Roboto-Light'), url("bower_components/jsorolla/styles/fonts/Roboto-Light.woff") format('woff');
}
@font-face {
    font-family: 'Roboto';
    font-style: normal;
    font-weight: 400;
    src: local('Roboto'), local('Roboto'), url("bower_components/jsorolla/styles/fonts/Roboto.woff") format('woff');
}
.ocb-tooltip-font {
    font-family: tahoma, arial, verdana, sans-serif;
}
.ocb-font-sourcesanspro {
    font-family: 'Source Sans Pro';
}
.ocb-font-ubuntu {
    font-family: 'Ubuntu';
}
.ocb-font-ubuntumono {
    font-family: 'Ubuntu Mono';
}
.ocb-font-lato {
    font-family: 'Lato';
}
.ocb-font-roboto {
    font-family: 'Roboto';
}
.ocb-font-size-16 {
    font-size: 16px;
}
.ocb-font-size-15 {
    font-size: 15px;
}
.ocb-font-size-14 {
    font-size: 14px;
}
.ocb-font-size-13 {
    font-size: 13px;
}
.ocb-font-size-12 {
    font-size: 12px;
}
.ocb-font-size-11 {
    font-size: 11px;
}
.ocb-font-size-10 {
    font-size: 10px;
}
.ocb-font-size-9 {
    font-size: 9px;
}
.ocb-font-size-8 {
    font-size: 8px;
}
.ocb-icon {
    display: block;
    box-sizing: border-box;
    margin-top: 2px;
    margin-bottom: 3px;
    width: 16px;
    height: 16px;
    background-repeat: no-repeat;
}
.ocb-icon-karyotype {
    background: url("bower_components/jsorolla/styles/img/ocb-icon-karyotype.png") !important;
}
.ocb-icon-chromosome {
    background: url("bower_components/jsorolla/styles/img/ocb-icon-chromosome.png") !important;
}
.ocb-icon-region {
    background: url("bower_components/jsorolla/styles/img/ocb-icon-region.png") !important;
}

</style>

<dom-module id="jso-genome-viewer-element" assetpath="bower_components/jsorolla/src/lib/components/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            width: 100%;
            z-index: 0;
            overflow-x: hidden;
            overflow-y: hidden;
            border: 1px solid #d3d3d3;
        }

        #gv {
            position: relative;
            box-sizing: border-box;
            width: 100%;
            border-bottom: 1px solid #d3d3d3;
        }

        #content {
            position: absolute;
            z-index: 4;
        }
    </style>
    <template>
        <div id="gv"></div>
        <div id="content"></div>
    </template>
    <script>
        Polymer({
            is: "jso-genome-viewer-element",
            properties: {
                selectedSpecies: {
                    type: Object,
                    value: function() {
                        return DEFAULT_SPECIES;
                    }
                },
                region: {
                    type: Object,
                    value: function() {
                        var region = new Region();
                        region.load("1:1004608-1004608");
                        return region;
                    }
                },
                width: {
                    type: Number,
                    value: 800
                },
                hidden: {
                    type: Boolean,
                    reflectToAttribute: true,
                    observer: 'hiddenChanged',
                    nofity: true
                }
            },
            // _resizing: false,

            hiddenChanged: function(neo, old) {
                this.fire('hidden', this.hidden);
                // if (neo == false && this.genomeViewer == null) {
                //     this.createGenomeViewer();
                //     this.genomeViewer.draw();
                //     this.genomeViewer.toggleAutoHeight(true);
                // }
            },
            created: function() {
                var me = this;
                // var after_resize = (function() {
                //     var timer = 0;
                //     return function(callback, ms) {
                //         clearTimeout(timer);
                //         timer = setTimeout(callback, ms);
                //     };
                // })();
                // window.addEventListener("resize", function(e) {
                //     after_resize(function() {
                //         console.log(' new Size ----------> ' + me.getBoundingClientRect().width)
                //         me.genomeViewer.setWidth(me.getBoundingClientRect().width);
                //     }, 300);
                // });

                this.async(function() {
                    var w = this.getBoundingClientRect().width;
                    if (w !== 0) {
                        this.set('width', w);
                    }

                    window.setInterval(function() {
                        var w = me.getBoundingClientRect().width;
                        if (
                            me.genomeViewer != null &&
                            me.genomeViewer.rendered === true &&
                            me.genomeViewer._checkChangingRegion() &&
                            w !== 0 &&
                            w !== me.width
                        ) {
                            me.set('width', w);
                            me.genomeViewer.setWidth(w);
                        }
                    }, 1000);

                }, 100);
            },
            createGenomeViewer: function(config, region) {
                var w = this.getBoundingClientRect().width;
                if (w == 0) {
                    w = this.width;
                }

                if (region != null) {
                    this.region.load(region);
                }

                if (config != null) {
                    config.target = this.$.gv;
                    config.width = w;
                    this.genomeViewer = new GenomeViewer(config);
                    this.addOverviewTracks();
                } else {
                    this.genomeViewer = new GenomeViewer({
                        cellBaseHost: CELLBASE_HOST,
                        cellBaseVersion: CELLBASE_VERSION,
                        target: this.$.gv,
                        width: w,
                        region: this.region,
                        //                        version: this.version,
                        availableSpecies: AVAILABLE_SPECIES,
                        species: this.selectedSpecies,
                        sidePanel: false,
                        resizable: false,
                        //                        quickSearchResultFn:quickSearchResultFn,
                        //                        quickSearchDisplayKey:,
                        karyotypePanelConfig: {
                            hidden: true,
                            collapsed: false,
                            collapsible: true
                        },
                        chromosomePanelConfig: {
                            hidden: true,
                            collapsed: false,
                            collapsible: true
                        },
                        regionPanelConfig: {
                            hidden: false,
                            collapsed: false,
                            collapsible: true
                        },
                        drawStatusBar: true,
                        //                       drawNavigationBar: false,
                        navigationBarConfig: {
                            componentsConfig: {
                                menuButton: false,
                                leftSideButton: false,
                                restoreDefaultRegionButton: false,
                                regionHistoryButton: false,
                                speciesButton: false,
                                chromosomesButton: false,
                                karyotypeButton: false,
                                chromosomeButton: false,
                                // regionButton: false,
                                // zoomControl: false,
                                // windowSizeControl: false,
                                // positionControl: false,
                                // moveControl: false,
                                // autoheightButton: true,
                                // compactButton: false,
                                searchControl: false
                            }
                        }

                        //        chromosomeList:[]
                        //            trackListTitle: ''
                        //            drawNavigationBar = true;
                        //            drawKaryotypePanel: false,
                        //            drawChromosomePanel: false,
                        //            drawOverviewTrackListPanel: false

                    });
                    this.addOverviewTracks();
                    this.addDefaultTracks();
                }

                this.fire('created');

                return this.genomeViewer;
            },
            addOverviewTracks: function() {
                var me = this;

                var renderer = new FeatureRenderer(FEATURE_TYPES.gene);
                renderer.on({
                    'feature:click': function(event) {
                        // feature click event example
                        console.log(event)
                    }
                });
                var gene = new FeatureTrack({
                    //        title: 'Gene overview',
                    minHistogramRegionSize: 20000000,
                    maxLabelRegionSize: 10000000,
                    height: 100,

                    renderer: renderer,

                    dataAdapter: new CellBaseAdapter({
                        category: "genomic",
                        subCategory: "region",
                        resource: "gene",
                        params: {
                            exclude: 'transcripts,chunkIds'
                        },
                        species: this.genomeViewer.species,
                        cacheConfig: {
                            chunkSize: 100000
                        }
                    })
                });
                this.genomeViewer.addOverviewTrack(gene);
            },
            addDefaultTracks: function() {
                var me = this;
                var sequenceTrack = new FeatureTrack({
                    title: 'Sequence',
                    height: 25,
                    visibleRegionSize: 200,
                    renderer: new SequenceRenderer(),
                    dataAdapter: new CellBaseAdapter({
                        category: "genomic",
                        subCategory: "region",
                        resource: "sequence",
                        params: {},
                        species: this.genomeViewer.species,
                        cacheConfig: {
                            chunkSize: 100
                        }
                    })
                });
                this.genomeViewer.addTrack(sequenceTrack);

                var geneTrack = new GeneTrack({
                    title: 'Gene',
                    minHistogramRegionSize: 20000000,
                    maxLabelRegionSize: 10000000,
                    minTranscriptRegionSize: 200000,
                    height: 100,
                    renderer: new GeneRenderer({
                        handlers: {
                            'feature:click': function(e) {
                                console.log(e);
                                console.log(e.feature);
                                switch (e.featureType) {
                                    case "gene":
                                        me.$.content.appendChild(new JsoGeneInfoPanel(e.query, e.feature, CELLBASE_HOST, me.genomeViewer.species));
                                        break;
                                    case "transcript":
                                        me.$.content.appendChild(new JsoTranscriptInfoPanel(e.query, e.feature, CELLBASE_HOST, me.genomeViewer.species));
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }),
                    dataAdapter: new CellBaseAdapter({
                        category: "genomic",
                        subCategory: "region",
                        resource: "gene",
                        species: this.genomeViewer.species,
                        params: {
                            exclude: 'transcripts.tfbs,transcripts.xrefs,transcripts.exons.sequence'
                        },
                        cacheConfig: {
                            chunkSize: 100000
                        }
                    })
                });
                this.genomeViewer.addTrack(geneTrack);

                var renderer = new FeatureRenderer(FEATURE_TYPES.snp);
                renderer.on('feature:click', function(e) {
                    me.$.content.appendChild(new JsoSnpInfoPanel(e.query, e.feature, CELLBASE_HOST, me.genomeViewer.species));
                });
                snpTrack = new FeatureTrack({
                    title: 'SNP',
                    featureType: 'SNP',
                    minHistogramRegionSize: 12000,
                    maxLabelRegionSize: 3000,
                    height: 120,
                    renderer: renderer,
                    dataAdapter: new CellBaseAdapter({
                        category: "genomic",
                        subCategory: "region",
                        resource: "snp",
                        params: {
                            exclude: 'transcriptVariations,xrefs,samples'
                        },
                        species: this.genomeViewer.species,
                        cacheConfig: {
                            chunkSize: 10000
                        }
                    })
                });

                this.genomeViewer.addTrack(snpTrack);
            }
        });
    </script>
</dom-module>
<script>/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2015-05-07.2
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\ufeff", blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name) {
			blob = auto_bom(blob);
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				revoke(object_url);
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name) {
			return navigator.msSaveOrOpenBlob(auto_bom(blob), name);
		};
	}

	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}</script>
<dom-module id="jso-table" assetpath="bower_components/jsorolla/src/lib/components/table/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            font-size: 13px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -khtml-user-select: none;
            -ms-user-select: none;
        }

        .scrollfix {
            position: absolute;
            width: 25px;
            height: 100%;
            top: 0;
            right: 0;
            background-color: inherit;
            z-index: 1;
        }

        :host[enable-paging] .scrollfix {
            display: none;
        }

        #wrap {
            height: calc(100% - 30px);
            background-color: #fcfcfc;
        }

        .table-header,
        .table-filter,
        .table-body {
            box-sizing: border-box;
            border-right: 1px solid #dadada;
        }

        .table-header {
            position: relative;
            /*box-sizing: border-box;*/
            background-color: #F1F3F5;
            border-bottom: 1px solid #d3d3d3;
        }

        #headerRow {
            position: relative;
        }

        .table-header-row {
            position: relative;
            box-sizing: border-box;
            font-weight: bold;
            color: #666;
            overflow-y: scroll;
            overflow-x: hidden;
            width: 100%;
            background-color: inherit;
        }

        :host[enable-paging] .table-header-row {
            overflow-y: hidden;
        }

        .table-header-field {
            box-sizing: border-box;
            border-right: 1px solid #d3d3d3;
            /*white-space: nowrap;*/
            /*overflow: hidden;*/
            /*text-overflow: ellipsis;*/
            cursor: pointer;
            position: relative;
        }

        .table-header-field.sort-down > .name:after {
            font-family: 'FontAwesome';
            content: ' \f107';
        }

        .table-header-field.sort-up > .name:after {
            font-family: 'FontAwesome';
            content: ' \f106';
        }

        .table-header-field > .name {
            box-sizing: border-box;
            /*cursor: pointer;*/
            text-align: center;
            padding: 7px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .table-header-field > .sub {
            box-sizing: border-box;
            /*cursor: pointer;*/
            text-align: center;
            border-top: 1px solid #d3d3d3;
        }

        div.table-header-field:last-of-type {
            border-right-width: 0;
        }

        .table-filter {
            position: relative;
            /*box-sizing: border-box;*/
            background-color: #F1F3F5;
            border-bottom: 1px solid #d3d3d3;
        }

        #filterRow {
            position: relative;
            height: 26px;
            overflow-y: scroll;
            overflow-x: hidden;
            width: 100%;
            background-color: inherit;
        }

        :host[enable-paging] #filterRow {
            overflow-y: hidden;
        }

        .table-pager {
            overflow-y: hidden;
            overflow-x: hidden;
        }

        .table-pager > * {
            margin: 0 2px;
        }

        .table-bbar {
            position: relative;
            box-sizing: border-box;
            border-top: 1px solid #d3d3d3;
            background-color: #fafafa;
            color: #666;
            padding: 3px;
        }

        .table-body {
            /*box-sizing: border-box;*/
            overflow-x: auto;
            /*overflow-y: scroll;*/
            height: calc(100% - 28px);
            background-color: #fafafa;
        }

        :host > .table-body {
            overflow-y: scroll;
        }

        :host[enable-paging] > .table-body {
            overflow-y: hidden;
        }

        :host[enable-filter] > .table-body {
            height: calc(100% - 88px);
        }

        .table-row {
            position: relative;
            box-sizing: border-box;
            cursor: default;
            background-color: #fff;
            overflow: hidden;
            border-bottom: 1px solid #ddd;
            height: 30px;
        }

        .table-row.selected {
            background-color: #ccc !important;
        }

        .table-row.selected:hover {
            background-color: #bbb !important;
        }

        div.table-row:last-of-type {
            border-bottom-width: 0;
        }

        .table-row:nth-child(2n) {
            background-color: #fbfbfb;
        }

        .table-row:hover {
            background-color: #eee;
        }

        .table-field {
            position: relative;
            box-sizing: border-box;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-right: 1px solid #d3d3d3;
            float: left;
            height: 100%;
        }

        .table-field > div {
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        div.table-field:last-of-type {
            border-right-width: 0;
        }

        #loading {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            right: 0;
            background-color: rgba(0, 0, 0, .1);
            /*z-index: 2;*/
        }

        #loading-text {
            position: absolute;
            color: #445D76;
            top: 45%;
            font-size: 16px;
            padding: 20px;
            width: 124px;
        }

        .select {
            position: relative;
            display: inline-block;
        }

        .select select {
            box-sizing: content-box;
            width: 100%;
            background: transparent;
            border: 0;
            outline: 0;
            -webkit-appearance: none;
            -moz-appearance: radio-container;
            appearance: none;
        }

        .select select:-moz-focusring {
            color: transparent;
            text-shadow: 0 0 0 #000;
        }

        .select select::-ms-expand {
            display: none;
        }

        .select:after {
            -ms-display: none;
            position: absolute;
            box-sizing: border-box;
            right: 7px;
            top: 0;
            color: inherit;
            font-family: FontAwesome;
            content: '\f107';
            pointer-events: none;
        }

        .select,
        input[type=text] {
            display: block;
            position: relative;
            outline: transparent solid 0px;
            box-sizing: border-box;
            line-height: 21px;
            border: 1px solid #ccc;
            padding: 0px 5px;
            background-color: #fff;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            height: 23px;
            margin: 1px;
        }

        .table-filter-field:last-child > .select,
        .table-filter-field:last-child > input[type=text] {
            margin-right: 15px;
        }

        :host[enable-paging] .table-filter-field:last-child > .select,
        :host[enable-paging] .table-filter-field:last-child > input[type=text] {
            margin-right: 1px;
        }

        input[type=text] {
            transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
        }

        input[type=text]:-moz-ui-invalid {
            box-shadow: none;
        }

        input[type=text]:focus {
            border-color: #66afe9;
            box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6);
        }

        .table-field > .select,
        .table-field > input[type=text] {
            box-sizing: border-box;
            background-color: transparent;
            border-color: transparent;
            height: 100%;
            width: 100%;
            margin: 0;
        }

        .table-field > input[type=text]:hover {
            border-color: #ccc;
        }

        .table-field > input[type=text][readonly]:focus {
            border-color: #ccc;
            box-shadow: inset 0 0 3px 1px rgba(0, 0, 0, .01);
            background-color: #fff;
        }

        .table-field > input[type=text]:focus {
            border-color: #66afe9;
            box-shadow: inset 0 0 3px 1px rgba(102, 175, 233, .5);
            background-color: #fff;
        }

        .table-header-field > .resizer {
            width: 2px;
            height: 100%;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: col-resize;
            display: none;
        }

        .table-header-field:hover > .resizer {
            display: inherit;
            background-color: #E1E3E5;
            border-left: 1px solid #DDD;
        }

        #columnsMenu {
            box-sizing: border-box;
            position: fixed;
            min-width: 200px;
            cursor: pointer;
            transition: opacity 0.1s, visibility 0.1s;
            max-height: 300px;
            overflow-y: auto;
            visibility: hidden;
            opacity: 0;
            list-style: none;
            text-decoration: none;
            z-index: 100000;
            border: 1px solid #afafaf;
            background-color: #fff;
            line-height: 22px;
            margin: 1px 0 0 0;
            padding: 5px 0;
            box-shadow: 4px 4px 4px rgba(0, 0, 0, 0.2);
        }
        /*div.jso-dropdown ul li:hover,
        ul.jso-context li:hover {
            background-color: var(--default-primary-color);
            color: var(--text-primary-color);
        }*/

        li.columnControl {
            cursor: pointer;
        }

        li.columnControl:hover,
        li.columnControl:hover {
            background-color: inherit !important;
            color: inherit !important;
        }

        #list[loading] {
            visibility: hidden;
        }
    </style>
    <template>
        <div id="loading" hidden$="{{!loading}}">
            <div id="loading-text">
                <i class="fa fa-circle-o-notch fa-spin"></i>
                <span>{{loadingMsg}}</span>
            </div>
        </div>

        <div id="wrap" style="overflow-x: scroll;overflow-y:hidden; width:100%;">
            <div id="header" class="table-header" on-contextmenu="handleColumnsMenu">
                <div id="headerRow"></div>
                <div class="scrollfix"></div>
            </div>
            <div id="filter" class="table-filter" hidden$="{{!enableFilter}}">
                <div id="filterRow" hidden$="{{!enableFilter}}"></div>
                <div class="scrollfix"></div>
            </div>
            <div id="list" class="table-body" on-dragover="allowDrop" on-drop="drop" loading$="{{loading}}"></div>
        </div>


        <div class="horizontal layout center table-bbar" style="height:30px;">
            <div id="pager" hidden$="{{!enablePaging}}" class="table-pager horizontal layout center flex">
                <div class="jso-btn jso-btn-shdw" on-click="handleFirstClick"><i class="fa fa-angle-double-left"></i>
                </div>
                <div class="jso-btn jso-btn-shdw" on-click="handlePreviousClick"><i class="fa fa-angle-left"></i></div>
                <div class="">Page</div>
                <input type="text" class="jso" style="width:80px;" value="{{currentPage::input}}">

                <div class="">of</div>
                <div class="">{{computePageTotal(pageSize, itemCount)}}</div>

                <div class="jso-btn jso-btn-shdw" on-click="handleNextClick"><i class="fa fa-angle-right"></i></div>
                <div class="jso-btn jso-btn-shdw" on-click="handleLastClick"><i class="fa fa-angle-double-right"></i>
                </div>

                <div class="flex"></div>
                <content select=".custom-buttons"></content>
                <div class="">{{pageFirstItem}}</div>
                <div class="">-</div>
                <div class="">{{pageLastItem}}</div>
                <div class="">of</div>
                <div class="">{{itemCount}}</div>
            </div>

            <div hidden$="{{enablePaging}}" class="flex">
                <span>Total: </span>
                <span>{{itemCount}}</span>
            </div>
            <div class="jso-btn" style="margin:0 2px;" on-click="handleExportCSVMenuButton" hidden$="{{!enableExport}}">
                <i class="fa fa-download"></i>
            </div>
            <div class="jso-btn" style="margin:0 2px;" on-click="handleColumnsMenuButton" hidden$="{{hideColumnSelector}}">
                <i class="fa fa-bars"></i>
            </div>
        </div>


        <ul id="columnsMenu" on-mouseleave="handleColumnsMenuLeave" on-wheel="handleMenuScroll">
            
            <template is="dom-repeat" items="{{columns}}">
                <li class="columnControl">
                    <jso-table-column-menu-item column="{{item}}" on-column-toggle="handleColumnVisibilityClick"></jso-table-column-menu-item>
                    
                </li>
            </template>
        </ul>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'jso-table',
        behaviors: [
            Polymer.IronResizableBehavior
        ],
        properties: {
            columns: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                }
            },
            data: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                }
            },
            viewData: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                }
            },
            request: {
                type: Object,
                observer: 'requestChanged'
            },
            enableRemote: {
                type: Boolean,
                observer: 'enableRemoteChanged',
                value: false
            },
            enablePaging: {
                type: Boolean,
                observer: 'enablePagingChanged',
                value: false
            },
            enableResize: {
                type: Boolean,
                value: false
            },
            pageSize: {
                type: Number,
                observer: 'pageSizeChanged',
                value: 10
            },
            currentPage: {
                type: Number,
                observer: 'currentPageChanged',
                value: 1
            },
            pageFirstItem: {
                type: Number,
                computed: 'computePageFirstItem(currentPage, pageSize, itemCount)',
                value: 0
            },
            pageLastItem: {
                type: Number,
                computed: 'computePageLastItem(currentPage, pageSize, itemCount)',
                value: 0
            },
            selected: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                }
            },
            enableSelect: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            disableTooltip: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            lastSelectedRow: {
                type: Object,
                value: null
            },
            enableFilter: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            filters: {
                type: Object,
                value: function() {
                    return {};
                }
            },
            itemCount: {
                type: Number,
                value: 0
            },
            pageCount: {
                type: Number,
                value: 0
            },
            enableLoading: {
                type: Boolean,
                value: false,
            },
            loading: {
                type: Boolean,
                value: false,
                observer: 'handleLoading'
            },
            loadingMsg: {
                type: String,
                value: 'Loading...'
            },
            draggable: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
            },
            enableEdit: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
            },
            hideColumnSelector: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            enableExport: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            exportParsers: {
                type: Object,
                value: function() {
                    return {};
                }
            }
        },
        observers: [
            "dataChanged(data.splices)",
            "selectedChanged(selected.splices)",
            "viewDataChanged(viewData.splices)",
            'columnsChanged(columns.splices)',
        ],
        listeners: {
            'wheel': 'handleScroll',
            'mouseleave': 'handleColumnsMenuLeave',
            'iron-resize': '_onIronResize'
        },
        _onIronResize: function() {
            this._setPageSizeAuto();
        },
        _setPageSizeAuto: function() {
            this.async(function() {
                var listHeight = this.$.list.getBoundingClientRect().height;
                if (listHeight != 0) {
                    var n = listHeight / 30;
                    this.set('pageSize', parseInt(Math.floor(n)))
                }
            }, 150);
        },
        ready: function() {
            var me = this;

            this.exportParsers.separator = "\t";
            this.exportParsers.comment = "#";
            this.exportParsers.chunkSize = 1000;
            this.exportParsers.maxLimit = 1000;

            this.exportParsers.headerParser = function(columns) {
                var headerLine = this.comment;
                for (var i = 0; i < columns.length; i++) {
                    if (columns[i].type === "action") {
                        continue;
                    }
                    headerLine += columns[i].title + this.separator;
                }
                return headerLine;
            }
            this.exportParsers.dataParser = function(columns, row) {

                var dataLine = "";
                for (var j = 0; j < columns.length; j++) {
                    var column = columns[j];

                    if (column.type === "action") {
                        continue;
                    }

                    var key = column.name;
                    var value = (column.defaultValue) ? column.defaultValue : "";

                    if (column.formula) {
                        value = column.formula(row);
                    } else {
                        value = row[key];
                    }

                    dataLine += value + this.separator;
                }
                return dataLine;
            }

            this.async(function() {
                this._setPageSizeAuto();
                var hiddenParent = Utils.closest(this, "[hidden]");
                if (hiddenParent != null) {
                    var observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            if (mutation.type == 'attributes' && mutation.attributeName == 'hidden') {
                                me._setPageSizeAuto();
                            }
                        });
                    });
                    observer.observe(hiddenParent, {
                        attributes: true
                    });
                }
            }, 10);
        },
        isColumnVisible: function(v) {
            return v.visible !== false;
        },
        handleColumnVisibilityClick: function(e) {
            // var columnIndex = this.columns.indexOf(e.model.item);
            // this.set('columns.' + columnIndex + '.visible', e.currentTarget.checked);
            this.columnsChanged();
            this.fire('column-visibility-change', e);
        },
        /* LISTENERS */
        handleScroll: function(e) {
            if (this.enablePaging == true) {
                e.preventDefault();
                if (e.deltaY > 0) {
                    this.handleNextClick();
                }
                if (e.deltaY < 0) {
                    this.handlePreviousClick();
                }
            }
        },
        handleColumnsMenu: function(e) {
            e.preventDefault();
            e.stopPropagation();

            this.$.columnsMenu.style.opacity = "1";
            this.$.columnsMenu.style.visibility = "visible";
            this.$.columnsMenu.style.top = (e.clientY + 10) + "px";
            this.$.columnsMenu.style.left = (e.clientX) + "px";
        },
        handleColumnsMenuButton: function(e) {
            e.preventDefault();
            e.stopPropagation();

            this.$.columnsMenu.style.opacity = "1";
            this.$.columnsMenu.style.visibility = "visible";
            var bcrColumnsMenu = this.$.columnsMenu.getBoundingClientRect();
            var bcrCurrent = e.currentTarget.getBoundingClientRect();
            this.$.columnsMenu.style.top = (bcrCurrent.top - bcrColumnsMenu.height) + "px";
            this.$.columnsMenu.style.left = (bcrCurrent.left - bcrColumnsMenu.width + bcrCurrent.width) + "px";
        },
        handleColumnsMenuLeave: function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.$.columnsMenu.style.opacity = "";
            this.$.columnsMenu.style.visibility = "";
        },
        handleMenuScroll: function(e) {
            e.stopPropagation();
        },

        selectedChanged: function(changeRecord) {
            this._updateSelected();
            this.fire('selected', this.selected);
        },
        _updateSelected: function() {
            var els = Polymer.dom(this.$.list).querySelectorAll('.table-row');
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                var index = this.selected.indexOf(el._rowData);
                if (index >= 0) {
                    el.classList.add("selected");
                } else {
                    el.classList.remove("selected");
                }
            }
        },
        /* OBSERVERS */
        dataChanged: function(neo, old) {
            for (var i = 0; i < this.data.length; i++) {
                var row = this.data[i];
                delete row._filtered;
            }
            this.refreshPagination();
        },
        refreshPagination: function() {
            this.currentPage = 1;
            var count = 0;
            if (this.data) {
                this.data.forEach(function(row) {
                    if (row._filtered || row._filtered == null) {
                        count++;
                    }
                });
            }
            this.itemCount = count;
            this.pageCount = Math.ceil(count / this.pageSize);
            this.filterPage();
        },
        filterPage: function() {
            var filteredRows = this.enableFilter ? this.data.filter(function(r) {
                if (r._filtered == undefined) {
                    return true;
                }
                return r._filtered;
            }) : this.data;
            if (this.enablePaging) {
                var from = (this.currentPage - 1) * this.pageSize;
                var to = from + this.pageSize;
                if (this.request) {
                    this.checkRemote();
                } else {
                    this.set('viewData', filteredRows.slice(from, to));
                    this._updateSelected();
                }
            } else {
                var viewData = [];
                for (var i = 0; filteredRows && i < filteredRows.length; i++) {
                    var row = filteredRows[i];
                    viewData.push(row);
                }
                this.set('viewData', viewData);
            }
        },
        viewDataChanged: function(neo, old) {
            while (this.$.list.firstChild) {
                this.$.list.removeChild(this.$.list.firstChild);
            }
            for (var i = 0; this.viewData && i < this.viewData.length; i++) {
                var rowData = this.viewData[i];
                this._createRow(rowData);
            }

        },
        // pagination
        handleFirstClick: function() {
            this.currentPage = 1;
        },
        handlePreviousClick: function() {
            if (this.currentPage > 1) {
                this.currentPage--;
            }
        },
        handleNextClick: function() {
            // console.log(this.currentPage);
            // console.log(this.pageCount);
            if (this.currentPage < this.pageCount) {
                this.currentPage++;
            }
        },
        handleLastClick: function() {
            this.currentPage = this.pageCount;
        },
        currentPageChanged: function(neo, old) {
            this.currentPage = this.currentPage ? parseInt(this.currentPage) : 0;
            this.currentPage = this.currentPage < 1 ? 1 : this.currentPage;
            this.currentPage = this.pageCount > 0 && this.currentPage > this.pageCount ? this.pageCount : this.currentPage;
            this.filterPage();
        },
        pageSizeChanged: function() {
            this.pagesize = parseInt(this.pagesize);
            this.refreshPagination();
        },
        computePageFirstItem: function(currentPage, pageSize, itemCount) {
            return ((currentPage - 1) * pageSize) + 1;
        },
        computePageLastItem: function(currentPage, pageSize, itemCount) {
            var end = currentPage * pageSize;
            if (itemCount < end) {
                return itemCount;
            }
            return end;
        },
        computePageTotal: function(pageSize, itemCount) {
            return Math.ceil(itemCount / pageSize);
        },
        enablePagingChanged: function(neo, old) {
            this.refreshPagination();
        },
        enableRemoteChanged: function(neo, old) {
            if (this.request) {
                this.checkRemote();
            }
        },
        requestChanged: function(neo, old) {
            if (this.currentPage != 1) {
                this.currentPage = 1;
            } else if (this.request && this.request.url != null && this.request.url != "") {
                this.checkRemote();
            }
        },
        columnsChanged: function(neo, old) {
            this.updateColumns();
            this.viewDataChanged();
        },
        clear: function() {
            this.data = [];
            this.viewData = [];
            this.currentPage = 1;
            this.columns = [];
        },
        refresh: function() {
            this.updateColumns();
            this.dataChanged();
        },
        checkRemote: function() {
            var me = this;
            if (this.enableLoading && this.currentPage == 1) {
                this.setLoading(true);
            }
            if (this.enableRemote) {
                this._callRemote(function(resp) {
                    me.itemCount = me.request.parseTotal(resp);
                    me.pageCount = Math.ceil(me.itemCount / me.pageSize);
                    me.viewData = me.request.parse(resp);
                    if (me.enableLoading && me.currentPage == 1) {
                        me.setLoading(false);
                    }
                });
            } else {
                //                ...
            }
        },
        _callRemote: function(callback) {
            var method = 'GET';
            if (typeof this.request.method !== 'undefined' && this.request.method != null) {
                method = this.request.method;
            }
            var request = new XMLHttpRequest();
            request.onload = function() {
                var contentType = this.getResponseHeader('Content-Type');
                var resp;
                if (contentType === 'application/json') {
                    resp = JSON.parse(this.response, this);
                } else {
                    resp = this.response;
                }
                callback(resp)
            };
            request.onerror = function() {
                //                args.request.error(this);
            };
            if (this.request.url && this.request.url != "") {

                var url = Utils.addQueryParamtersToUrl({
                    skip: ((this.currentPage - 1) * this.pageSize),
                    limit: this.pageSize
                }, this.request.url);
                request.open(method, url, true);
                request.send();
                console.log(url)
            }
        },
        updateColumns: function() {
            var els = this.$.headerRow.querySelectorAll('.table-header-row');
            for (var i = 0; i < els.length; i++) {
                this.$.headerRow.removeChild(els[i]);
            }

            els = this.$.filterRow.children;
            for (var i = 0; i < els.length; i++) {
                this.$.filterRow.removeChild(els[i]);
            }

            var totalColWidth = 0;
            for (var i = 0; i < this.columns.length; i++) {
                var x = [];
                var column = this.columns[i];
                // set default width
                if (isNaN(column.width)) {
                    column.width = 100;
                }
                this._processColumn(column, x);
                column.plainColumns = x;
                if (column.visible !== false) {
                    totalColWidth += column.width;
                }

            }
            this._createHeaderRow();
            this._createFilterRow();

            this.$.header.style.width = totalColWidth + 'px';
            this.$.filter.style.width = totalColWidth + 'px';
            this.$.list.style.width = totalColWidth + 'px';

            if (totalColWidth === 0) {
                this.$.list.setAttribute('hidden', '');
            } else {
                this.$.list.removeAttribute('hidden');
            }

        },
        _createFilterRow: function() {
            var el = document.createElement('div');
            el.classList.add('horizontal', 'layout', 'style-scope', 'jso-table');
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                if (column.visible !== false) {
                    this._createFilterField(el, column);
                }
            }
            this.$.filterRow.appendChild(el);
        },
        _createFilterField: function(rowEl, column, rowData) {
            var me = this;
            var el = document.createElement('div');
            el.classList.add('table-filter-field', 'horizontal', 'layout', 'style-scope', 'jso-table');
            if (isNaN(column.width)) {
                el.classList.add('flex');
            } else {
                el.style.width = column.width + "px";
                el.style.minWidth = column.width + "px";
            }
            if (column.plainColumns.length > 0) {
                // TODO aaleman: nested columns
                //                for (var i = 0; i < column.plainColumns.length; i++) {
                //
                //                    var cEl = document.createElement('div');
                //                    var c = column.plainColumns[i];
                //                    cEl.style.width = c.width + "px";
                //                    var defValue = c.defaultValue != null ? c.defaultValue : '';
                //                    var value = null;
                //                    if (c.formula) {
                //                        value = c.formula(rowData);
                //                    } else {
                //                        value = this._deepValue(rowData, c.ak);
                //                    }
                //                    cEl.innerHTML = value != null ? value : defValue;
                //                    el.appendChild(cEl);
                //                }
            } else {
                if (!column.type) {
                    column.type = 'text';
                }
                switch (column.type) {
                    case 'text':
                        var input = document.createElement("input");
                        input.setAttribute("type", "text");
                        input.setAttribute("placeholder", "filter by " + column.title);
                        input.classList.add('style-scope', 'jso-table');
                        if (isNaN(column.width)) {
                            input.classList.add('flex');
                        } else {
                            input.style.width = column.width + "px";
                        }
                        input._col = column.name;
                        input.addEventListener('input', function(e) {
                            var query = this.value;
                            var filter = {}
                            if (input._col in me.filters) {
                                filter = me.filters[input._col];
                            }
                            if (query != "") {
                                filter.type = 'text';
                                filter.colName = input._col;
                                filter.query = query;
                                filter.func = null;
                                me.filters[input._col] = filter;
                            } else {
                                delete me.filters[input._col];
                            }
                            me._applyFilters();
                        });
                        el.appendChild(input);
                        break;
                    case 'select':
                        var selwrap = document.createElement("div");
                        selwrap.classList.add('style-scope', 'jso-table', 'select');
                        if (isNaN(column.width)) {
                            selwrap.classList.add('flex');
                        } else {
                            selwrap.style.width = column.width + "px";
                        }
                        var input = document.createElement("select");
                        input.classList.add('style-scope', 'jso-table');
                        selwrap.appendChild(input);

                        input._col = column.name;
                        var option = document.createElement("option");
                        var optVal = "";
                        option.value = optVal;
                        option.text = optVal;
                        input.appendChild(option);
                        for (var i = 0; i < column.options.length; i++) {
                            option = document.createElement("option");
                            optVal = column.options[i];
                            option.value = optVal;
                            option.text = optVal;
                            input.appendChild(option);
                        }
                        input.addEventListener('click', function(e) {
                            var query = this.value;
                            var filter = {}
                            if (input._col in me.filters) {
                                filter = me.filters[input._col];
                            }
                            if (query != "") {
                                filter.type = 'select';
                                filter.colName = input._col;
                                filter.query = query;
                                filter.func = null;
                                me.filters[input._col] = filter;
                            } else {
                                delete me.filters[input._col];
                            }
                            me._applyFilters();
                        });
                        el.appendChild(selwrap);
                        break;
                    default:
                        var input = document.createElement("div");
                        el.appendChild(input);
                        break;
                }
            }
            rowEl.appendChild(el);
        },
        _applyFilters: function() {
            for (var i = 0; i < this.data.length; i++) {
                var row = this.data[i];
                var filtered = true;
                for (var key in this.filters) {
                    var filter = this.filters[key];
                    var match = false;
                    switch (filter.type) {
                        case 'text':
                            var value = row[filter.colName].toLowerCase();
                            match = (value.indexOf(filter.query.toLowerCase()) >= 0);
                            break;
                        case 'select':
                            var value = row[filter.colName].toLowerCase();
                            match = (value === filter.query.toLowerCase());
                            break;
                    }
                    filtered &= match;
                }
                row._filtered = filtered;
            }
            this.refreshPagination();
        },
        _processColumn: function(column, x) {
            if (column.columns && column.columns.length > 0) {
                for (var i = 0; i < column.columns.length; i++) {
                    var col = column.columns[i];
                    col._parentColumn = column;

                    if (column.ak) {
                        col.ak = column.ak + "." + col.name
                    } else {
                        col.ak = column.name + "." + col.name
                    }
                    if (col.columns == null) {
                        x.push(col);
                    }
                    this._processColumn(col, x);
                }
            }
        },
        _createHeaderRow: function() {
            var el = document.createElement('div');
            el.classList.add('table-header-row', 'horizontal', 'layout', 'style-scope', 'jso-table');
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                if (column.visible !== false) {
                    this._createHeaderField(el, column);
                }
            }
            this.$.headerRow.appendChild(el);
        },
        _setResizable: function(elem) {
            var me = this;

            var columnName = ".column-" + elem._column.name;

            var resizer = document.createElement('div');
            resizer.classList.add("resizer", 'style-scope', 'jso-table');
            elem.appendChild(resizer);

            var startX, startWidth;

            function initDrag(e) {
                startX = e.clientX;
                startWidth = parseInt(document.defaultView.getComputedStyle(elem).width, 10);
                document.documentElement.addEventListener('mousemove', doDrag, false);
                document.documentElement.addEventListener('mouseup', stopDrag, false);
            }

            function doDrag(e) {
                elem.style.width = (startWidth + e.clientX - startX) + 'px';
                elem.style.minWidth = (startWidth + e.clientX - startX) + 'px';
            }

            function stopDrag(e) {

                document.documentElement.removeEventListener('mousemove', doDrag, false);
                document.documentElement.removeEventListener('mouseup', stopDrag, false);

                var dif = e.clientX - startX;

                elem.style.width = (startWidth + dif) + 'px';
                elem._column.width = (startWidth + dif);

                var parentColumn = elem._column._parentColumn;
                while (parentColumn != null) {
                    parentColumn.width += dif;
                    parentColumn = parentColumn._parentColumn;
                }

                function resizeChildren(columns, d) {

                    if (Array.isArray(columns)) {

                        for (var i = 0; i < columns.length; i++) {
                            var col = columns[i];

                            col.width += (d / columns.length);
                            resizeChildren(col.columns, d / columns.length);
                        }
                    }
                }

                resizeChildren(elem._column.columns, dif);

                me.updateColumns();
                me.viewDataChanged();
            }

            resizer.addEventListener('mousedown', initDrag, false);
        },

        _createHeaderField: function(rowEl, column) {
            var me = this;
            var el = document.createElement('div');
            el.classList.add('table-header-field', 'vertical', 'layout', 'center-justified', 'style-scope', 'jso-table', ('column-' + column.name.replace(/\s/g, '_')));
            if (isNaN(column.width)) {
                el.classList.add('flex');
            } else {
                el.style.width = column.width + "px";
                el.style.minWidth = column.width + "px";
            }
            el._column = column;
            var nameEl = document.createElement('div');
            nameEl.classList.add('name', 'style-scope', 'jso-table');
            nameEl.innerHTML = column.title;
            el.appendChild(nameEl);

            if (this.enableResize) {
                this._setResizable(el);
            }

            if (column.columns && column.columns.length > 0) {
                var subColumnsEl = document.createElement('div');
                subColumnsEl.classList.add('sub', 'horizontal', 'layout', 'style-scope', 'jso-table');
                for (var i = 0; i < column.columns.length; i++) {
                    var subColumn = column.columns[i];
                    if (subColumn.visible != false) {
                        this._createHeaderField(subColumnsEl, subColumn);
                    }
                    // this._createHeaderField(subColumnsEl, subColumn);
                }
                el.appendChild(subColumnsEl);
            } else {
                el.addEventListener('click', this.handleHeaderFieldClick.bind(this));
            }
            rowEl.appendChild(el);
        },
        handleHeaderFieldClick: function(e) {
            var me = this;
            var column = e.currentTarget._column;
            var sortedData = this.data.slice(0);
            var els = this.querySelectorAll('.table-header-field');
            var isSortDown = e.currentTarget.classList.contains("sort-down");
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                el.classList.remove('sort-down');
                el.classList.remove('sort-up');
            }
            if (isSortDown) {
                sortedData.sort(function(a, b) {
                    return me._columnSort(column, b, a);
                });
                e.currentTarget.classList.add('sort-up');
            } else {
                sortedData.sort(function(a, b) {
                    return me._columnSort(column, a, b);
                });
                e.currentTarget.classList.add('sort-down');
            }
            this.data = sortedData;
        },
        _columnSort: function(column, a, b) {
            //checking formula or TODO save calculated value in the item;
            var aVal, bVal;
            if (column.formula != null) {
                aVal = column.formula(a);
                bVal = column.formula(b);
            } else {
                aVal = a[column.name];
                bVal = b[column.name];
            }
            if (!isNaN(bVal) && !isNaN(aVal)) {
                return aVal - bVal;
            } else {
                return (aVal > bVal) - (aVal < bVal);
            }
        },
        _getPos: function(row) {
            for (var i = 0; i < this.viewData.length; i++) {
                var elem = this.viewData[i];
                if (elem === row) {
                    return i;
                }
            }
            return -1;
        },
        _createRow: function(rowData) {
            var me = this;
            var el = document.createElement('div');
            el.classList.add('table-row', 'horizontal', 'layout', 'style-scope', 'jso-table');
            el._rowData = rowData;
            var id = "idRow_" + this._getPos(rowData);
            el.setAttribute("id", id);
            if (this.draggable) {
                el.setAttribute("draggable", "true");
                el.addEventListener('dragstart', this.drag);
            }
            el.addEventListener('click', function(e) {
                me.fire('rowclick', {
                    row: rowData
                });
                var currentTarget = e.currentTarget;
                console.log("Position: " + me._getPos(currentTarget._rowData));
                if (me.enableSelect) {
                    if (e.ctrlKey) {
                        me._toggleSelected(currentTarget, rowData);
                    }
                    if (e.button === 0) {
                        if (!e.ctrlKey && !e.shiftKey) {
                            me._clearSelection();
                            me._toggleSelected(currentTarget, rowData);
                        }
                        if (e.shiftKey) {
                            var first = me._getPos(me.lastSelectedRow._rowData);
                            var last = me._getPos(currentTarget._rowData);
                            if (last < first) {
                                var tmp = last;
                                last = first;
                                first = tmp;
                            }
                            me._selectRowsBetweenIndexes(first, last);
                        }
                    }
                }
            });
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                if (column.visible !== false) {
                    this._createField(el, column, rowData);
                }
            }
            this.$.list.appendChild(el);
        },
        _toggleSelected: function(domElem, rowData) {
            if (domElem.classList.contains("selected")) {
                var index = this.selected.indexOf(rowData);
                if (index >= 0) {
                    this.splice('selected', index, 1);
                    domElem.classList.remove("selected");
                }
            } else {
                if (this.selected.indexOf(rowData) < 0) {
                    this.push('selected', rowData);
                    domElem.classList.add("selected");
                }
            }
            this.lastSelectedRow = domElem;
        },
        _selectRowsBetweenIndexes: function(first, last) {
            var rows = this.$.list.getElementsByClassName("table-row");
            for (var i = 0; i < rows.length; i++) {
                var obj = rows[i];
                var pos = this._getPos(obj._rowData);
                var index = this.selected.indexOf(obj._rowData);
                if (pos >= first && pos <= last) {
                    obj.classList.add("selected");
                    if (index < 0) {
                        this.push('selected', obj._rowData);
                    }
                } else {
                    if (index >= 0) {
                        this.splice('selected', index, 1);
                    }
                }
            }
        },
        _clearSelection: function() {
            var rows = this.$.list.getElementsByClassName("table-row");
            for (var i = 0; i < rows.length; i++) {
                var obj = rows[i];
                obj.classList.remove("selected");
            }
            this.splice('selected', 0, this.selected.length);
        },
        _createField: function(rowEl, column, rowData) {
            var me = this;
            var el = document.createElement('div');
            el.classList.add('table-field', 'horizontal', 'layout', 'center', 'style-scope', 'jso-table');
            if (isNaN(column.width)) {
                el.classList.add('flex');
            } else {
                el.style.width = column.width + "px";
                el.style.minWidth = column.width + "px";
            }
            if (column.type === "action") {
                var remove = document.createElement("i");
                remove.classList.add("fa", "fa-remove");
                remove.addEventListener('click', function(e) {
                    me.fire('removerow', {
                        row: rowData
                    });
                    var pos = me._getPos(rowData);
                    if (pos >= 0) {
                        me.splice('data', pos, 1);
                    }
                });
                el.classList.add("center-justified")
                el.appendChild(remove);
            } else if (column.plainColumns.length > 0) {
                for (var i = 0; i < column.plainColumns.length; i++) {
                    var c = column.plainColumns[i];
                    if (c.visible != false) {
                        this._createTypeField(el, c, rowData, true);
                    }
                    // this._createTypeField(el, c, rowData, true);
                }
            } else {
                this._createTypeField(el, column, rowData);
            }
            rowEl.appendChild(el);
        },
        _createTypeField: function(el, column, rowData, isSubCol) {
            var me = this;
            var value;
            var defValue = column.defaultValue;

            if (column.formula) {
                value = column.formula(rowData);
            } else {
                if (isSubCol == true) {
                    value = this._deepValue(rowData, column.ak);
                } else {
                    value = rowData[column.name];
                }
            }

            // set empty string if no value found.
            value = (value == null) ? defValue : value;
            value = (value == null) ? '' : value;

            if (this.enableEdit && column.editable != false) {
                if (!column.type) {
                    column.type = 'text';
                }
                switch (column.type) {
                    case 'text':
                        var input = document.createElement("input");
                        input.setAttribute("type", "text");
                        input.setAttribute("placeholder", "");
                        input.setAttribute("readonly", "");
                        input.classList.add('style-scope', 'jso-table');
                        input._col = column.name;
                        input.addEventListener('dblclick', function(e) {
                            this.removeAttribute('readonly');
                        });
                        input.addEventListener('blur', function(e) {
                            if (!this.hasAttribute('readonly')) {
                                this.setAttribute('readonly', '');
                                var val = this.value;
                                if (column.editFormula != null) {
                                    column.editFormula(rowData, val);
                                } else {
                                    rowData[column.name] = val;
                                }
                                // rowData.attributes[column.name] = val;
                                me.fire('update-row', {
                                    row: rowData,
                                    column: column
                                });
                            }
                        });
                        input.value = value;
                        el.appendChild(input);
                        break;
                    case 'select':
                        //TODO check styles
                        el.classList.add('table-field-nopadding');
                        var selwrap = document.createElement("div");
                        selwrap.classList.add('style-scope', 'jso-table', 'select');
                        if (isNaN(column.width)) {
                            selwrap.classList.add('flex');
                        } else {
                            selwrap.style.width = column.width + "px";
                        }
                        var input = document.createElement("select");
                        input.classList.add('style-scope', 'jso-table');
                        selwrap.appendChild(input);
                        input._col = column.name;
                        var option = document.createElement("option");
                        var optVal = "";
                        option.value = optVal;
                        option.text = optVal;
                        input.appendChild(option);
                        for (var i = 0; i < column.options.length; i++) {
                            option = document.createElement("option");
                            optVal = column.options[i];
                            option.value = optVal;
                            option.text = optVal;
                            input.appendChild(option);
                        }
                        //TODO check
                        input.addEventListener('click', function(e) {
                            var val = this.value;
                            rowData.attributes[column.name] = val;
                        });
                        input.value = value;
                        el.appendChild(selwrap);
                        break;
                }
            } else {
                var cEl = document.createElement('div');
                cEl.classList.add('style-scope', 'jso-table');
                if (isNaN(column.width)) {
                    cEl.classList.add('flex');
                } else {
                    cEl.style.width = column.width + "px";
                }
                cEl.innerHTML = value;
                if (!this.disableTooltip) {
                    var tooltipValue = value;
                    cEl.setAttribute("title", tooltipValue);
                }

                cEl.classList.add('column-' + column.name.replace(/\s/g, '_'));
                if (column.styleFormula) {
                    var newStyle = column.styleFormula(rowData);
                    for (var key in newStyle) {
                        cEl.style[key] = newStyle[key];
                    }
                }
                if (column.classFormula) {
                    var newClass = column.classFormula(rowData);
                    cEl.classList.add(newClass);
                }
                el.appendChild(cEl);
            }

        },
        _deepValue: function(obj, path) {
            for (var i = 0, path = path.split('.'), len = path.length; i < len; i++) {
                var auxPath = path[i];
                if (auxPath === "undefined") {
                    continue;
                }
                obj = auxPath;
            }
            return obj;
        },
        contains: function(searchElem, compareFunction) {
            var cmp = function(a, b) {
                return a === b;
            }
            if (compareFunction && typeof(compareFunction) === "function") {
                cmp = compareFunction;
            }
            for (var i = 0; i < this.data.length; i++) {
                var elem = this.data[i];
                if (cmp(searchElem, elem)) {
                    return true;
                }
            }
            return false;
        },
        setLoading: function(loading) {
            this.loading = loading;
        },
        allowDrop: function(e) {
            console.log("drag!!!")
            e.preventDefault();
        },
        drop: function(e) {
            e.preventDefault();
            var data = JSON.parse(e.dataTransfer.getData("rowData"));
            this.push('data', data);
        },
        drag: function(e) {
            e.dataTransfer.setData("rowData", JSON.stringify(e.currentTarget._rowData));
        },
        handleLoading: function(neo, old) {},

        selectElem: function(elem, compareFunction) {

            var selected = null;

            for (var i = 0; i < this.viewData.length && selected == null; i++) {
                var obj = this.viewData[i];
                if (compareFunction(elem, obj)) {
                    selected = obj;
                }
            }

            if (selected != null) {
                this.selected = [selected];
            } else {
                this._clearSelection();
            }

        },
        _callRemoteExport: function(url, callback) {
            var method = 'GET';
            if (typeof this.request.method !== 'undefined' && this.request.method != null) {
                method = this.request.method;
            }
            var request = new XMLHttpRequest();
            request.onload = function() {
                var contentType = this.getResponseHeader('Content-Type');
                var resp;
                if (contentType === 'application/json') {
                    resp = JSON.parse(this.response, this);
                } else {
                    resp = this.response;
                }
                callback(resp)
            };
            request.onerror = function() {
                //                args.request.error(this);
            };

            request.open(method, url, true);
            request.send();
            console.log(url)
        },
        handleExportCSVMenuButton: function(e) {

            e.stopPropagation();
            var me = this;

            var CSV = this.exportParsers.headerParser(this.columns);
            CSV += "\n";

            var data = (this.enableRemote) ? this.viewData : this.data;

            if (!this.enableRemote) {
                for (var i = 0; i < data.length; i++) {
                    var row = data[i];
                    CSV += this.exportParsers.dataParser(this.columns, row);
                    CSV += "\n";
                }
                var blob = new Blob([CSV], {
                    type: "text/plain;charset=utf-8"
                });

                var initialFileName = 'data.csv';
                var fileName = window.prompt("Please enter file name", initialFileName);
                if (fileName != null && fileName != "") {
                    saveAs(blob, fileName);
                }
            } else {
                var skip = 0;
                // var limit = this.exportParsers.chunkSize;
                var dataElems = 0;
                var limit = (this.itemCount <= this.exportParsers.maxLimit) ? this.itemCount : this.exportParsers.maxLimit;
                // var limit = 500;
                // var numTotalResults = this.itemCount;

                var url = Utils.addQueryParamtersToUrl({
                    skip: skip,
                    limit: limit
                }, this.request.url);

                this._callRemoteExport(url, function(response) {
                    var data = me.request.parse(response);

                    for (var i = 0; i < data.length; i++) {
                        var row = data[i];
                        CSV += me.exportParsers.dataParser(me.columns, row);
                        CSV += "\n";
                    }
                    var blob = new Blob([CSV], {
                        type: "text/plain;charset=utf-8"
                    });

                    var initialFileName = 'data.csv';
                    var fileName = window.prompt("Please enter file name", initialFileName);
                    if (fileName != null && fileName != "") {
                        saveAs(blob, fileName);
                    }

                });

                // while (skip < numTotalResults) {
                //
                //     var url = Utils.addQueryParamtersToUrl({
                //         skip: skip,
                //         limit: limit
                //
                //     }, this.request.url);
                //
                //     this._callRemoteExport(url, function(response) {
                //         var data = me.request.parse(response);
                //         for (var i = 0; i < data.length; i++) {
                //             var row = data[i];
                //             CSV += me.exportParsers.dataParser(me.columns, data);
                //             CSV += "\n";
                //         }
                //         console.log(skip);
                //
                //         if ((skip + limit) >= numTotalResults) {
                //             var blob = new Blob([CSV], {
                //                 type: "text/plain;charset=utf-8"
                //             });
                //
                //             var initialFileName = 'data.csv';
                //             // var fileName = window.prompt("Please enter file name", initialFileName);
                //             // if (fileName != null && fileName != "") {
                //               console.log("SAVEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE")
                //                 // saveAs(blob, fileName);
                //             // }
                //         }
                //     });
                //     skip += limit;
                // }
            }

        },
        exportToTable: function(start, end) {
            start = start || 0;
            end = end || this.data.length;

            var table = document.createElement("table");

            table.classList.add("jso-table");

            var thead = this._createTableHeader();

            var tbody = this._createTableBody(start, end);

            table.appendChild(thead);
            table.appendChild(tbody);
            return table;

        },
        _createTableHeader: function() {
            var thead = document.createElement("thead");
            thead.classList.add("jso-table");
            var tr = document.createElement("tr");
            tr.classList.add("jso-table");

            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                if (column.visible !== false) {
                    this._createTableHeaderField(tr, column);
                }
            }

            thead.appendChild(tr);
            return thead;
        },
        _createTableHeaderField: function(rowEl, column) {

            var th = document.createElement("th");
            th.classList.add("jso-table", ('column-' + column.name.replace(/\s/g, '_')));
            th.innerHTML = column.title;

            rowEl.appendChild(th);

        },

        _createTableBody: function(start, end) {

            var tbody = document.createElement("tbody");
            tbody.classList.add("jso-table");

            for (var i = start; this.data && i < end; i++) {
                var rowData = this.data[i];
                var elem = this._createTableRow(rowData);
                tbody.appendChild(elem);
            }

            return tbody;

        },
        _createTableRow: function(rowData) {

            var tr = document.createElement("tr");
            tr.classList.add("jso-table");

            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                if (column.visible !== false) {
                    this._createTableField(tr, column, rowData);
                }
            }
            return tr;
        },
        _createTableField: function(tr, column, rowData) {
            var td = document.createElement("td");
            td.classList.add("jso-table");

            if (column.plainColumns.length > 0) {
                for (var i = 0; i < column.plainColumns.length; i++) {
                    var c = column.plainColumns[i];
                    this._createTableTypeField(td, c, rowData, true);
                }
            } else {
                this._createTableTypeField(td, column, rowData);
            }

            tr.appendChild(td);
        },
        _createTableTypeField: function(el, column, rowData, isSubCol) {
            var me = this;
            var value;
            var defValue = column.defaultValue;

            if (column.formula) {
                value = column.formula(rowData);
            } else {
                if (isSubCol == true) {
                    value = this._deepValue(rowData, column.ak);
                } else {
                    value = rowData[column.name];
                }
            }

            // set empty string if no value found.
            value = (value == null) ? defValue : value;
            value = (value == null) ? '' : value;

            var cEl = document.createElement('div');
            cEl.classList.add('jso-table');
            if (isNaN(column.width)) {
                cEl.classList.add('flex');
            } else {
                cEl.style.width = column.width + "px";
            }
            cEl.innerHTML = value;
            //            if (!this.disableTooltip) {
            //                var tooltipValue = value;
            //                cEl.setAttribute("title", tooltipValue);
            //            }

            cEl.classList.add('column-' + column.name.replace(/\s/g, '_'));
            el.appendChild(cEl);

        }
    })
</script>

<dom-module id="jso-table-column-menu-item" assetpath="bower_components/jsorolla/src/lib/components/table/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning"></style>
    <style>

    </style>
    <template>
        <label class="jso-control">
            <input type="checkbox" checked$="{{isColumnVisible(column.visible)}}" on-click="handleColumnVisibilityClick">
            <span>{{column.title}}
                <template is="dom-if" if="{{column.columns}}">
                    ,
                    <template is="dom-repeat" items="{{column.columns}}">
                        <jso-table-subcolum-name column="{{item}}"></jso-table-subcolum-name>
                    </template>
                </template>
            </span>
        </label>
    </template>
    <script>
        Polymer({
            is: 'jso-table-column-menu-item',
            properties: {
                column: {
                    type: Object
                }
            },
            handleColumnVisibilityClick: function(e) {
                this.set('column.visible', !this.column.visible);
                this.fire('column-toggle', this.column);
            },
            isColumnVisible: function(v) {
                return v !== false;
            },
        })
    </script>
</dom-module>

<dom-module id="jso-table-subcolum-name" assetpath="bower_components/jsorolla/src/lib/components/table/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning"></style>
    <template>
        {{column.title}}
        <template is="dom-repeat" items="{{column.columns}}">
            {{item.title}}
        </template>
    </template>
    <script>
        Polymer({
            is: 'jso-table-subcolum-name',
            properties: {
                column: {
                    type: Object
                }
            }
        })
    </script>
</dom-module>
<script>; 
/* https://github.com/anpur/line-navigator Anton Purin MIT 2016 */
var createFileWrapper = function() {

    function FileWrapper (file, encoding) {
        var self = this;        

        // Node JS
        if (self.isNode(file)) {
            self.fs = require('fs');

            var StringDecoder = require('string_decoder').StringDecoder;
            self.string_decoder = new StringDecoder(encoding);

            if (self.fs.statSync(file) === undefined)
                throw "File '" + file + "' doesn't exists!";

            var fd = self.fs.openSync(file, 'r');
            
            self.readChunk = function (offset, length, callback) {
                var buffer = new Buffer(length);

                self.fs.read(fd, buffer, 0, length, offset, function (e, br) { callback(e, buffer, br); });
            };

            self.decode = function(buffer, callback) {
                callback(self.string_decoder.write(buffer));
            };

            self.getSize = function() {
                return self.fs.statSync(file)["size"];
            };
        } 

        // HTML5 File
        else if (self.isHtml5File(file)) {
            self.readChunk = function (offset, length, callback) {
                lastPosition = offset + length;
                var reader = new FileReader();

                reader.onloadend = function(progress) {
                    var buffer;
                    if (reader.result) {
                        buffer = new Int8Array(reader.result, 0);
                        buffer.slice = buffer.subarray;
                    }
                    callback(progress.err, buffer, progress.loaded);
                };

                reader.readAsArrayBuffer(file.slice(offset, offset + length));
            };

            self.decode = function(buffer, callback) {
                var reader = new FileReader();
                reader.onloadend = function(progress) {
                    callback(progress.currentTarget.result);
                };
                if (typeof encoding !== 'undefined') {
                    reader.readAsText(new Blob([buffer]), encoding);
                } else {
                    reader.readAsText(new Blob([buffer]));
                }
            };

            self.getSize = function() {
                return file.size;
            };
        } 
        // Unknown
        else {
            throw "Given file should be instance of the File class for browser \
            or a string containing a path to a file for Node.js, \
            but it is neither: [" + (typeof file) + "] " + file;
        }
    }

    FileWrapper.prototype.isNode = function (file) { 
        return typeof module !== 'undefined' && module.exports && typeof file === 'string'; 
    };

    FileWrapper.prototype.isHtml5File = function (file) { 
        return typeof File !== 'undefined' && file instanceof File; 
    }

    return FileWrapper;
}

// Node.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = createFileWrapper();
}
// AMD
else if (typeof define === 'function') {
    define(function(){
        return createFileWrapper();    
    });
}
// Vanilla
else {
    FileWrapper = createFileWrapper();
}</script>
<script>;
/* https://github.com/anpur/line-navigator Anton Purin MIT 2016 */
var getLineNavigatorClass = function() {
    function LineNavigator (file, options) {
        var self = this;

        // options init 
        options =       options           ? options           : {};        
        var encoding =  options.encoding  ? options.encoding  : 'utf8';
        var chunkSize = options.chunkSize ? options.chunkSize : 1024 * 4;
        var milestones = [];

        var wrapper = new FileWrapper(file, encoding);
        var oldFileSize = wrapper.getSize();

        var getFileSize = function (position) {
            return oldFileSize = oldFileSize > position
                ? oldFileSize 
                : wrapper.getSize(file);
        }

        var getProgressSimple = function(position) {
            var size = getFileSize(position);
            return Math.round(100 * position / size);
        }

        self.readSomeLines = function(index, callback) {
            var place = self.getPlaceToStart(index, milestones);     

            wrapper.readChunk(place.offset, chunkSize, function readChunkCallback(err, buffer, bytesRead) {                
                if (err) return callback(err, index);

                var isEof = bytesRead < chunkSize;
  
                var chunkContent = self.examineChunk(buffer, bytesRead, isEof); 
                if (chunkContent === undefined)
                    return callback('Line ' + index + ' is out of index, last available: ' + (milestones.length > 0 ? milestones[milestones.length - 1].lastLine : "none"), index);
                var inChunk = { 
                    firstLine: place.firstLine, 
                    lastLine: place.firstLine + chunkContent.lines - 1, 
                    offset: place.offset,
                    length: chunkContent.length + 1
                };

                if (place.isNew) 
                    milestones.push(inChunk);               

                var targetInChunk = inChunk.firstLine <= index && index <= inChunk.lastLine;

                if (targetInChunk) {
                    var bomOffset = place.offset !== 0 ? 0 : self.getBomOffset(buffer, encoding);

                    wrapper.decode(buffer.slice(bomOffset, inChunk.length), function(text) {
                        var expectedLinesCount = inChunk.lastLine - inChunk.firstLine + (isEof ? 2 : 1);
                        
                        var lines = text.split(self.splitLinesPattern);                            
                        if (!isEof)
                            lines = lines.slice(0, lines.length - 1);                   
                        if (index != inChunk.firstLine)
                            lines = lines.splice(index - inChunk.firstLine); 
                          
                        callback(undefined, index, lines, isEof, getProgressSimple(inChunk.offset + inChunk.length), inChunk);
                    });
                } else {
                    if (!isEof) {                        
                        place = self.getPlaceToStart(index, milestones);
                        wrapper.readChunk(place.offset, chunkSize, readChunkCallback);
                    } else {
                        return callback('Line ' + index + ' is out of index, last available: ' + inChunk.lastLine, index);
                    }
                }                
            });
        };        

        self.readLines = function(index, count, callback) {
            if (count === 0) 
                return callback(undefined, index, [], false, 0);            

            var result = [];
            self.readSomeLines(index, function readLinesCallback(err, partIndex, lines, isEof, progress, inChunk) {
                if (err) return callback(err, index);

                var resultEof = !isEof
                    ? false
                    :  partIndex + lines.length <= index + count;

                result = result.concat(lines);

                if (result.length >= count || isEof) {
                    result = result.splice(0, count);
                    var progress = self.getProgress(inChunk, index + result.length - 1, getFileSize(inChunk.offset + inChunk.length));
                    return callback(undefined, index, result, resultEof, progress);
                }

                self.readSomeLines(partIndex + lines.length, readLinesCallback);
            });
        };

        self.find = function(regex, index, callback) {
            self.readSomeLines(index, function readSomeLinesHandler(err, firstLine, lines, isEof, progress) {
                if (err) return callback(err);

                for (var i = 0; i < lines.length; i++) {
                    var match = self.searchInLine(regex, lines[i]);
                    if (match)       
                        return callback(undefined, firstLine + i, match);                    
                }

                if (isEof) 
                    return callback();

                self.readSomeLines(firstLine + lines.length + 1, readSomeLinesHandler);
            });
        };

        self.findAll = function(regex, index, limit, callback) {
            var results = [];

            self.readSomeLines(index, function readSomeLinesHandler(err, firstLine, lines, isEof) {
                if (err) return callback(err, index);

                for (var i = 0; i < lines.length; i++) {
                    var match = self.searchInLine(regex, lines[i]);
                    if (match) {
                        match.index = firstLine + i;
                        results.push(match);
                        if (results.length >= limit)
                            return callback(undefined, index, true, results);
                    }
                }
                if (isEof)
                    return callback(undefined, index, false, results);

                self.readSomeLines(firstLine + lines.length, readSomeLinesHandler);
            });
        };
    }

    LineNavigator.prototype.splitLinesPattern = /\r\n|\n|\r/;

    LineNavigator.prototype.getProgress = function (milestone, index, fileSize) {
        var linesInMilestone = milestone.lastLine - milestone.firstLine + 1;
        var indexNumberInMilestone = index - milestone.firstLine;
        var indexLineAssumablePosition = index !== milestone.lastLine 
            ? milestone.offset + milestone.length / linesInMilestone * indexNumberInMilestone
            : milestone.offset + milestone.length;

        return Math.floor(100 * (indexLineAssumablePosition / fileSize));
    }

    LineNavigator.prototype.searchInLine = function(regex, line) {
        var match = regex.exec(line);
        return !match 
            ? null 
            : {
                    offset: line.indexOf(match[0]),
                    length: match[0].length,
                    line: line
              };
    }

    LineNavigator.prototype.getPlaceToStart = function (index, milestones) {
        for (var i = milestones.length - 1; i >= 0; i--) {
            if (milestones[i].lastLine < index) 
                return { 
                    firstLine: milestones[i].lastLine + 1, 
                    offset: milestones[i].offset + milestones[i].length,
                    isNew: i === milestones.length - 1
                };
        }
        return { firstLine: 0, offset: 0, isNew: milestones.length === 0 };
    }

    // searches for line end, which can be \r\n, \n or \r (Windows, *nix, MacOs line endings)
    // returns line end postion including all line ending
    LineNavigator.prototype.getLineEnd = function (buffer, start, end, isEof) {
        var newLineCode = '\n'.charCodeAt(0);
        var caretReturnCode = '\r'.charCodeAt(0);

        for (var i = start; i < end; i++) {
            var char = buffer[i];
            if (char === newLineCode) {
                return i;
            } else if (char === caretReturnCode) {
                // \r is a last character in a given buffer and it is not the end of file yet, so it could be \r\n sequence which was separated
                var canBeSplitted = (i == end - 1) && !isEof; 

                if (!canBeSplitted) {
                    return buffer[i + 1] === newLineCode 
                        ? i + 1 
                        : i;
                } else {
                    return undefined;
                }
            }
        }
    }

    LineNavigator.prototype.examineChunk = function(buffer, bytesRead, isEof) {
        var lines = 0;
        var length = 0;
        
        do {
            var position = LineNavigator.prototype.getLineEnd(buffer, length, bytesRead, isEof);
            if (position !== undefined) {
                lines++;
                length = position + 1;
            }
        } while (position !== undefined);

        if (isEof) {
            lines++;
            length = bytesRead;
        }

        return length > 0 
            ? { lines: lines, length: length - 1 } 
            : undefined;
    };    

    var bomUtf8 = [239, 187, 191];
    var bomUtf16le = [255, 254];

    var arrayStartsWith = function (array, startsWith) {
        for (var i = 0; i < array.length && i < startsWith.length; i++) {
            if (array[i] !== startsWith[i])
                return false;
            if (i == startsWith.length - 1) 
                return true;
        }
        return false;
    };

    LineNavigator.prototype.getBomOffset = function(buffer, encoding) {
        switch (encoding.toLowerCase()) {
            case 'utf8':
                return arrayStartsWith(buffer, bomUtf8) ? bomUtf8.length : 0;
            case 'utf16le':
                return arrayStartsWith(buffer, bomUtf16le) ? bomUtf16le.length : 0;
            default:
                return 0;
        }
    }

    return LineNavigator;    
};

// Node.js
if (typeof module !== 'undefined' && module.exports) {
    FileWrapper = require('./file-wrapper.js');
    module.exports = getLineNavigatorClass();
}
// AMD
else if (typeof define === 'function') {
    define(['./file-wrapper'], function(fileWrapper){
        FileWrapper = fileWrapper;
        return getLineNavigatorClass();    
    });
}
// Vanilla
else {
    if (typeof FileWrapper === 'undefined') {
        throw "For vanilla JS please add 'file-wrapper.js' script tag before this one."
    }
    LineNavigator = getLineNavigatorClass();
}</script>






<dom-module name="jso-validator">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            height: 300px;
        }

        #header,
        #footer {
            box-sizing: border-box;
            background-color: var(--light-secondary-color);
            padding: 0 7px;
        }

        #header {
            height: 30px;
            border-bottom: 1px solid var(--divider-color);
        }

        #footer {
            height: 30px;
            border-top: 1px solid var(--divider-color);
        }

        #footer>* {
            margin-left: 3px;
        }

        .line {
            width: 40px;
        }

        .type {
            width: 60px;
        }

        #stop {
            margin-left: 7px;
            background-color: var(--dark-button-color);
            color: var(--text-primary-color);
        }

        #stop:hover {
            background-color: var(--light-button-color);
        }

        .type[type="error"],
        .error-count {
            color: #bf4747;
        }

        .type[type="info"],
        .info-count {
            color: #4790bf;
        }

        .type[type="warning"],
        .warning-count {
            color: #bf9947;
        }

        .item {
            /*display: block;*/
            /*position: relative;*/
            /*box-sizing: border-box;*/
            /*height: auto;*/
            /*margin: 3px;*/
            padding: 1px 2px;
            height: 50px;
            border-left: 2px solid transparent;
        }

        .item:hover {
            border-left: 2px solid var(--divider-color);
        }

        .view {
            cursor: pointer;
            visibility: hidden;
        }

        .item:hover > .view {
            visibility: visible;
        }

        .view > i:hover {
            color: var(--dark-button-color);
        }

        .line {
            padding-right: 1px;
            text-align: center;
        }

        .type {
            padding: 0 1px;
            text-align: center;
        }

        .msg {
            word-break: break-all;
            font-size: .95em;
        }

        .item[type="error"] {
            background-color: rgba(191, 71, 71, 0.15);
            border: 1px solid rgba(191, 71, 71, 0.3)
        }

        .item[type="warning"] {
            background-color: rgba(255, 191, 0, 0.15);
            border: 1px solid rgba(255, 191, 0, 0.3);
        }

        .log {
            position: relative;
            height: calc(100% - 48px);
            overflow-y: auto;
            /*background-color: #FAFAFA;*/
            background-color: white;
        }

        .count {
            padding: 0 5px;
        }

        .count > span {
            color: black;
        }

        .uploadbar {
            position: relative;
            height: 18px;
            width: 100px;
            background-color: var(--light-primary-color);
            line-height: 18px;
            border: 1px solid var(--divider-color);
        }

        .uploadprogress {
            position: absolute;
            top: 0px;
            left: 0px;
            height: 100%;
            width: 100%;
            background-color: var(--hover-color);
            /*margin-top: 10px;*/
        }

        .uploadtext {
            position: absolute;
            text-align: center;
            top: 0px;
            left: 0px;
            height: 100%;
            width: 100%;
        }

        .header > div {
            padding-left: 2px;
        }

        .wrapped-text {
            white-space: pre-wrap;
            padding: 10px;
            overflow-y: auto;
            min-width: 400px;
            min-height: 150px;
        }

        #linePreviewPanel {
            max-width: 1000px;
        }
    </style>
    <template>

        <div id="header" class="horizontal layout center">
            <div class="line">Line </div>
            <div class="type">Type</div>
            <div class="msg">Message</div>
            <div class="flex"></div>
            <div class="uploadbar" hidden$="{{!uploading}}">
                <div id="progressBar" class="uploadprogress"></div>
                <div class="uploadtext">
                    <i id="spin" hidden$="{{computeSpin(progress)}}" class="fa fa-spinner fa-spin"></i>
                    <span>{{progress}}</span> %
                </div>
                <br>
            </div>
            <div id="stop" class="jso-btn jso-btn-shdw" on-click="handleStop">Stop</div>
        </div>
        <iron-list class="log" items="{{logIron}}" as="item">
            <template>
                <div class="horizontal layout center item" type$="{{item.type}}">
                    <div class="line">{{item.line}}</div>
                    <div class="type" type$="{{item.type}}">{{item.type}}</div>
                    <div class="msg flex">{{item.msg}}</div>
                    <div class="view" line="{{item.line}}" column="{{item.column}}" on-click="handleLogViewClick" title="View line"><i class="fa fa-search"></i></div>
                </div>
            </template>
        </iron-list>

        <div id="footer" class="counts horizontal layout center">
            <div class="jso-btn jso-btn-shdw but" on-click="handleView" data-value="error" data-checked$="{{computeView(view, 'error')}}">
                <div class="error-count count">Errors:
                    <span>{{errorCount}}</span>
                </div>
            </div>
            <div class="jso-btn jso-btn-shdw but" on-click="handleView" data-value="warning" data-checked$="{{computeView(view, 'warning')}}">
                <div class="warning-count count">Warning:
                    <span>{{warningCount}}</span>
                </div>
            </div>
            <div class="jso-btn jso-btn-shdw but" on-click="handleView" data-value="info" data-checked$="{{computeView(view, 'info')}}">
                <div class="info-count count">Info:
                    <span>{{infoCount}}</span>
                </div>
            </div>
            <div class="flex"></div>
            <div class="count">Lines:
                <span>{{numLines}}</span>
            </div>
        </div>

        <jso-panel modal="" movable="" closable="" hidden="" id="linePreviewPanel" on-close="handleCloseLinePreview">
            <div class="header">
                <i class="fa fa-view"></i> &nbsp; View line
            </div>
            <div class="container wrapped-text">{{linePreview}}</div>
        </jso-panel>


    </template>

    <script>
        Polymer({
            is: "jso-validator",
            properties: {
                file: {
                    type: Object,
                    value: function() {
                        return null;
                    },
                    observer: 'fileChanged'
                },
                validator: {
                    type: Object,
                    value: function() {
                        return new Validator({});
                    },
                    observer: 'validatorChanged'
                },
                logIron: {
                    type: Array
                },
                log: {
                    type: Object,
                    value: function() {
                        return {
                            error: [],
                            warning: [],
                            info: []
                        }
                    }
                },
                errorCount: {
                    type: Number,
                    value: 0
                },
                warningCount: {
                    type: Number,
                    value: 0
                },
                infoCount: {
                    type: Number,
                    value: 0
                },
                numLines: {
                    type: Number,
                    value: 0
                },
                progress: {
                    type: Number,
                    value: 0,
                    observer: 'progressChanged'
                },
                view: {
                    type: String,
                    value: 'error'
                },
            },
            ready: function() {
                this.set("logIron", this.log[this.view]);
            },
            handleView: function(e) {
                this.view = e.currentTarget.dataset.value;
                this.set("logIron", this.log[this.view]);
            },
            computeView: function(view, value) {
                return view === value;
            },
            reset: function() {
                this.progress = 0;
                this.set("log", {
                    error: [],
                    warning: [],
                    info: []
                });
                this.set("logIron", this.log[this.view]);
                this.errorCount = 0;
                this.warningCount = 0;
                this.infoCount = 0;
                this.numLines = 0;
                if (this.validator) {
                    this.validator.init();
                }
                this.setFile();
            },
            validate: function() {
                this.set("log", {
                    error: [],
                    warning: [],
                    info: []
                });
                this.set("logIron", this.log[this.view]);
                this.errorCount = 0;
                this.warningCount = 0;
                this.infoCount = 0;
                this.numLines = 0;
                this.validator.validate();
            },
            handleStop: function(e) {
                this.stop();
            },
            stop: function() {
                if (this.validator) {
                    this.validator.stop();
                }
            },
            setFile: function(file) {
                this.fileChanged(file);
            },
            validatorChanged: function(neo, old) {
                var me = this;
                neo.on("end", function(e) {
                    me.numLines = me.validator.numLines;
                    me.fire("end");
                });

                neo.on("err", function(e) {
                    me.fire("err");
                });

                neo.on("stop", function(e) {
                    me.$.spin.setAttribute('hidden', '');
                    me.fire("stop");
                });

                neo.on("log", function(e) {
                    switch (e.type) {
                        case "error":
                            me.errorCount++;
                            if (me.errorCount == 100) {
                                me.stop();
                                alert('File has more than 100 errors, the validation is stopped');
                            }
                            break;
                        case "warning":
                            me.warningCount++;
                            break;
                    }
                    if (me.log[e.type] == me.logIron) {
                        me.push("logIron", e);
                    } else {
                        me.push('log.' + e.type, e);
                    }
                });

                neo.on("lines", function(e) {
                    me.set('numLines', e);
                });

                neo.on("progress", function(e) {
                    me.set('progress', Math.ceil(e));
                });

                neo.init();

            },
            fileChanged: function(neo, old) {
                if (neo && this.validator) {
                    this.validator.init();
                    this.validator.file = neo;
                }
            },
            computeLog: function(validator) {
                if (validator) {
                    return validator.log;
                } else {
                    return [];
                }
            },
            progressChanged: function(neo, old) {
                // console.log("progress : " + neo);
                this.$.progressBar.style.width = neo + '%';
            },
            computeSpin: function(progress) {
                return progress >= 100 || progress <= 0;
            },
            handleLogViewClick: function(e) {
                var me = this;
                var elem = e.currentTarget;
                var line = elem.line - 1;
                this.column = elem.column;
                this.validator._navigator.readLines(line, 1, function linesReadHandler(err, index, lines, eof, progress) {
                    if (err) {
                        return;
                    }

                    if (lines.length > 0) {
                        var aux = lines[0].split("\t");
                        aux[me.column] = '<span style="color:red">' + aux[me.column] + '</span>';
                        me.linePreview = lines[0];
                        me.$.linePreviewPanel.hidden = false;
                    }

                    if (eof) {
                        return;
                    }

                });
            },
            handleCloseLinePreview: function(e) {
                e.stopPropagation();
                this.linePreview = "";
            }
        })
    </script>
</dom-module>
<script>
  /**
  Polymer.IronFormElementBehavior enables a custom element to be included
  in an `iron-form`.

  @demo demo/index.html
  @polymerBehavior
  */
  Polymer.IronFormElementBehavior = {

    properties: {
      /**
       * Fired when the element is added to an `iron-form`.
       *
       * @event iron-form-element-register
       */

      /**
       * Fired when the element is removed from an `iron-form`.
       *
       * @event iron-form-element-unregister
       */

      /**
       * The name of this element.
       */
      name: {
        type: String
      },

      /**
       * The value for this element.
       */
      value: {
        notify: true,
        type: String
      },

      /**
       * Set to true to mark the input as required. If used in a form, a
       * custom element that uses this behavior should also use
       * Polymer.IronValidatableBehavior and define a custom validation method.
       * Otherwise, a `required` element will always be considered valid.
       * It's also strongly recommended to provide a visual style for the element
       * when its value is invalid.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * The form that the element is registered to.
       */
      _parentForm: {
        type: Object
      }
    },

    attached: function() {
      // Note: the iron-form that this element belongs to will set this
      // element's _parentForm property when handling this event.
      this.fire('iron-form-element-register');
    },

    detached: function() {
      if (this._parentForm) {
        this._parentForm.fire('iron-form-element-unregister', {target: this});
      }
    }

  };

</script>
<script>

 /**
 * `iron-range-behavior` provides the behavior for something with a minimum to maximum range.
 *
 * @demo demo/index.html
 * @polymerBehavior
 */
 Polymer.IronRangeBehavior = {

  properties: {

    /**
     * The number that represents the current value.
     */
    value: {
      type: Number,
      value: 0,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * The number that indicates the minimum value of the range.
     */
    min: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * The number that indicates the maximum value of the range.
     */
    max: {
      type: Number,
      value: 100,
      notify: true
    },

    /**
     * Specifies the value granularity of the range's value.
     */
    step: {
      type: Number,
      value: 1,
      notify: true
    },

    /**
     * Returns the ratio of the value.
     */
    ratio: {
      type: Number,
      value: 0,
      readOnly: true,
      notify: true
    },
  },

  observers: [
    '_update(value, min, max, step)'
  ],

  _calcRatio: function(value) {
    return (this._clampValue(value) - this.min) / (this.max - this.min);
  },

  _clampValue: function(value) {
    return Math.min(this.max, Math.max(this.min, this._calcStep(value)));
  },

  _calcStep: function(value) {
    // polymer/issues/2493
    value = parseFloat(value);

    if (!this.step) {
      return value;
    }

    var numSteps = Math.round((value - this.min) / this.step);
    if (this.step < 1) {
     /**
      * For small values of this.step, if we calculate the step using
      * `Math.round(value / step) * step` we may hit a precision point issue
      * eg. 0.1 * 0.2 =  0.020000000000000004
      * http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
      *
      * as a work around we can divide by the reciprocal of `step`
      */
      return numSteps / (1 / this.step) + this.min;
    } else {
      return numSteps * this.step + this.min;
    }
  },

  _validateValue: function() {
    var v = this._clampValue(this.value);
    this.value = this.oldValue = isNaN(v) ? this.oldValue : v;
    return this.value !== v;
  },

  _update: function() {
    this._validateValue();
    this._setRatio(this._calcRatio(this.value) * 100);
  }

};
</script>
<script>

  /**
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronControlState = {

    properties: {

      /**
       * If true, the element currently has focus.
       */
      focused: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        notify: true,
        observer: '_disabledChanged',
        reflectToAttribute: true
      },

      _oldTabIndex: {
        type: Number
      },

      _boundFocusBlurHandler: {
        type: Function,
        value: function() {
          return this._focusBlurHandler.bind(this);
        }
      }

    },

    observers: [
      '_changedControlState(focused, disabled)'
    ],

    ready: function() {
      this.addEventListener('focus', this._boundFocusBlurHandler, true);
      this.addEventListener('blur', this._boundFocusBlurHandler, true);
    },

    _focusBlurHandler: function(event) {
      // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
      // eventually become `this` due to retargeting; if we are not in
      // ShadowDOM land, `event.target` will eventually become `this` due
      // to the second conditional which fires a synthetic event (that is also
      // handled). In either case, we can disregard `event.path`.

      if (event.target === this) {
        this._setFocused(event.type === 'focus');
      } else if (!this.shadowRoot) {
        var target = /** @type {Node} */(Polymer.dom(event).localTarget);
        if (!this.isLightDescendant(target)) {
          this.fire(event.type, {sourceEvent: event}, {
            node: this,
            bubbles: event.bubbles,
            cancelable: event.cancelable
          });
        }
      }
    },

    _disabledChanged: function(disabled, old) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      this.style.pointerEvents = disabled ? 'none' : '';
      if (disabled) {
        this._oldTabIndex = this.tabIndex;
        this._setFocused(false);
        this.tabIndex = -1;
        this.blur();
      } else if (this._oldTabIndex !== undefined) {
        this.tabIndex = this._oldTabIndex;
      }
    },

    _changedControlState: function() {
      // _controlStateChanged is abstract, follow-on behaviors may implement it
      if (this._controlStateChanged) {
        this._controlStateChanged();
      }
    }

  };

</script>
<script>

  /**
   * @demo demo/index.html
   * @polymerBehavior Polymer.IronButtonState
   */
  Polymer.IronButtonStateImpl = {

    properties: {

      /**
       * If true, the user is currently holding down the button.
       */
      pressed: {
        type: Boolean,
        readOnly: true,
        value: false,
        reflectToAttribute: true,
        observer: '_pressedChanged'
      },

      /**
       * If true, the button toggles the active state with each tap or press
       * of the spacebar.
       */
      toggles: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * If true, the button is a toggle and is currently in the active state.
       */
      active: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },

      /**
       * True if the element is currently being pressed by a "pointer," which
       * is loosely defined as mouse or touch input (but specifically excluding
       * keyboard input).
       */
      pointerDown: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      /**
       * True if the input device that caused the element to receive focus
       * was a keyboard.
       */
      receivedFocusFromKeyboard: {
        type: Boolean,
        readOnly: true
      },

      /**
       * The aria attribute to be set if the button is a toggle and in the
       * active state.
       */
      ariaActiveAttribute: {
        type: String,
        value: 'aria-pressed',
        observer: '_ariaActiveAttributeChanged'
      }
    },

    listeners: {
      down: '_downHandler',
      up: '_upHandler',
      tap: '_tapHandler'
    },

    observers: [
      '_detectKeyboardFocus(focused)',
      '_activeChanged(active, ariaActiveAttribute)'
    ],

    keyBindings: {
      'enter:keydown': '_asyncClick',
      'space:keydown': '_spaceKeyDownHandler',
      'space:keyup': '_spaceKeyUpHandler',
    },

    _mouseEventRe: /^mouse/,

    _tapHandler: function() {
      if (this.toggles) {
       // a tap is needed to toggle the active state
        this._userActivate(!this.active);
      } else {
        this.active = false;
      }
    },

    _detectKeyboardFocus: function(focused) {
      this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
    },

    // to emulate native checkbox, (de-)activations from a user interaction fire
    // 'change' events
    _userActivate: function(active) {
      if (this.active !== active) {
        this.active = active;
        this.fire('change');
      }
    },

    _downHandler: function(event) {
      this._setPointerDown(true);
      this._setPressed(true);
      this._setReceivedFocusFromKeyboard(false);
    },

    _upHandler: function() {
      this._setPointerDown(false);
      this._setPressed(false);
    },

    /**
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyDownHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      var target = Polymer.dom(keyboardEvent).localTarget;

      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (this.isLightDescendant(/** @type {Node} */(target)))
        return;

      keyboardEvent.preventDefault();
      keyboardEvent.stopImmediatePropagation();
      this._setPressed(true);
    },

    /**
     * @param {!KeyboardEvent} event .
     */
    _spaceKeyUpHandler: function(event) {
      var keyboardEvent = event.detail.keyboardEvent;
      var target = Polymer.dom(keyboardEvent).localTarget;

      // Ignore the event if this is coming from a focused light child, since that
      // element will deal with it.
      if (this.isLightDescendant(/** @type {Node} */(target)))
        return;

      if (this.pressed) {
        this._asyncClick();
      }
      this._setPressed(false);
    },

    // trigger click asynchronously, the asynchrony is useful to allow one
    // event handler to unwind before triggering another event
    _asyncClick: function() {
      this.async(function() {
        this.click();
      }, 1);
    },

    // any of these changes are considered a change to button state

    _pressedChanged: function(pressed) {
      this._changedButtonState();
    },

    _ariaActiveAttributeChanged: function(value, oldValue) {
      if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
        this.removeAttribute(oldValue);
      }
    },

    _activeChanged: function(active, ariaActiveAttribute) {
      if (this.toggles) {
        this.setAttribute(this.ariaActiveAttribute,
                          active ? 'true' : 'false');
      } else {
        this.removeAttribute(this.ariaActiveAttribute);
      }
      this._changedButtonState();
    },

    _controlStateChanged: function() {
      if (this.disabled) {
        this._setPressed(false);
      } else {
        this._changedButtonState();
      }
    },

    // provide hook for follow-on behaviors to react to button-state

    _changedButtonState: function() {
      if (this._buttonStateChanged) {
        this._buttonStateChanged(); // abstract
      }
    }

  };

  /** @polymerBehavior */
  Polymer.IronButtonState = [
    Polymer.IronA11yKeysBehavior,
    Polymer.IronButtonStateImpl
  ];

</script>


<dom-module id="paper-ripple" assetpath="bower_components/paper-ripple/">

  <template>
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
  </template>
</dom-module>
<script>
  (function() {
    var Utility = {
      distance: function(x1, y1, x2, y2) {
        var xDelta = (x1 - x2);
        var yDelta = (y1 - y2);

        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
      },

      now: window.performance && window.performance.now ?
          window.performance.now.bind(window.performance) : Date.now
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function ElementMetrics(element) {
      this.element = element;
      this.width = this.boundingRect.width;
      this.height = this.boundingRect.height;

      this.size = Math.max(this.width, this.height);
    }

    ElementMetrics.prototype = {
      get boundingRect () {
        return this.element.getBoundingClientRect();
      },

      furthestCornerDistanceFrom: function(x, y) {
        var topLeft = Utility.distance(x, y, 0, 0);
        var topRight = Utility.distance(x, y, this.width, 0);
        var bottomLeft = Utility.distance(x, y, 0, this.height);
        var bottomRight = Utility.distance(x, y, this.width, this.height);

        return Math.max(topLeft, topRight, bottomLeft, bottomRight);
      }
    };

    /**
     * @param {HTMLElement} element
     * @constructor
     */
    function Ripple(element) {
      this.element = element;
      this.color = window.getComputedStyle(element).color;

      this.wave = document.createElement('div');
      this.waveContainer = document.createElement('div');
      this.wave.style.backgroundColor = this.color;
      this.wave.classList.add('wave');
      this.waveContainer.classList.add('wave-container');
      Polymer.dom(this.waveContainer).appendChild(this.wave);

      this.resetInteractionState();
    }

    Ripple.MAX_RADIUS = 300;

    Ripple.prototype = {
      get recenters() {
        return this.element.recenters;
      },

      get center() {
        return this.element.center;
      },

      get mouseDownElapsed() {
        var elapsed;

        if (!this.mouseDownStart) {
          return 0;
        }

        elapsed = Utility.now() - this.mouseDownStart;

        if (this.mouseUpStart) {
          elapsed -= this.mouseUpElapsed;
        }

        return elapsed;
      },

      get mouseUpElapsed() {
        return this.mouseUpStart ?
          Utility.now () - this.mouseUpStart : 0;
      },

      get mouseDownElapsedSeconds() {
        return this.mouseDownElapsed / 1000;
      },

      get mouseUpElapsedSeconds() {
        return this.mouseUpElapsed / 1000;
      },

      get mouseInteractionSeconds() {
        return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
      },

      get initialOpacity() {
        return this.element.initialOpacity;
      },

      get opacityDecayVelocity() {
        return this.element.opacityDecayVelocity;
      },

      get radius() {
        var width2 = this.containerMetrics.width * this.containerMetrics.width;
        var height2 = this.containerMetrics.height * this.containerMetrics.height;
        var waveRadius = Math.min(
          Math.sqrt(width2 + height2),
          Ripple.MAX_RADIUS
        ) * 1.1 + 5;

        var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
        var timeNow = this.mouseInteractionSeconds / duration;
        var size = waveRadius * (1 - Math.pow(80, -timeNow));

        return Math.abs(size);
      },

      get opacity() {
        if (!this.mouseUpStart) {
          return this.initialOpacity;
        }

        return Math.max(
          0,
          this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
        );
      },

      get outerOpacity() {
        // Linear increase in background opacity, capped at the opacity
        // of the wavefront (waveOpacity).
        var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
        var waveOpacity = this.opacity;

        return Math.max(
          0,
          Math.min(outerOpacity, waveOpacity)
        );
      },

      get isOpacityFullyDecayed() {
        return this.opacity < 0.01 &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isRestingAtMaxRadius() {
        return this.opacity >= this.initialOpacity &&
          this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
      },

      get isAnimationComplete() {
        return this.mouseUpStart ?
          this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
      },

      get translationFraction() {
        return Math.min(
          1,
          this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
        );
      },

      get xNow() {
        if (this.xEnd) {
          return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
        }

        return this.xStart;
      },

      get yNow() {
        if (this.yEnd) {
          return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
        }

        return this.yStart;
      },

      get isMouseDown() {
        return this.mouseDownStart && !this.mouseUpStart;
      },

      resetInteractionState: function() {
        this.maxRadius = 0;
        this.mouseDownStart = 0;
        this.mouseUpStart = 0;

        this.xStart = 0;
        this.yStart = 0;
        this.xEnd = 0;
        this.yEnd = 0;
        this.slideDistance = 0;

        this.containerMetrics = new ElementMetrics(this.element);
      },

      draw: function() {
        var scale;
        var translateString;
        var dx;
        var dy;

        this.wave.style.opacity = this.opacity;

        scale = this.radius / (this.containerMetrics.size / 2);
        dx = this.xNow - (this.containerMetrics.width / 2);
        dy = this.yNow - (this.containerMetrics.height / 2);


        // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
        // https://bugs.webkit.org/show_bug.cgi?id=98538
        this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
        this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
        this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
        this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
      },

      /** @param {Event=} event */
      downAction: function(event) {
        var xCenter = this.containerMetrics.width / 2;
        var yCenter = this.containerMetrics.height / 2;

        this.resetInteractionState();
        this.mouseDownStart = Utility.now();

        if (this.center) {
          this.xStart = xCenter;
          this.yStart = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        } else {
          this.xStart = event ?
              event.detail.x - this.containerMetrics.boundingRect.left :
              this.containerMetrics.width / 2;
          this.yStart = event ?
              event.detail.y - this.containerMetrics.boundingRect.top :
              this.containerMetrics.height / 2;
        }

        if (this.recenters) {
          this.xEnd = xCenter;
          this.yEnd = yCenter;
          this.slideDistance = Utility.distance(
            this.xStart, this.yStart, this.xEnd, this.yEnd
          );
        }

        this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
          this.xStart,
          this.yStart
        );

        this.waveContainer.style.top =
          (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
        this.waveContainer.style.left =
          (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

        this.waveContainer.style.width = this.containerMetrics.size + 'px';
        this.waveContainer.style.height = this.containerMetrics.size + 'px';
      },

      /** @param {Event=} event */
      upAction: function(event) {
        if (!this.isMouseDown) {
          return;
        }

        this.mouseUpStart = Utility.now();
      },

      remove: function() {
        Polymer.dom(this.waveContainer.parentNode).removeChild(
          this.waveContainer
        );
      }
    };

    Polymer({
      is: 'paper-ripple',

      behaviors: [
        Polymer.IronA11yKeysBehavior
      ],

      properties: {
        /**
         * The initial opacity set on the wave.
         *
         * @attribute initialOpacity
         * @type number
         * @default 0.25
         */
        initialOpacity: {
          type: Number,
          value: 0.25
        },

        /**
         * How fast (opacity per second) the wave fades out.
         *
         * @attribute opacityDecayVelocity
         * @type number
         * @default 0.8
         */
        opacityDecayVelocity: {
          type: Number,
          value: 0.8
        },

        /**
         * If true, ripples will exhibit a gravitational pull towards
         * the center of their container as they fade away.
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        recenters: {
          type: Boolean,
          value: false
        },

        /**
         * If true, ripples will center inside its container
         *
         * @attribute recenters
         * @type boolean
         * @default false
         */
        center: {
          type: Boolean,
          value: false
        },

        /**
         * A list of the visual ripples.
         *
         * @attribute ripples
         * @type Array
         * @default []
         */
        ripples: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /**
         * True when there are visible ripples animating within the
         * element.
         */
        animating: {
          type: Boolean,
          readOnly: true,
          reflectToAttribute: true,
          value: false
        },

        /**
         * If true, the ripple will remain in the "down" state until `holdDown`
         * is set to false again.
         */
        holdDown: {
          type: Boolean,
          value: false,
          observer: '_holdDownChanged'
        },

        /**
         * If true, the ripple will not generate a ripple effect
         * via pointer interaction.
         * Calling ripple's imperative api like `simulatedRipple` will
         * still generate the ripple effect.
         */
        noink: {
          type: Boolean,
          value: false
        },

        _animating: {
          type: Boolean
        },

        _boundAnimate: {
          type: Function,
          value: function() {
            return this.animate.bind(this);
          }
        }
      },

      get target () {
        return this.keyEventTarget;
      },

      keyBindings: {
        'enter:keydown': '_onEnterKeydown',
        'space:keydown': '_onSpaceKeydown',
        'space:keyup': '_onSpaceKeyup'
      },

      attached: function() {
        // Set up a11yKeysBehavior to listen to key events on the target,
        // so that space and enter activate the ripple even if the target doesn't
        // handle key events. The key handlers deal with `noink` themselves.
        if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
          this.keyEventTarget = Polymer.dom(this).getOwnerRoot().host;
        } else {
          this.keyEventTarget = this.parentNode;
        }
        var keyEventTarget = /** @type {!EventTarget} */ (this.keyEventTarget);
        this.listen(keyEventTarget, 'up', 'uiUpAction');
        this.listen(keyEventTarget, 'down', 'uiDownAction');
      },

      detached: function() {
        this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
        this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
        this.keyEventTarget = null;
      },

      get shouldKeepAnimating () {
        for (var index = 0; index < this.ripples.length; ++index) {
          if (!this.ripples[index].isAnimationComplete) {
            return true;
          }
        }

        return false;
      },

      simulatedRipple: function() {
        this.downAction(null);

        // Please see polymer/polymer#1305
        this.async(function() {
          this.upAction();
        }, 1);
      },

      /**
       * Provokes a ripple down effect via a UI event,
       * respecting the `noink` property.
       * @param {Event=} event
       */
      uiDownAction: function(event) {
        if (!this.noink) {
          this.downAction(event);
        }
      },

      /**
       * Provokes a ripple down effect via a UI event,
       * *not* respecting the `noink` property.
       * @param {Event=} event
       */
      downAction: function(event) {
        if (this.holdDown && this.ripples.length > 0) {
          return;
        }

        var ripple = this.addRipple();

        ripple.downAction(event);

        if (!this._animating) {
          this._animating = true;
          this.animate();
        }
      },

      /**
       * Provokes a ripple up effect via a UI event,
       * respecting the `noink` property.
       * @param {Event=} event
       */
      uiUpAction: function(event) {
        if (!this.noink) {
          this.upAction(event);
        }
      },

      /**
       * Provokes a ripple up effect via a UI event,
       * *not* respecting the `noink` property.
       * @param {Event=} event
       */
      upAction: function(event) {
        if (this.holdDown) {
          return;
        }

        this.ripples.forEach(function(ripple) {
          ripple.upAction(event);
        });

        this._animating = true;
        this.animate();
      },

      onAnimationComplete: function() {
        this._animating = false;
        this.$.background.style.backgroundColor = null;
        this.fire('transitionend');
      },

      addRipple: function() {
        var ripple = new Ripple(this);

        Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
        this.$.background.style.backgroundColor = ripple.color;
        this.ripples.push(ripple);

        this._setAnimating(true);

        return ripple;
      },

      removeRipple: function(ripple) {
        var rippleIndex = this.ripples.indexOf(ripple);

        if (rippleIndex < 0) {
          return;
        }

        this.ripples.splice(rippleIndex, 1);

        ripple.remove();

        if (!this.ripples.length) {
          this._setAnimating(false);
        }
      },

      /**
       * This conflicts with Element#antimate().
       * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
       * @suppress {checkTypes}
       */
      animate: function() {
        if (!this._animating) {
          return;
        }
        var index;
        var ripple;

        for (index = 0; index < this.ripples.length; ++index) {
          ripple = this.ripples[index];

          ripple.draw();

          this.$.background.style.opacity = ripple.outerOpacity;

          if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
            this.removeRipple(ripple);
          }
        }

        if (!this.shouldKeepAnimating && this.ripples.length === 0) {
          this.onAnimationComplete();
        } else {
          window.requestAnimationFrame(this._boundAnimate);
        }
      },

      _onEnterKeydown: function() {
        this.uiDownAction();
        this.async(this.uiUpAction, 1);
      },

      _onSpaceKeydown: function() {
        this.uiDownAction();
      },

      _onSpaceKeyup: function() {
        this.uiUpAction();
      },

      // note: holdDown does not respect noink since it can be a focus based
      // effect.
      _holdDownChanged: function(newVal, oldVal) {
        if (oldVal === undefined) {
          return;
        }
        if (newVal) {
          this.downAction();
        } else {
          this.upAction();
        }
      }

      /**
      Fired when the animation finishes.
      This is useful if you want to wait until
      the ripple animation finishes to perform some action.

      @event transitionend
      @param {{node: Object}} detail Contains the animated node.
      */
    });
  })();
</script>
<script>
  /**
   * `Polymer.PaperRippleBehavior` dynamically implements a ripple
   * when the element has focus via pointer or keyboard.
   *
   * NOTE: This behavior is intended to be used in conjunction with and after
   * `Polymer.IronButtonState` and `Polymer.IronControlState`.
   *
   * @polymerBehavior Polymer.PaperRippleBehavior
   */
  Polymer.PaperRippleBehavior = {
    properties: {
      /**
       * If true, the element will not produce a ripple effect when interacted
       * with via the pointer.
       */
      noink: {
        type: Boolean,
        observer: '_noinkChanged'
      },

      /**
       * @type {Element|undefined}
       */
      _rippleContainer: {
        type: Object,
      }
    },

    /**
     * Ensures a `<paper-ripple>` element is available when the element is
     * focused.
     */
    _buttonStateChanged: function() {
      if (this.focused) {
        this.ensureRipple();
      }
    },

    /**
     * In addition to the functionality provided in `IronButtonState`, ensures
     * a ripple effect is created when the element is in a `pressed` state.
     */
    _downHandler: function(event) {
      Polymer.IronButtonStateImpl._downHandler.call(this, event);
      if (this.pressed) {
        this.ensureRipple(event);
      }
    },

    /**
     * Ensures this element contains a ripple effect. For startup efficiency
     * the ripple effect is dynamically on demand when needed.
     * @param {!Event=} optTriggeringEvent (optional) event that triggered the
     * ripple.
     */
    ensureRipple: function(optTriggeringEvent) {
      if (!this.hasRipple()) {
        this._ripple = this._createRipple();
        this._ripple.noink = this.noink;
        var rippleContainer = this._rippleContainer || this.root;
        if (rippleContainer) {
          Polymer.dom(rippleContainer).appendChild(this._ripple);
        }
        if (optTriggeringEvent) {
          // Check if the event happened inside of the ripple container
          // Fall back to host instead of the root because distributed text
          // nodes are not valid event targets
          var domContainer = Polymer.dom(this._rippleContainer || this);
          var target = Polymer.dom(optTriggeringEvent).rootTarget;
          if (domContainer.deepContains( /** @type {Node} */(target))) {
            this._ripple.uiDownAction(optTriggeringEvent);
          }
        }
      }
    },

    /**
     * Returns the `<paper-ripple>` element used by this element to create
     * ripple effects. The element's ripple is created on demand, when
     * necessary, and calling this method will force the
     * ripple to be created.
     */
    getRipple: function() {
      this.ensureRipple();
      return this._ripple;
    },

    /**
     * Returns true if this element currently contains a ripple effect.
     * @return {boolean}
     */
    hasRipple: function() {
      return Boolean(this._ripple);
    },

    /**
     * Create the element's ripple effect via creating a `<paper-ripple>`.
     * Override this method to customize the ripple element.
     * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
     */
    _createRipple: function() {
      return /** @type {!PaperRippleElement} */ (
          document.createElement('paper-ripple'));
    },

    _noinkChanged: function(noink) {
      if (this.hasRipple()) {
        this._ripple.noink = noink;
      }
    }
  };
</script>
<script>
  /**
   * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
   *
   * @polymerBehavior Polymer.PaperInkyFocusBehavior
   */
  Polymer.PaperInkyFocusBehaviorImpl = {
    observers: [
      '_focusedChanged(receivedFocusFromKeyboard)'
    ],

    _focusedChanged: function(receivedFocusFromKeyboard) {
      if (receivedFocusFromKeyboard) {
        this.ensureRipple();
      }
      if (this.hasRipple()) {
        this._ripple.holdDown = receivedFocusFromKeyboard;
      }
    },

    _createRipple: function() {
      var ripple = Polymer.PaperRippleBehavior._createRipple();
      ripple.id = 'ink';
      ripple.setAttribute('center', '');
      ripple.classList.add('circle');
      return ripple;
    }
  };

  /** @polymerBehavior Polymer.PaperInkyFocusBehavior */
  Polymer.PaperInkyFocusBehavior = [
    Polymer.IronButtonState,
    Polymer.IronControlState,
    Polymer.PaperRippleBehavior,
    Polymer.PaperInkyFocusBehaviorImpl
  ];
</script>


<dom-module id="iron-a11y-announcer" assetpath="bower_components/iron-a11y-announcer/">
  <template>
    <style>
      :host {
        display: inline-block;
        position: fixed;
        clip: rect(0px,0px,0px,0px);
      }
    </style>
    <div aria-live$="[[mode]]">[[_text]]</div>
  </template>

  <script>

    (function() {
      'use strict';

      Polymer.IronA11yAnnouncer = Polymer({
        is: 'iron-a11y-announcer',

        properties: {

          /**
           * The value of mode is used to set the `aria-live` attribute
           * for the element that will be announced. Valid values are: `off`,
           * `polite` and `assertive`.
           */
          mode: {
            type: String,
            value: 'polite'
          },

          _text: {
            type: String,
            value: ''
          }
        },

        created: function() {
          if (!Polymer.IronA11yAnnouncer.instance) {
            Polymer.IronA11yAnnouncer.instance = this;
          }

          document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
        },

        /**
         * Cause a text string to be announced by screen readers.
         *
         * @param {string} text The text that should be announced.
         */
        announce: function(text) {
          this._text = '';
          this.async(function() {
            this._text = text;
          }, 100);
        },

        _onIronAnnounce: function(event) {
          if (event.detail && event.detail.text) {
            this.announce(event.detail.text);
          }
        }
      });

      Polymer.IronA11yAnnouncer.instance = null;

      Polymer.IronA11yAnnouncer.requestAvailability = function() {
        if (!Polymer.IronA11yAnnouncer.instance) {
          Polymer.IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
        }

        document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
      };
    })();

  </script>
</dom-module>


<script>

  (function() {

    // monostate data
    var metaDatas = {};
    var metaArrays = {};
    var singleton = null;

    Polymer.IronMeta = Polymer({

      is: 'iron-meta',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * The key used to store `value` under the `type` namespace.
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         */
        value: {
          type: Object,
          notify: true,
          observer: '_valueChanged'
        },

        /**
         * If true, `value` is set to the iron-meta instance itself.
         */
         self: {
          type: Boolean,
          observer: '_selfChanged'
        },

        /**
         * Array of all meta-data values for the given type.
         */
        list: {
          type: Array,
          notify: true
        }

      },

      hostAttributes: {
        hidden: true
      },

      /**
       * Only runs if someone invokes the factory/constructor directly
       * e.g. `new Polymer.IronMeta()`
       *
       * @param {{type: (string|undefined), key: (string|undefined), value}=} config
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
              case 'value':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key, old) {
        this._resetRegistration(old);
      },

      _valueChanged: function(value) {
        this._resetRegistration(this.key);
      },

      _selfChanged: function(self) {
        if (self) {
          this.value = this;
        }
      },

      _typeChanged: function(type) {
        this._unregisterKey(this.key);
        if (!metaDatas[type]) {
          metaDatas[type] = {};
        }
        this._metaData = metaDatas[type];
        if (!metaArrays[type]) {
          metaArrays[type] = [];
        }
        this.list = metaArrays[type];
        this._registerKeyValue(this.key, this.value);
      },

      /**
       * Retrieves meta data value by key.
       *
       * @method byKey
       * @param {string} key The key of the meta-data to be returned.
       * @return {*}
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      },

      _resetRegistration: function(oldKey) {
        this._unregisterKey(oldKey);
        this._registerKeyValue(this.key, this.value);
      },

      _unregisterKey: function(key) {
        this._unregister(key, this._metaData, this.list);
      },

      _registerKeyValue: function(key, value) {
        this._register(key, value, this._metaData, this.list);
      },

      _register: function(key, value, data, list) {
        if (key && data && value !== undefined) {
          data[key] = value;
          list.push(value);
        }
      },

      _unregister: function(key, data, list) {
        if (key && data) {
          if (key in data) {
            var value = data[key];
            delete data[key];
            this.arrayDelete(list, value);
          }
        }
      }

    });

    Polymer.IronMeta.getIronMeta = function getIronMeta() {
       if (singleton === null) {
         singleton = new Polymer.IronMeta();
       }
       return singleton;
     };

    /**
    `iron-meta-query` can be used to access infomation stored in `iron-meta`.

    Examples:

    If I create an instance like this:

        <iron-meta key="info" value="foo/bar"></iron-meta>

    Note that value="foo/bar" is the metadata I've defined. I could define more
    attributes or use child nodes to define additional metadata.

    Now I can access that element (and it's metadata) from any `iron-meta-query` instance:

         var value = new Polymer.IronMetaQuery({key: 'info'}).value;

    @group Polymer Iron Elements
    @element iron-meta-query
    */
    Polymer.IronMetaQuery = Polymer({

      is: 'iron-meta-query',

      properties: {

        /**
         * The type of meta-data.  All meta-data of the same type is stored
         * together.
         */
        type: {
          type: String,
          value: 'default',
          observer: '_typeChanged'
        },

        /**
         * Specifies a key to use for retrieving `value` from the `type`
         * namespace.
         */
        key: {
          type: String,
          observer: '_keyChanged'
        },

        /**
         * The meta-data to store or retrieve.
         */
        value: {
          type: Object,
          notify: true,
          readOnly: true
        },

        /**
         * Array of all meta-data values for the given type.
         */
        list: {
          type: Array,
          notify: true
        }

      },

      /**
       * Actually a factory method, not a true constructor. Only runs if
       * someone invokes it directly (via `new Polymer.IronMeta()`);
       *
       * @param {{type: (string|undefined), key: (string|undefined)}=} config
       */
      factoryImpl: function(config) {
        if (config) {
          for (var n in config) {
            switch(n) {
              case 'type':
              case 'key':
                this[n] = config[n];
                break;
            }
          }
        }
      },

      created: function() {
        // TODO(sjmiles): good for debugging?
        this._metaDatas = metaDatas;
        this._metaArrays = metaArrays;
      },

      _keyChanged: function(key) {
        this._setValue(this._metaData && this._metaData[key]);
      },

      _typeChanged: function(type) {
        this._metaData = metaDatas[type];
        this.list = metaArrays[type];
        if (this.key) {
          this._keyChanged(this.key);
        }
      },

      /**
       * Retrieves meta data value by key.
       * @param {string} key The key of the meta-data to be returned.
       * @return {*}
       */
      byKey: function(key) {
        return this._metaData && this._metaData[key];
      }

    });

  })();
</script>
<script>
  /**
   * Singleton IronMeta instance.
   */
  Polymer.IronValidatableBehaviorMeta = null;

  /**
   * `Use Polymer.IronValidatableBehavior` to implement an element that validates user input.
   * Use the related `Polymer.IronValidatorBehavior` to add custom validation logic to an iron-input.
   *
   * By default, an `<iron-form>` element validates its fields when the user presses the submit button.
   * To validate a form imperatively, call the form's `validate()` method, which in turn will
   * call `validate()` on all its children. By using `Polymer.IronValidatableBehavior`, your
   * custom element will get a public `validate()`, which
   * will return the validity of the element, and a corresponding `invalid` attribute,
   * which can be used for styling.
   *
   * To implement the custom validation logic of your element, you must override
   * the protected `_getValidity()` method of this behaviour, rather than `validate()`.
   * See [this](https://github.com/PolymerElements/iron-form/blob/master/demo/simple-element.html)
   * for an example.
   *
   * ### Accessibility
   *
   * Changing the `invalid` property, either manually or by calling `validate()` will update the
   * `aria-invalid` attribute.
   *
   * @demo demo/index.html
   * @polymerBehavior
   */
  Polymer.IronValidatableBehavior = {

    properties: {

      /**
       * Name of the validator to use.
       */
      validator: {
        type: String
      },

      /**
       * True if the last call to `validate` is invalid.
       */
      invalid: {
        notify: true,
        reflectToAttribute: true,
        type: Boolean,
        value: false
      },

      /**
       * This property is deprecated and should not be used. Use the global
       * validator meta singleton, `Polymer.IronValidatableBehaviorMeta` instead.
       */
      _validatorMeta: {
        type: Object
      },

      /**
       * Namespace for this validator. This property is deprecated and should
       * not be used. For all intents and purposes, please consider it a
       * read-only, config-time property.
       */
      validatorType: {
        type: String,
        value: 'validator'
      },

      _validator: {
        type: Object,
        computed: '__computeValidator(validator)'
      }
    },

    observers: [
      '_invalidChanged(invalid)'
    ],

    registered: function() {
      Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({type: 'validator'});
    },

    _invalidChanged: function() {
      if (this.invalid) {
        this.setAttribute('aria-invalid', 'true');
      } else {
        this.removeAttribute('aria-invalid');
      }
    },

    /**
     * @return {boolean} True if the validator `validator` exists.
     */
    hasValidator: function() {
      return this._validator != null;
    },

    /**
     * Returns true if the `value` is valid, and updates `invalid`. If you want
     * your element to have custom validation logic, do not override this method;
     * override `_getValidity(value)` instead.

     * @param {Object} value The value to be validated. By default, it is passed
     * to the validator's `validate()` function, if a validator is set.
     * @return {boolean} True if `value` is valid.
     */
    validate: function(value) {
      this.invalid = !this._getValidity(value);
      return !this.invalid;
    },

    /**
     * Returns true if `value` is valid.  By default, it is passed
     * to the validator's `validate()` function, if a validator is set. You
     * should override this method if you want to implement custom validity
     * logic for your element.
     *
     * @param {Object} value The value to be validated.
     * @return {boolean} True if `value` is valid.
     */

    _getValidity: function(value) {
      if (this.hasValidator()) {
        return this._validator.validate(value);
      }
      return true;
    },

    __computeValidator: function() {
      return Polymer.IronValidatableBehaviorMeta &&
          Polymer.IronValidatableBehaviorMeta.byKey(this.validator);
    }
  };

</script>
<script>

/*
`<iron-input>` adds two-way binding and custom validators using `Polymer.IronValidatorBehavior`
to `<input>`.

### Two-way binding

By default you can only get notified of changes to an `input`'s `value` due to user input:

    <input value="{{myValue::input}}">

`iron-input` adds the `bind-value` property that mirrors the `value` property, and can be used
for two-way data binding. `bind-value` will notify if it is changed either by user input or by script.

    <input is="iron-input" bind-value="{{myValue}}">

### Custom validators

You can use custom validators that implement `Polymer.IronValidatorBehavior` with `<iron-input>`.

    <input is="iron-input" validator="my-custom-validator">

### Stopping invalid input

It may be desirable to only allow users to enter certain characters. You can use the
`prevent-invalid-input` and `allowed-pattern` attributes together to accomplish this. This feature
is separate from validation, and `allowed-pattern` does not affect how the input is validated.

    <!-- only allow characters that match [0-9] -->
    <input is="iron-input" prevent-invalid-input allowed-pattern="[0-9]">

@hero hero.svg
@demo demo/index.html
*/

  Polymer({

    is: 'iron-input',

    extends: 'input',

    behaviors: [
      Polymer.IronValidatableBehavior
    ],

    properties: {

      /**
       * Use this property instead of `value` for two-way data binding.
       */
      bindValue: {
        observer: '_bindValueChanged',
        type: String
      },

      /**
       * Set to true to prevent the user from entering invalid input. If `allowedPattern` is set,
       * any character typed by the user will be matched against that pattern, and rejected if it's not a match.
       * Pasted input will have each character checked individually; if any character
       * doesn't match `allowedPattern`, the entire pasted string will be rejected.
       * If `allowedPattern` is not set, it will use the `type` attribute (only supported for `type=number`).
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Regular expression that list the characters allowed as input.
       * This pattern represents the allowed characters for the field; as the user inputs text,
       * each individual character will be checked against the pattern (rather than checking
       * the entire value as a whole). The recommended format should be a list of allowed characters;
       * for example, `[a-zA-Z0-9.+-!;:]`
       */
      allowedPattern: {
        type: String,
        observer: "_allowedPatternChanged"
      },

      _previousValidInput: {
        type: String,
        value: ''
      },

      _patternAlreadyChecked: {
        type: Boolean,
        value: false
      }

    },

    listeners: {
      'input': '_onInput',
      'keypress': '_onKeypress'
    },

    /** @suppress {checkTypes} */
    registered: function() {
      // Feature detect whether we need to patch dispatchEvent (i.e. on FF and IE).
      if (!this._canDispatchEventOnDisabled()) {
        this._origDispatchEvent = this.dispatchEvent;
        this.dispatchEvent = this._dispatchEventFirefoxIE;
      }
    },

    created: function() {
      Polymer.IronA11yAnnouncer.requestAvailability();
    },

    _canDispatchEventOnDisabled: function() {
      var input = document.createElement('input');
      var canDispatch = false;
      input.disabled = true;

      input.addEventListener('feature-check-dispatch-event', function() {
        canDispatch = true;
      });

      try {
        input.dispatchEvent(new Event('feature-check-dispatch-event'));
      } catch(e) {}

      return canDispatch;
    },

    _dispatchEventFirefoxIE: function() {
      // Due to Firefox bug, events fired on disabled form controls can throw
      // errors; furthermore, neither IE nor Firefox will actually dispatch
      // events from disabled form controls; as such, we toggle disable around
      // the dispatch to allow notifying properties to notify
      // See issue #47 for details
      var disabled = this.disabled;
      this.disabled = false;
      this._origDispatchEvent.apply(this, arguments);
      this.disabled = disabled;
    },

    get _patternRegExp() {
      var pattern;
      if (this.allowedPattern) {
        pattern = new RegExp(this.allowedPattern);
      } else {
        switch (this.type) {
          case 'number':
            pattern = /[0-9.,e-]/;
            break;
        }
      }
      return pattern;
    },

    ready: function() {
      this.bindValue = this.value;
    },

    /**
     * @suppress {checkTypes}
     */
    _bindValueChanged: function() {
      if (this.value !== this.bindValue) {
        this.value = !(this.bindValue || this.bindValue === 0 || this.bindValue === false) ? '' : this.bindValue;
      }
      // manually notify because we don't want to notify until after setting value
      this.fire('bind-value-changed', {value: this.bindValue});
    },

    _allowedPatternChanged: function() {
      // Force to prevent invalid input when an `allowed-pattern` is set
      this.preventInvalidInput = this.allowedPattern ? true : false;
    },

    _onInput: function() {
      // Need to validate each of the characters pasted if they haven't
      // been validated inside `_onKeypress` already.
      if (this.preventInvalidInput && !this._patternAlreadyChecked) {
        var valid = this._checkPatternValidity();
        if (!valid) {
          this._announceInvalidCharacter('Invalid string of characters not entered.');
          this.value = this._previousValidInput;
        }
      }

      this.bindValue = this.value;
      this._previousValidInput = this.value;
      this._patternAlreadyChecked = false;
    },

    _isPrintable: function(event) {
      // What a control/printable character is varies wildly based on the browser.
      // - most control characters (arrows, backspace) do not send a `keypress` event
      //   in Chrome, but the *do* on Firefox
      // - in Firefox, when they do send a `keypress` event, control chars have
      //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
      // - printable characters always send a keypress event.
      // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
      //   always matches the charCode.
      // None of this makes any sense.

      // For these keys, ASCII code == browser keycode.
      var anyNonPrintable =
        (event.keyCode == 8)   ||  // backspace
        (event.keyCode == 9)   ||  // tab
        (event.keyCode == 13)  ||  // enter
        (event.keyCode == 27);     // escape

      // For these keys, make sure it's a browser keycode and not an ASCII code.
      var mozNonPrintable =
        (event.keyCode == 19)  ||  // pause
        (event.keyCode == 20)  ||  // caps lock
        (event.keyCode == 45)  ||  // insert
        (event.keyCode == 46)  ||  // delete
        (event.keyCode == 144) ||  // num lock
        (event.keyCode == 145) ||  // scroll lock
        (event.keyCode > 32 && event.keyCode < 41)   || // page up/down, end, home, arrows
        (event.keyCode > 111 && event.keyCode < 124); // fn keys

      return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
    },

    _onKeypress: function(event) {
      if (!this.preventInvalidInput && this.type !== 'number') {
        return;
      }
      var regexp = this._patternRegExp;
      if (!regexp) {
        return;
      }

      // Handle special keys and backspace
      if (event.metaKey || event.ctrlKey || event.altKey)
        return;

      // Check the pattern either here or in `_onInput`, but not in both.
      this._patternAlreadyChecked = true;

      var thisChar = String.fromCharCode(event.charCode);
      if (this._isPrintable(event) && !regexp.test(thisChar)) {
        event.preventDefault();
        this._announceInvalidCharacter('Invalid character ' + thisChar + ' not entered.');
      }
    },

    _checkPatternValidity: function() {
      var regexp = this._patternRegExp;
      if (!regexp) {
        return true;
      }
      for (var i = 0; i < this.value.length; i++) {
        if (!regexp.test(this.value[i])) {
          return false;
        }
      }
      return true;
    },

    /**
     * Returns true if `value` is valid. The validator provided in `validator` will be used first,
     * then any constraints.
     * @return {boolean} True if the value is valid.
     */
    validate: function() {
      // First, check what the browser thinks. Some inputs (like type=number)
      // behave weirdly and will set the value to "" if something invalid is
      // entered, but will set the validity correctly.
      var valid =  this.checkValidity();

      // Only do extra checking if the browser thought this was valid.
      if (valid) {
        // Empty, required input is invalid
        if (this.required && this.value === '') {
          valid = false;
        } else if (this.hasValidator()) {
          valid = Polymer.IronValidatableBehavior.validate.call(this, this.value);
        }
      }

      this.invalid = !valid;
      this.fire('iron-input-validate');
      return valid;
    },

    _announceInvalidCharacter: function(message) {
      this.fire('iron-announce', { text: message });
    }
  });

  /*
  The `iron-input-validate` event is fired whenever `validate()` is called.
  @event iron-input-validate
  */

</script>
<script>

  // Generate unique, monotonically increasing IDs for labels (needed by
  // aria-labelledby) and add-ons.
  Polymer.PaperInputHelper = {};
  Polymer.PaperInputHelper.NextLabelID = 1;
  Polymer.PaperInputHelper.NextAddonID = 1;

  /**
   * Use `Polymer.PaperInputBehavior` to implement inputs with `<paper-input-container>`. This
   * behavior is implemented by `<paper-input>`. It exposes a number of properties from
   * `<paper-input-container>` and `<input is="iron-input">` and they should be bound in your
   * template.
   *
   * The input element can be accessed by the `inputElement` property if you need to access
   * properties or methods that are not exposed.
   * @polymerBehavior Polymer.PaperInputBehavior
   */
  Polymer.PaperInputBehaviorImpl = {

    properties: {
      /**
       * Fired when the input changes due to user interaction.
       *
       * @event change
       */

      /**
       * The label for this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * `<label>`'s content and `hidden` property, e.g.
       * `<label hidden$="[[!label]]">[[label]]</label>` in your `template`
       */
      label: {
        type: String
      },

      /**
       * The value for this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `bindValue`
       * property, or the value property of your input that is `notify:true`.
       */
      value: {
        notify: true,
        type: String
      },

      /**
       * Set to true to disable this input. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * both the `<paper-input-container>`'s and the input's `disabled` property.
       */
      disabled: {
        type: Boolean,
        value: false
      },

      /**
       * Returns true if the value is invalid. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to both the
       * `<paper-input-container>`'s and the input's `invalid` property.
       *
       * If `autoValidate` is true, the `invalid` attribute is managed automatically,
       * which can clobber attempts to manage it manually.
       */
      invalid: {
        type: Boolean,
        value: false,
        notify: true
      },

      /**
       * Set to true to prevent the user from entering invalid input. If you're
       * using PaperInputBehavior to  implement your own paper-input-like element,
       * bind this to `<input is="iron-input">`'s `preventInvalidInput` property.
       */
      preventInvalidInput: {
        type: Boolean
      },

      /**
       * Set this to specify the pattern allowed by `preventInvalidInput`. If
       * you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `allowedPattern`
       * property.
       */
      allowedPattern: {
        type: String
      },

      /**
       * The type of the input. The supported types are `text`, `number` and `password`.
       * If you're using PaperInputBehavior to implement your own paper-input-like element,
       * bind this to the `<input is="iron-input">`'s `type` property.
       */
      type: {
        type: String
      },

      /**
       * The datalist of the input (if any). This should match the id of an existing `<datalist>`.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `list` property.
       */
      list: {
        type: String
      },

      /**
       * A pattern to validate the `input` with. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `pattern` property.
       */
      pattern: {
        type: String
      },

      /**
       * Set to true to mark the input as required. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `required` property.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * The error message to display when the input is invalid. If you're using
       * PaperInputBehavior to implement your own paper-input-like element,
       * bind this to the `<paper-input-error>`'s content, if using.
       */
      errorMessage: {
        type: String
      },

      /**
       * Set to true to show a character counter.
       */
      charCounter: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable the floating label. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `noLabelFloat` property.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the label. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `alwaysFloatLabel` property.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to auto-validate the input value. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<paper-input-container>`'s `autoValidate` property.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * Name of the validator to use. If you're using PaperInputBehavior to
       * implement your own paper-input-like element, bind this to
       * the `<input is="iron-input">`'s `validator` property.
       */
      validator: {
        type: String
      },

      // HTMLInputElement attributes for binding if needed

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocomplete` property.
       */
      autocomplete: {
        type: String,
        value: 'off'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autofocus` property.
       */
      autofocus: {
        type: Boolean,
        observer: '_autofocusChanged'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `inputmode` property.
       */
      inputmode: {
        type: String
      },

      /**
       * The minimum length of the input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `minlength` property.
       */
      minlength: {
        type: Number
      },

      /**
       * The maximum length of the input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `maxlength` property.
       */
      maxlength: {
        type: Number
      },

      /**
       * The minimum (numeric or date-time) input value.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `min` property.
       */
      min: {
        type: String
      },

      /**
       * The maximum (numeric or date-time) input value.
       * Can be a String (e.g. `"2000-01-01"`) or a Number (e.g. `2`).
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `max` property.
       */
      max: {
        type: String
      },

      /**
       * Limits the numeric or date-time increments.
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `step` property.
       */
      step: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `name` property.
       */
      name: {
        type: String
      },

      /**
       * A placeholder string in addition to the label. If this is set, the label will always float.
       */
      placeholder: {
        type: String,
        // need to set a default so _computeAlwaysFloatLabel is run
        value: ''
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `readonly` property.
       */
      readonly: {
        type: Boolean,
        value: false
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `size` property.
       */
      size: {
        type: Number
      },

      // Nonstandard attributes for binding if needed

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocapitalize` property.
       */
      autocapitalize: {
        type: String,
        value: 'none'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autocorrect` property.
       */
      autocorrect: {
        type: String,
        value: 'off'
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `autosave` property,
       * used with type=search.
       */
      autosave: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `results` property,
       * used with type=search.
       */
      results: {
        type: Number
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the `<input is="iron-input">`'s `accept` property,
       * used with type=file.
       */
      accept: {
        type: String
      },

      /**
       * If you're using PaperInputBehavior to implement your own paper-input-like
       * element, bind this to the`<input is="iron-input">`'s `multiple` property,
       * used with type=file.
       */
      multiple: {
        type: Boolean
      },

      _ariaDescribedBy: {
        type: String,
        value: ''
      },

      _ariaLabelledBy: {
        type: String,
        value: ''
      }

    },

    listeners: {
      'addon-attached': '_onAddonAttached',
    },

    keyBindings: {
      'shift+tab:keydown': '_onShiftTabDown'
    },

    hostAttributes: {
      tabindex: 0
    },

    /**
     * Returns a reference to the input element.
     */
    get inputElement() {
      return this.$.input;
    },

    /**
     * Returns a reference to the focusable element.
     */
    get _focusableElement() {
      return this.inputElement;
    },

    registered: function() {
      // These types have some default placeholder text; overlapping
      // the label on top of it looks terrible. Auto-float the label in this case.
      this._typesThatHaveText = ["date", "datetime", "datetime-local", "month",
          "time", "week", "file"];
    },

    attached: function() {
      this._updateAriaLabelledBy();

      if (this.inputElement &&
          this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
        this.alwaysFloatLabel = true;
      }
    },

    _appendStringWithSpace: function(str, more) {
      if (str) {
        str = str + ' ' + more;
      } else {
        str = more;
      }
      return str;
    },

    _onAddonAttached: function(event) {
      var target = event.path ? event.path[0] : event.target;
      if (target.id) {
        this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
      } else {
        var id = 'paper-input-add-on-' + Polymer.PaperInputHelper.NextAddonID++;
        target.id = id;
        this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
      }
    },

    /**
     * Validates the input element and sets an error style if needed.
     *
     * @return {boolean}
     */
    validate: function() {
      return this.inputElement.validate();
    },

    /**
     * Forward focus to inputElement. Overriden from IronControlState.
     */
    _focusBlurHandler: function(event) {
      Polymer.IronControlState._focusBlurHandler.call(this, event);

      // Forward the focus to the nested input.
      if (this.focused && !this._shiftTabPressed)
        this._focusableElement.focus();
    },

    /**
     * Handler that is called when a shift+tab keypress is detected by the menu.
     *
     * @param {CustomEvent} event A key combination event.
     */
    _onShiftTabDown: function(event) {
      var oldTabIndex = this.getAttribute('tabindex');
      this._shiftTabPressed = true;
      this.setAttribute('tabindex', '-1');
      this.async(function() {
        this.setAttribute('tabindex', oldTabIndex);
        this._shiftTabPressed = false;
      }, 1);
    },

    /**
     * If `autoValidate` is true, then validates the element.
     */
    _handleAutoValidate: function() {
      if (this.autoValidate)
        this.validate();
    },

    /**
     * Restores the cursor to its original position after updating the value.
     * @param {string} newValue The value that should be saved.
     */
    updateValueAndPreserveCaret: function(newValue) {
      // Not all elements might have selection, and even if they have the
      // right properties, accessing them might throw an exception (like for
      // <input type=number>)
      try {
        var start = this.inputElement.selectionStart;
        this.value = newValue;

        // The cursor automatically jumps to the end after re-setting the value,
        // so restore it to its original position.
        this.inputElement.selectionStart = start;
        this.inputElement.selectionEnd = start;
      } catch (e) {
        // Just set the value and give up on the caret.
        this.value = newValue;
      }
    },

    _computeAlwaysFloatLabel: function(alwaysFloatLabel, placeholder) {
      return placeholder || alwaysFloatLabel;
    },

    _updateAriaLabelledBy: function() {
      var label = Polymer.dom(this.root).querySelector('label');
      if (!label) {
        this._ariaLabelledBy = '';
        return;
      }
      var labelledBy;
      if (label.id) {
        labelledBy = label.id;
      } else {
        labelledBy = 'paper-input-label-' + Polymer.PaperInputHelper.NextLabelID++;
        label.id = labelledBy;
      }
      this._ariaLabelledBy = labelledBy;
    },

    _onChange:function(event) {
      // In the Shadow DOM, the `change` event is not leaked into the
      // ancestor tree, so we must do this manually.
      // See https://w3c.github.io/webcomponents/spec/shadow/#events-that-are-not-leaked-into-ancestor-trees.
      if (this.shadowRoot) {
        this.fire(event.type, {sourceEvent: event}, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    },

    _autofocusChanged: function() {
      // Firefox doesn't respect the autofocus attribute if it's applied after
      // the page is loaded (Chrome/WebKit do respect it), preventing an
      // autofocus attribute specified in markup from taking effect when the
      // element is upgraded. As a workaround, if the autofocus property is set,
      // and the focus hasn't already been moved elsewhere, we take focus.
      if (this.autofocus && this._focusableElement) {

        // In IE 11, the default document.activeElement can be the page's
        // outermost html element, but there are also cases (under the
        // polyfill?) in which the activeElement is not a real HTMLElement, but
        // just a plain object. We identify the latter case as having no valid
        // activeElement.
        var activeElement = document.activeElement;
        var isActiveElementValid = activeElement instanceof HTMLElement;

        // Has some other element has already taken the focus?
        var isSomeElementActive = isActiveElementValid &&
            activeElement !== document.body &&
            activeElement !== document.documentElement; /* IE 11 */
        if (!isSomeElementActive) {
          // No specific element has taken the focus yet, so we can take it.
          this._focusableElement.focus();
        }
      }
    }
  }

  /** @polymerBehavior */
  Polymer.PaperInputBehavior = [
    Polymer.IronControlState,
    Polymer.IronA11yKeysBehavior,
    Polymer.PaperInputBehaviorImpl
  ];
</script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,500italic,700,700italic">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700">
<style is="custom-style">

  :root {

    /* Shared Styles */
    --paper-font-common-base: {
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-code: {
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-expensive-kerning: {
      text-rendering: optimizeLegibility;
    };

    --paper-font-common-nowrap: {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    };

    /* Material Font Styles */

    --paper-font-display4: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 112px;
      font-weight: 300;
      letter-spacing: -.044em;
      line-height: 120px;
    };

    --paper-font-display3: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 56px;
      font-weight: 400;
      letter-spacing: -.026em;
      line-height: 60px;
    };

    --paper-font-display2: {
      @apply(--paper-font-common-base);

      font-size: 45px;
      font-weight: 400;
      letter-spacing: -.018em;
      line-height: 48px;
    };

    --paper-font-display1: {
      @apply(--paper-font-common-base);

      font-size: 34px;
      font-weight: 400;
      letter-spacing: -.01em;
      line-height: 40px;
    };

    --paper-font-headline: {
      @apply(--paper-font-common-base);

      font-size: 24px;
      font-weight: 400;
      letter-spacing: -.012em;
      line-height: 32px;
    };

    --paper-font-title: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 20px;
      font-weight: 500;
      line-height: 28px;
    };

    --paper-font-subhead: {
      @apply(--paper-font-common-base);

      font-size: 16px;
      font-weight: 400;
      line-height: 24px;
    };

    --paper-font-body2: {
      @apply(--paper-font-common-base);

      font-size: 14px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-body1: {
      @apply(--paper-font-common-base);

      font-size: 14px;
      font-weight: 400;
      line-height: 20px;
    };

    --paper-font-caption: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 12px;
      font-weight: 400;
      letter-spacing: 0.011em;
      line-height: 20px;
    };

    --paper-font-menu: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 13px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-button: {
      @apply(--paper-font-common-base);
      @apply(--paper-font-common-nowrap);

      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.018em;
      line-height: 24px;
      text-transform: uppercase;
    };

    --paper-font-code2: {
      @apply(--paper-font-common-code);

      font-size: 14px;
      font-weight: 700;
      line-height: 20px;
    };

    --paper-font-code1: {
      @apply(--paper-font-common-code);

      font-size: 14px;
      font-weight: 500;
      line-height: 20px;
    };

  }

</style>
<script>

  /**
   * Use `Polymer.PaperInputAddonBehavior` to implement an add-on for `<paper-input-container>`. A
   * add-on appears below the input, and may display information based on the input value and
   * validity such as a character counter or an error message.
   * @polymerBehavior
   */
  Polymer.PaperInputAddonBehavior = {

    hostAttributes: {
      'add-on': ''
    },

    attached: function() {
      this.fire('addon-attached');
    },

    /**
     * The function called by `<paper-input-container>` when the input value or validity changes.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
    }

  };

</script>


<dom-module id="paper-input-char-counter" assetpath="bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: inline-block;
        float: right;

        @apply(--paper-font-caption);
        @apply(--paper-input-char-counter);
      }

      :host([hidden]) {
        display: none !important;
      }

      :host-context([dir="rtl"]) {
        float: left;
      }
    </style>

    <span>[[_charCounterStr]]</span>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-char-counter',

    behaviors: [
      Polymer.PaperInputAddonBehavior
    ],

    properties: {
      _charCounterStr: {
        type: String,
        value: '0'
      }
    },

    /**
     * This overrides the update function in PaperInputAddonBehavior.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
      if (!state.inputElement) {
        return;
      }

      state.value = state.value || '';

      var counter = state.value.toString().length.toString();

      if (state.inputElement.hasAttribute('maxlength')) {
        counter += '/' + state.inputElement.getAttribute('maxlength');
      }

      this._charCounterStr = counter;
    }
  });
</script>
<style is="custom-style">

  :root {

    /* Material Design color palette for Google products */

    --google-red-100: #f4c7c3;
    --google-red-300: #e67c73;
    --google-red-500: #db4437;
    --google-red-700: #c53929;

    --google-blue-100: #c6dafc;
    --google-blue-300: #7baaf7;
    --google-blue-500: #4285f4;
    --google-blue-700: #3367d6;

    --google-green-100: #b7e1cd;
    --google-green-300: #57bb8a;
    --google-green-500: #0f9d58;
    --google-green-700: #0b8043;

    --google-yellow-100: #fce8b2;
    --google-yellow-300: #f7cb4d;
    --google-yellow-500: #f4b400;
    --google-yellow-700: #f09300;

    --google-grey-100: #f5f5f5;
    --google-grey-300: #e0e0e0;
    --google-grey-500: #9e9e9e;
    --google-grey-700: #616161;
    
    /* Material Design color palette from online spec document */

    --paper-red-50: #ffebee;
    --paper-red-100: #ffcdd2;
    --paper-red-200: #ef9a9a;
    --paper-red-300: #e57373;
    --paper-red-400: #ef5350;
    --paper-red-500: #f44336;
    --paper-red-600: #e53935;
    --paper-red-700: #d32f2f;
    --paper-red-800: #c62828;
    --paper-red-900: #b71c1c;
    --paper-red-a100: #ff8a80;
    --paper-red-a200: #ff5252;
    --paper-red-a400: #ff1744;
    --paper-red-a700: #d50000;
 
    --paper-pink-50: #fce4ec;
    --paper-pink-100: #f8bbd0;
    --paper-pink-200: #f48fb1;
    --paper-pink-300: #f06292;
    --paper-pink-400: #ec407a;
    --paper-pink-500: #e91e63;
    --paper-pink-600: #d81b60;
    --paper-pink-700: #c2185b;
    --paper-pink-800: #ad1457;
    --paper-pink-900: #880e4f;
    --paper-pink-a100: #ff80ab;
    --paper-pink-a200: #ff4081;
    --paper-pink-a400: #f50057;
    --paper-pink-a700: #c51162;
 
    --paper-purple-50: #f3e5f5;
    --paper-purple-100: #e1bee7;
    --paper-purple-200: #ce93d8;
    --paper-purple-300: #ba68c8;
    --paper-purple-400: #ab47bc;
    --paper-purple-500: #9c27b0;
    --paper-purple-600: #8e24aa;
    --paper-purple-700: #7b1fa2;
    --paper-purple-800: #6a1b9a;
    --paper-purple-900: #4a148c;
    --paper-purple-a100: #ea80fc;
    --paper-purple-a200: #e040fb;
    --paper-purple-a400: #d500f9;
    --paper-purple-a700: #aa00ff;
 
    --paper-deep-purple-50: #ede7f6;
    --paper-deep-purple-100: #d1c4e9;
    --paper-deep-purple-200: #b39ddb;
    --paper-deep-purple-300: #9575cd;
    --paper-deep-purple-400: #7e57c2;
    --paper-deep-purple-500: #673ab7;
    --paper-deep-purple-600: #5e35b1;
    --paper-deep-purple-700: #512da8;
    --paper-deep-purple-800: #4527a0;
    --paper-deep-purple-900: #311b92;
    --paper-deep-purple-a100: #b388ff;
    --paper-deep-purple-a200: #7c4dff;
    --paper-deep-purple-a400: #651fff;
    --paper-deep-purple-a700: #6200ea;
 
    --paper-indigo-50: #e8eaf6;
    --paper-indigo-100: #c5cae9;
    --paper-indigo-200: #9fa8da;
    --paper-indigo-300: #7986cb;
    --paper-indigo-400: #5c6bc0;
    --paper-indigo-500: #3f51b5;
    --paper-indigo-600: #3949ab;
    --paper-indigo-700: #303f9f;
    --paper-indigo-800: #283593;
    --paper-indigo-900: #1a237e;
    --paper-indigo-a100: #8c9eff;
    --paper-indigo-a200: #536dfe;
    --paper-indigo-a400: #3d5afe;
    --paper-indigo-a700: #304ffe;
 
    --paper-blue-50: #e3f2fd;
    --paper-blue-100: #bbdefb;
    --paper-blue-200: #90caf9;
    --paper-blue-300: #64b5f6;
    --paper-blue-400: #42a5f5;
    --paper-blue-500: #2196f3;
    --paper-blue-600: #1e88e5;
    --paper-blue-700: #1976d2;
    --paper-blue-800: #1565c0;
    --paper-blue-900: #0d47a1;
    --paper-blue-a100: #82b1ff;
    --paper-blue-a200: #448aff;
    --paper-blue-a400: #2979ff;
    --paper-blue-a700: #2962ff;
 
    --paper-light-blue-50: #e1f5fe;
    --paper-light-blue-100: #b3e5fc;
    --paper-light-blue-200: #81d4fa;
    --paper-light-blue-300: #4fc3f7;
    --paper-light-blue-400: #29b6f6;
    --paper-light-blue-500: #03a9f4;
    --paper-light-blue-600: #039be5;
    --paper-light-blue-700: #0288d1;
    --paper-light-blue-800: #0277bd;
    --paper-light-blue-900: #01579b;
    --paper-light-blue-a100: #80d8ff;
    --paper-light-blue-a200: #40c4ff;
    --paper-light-blue-a400: #00b0ff;
    --paper-light-blue-a700: #0091ea;
 
    --paper-cyan-50: #e0f7fa;
    --paper-cyan-100: #b2ebf2;
    --paper-cyan-200: #80deea;
    --paper-cyan-300: #4dd0e1;
    --paper-cyan-400: #26c6da;
    --paper-cyan-500: #00bcd4;
    --paper-cyan-600: #00acc1;
    --paper-cyan-700: #0097a7;
    --paper-cyan-800: #00838f;
    --paper-cyan-900: #006064;
    --paper-cyan-a100: #84ffff;
    --paper-cyan-a200: #18ffff;
    --paper-cyan-a400: #00e5ff;
    --paper-cyan-a700: #00b8d4;
 
    --paper-teal-50: #e0f2f1;
    --paper-teal-100: #b2dfdb;
    --paper-teal-200: #80cbc4;
    --paper-teal-300: #4db6ac;
    --paper-teal-400: #26a69a;
    --paper-teal-500: #009688;
    --paper-teal-600: #00897b;
    --paper-teal-700: #00796b;
    --paper-teal-800: #00695c;
    --paper-teal-900: #004d40;
    --paper-teal-a100: #a7ffeb;
    --paper-teal-a200: #64ffda;
    --paper-teal-a400: #1de9b6;
    --paper-teal-a700: #00bfa5;
 
    --paper-green-50: #e8f5e9;
    --paper-green-100: #c8e6c9;
    --paper-green-200: #a5d6a7;
    --paper-green-300: #81c784;
    --paper-green-400: #66bb6a;
    --paper-green-500: #4caf50;
    --paper-green-600: #43a047;
    --paper-green-700: #388e3c;
    --paper-green-800: #2e7d32;
    --paper-green-900: #1b5e20;
    --paper-green-a100: #b9f6ca;
    --paper-green-a200: #69f0ae;
    --paper-green-a400: #00e676;
    --paper-green-a700: #00c853;
 
    --paper-light-green-50: #f1f8e9;
    --paper-light-green-100: #dcedc8;
    --paper-light-green-200: #c5e1a5;
    --paper-light-green-300: #aed581;
    --paper-light-green-400: #9ccc65;
    --paper-light-green-500: #8bc34a;
    --paper-light-green-600: #7cb342;
    --paper-light-green-700: #689f38;
    --paper-light-green-800: #558b2f;
    --paper-light-green-900: #33691e;
    --paper-light-green-a100: #ccff90;
    --paper-light-green-a200: #b2ff59;
    --paper-light-green-a400: #76ff03;
    --paper-light-green-a700: #64dd17;
 
    --paper-lime-50: #f9fbe7;
    --paper-lime-100: #f0f4c3;
    --paper-lime-200: #e6ee9c;
    --paper-lime-300: #dce775;
    --paper-lime-400: #d4e157;
    --paper-lime-500: #cddc39;
    --paper-lime-600: #c0ca33;
    --paper-lime-700: #afb42b;
    --paper-lime-800: #9e9d24;
    --paper-lime-900: #827717;
    --paper-lime-a100: #f4ff81;
    --paper-lime-a200: #eeff41;
    --paper-lime-a400: #c6ff00;
    --paper-lime-a700: #aeea00;
 
    --paper-yellow-50: #fffde7;
    --paper-yellow-100: #fff9c4;
    --paper-yellow-200: #fff59d;
    --paper-yellow-300: #fff176;
    --paper-yellow-400: #ffee58;
    --paper-yellow-500: #ffeb3b;
    --paper-yellow-600: #fdd835;
    --paper-yellow-700: #fbc02d;
    --paper-yellow-800: #f9a825;
    --paper-yellow-900: #f57f17;
    --paper-yellow-a100: #ffff8d;
    --paper-yellow-a200: #ffff00;
    --paper-yellow-a400: #ffea00;
    --paper-yellow-a700: #ffd600;
 
    --paper-amber-50: #fff8e1;
    --paper-amber-100: #ffecb3;
    --paper-amber-200: #ffe082;
    --paper-amber-300: #ffd54f;
    --paper-amber-400: #ffca28;
    --paper-amber-500: #ffc107;
    --paper-amber-600: #ffb300;
    --paper-amber-700: #ffa000;
    --paper-amber-800: #ff8f00;
    --paper-amber-900: #ff6f00;
    --paper-amber-a100: #ffe57f;
    --paper-amber-a200: #ffd740;
    --paper-amber-a400: #ffc400;
    --paper-amber-a700: #ffab00;
 
    --paper-orange-50: #fff3e0;
    --paper-orange-100: #ffe0b2;
    --paper-orange-200: #ffcc80;
    --paper-orange-300: #ffb74d;
    --paper-orange-400: #ffa726;
    --paper-orange-500: #ff9800;
    --paper-orange-600: #fb8c00;
    --paper-orange-700: #f57c00;
    --paper-orange-800: #ef6c00;
    --paper-orange-900: #e65100;
    --paper-orange-a100: #ffd180;
    --paper-orange-a200: #ffab40;
    --paper-orange-a400: #ff9100;
    --paper-orange-a700: #ff6500;
 
    --paper-deep-orange-50: #fbe9e7;
    --paper-deep-orange-100: #ffccbc;
    --paper-deep-orange-200: #ffab91;
    --paper-deep-orange-300: #ff8a65;
    --paper-deep-orange-400: #ff7043;
    --paper-deep-orange-500: #ff5722;
    --paper-deep-orange-600: #f4511e;
    --paper-deep-orange-700: #e64a19;
    --paper-deep-orange-800: #d84315;
    --paper-deep-orange-900: #bf360c;
    --paper-deep-orange-a100: #ff9e80;
    --paper-deep-orange-a200: #ff6e40;
    --paper-deep-orange-a400: #ff3d00;
    --paper-deep-orange-a700: #dd2c00;
 
    --paper-brown-50: #efebe9;
    --paper-brown-100: #d7ccc8;
    --paper-brown-200: #bcaaa4;
    --paper-brown-300: #a1887f;
    --paper-brown-400: #8d6e63;
    --paper-brown-500: #795548;
    --paper-brown-600: #6d4c41;
    --paper-brown-700: #5d4037;
    --paper-brown-800: #4e342e;
    --paper-brown-900: #3e2723;
 
    --paper-grey-50: #fafafa;
    --paper-grey-100: #f5f5f5;
    --paper-grey-200: #eeeeee;
    --paper-grey-300: #e0e0e0;
    --paper-grey-400: #bdbdbd;
    --paper-grey-500: #9e9e9e;
    --paper-grey-600: #757575;
    --paper-grey-700: #616161;
    --paper-grey-800: #424242;
    --paper-grey-900: #212121;
 
    --paper-blue-grey-50: #eceff1;
    --paper-blue-grey-100: #cfd8dc;
    --paper-blue-grey-200: #b0bec5;
    --paper-blue-grey-300: #90a4ae;
    --paper-blue-grey-400: #78909c;
    --paper-blue-grey-500: #607d8b;
    --paper-blue-grey-600: #546e7a;
    --paper-blue-grey-700: #455a64;
    --paper-blue-grey-800: #37474f;
    --paper-blue-grey-900: #263238;

    /* opacity for dark text on a light background */
    --dark-divider-opacity: 0.12;
    --dark-disabled-opacity: 0.38; /* or hint text or icon */
    --dark-secondary-opacity: 0.54;
    --dark-primary-opacity: 0.87;

    /* opacity for light text on a dark background */
    --light-divider-opacity: 0.12;
    --light-disabled-opacity: 0.3; /* or hint text or icon */
    --light-secondary-opacity: 0.7;
    --light-primary-opacity: 1.0;

  }

</style>


<style is="custom-style">

  :root {
    /*
     * You can use these generic variables in your elements for easy theming.
     * For example, if all your elements use `--primary-text-color` as its main
     * color, then switching from a light to a dark theme is just a matter of
     * changing the value of `--primary-text-color` in your application.
     */
    --primary-text-color: var(--light-theme-text-color);
    --primary-background-color: var(--light-theme-background-color);
    --secondary-text-color: var(--light-theme-secondary-color);
    --disabled-text-color: var(--light-theme-disabled-color);
    --divider-color: var(--light-theme-divider-color);
    --error-color: var(--paper-deep-orange-a700);

    /*
     * Primary and accent colors. Also see color.html for more colors.
     */
    --primary-color: var(--paper-indigo-500);
    --light-primary-color: var(--paper-indigo-100);
    --dark-primary-color: var(--paper-indigo-700);

    --accent-color: var(--paper-pink-a200);
    --light-accent-color: var(--paper-pink-a100);
    --dark-accent-color: var(--paper-pink-a400);


    /*
     * Material Design Light background theme
     */
    --light-theme-background-color: #ffffff;
    --light-theme-base-color: #000000;
    --light-theme-text-color: var(--paper-grey-900);
    --light-theme-secondary-color: #737373;  /* for secondary text and icons */
    --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */
    --light-theme-divider-color: #dbdbdb;

    /*
     * Material Design Dark background theme
     */
    --dark-theme-background-color: var(--paper-grey-900);
    --dark-theme-base-color: #ffffff;
    --dark-theme-text-color: #ffffff;
    --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */
    --dark-theme-disabled-color: #646464;  /* disabled/hint text */
    --dark-theme-divider-color: #3c3c3c;

    /*
     * Deprecated values because of their confusing names.
     */
    --text-primary-color: var(--dark-theme-text-color);
    --default-primary-color: var(--primary-color);

  }

</style>


<dom-module id="paper-input-container" assetpath="bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: block;
        padding: 8px 0;

        @apply(--paper-input-container);
      }

      :host([inline]) {
        display: inline-block;
      }

      :host([disabled]) {
        pointer-events: none;
        opacity: 0.33;

        @apply(--paper-input-container-disabled);
      }

      :host([hidden]) {
        display: none !important;
      }

      .floated-label-placeholder {
        @apply(--paper-font-caption);
      }

      .underline {
        position: relative;
      }

      .focused-line {
        @apply(--layout-fit);

        background: var(--paper-input-container-focus-color, --primary-color);
        height: 2px;

        -webkit-transform-origin: center center;
        transform-origin: center center;
        -webkit-transform: scale3d(0,1,1);
        transform: scale3d(0,1,1);

        @apply(--paper-input-container-underline-focus);
      }

      .underline.is-highlighted .focused-line {
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply(--paper-transition-easing);
      }

      .underline.is-invalid .focused-line {
        background: var(--paper-input-container-invalid-color, --error-color);
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply(--paper-transition-easing);
      }

      .unfocused-line {
        @apply(--layout-fit);

        background: var(--paper-input-container-color, --secondary-text-color);
        height: 1px;

        @apply(--paper-input-container-underline);
      }

      :host([disabled]) .unfocused-line {
        border-bottom: 1px dashed;
        border-color: var(--paper-input-container-color, --secondary-text-color);
        background: transparent;

        @apply(--paper-input-container-underline-disabled);
      }

      .label-and-input-container {
        @apply(--layout-flex-auto);
        @apply(--layout-relative);

        width: 100%;
        max-width: 100%;
      }

      .input-content {
        @apply(--layout-horizontal);
        @apply(--layout-center);

        position: relative;
      }

      .input-content ::content label,
      .input-content ::content .paper-input-label {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
        width: 100%;
        font: inherit;
        color: var(--paper-input-container-color, --secondary-text-color);
        -webkit-transition: -webkit-transform 0.25s, width 0.25s;
        transition: transform 0.25s, width 0.25s;
        -webkit-transform-origin: left top;
        transform-origin: left top;

        @apply(--paper-font-common-nowrap);
        @apply(--paper-font-subhead);
        @apply(--paper-input-container-label);
        @apply(--paper-transition-easing);
      }

      .input-content.label-is-floating ::content label,
      .input-content.label-is-floating ::content .paper-input-label {
        -webkit-transform: translateY(-75%) scale(0.75);
        transform: translateY(-75%) scale(0.75);

        /* Since we scale to 75/100 of the size, we actually have 100/75 of the
        original space now available */
        width: 133%;

        @apply(--paper-input-container-label-floating);
      }

      :host-context([dir="rtl"]) .input-content.label-is-floating ::content label,
      :host-context([dir="rtl"]) .input-content.label-is-floating ::content .paper-input-label {
        /* TODO(noms): Figure out why leaving the width at 133% before the animation
         * actually makes
         * it wider on the right side, not left side, as you would expect in RTL */
        width: 100%;
        -webkit-transform-origin: right top;
        transform-origin: right top;
      }

      .input-content.label-is-highlighted ::content label,
      .input-content.label-is-highlighted ::content .paper-input-label {
        color: var(--paper-input-container-focus-color, --primary-color);

        @apply(--paper-input-container-label-focus);
      }

      .input-content.is-invalid ::content label,
      .input-content.is-invalid ::content .paper-input-label {
        color: var(--paper-input-container-invalid-color, --error-color);
      }

      .input-content.label-is-hidden ::content label,
      .input-content.label-is-hidden ::content .paper-input-label {
        visibility: hidden;
      }

      .input-content ::content input,
      .input-content ::content textarea,
      .input-content ::content iron-autogrow-textarea,
      .input-content ::content .paper-input-input {
        position: relative; /* to make a stacking context */
        outline: none;
        box-shadow: none;
        padding: 0;
        width: 100%;
        max-width: 100%;
        background: transparent;
        border: none;
        color: var(--paper-input-container-input-color, --primary-text-color);
        -webkit-appearance: none;
        text-align: inherit;
        vertical-align: bottom;

        @apply(--paper-font-subhead);
        @apply(--paper-input-container-input);
      }

      ::content [prefix] {
        @apply(--paper-font-subhead);

        @apply(--paper-input-prefix);
        @apply(--layout-flex-none);
      }

      ::content [suffix] {
        @apply(--paper-font-subhead);

        @apply(--paper-input-suffix);
        @apply(--layout-flex-none);
      }

      /* Firefox sets a min-width on the input, which can cause layout issues */
      .input-content ::content input {
        min-width: 0;
      }

      .input-content ::content textarea {
        resize: none;
      }

      .add-on-content {
        position: relative;
      }

      .add-on-content.is-invalid ::content * {
        color: var(--paper-input-container-invalid-color, --error-color);
      }

      .add-on-content.is-highlighted ::content * {
        color: var(--paper-input-container-focus-color, --primary-color);
      }
    </style>

    <template is="dom-if" if="[[!noLabelFloat]]">
      <div class="floated-label-placeholder" aria-hidden="true">&nbsp;</div>
    </template>

    <div class$="[[_computeInputContentClass(noLabelFloat,alwaysFloatLabel,focused,invalid,_inputHasContent)]]">
      <content select="[prefix]" id="prefix"></content>

      <div class="label-and-input-container" id="labelAndInputContainer">
        <content select=":not([add-on]):not([prefix]):not([suffix])"></content>
      </div>

      <content select="[suffix]"></content>
    </div>

    <div class$="[[_computeUnderlineClass(focused,invalid)]]">
      <div class="unfocused-line"></div>
      <div class="focused-line"></div>
    </div>

    <div class$="[[_computeAddOnContentClass(focused,invalid)]]">
      <content id="addOnContent" select="[add-on]"></content>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-container',

    properties: {
      /**
       * Set to true to disable the floating label. The label disappears when the input value is
       * not null.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to always float the floating label.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * The attribute to listen for value changes on.
       */
      attrForValue: {
        type: String,
        value: 'bind-value'
      },

      /**
       * Set to true to auto-validate the input value when it changes.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * True if the input is invalid. This property is set automatically when the input value
       * changes if auto-validating, or when the `iron-input-validate` event is heard from a child.
       */
      invalid: {
        observer: '_invalidChanged',
        type: Boolean,
        value: false
      },

      /**
       * True if the input has focus.
       */
      focused: {
        readOnly: true,
        type: Boolean,
        value: false,
        notify: true
      },

      _addons: {
        type: Array
        // do not set a default value here intentionally - it will be initialized lazily when a
        // distributed child is attached, which may occur before configuration for this element
        // in polyfill.
      },

      _inputHasContent: {
        type: Boolean,
        value: false
      },

      _inputSelector: {
        type: String,
        value: 'input,textarea,.paper-input-input'
      },

      _boundOnFocus: {
        type: Function,
        value: function() {
          return this._onFocus.bind(this);
        }
      },

      _boundOnBlur: {
        type: Function,
        value: function() {
          return this._onBlur.bind(this);
        }
      },

      _boundOnInput: {
        type: Function,
        value: function() {
          return this._onInput.bind(this);
        }
      },

      _boundValueChanged: {
        type: Function,
        value: function() {
          return this._onValueChanged.bind(this);
        }
      }
    },

    listeners: {
      'addon-attached': '_onAddonAttached',
      'iron-input-validate': '_onIronInputValidate'
    },

    get _valueChangedEvent() {
      return this.attrForValue + '-changed';
    },

    get _propertyForValue() {
      return Polymer.CaseMap.dashToCamelCase(this.attrForValue);
    },

    get _inputElement() {
      return Polymer.dom(this).querySelector(this._inputSelector);
    },

    get _inputElementValue() {
      return this._inputElement[this._propertyForValue] || this._inputElement.value;
    },

    ready: function() {
      if (!this._addons) {
        this._addons = [];
      }
      this.addEventListener('focus', this._boundOnFocus, true);
      this.addEventListener('blur', this._boundOnBlur, true);
    },

    attached: function() {
      if (this.attrForValue) {
        this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
      } else {
        this.addEventListener('input', this._onInput);
      }

      // Only validate when attached if the input already has a value.
      if (this._inputElementValue != '') {
        this._handleValueAndAutoValidate(this._inputElement);
      } else {
        this._handleValue(this._inputElement);
      }
    },

    _onAddonAttached: function(event) {
      if (!this._addons) {
        this._addons = [];
      }
      var target = event.target;
      if (this._addons.indexOf(target) === -1) {
        this._addons.push(target);
        if (this.isAttached) {
          this._handleValue(this._inputElement);
        }
      }
    },

    _onFocus: function() {
      this._setFocused(true);
    },

    _onBlur: function() {
      this._setFocused(false);
      this._handleValueAndAutoValidate(this._inputElement);
    },

    _onInput: function(event) {
      this._handleValueAndAutoValidate(event.target);
    },

    _onValueChanged: function(event) {
      this._handleValueAndAutoValidate(event.target);
    },

    _handleValue: function(inputElement) {
      var value = this._inputElementValue;

      // type="number" hack needed because this.value is empty until it's valid
      if (value || value === 0 || (inputElement.type === 'number' && !inputElement.checkValidity())) {
        this._inputHasContent = true;
      } else {
        this._inputHasContent = false;
      }

      this.updateAddons({
        inputElement: inputElement,
        value: value,
        invalid: this.invalid
      });
    },

    _handleValueAndAutoValidate: function(inputElement) {
      if (this.autoValidate) {
        var valid;
        if (inputElement.validate) {
          valid = inputElement.validate(this._inputElementValue);
        } else {
          valid = inputElement.checkValidity();
        }
        this.invalid = !valid;
      }

      // Call this last to notify the add-ons.
      this._handleValue(inputElement);
    },

    _onIronInputValidate: function(event) {
      this.invalid = this._inputElement.invalid;
    },

    _invalidChanged: function() {
      if (this._addons) {
        this.updateAddons({invalid: this.invalid});
      }
    },

    /**
     * Call this to update the state of add-ons.
     * @param {Object} state Add-on state.
     */
    updateAddons: function(state) {
      for (var addon, index = 0; addon = this._addons[index]; index++) {
        addon.update(state);
      }
    },

    _computeInputContentClass: function(noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
      var cls = 'input-content';
      if (!noLabelFloat) {
        var label = this.querySelector('label');

        if (alwaysFloatLabel || _inputHasContent) {
          cls += ' label-is-floating';
          // If the label is floating, ignore any offsets that may have been
          // applied from a prefix element.
          this.$.labelAndInputContainer.style.position = 'static';

          if (invalid) {
            cls += ' is-invalid';
          } else if (focused) {
            cls += " label-is-highlighted";
          }
        } else {
          // When the label is not floating, it should overlap the input element.
          if (label) {
            this.$.labelAndInputContainer.style.position = 'relative';
          }
        }
      } else {
        if (_inputHasContent) {
          cls += ' label-is-hidden';
        }
      }
      return cls;
    },

    _computeUnderlineClass: function(focused, invalid) {
      var cls = 'underline';
      if (invalid) {
        cls += ' is-invalid';
      } else if (focused) {
        cls += ' is-highlighted'
      }
      return cls;
    },

    _computeAddOnContentClass: function(focused, invalid) {
      var cls = 'add-on-content';
      if (invalid) {
        cls += ' is-invalid';
      } else if (focused) {
        cls += ' is-highlighted'
      }
      return cls;
    }
  });
</script>


<dom-module id="paper-input-error" assetpath="bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: inline-block;
        visibility: hidden;

        color: var(--paper-input-container-invalid-color, --error-color);

        @apply(--paper-font-caption);
        @apply(--paper-input-error);
        position: absolute;
        left:0;
        right:0;
      }

      :host([invalid]) {
        visibility: visible;
      };
    </style>

    <content></content>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input-error',

    behaviors: [
      Polymer.PaperInputAddonBehavior
    ],

    properties: {
      /**
       * True if the error is showing.
       */
      invalid: {
        readOnly: true,
        reflectToAttribute: true,
        type: Boolean
      }
    },

    /**
     * This overrides the update function in PaperInputAddonBehavior.
     * @param {{
     *   inputElement: (Element|undefined),
     *   value: (string|undefined),
     *   invalid: boolean
     * }} state -
     *     inputElement: The input element.
     *     value: The input value.
     *     invalid: True if the input value is invalid.
     */
    update: function(state) {
      this._setInvalid(state.invalid);
    }
  });
</script>


<dom-module id="paper-input" assetpath="bower_components/paper-input/">
  <template>
    <style>
      :host {
        display: block;
      }

      :host([focused]) {
        outline: none;
      }

      :host([hidden]) {
        display: none !important;
      }

      input::-webkit-input-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input:-moz-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input::-moz-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      input:-ms-input-placeholder {
        color: var(--paper-input-container-color, --secondary-text-color);
      }

      label {
        pointer-events: none;
      }
    </style>

    <paper-input-container no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate$="[[autoValidate]]" disabled$="[[disabled]]" invalid="[[invalid]]">

      <content select="[prefix]"></content>

      <label hidden$="[[!label]]" aria-hidden="true" for="input">[[label]]</label>

      <input is="iron-input" id="input" aria-labelledby$="[[_ariaLabelledBy]]" aria-describedby$="[[_ariaDescribedBy]]" disabled$="[[disabled]]" title$="[[title]]" bind-value="{{value}}" invalid="{{invalid}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" validator="[[validator]]" type$="[[type]]" pattern$="[[pattern]]" required$="[[required]]" autocomplete$="[[autocomplete]]" autofocus$="[[autofocus]]" inputmode$="[[inputmode]]" minlength$="[[minlength]]" maxlength$="[[maxlength]]" min$="[[min]]" max$="[[max]]" step$="[[step]]" name$="[[name]]" placeholder$="[[placeholder]]" readonly$="[[readonly]]" list$="[[list]]" size$="[[size]]" autocapitalize$="[[autocapitalize]]" autocorrect$="[[autocorrect]]" on-change="_onChange" tabindex$="[[tabindex]]" autosave$="[[autosave]]" results$="[[results]]" accept$="[[accept]]" multiple$="[[multiple]]">

      <content select="[suffix]"></content>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error aria-live="assertive">[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter></paper-input-char-counter>
      </template>

    </paper-input-container>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-input',

    behaviors: [
      Polymer.IronFormElementBehavior,
      Polymer.PaperInputBehavior
    ]
  });
</script>


<dom-module id="paper-progress" assetpath="bower_components/paper-progress/">
  <template>
    <style>
      :host {
        display: block;
        width: 200px;
        position: relative;
        overflow: hidden;
      }

      :host([hidden]) {
        display: none !important;
      }

      #progressContainer {
        @apply(--paper-progress-container);
        position: relative;
      }

      #progressContainer,
      /* the stripe for the indeterminate animation*/
      .indeterminate::after {
        height: var(--paper-progress-height, 4px);
      }

      #primaryProgress,
      #secondaryProgress,
      .indeterminate::after {
        @apply(--layout-fit);
      }

      #progressContainer,
      .indeterminate::after {
        background: var(--paper-progress-container-color, --google-grey-300);
      }

      :host(.transiting) #primaryProgress,
      :host(.transiting) #secondaryProgress {
        -webkit-transition-property: -webkit-transform;
        transition-property: transform;

        /* Duration */
        -webkit-transition-duration: var(--paper-progress-transition-duration, 0.08s);
        transition-duration: var(--paper-progress-transition-duration, 0.08s);

        /* Timing function */
        -webkit-transition-timing-function: var(--paper-progress-transition-timing-function, ease);
        transition-timing-function: var(--paper-progress-transition-timing-function, ease);

        /* Delay */
        -webkit-transition-delay: var(--paper-progress-transition-delay, 0s);
        transition-delay: var(--paper-progress-transition-delay, 0s);
      }

      #primaryProgress,
      #secondaryProgress {
        @apply(--layout-fit);
        -webkit-transform-origin: left center;
        transform-origin: left center;
        -webkit-transform: scaleX(0);
        transform: scaleX(0);
        will-change: transform;
      }

      #primaryProgress {
        background: var(--paper-progress-active-color, --google-green-500);
      }

      #secondaryProgress {
        background: var(--paper-progress-secondary-color, --google-green-100);
      }

      :host([disabled]) #primaryProgress {
        background: var(--paper-progress-disabled-active-color, --google-grey-500);
      }

      :host([disabled]) #secondaryProgress {
        background: var(--paper-progress-disabled-secondary-color, --google-grey-300);
      }

      :host(:not([disabled])) #primaryProgress.indeterminate {
        -webkit-transform-origin: right center;
        transform-origin: right center;
        -webkit-animation: indeterminate-bar var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
        animation: indeterminate-bar var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
      }

      :host(:not([disabled])) #primaryProgress.indeterminate::after {
        content: "";
        -webkit-transform-origin: center center;
        transform-origin: center center;

        -webkit-animation: indeterminate-splitter var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
        animation: indeterminate-splitter var(--paper-progress-indeterminate-cycle-duration, 2s) linear infinite;
      }

      @-webkit-keyframes indeterminate-bar {
        0% {
          -webkit-transform: scaleX(1) translateX(-100%);
        }
        50% {
          -webkit-transform: scaleX(1) translateX(0%);
        }
        75% {
          -webkit-transform: scaleX(1) translateX(0%);
          -webkit-animation-timing-function: cubic-bezier(.28,.62,.37,.91);
        }
        100% {
          -webkit-transform: scaleX(0) translateX(0%);
        }
      }

      @-webkit-keyframes indeterminate-splitter {
        0% {
          -webkit-transform: scaleX(.75) translateX(-125%);
        }
        30% {
          -webkit-transform: scaleX(.75) translateX(-125%);
          -webkit-animation-timing-function: cubic-bezier(.42,0,.6,.8);
        }
        90% {
          -webkit-transform: scaleX(.75) translateX(125%);
        }
        100% {
          -webkit-transform: scaleX(.75) translateX(125%);
        }
      }

      @keyframes indeterminate-bar {
        0% {
          transform: scaleX(1) translateX(-100%);
        }
        50% {
          transform: scaleX(1) translateX(0%);
        }
        75% {
          transform: scaleX(1) translateX(0%);
          animation-timing-function: cubic-bezier(.28,.62,.37,.91);
        }
        100% {
          transform: scaleX(0) translateX(0%);
        }
      }

      @keyframes indeterminate-splitter {
        0% {
          transform: scaleX(.75) translateX(-125%);
        }
        30% {
          transform: scaleX(.75) translateX(-125%);
          animation-timing-function: cubic-bezier(.42,0,.6,.8);
        }
        90% {
          transform: scaleX(.75) translateX(125%);
        }
        100% {
          transform: scaleX(.75) translateX(125%);
        }
      }
    </style>

    <div id="progressContainer">
      <div id="secondaryProgress" hidden$="[[_hideSecondaryProgress(secondaryRatio)]]"></div>
      <div id="primaryProgress"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'paper-progress',

    behaviors: [
      Polymer.IronRangeBehavior
    ],

    properties: {
      /**
       * The number that represents the current secondary progress.
       */
      secondaryProgress: {
        type: Number,
        value: 0
      },

      /**
       * The secondary ratio
       */
      secondaryRatio: {
        type: Number,
        value: 0,
        readOnly: true
      },

      /**
       * Use an indeterminate progress indicator.
       */
      indeterminate: {
        type: Boolean,
        value: false,
        observer: '_toggleIndeterminate'
      },

      /**
       * True if the progress is disabled.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: '_disabledChanged'
      }
    },

    observers: [
      '_progressChanged(secondaryProgress, value, min, max)'
    ],

    hostAttributes: {
      role: 'progressbar'
    },

    _toggleIndeterminate: function(indeterminate) {
      // If we use attribute/class binding, the animation sometimes doesn't translate properly
      // on Safari 7.1. So instead, we toggle the class here in the update method.
      this.toggleClass('indeterminate', indeterminate, this.$.primaryProgress);
    },

    _transformProgress: function(progress, ratio) {
      var transform = 'scaleX(' + (ratio / 100) + ')';
      progress.style.transform = progress.style.webkitTransform = transform;
    },

    _mainRatioChanged: function(ratio) {
      this._transformProgress(this.$.primaryProgress, ratio);
    },

    _progressChanged: function(secondaryProgress, value, min, max) {
      secondaryProgress = this._clampValue(secondaryProgress);
      value = this._clampValue(value);

      var secondaryRatio = this._calcRatio(secondaryProgress) * 100;
      var mainRatio = this._calcRatio(value) * 100;

      this._setSecondaryRatio(secondaryRatio);
      this._transformProgress(this.$.secondaryProgress, secondaryRatio);
      this._transformProgress(this.$.primaryProgress, mainRatio);

      this.secondaryProgress = secondaryProgress;

      this.setAttribute('aria-valuenow', value);
      this.setAttribute('aria-valuemin', min);
      this.setAttribute('aria-valuemax', max);
    },

    _disabledChanged: function(disabled) {
      this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    },

    _hideSecondaryProgress: function(secondaryRatio) {
      return secondaryRatio === 0;
    }
  });
</script>


<dom-module id="paper-slider" assetpath="bower_components/paper-slider/">
  <template strip-whitespace="">
    <style>
      :host {
        @apply(--layout);
        @apply(--layout-justified);
        @apply(--layout-center);
        width: 200px;
        cursor: default;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        --paper-progress-active-color: var(--paper-slider-active-color, --google-blue-700);
        --paper-progress-secondary-color: var(--paper-slider-secondary-color, --google-blue-300);
        --paper-progress-disabled-active-color: var(--paper-slider-disabled-active-color, --paper-grey-400);
        --paper-progress-disabled-secondary-color: var(--paper-slider-disabled-secondary-color, --paper-grey-400);
        --calculated-paper-slider-height: var(--paper-slider-height, 2px);
      }

      /* focus shows the ripple */
      :host(:focus) {
        outline: none;
      }

      #sliderContainer {
        position: relative;
        width: 100%;
        height: calc(30px + var(--calculated-paper-slider-height));
        margin-left: calc(15px + var(--calculated-paper-slider-height)/2);
        margin-right: calc(15px + var(--calculated-paper-slider-height)/2);
      }

      #sliderContainer:focus {
        outline: 0;
      }

      #sliderContainer.editable {
        margin-top: 12px;
        margin-bottom: 12px;
      }

      .bar-container {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        overflow: hidden;
      }

      .ring > .bar-container {
        left: calc(5px + var(--calculated-paper-slider-height)/2);
        transition: left 0.18s ease;
      }

      .ring.expand.dragging > .bar-container {
        transition: none;
      }

      .ring.expand:not(.pin) > .bar-container {
        left: calc(8px + var(--calculated-paper-slider-height)/2);
      }

      #sliderBar {
        padding: 15px 0;
        width: 100%;
        background-color: var(--paper-slider-bar-color, transparent);
        --paper-progress-container-color: var(--paper-slider-container-color, --paper-grey-400);
        --paper-progress-height: var(--calculated-paper-slider-height);
      }

      .slider-markers {
        position: absolute;
        top: calc(14px + var(--paper-slider-height,2px)/2);
        height: var(--calculated-paper-slider-height);
        left: 0;
        right: -1px;
        box-sizing: border-box;
        pointer-events: none;
        @apply(--layout-horizontal);
      }

      .slider-marker {
        @apply(--layout-flex);
      }
      .slider-markers::after,
      .slider-marker::after {
        content: "";
        display: block;
        margin-left: -1px;
        width: 2px;
        height: var(--calculated-paper-slider-height);
        border-radius: 50%;
        background-color: var(--paper-slider-markers-color, #000);
      }

      .slider-knob {
        position: absolute;
        left: 0;
        top: 0;
        margin-left: calc(-15px - var(--calculated-paper-slider-height)/2);
        width: calc(30px + var(--calculated-paper-slider-height));
        height: calc(30px + var(--calculated-paper-slider-height));
      }

      .transiting > .slider-knob {
        transition: left 0.08s ease;
      }

      .slider-knob:focus {
        outline: none;
      }

      .slider-knob.dragging {
        transition: none;
      }

      .snaps > .slider-knob.dragging {
        transition: -webkit-transform 0.08s ease;
        transition: transform 0.08s ease;
      }

      .slider-knob-inner {
        margin: 10px;
        width: calc(100% - 20px);
        height: calc(100% - 20px);
        background-color: var(--paper-slider-knob-color, --google-blue-700);
        border: 2px solid var(--paper-slider-knob-color, --google-blue-700);
        border-radius: 50%;

        -moz-box-sizing: border-box;
        box-sizing: border-box;

        transition-property: -webkit-transform, background-color, border;
        transition-property: transform, background-color, border;
        transition-duration: 0.18s;
        transition-timing-function: ease;
      }

      .expand:not(.pin) > .slider-knob > .slider-knob-inner {
        -webkit-transform: scale(1.5);
        transform: scale(1.5);
      }

      .ring > .slider-knob > .slider-knob-inner {
        background-color: var(--paper-slider-knob-start-color, transparent);
        border: 2px solid var(--paper-slider-knob-start-border-color, --paper-grey-400);
      }

      .slider-knob-inner::before {
        background-color: var(--paper-slider-pin-color, --google-blue-700);
      }

      .pin > .slider-knob > .slider-knob-inner::before {
        content: "";
        position: absolute;
        top: 0;
        left: 50%;
        margin-left: -13px;
        width: 26px;
        height: 26px;
        border-radius: 50% 50% 50% 0;

        -webkit-transform: rotate(-45deg) scale(0) translate(0);
        transform: rotate(-45deg) scale(0) translate(0);
      }

      .slider-knob-inner::before,
      .slider-knob-inner::after {
        transition: -webkit-transform .18s ease, background-color .18s ease;
        transition: transform .18s ease, background-color .18s ease;
      }

      .pin.ring > .slider-knob > .slider-knob-inner::before {
        background-color: var(--paper-slider-pin-start-color, --paper-grey-400);
      }

      .pin.expand > .slider-knob > .slider-knob-inner::before {
        -webkit-transform: rotate(-45deg) scale(1) translate(17px, -17px);
        transform: rotate(-45deg) scale(1) translate(17px, -17px);
      }

      .pin > .slider-knob > .slider-knob-inner::after {
        content: attr(value);
        position: absolute;
        top: 0;
        left: 50%;
        margin-left: -16px;
        width: 32px;
        height: 26px;
        text-align: center;
        color: var(--paper-slider-font-color, #fff);
        font-size: 10px;

        -webkit-transform: scale(0) translate(0);
        transform: scale(0) translate(0);
      }

      .pin.expand > .slider-knob > .slider-knob-inner::after {
        -webkit-transform: scale(1) translate(0, -17px);
        transform: scale(1) translate(0, -17px);
      }

      /* paper-input */
      .slider-input {
        width: 50px;
        overflow: hidden;
        --paper-input-container-input: {
          text-align: center;
        };
        @apply(--paper-slider-input);
      }

      /* disabled state */
      #sliderContainer.disabled {
        pointer-events: none;
      }

      .disabled > .slider-knob > .slider-knob-inner {
        background-color: var(--paper-slider-disabled-knob-color, --paper-grey-400);
        border: 2px solid var(--paper-slider-disabled-knob-color, --paper-grey-400);
        -webkit-transform: scale3d(0.75, 0.75, 1);
        transform: scale3d(0.75, 0.75, 1);
      }

      .disabled.ring > .slider-knob > .slider-knob-inner {
        background-color: var(--paper-slider-knob-start-color, transparent);
        border: 2px solid var(--paper-slider-knob-start-border-color, --paper-grey-400);
      }

      paper-ripple {
        color: var(--paper-slider-knob-color, --google-blue-700);
      }
    </style>

    <div id="sliderContainer" class$="[[_getClassNames(disabled, pin, snaps, immediateValue, min, expand, dragging, transiting, editable)]]">
      <div class="bar-container">
        <paper-progress disabled$="[[disabled]]" id="sliderBar" aria-hidden="true" min="[[min]]" max="[[max]]" step="[[step]]" value="[[immediateValue]]" secondary-progress="[[secondaryProgress]]" on-down="_bardown" on-up="_resetKnob" on-track="_onTrack">
        </paper-progress>
      </div>

      <template is="dom-if" if="[[snaps]]">
        <div class="slider-markers">
          <template is="dom-repeat" items="[[markers]]">
            <div class="slider-marker"></div>
          </template>
        </div>
      </template>

      <div id="sliderKnob" class="slider-knob" on-down="_knobdown" on-up="_resetKnob" on-track="_onTrack" on-transitionend="_knobTransitionEnd">
          <div class="slider-knob-inner" value$="[[immediateValue]]"></div>
      </div>
    </div>

    <template is="dom-if" if="[[editable]]">
      <paper-input id="input" type="number" step="[[step]]" min="[[min]]" max="[[max]]" class="slider-input" disabled$="[[disabled]]" value="[[immediateValue]]" on-change="_changeValue" on-keydown="_inputKeyDown" no-label-float="">
      </paper-input>
    </template>
  </template>

  <script>
    Polymer({
      is: 'paper-slider',

      behaviors: [
        Polymer.IronA11yKeysBehavior,
        Polymer.IronFormElementBehavior,
        Polymer.PaperInkyFocusBehavior,
        Polymer.IronRangeBehavior
      ],

      properties: {
        /**
         * If true, the slider thumb snaps to tick marks evenly spaced based
         * on the `step` property value.
         */
        snaps: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * If true, a pin with numeric value label is shown when the slider thumb
         * is pressed. Use for settings for which users need to know the exact
         * value of the setting.
         */
        pin: {
          type: Boolean,
          value: false,
          notify: true
        },

        /**
         * The number that represents the current secondary progress.
         */
        secondaryProgress: {
          type: Number,
          value: 0,
          notify: true,
          observer: '_secondaryProgressChanged'
        },

        /**
         * If true, an input is shown and user can use it to set the slider value.
         */
        editable: {
          type: Boolean,
          value: false
        },

        /**
         * The immediate value of the slider.  This value is updated while the user
         * is dragging the slider.
         */
        immediateValue: {
          type: Number,
          value: 0,
          readOnly: true,
          notify: true
        },

        /**
         * The maximum number of markers
         */
        maxMarkers: {
          type: Number,
          value: 0,
          notify: true
        },

        /**
         * If true, the knob is expanded
         */
        expand: {
          type: Boolean,
          value: false,
          readOnly: true
        },

        /**
         * True when the user is dragging the slider.
         */
        dragging: {
          type: Boolean,
          value: false,
          readOnly: true
        },

        transiting: {
          type: Boolean,
          value: false,
          readOnly: true
        },

        markers: {
          type: Array,
          readOnly: true,
          value: function() {
              return [];
          }
        },
      },

      observers: [
        '_updateKnob(value, min, max, snaps, step)',
        '_valueChanged(value)',
        '_immediateValueChanged(immediateValue)',
        '_updateMarkers(maxMarkers, min, max, snaps)'
      ],

      hostAttributes: {
        role: 'slider',
        tabindex: 0
      },

      keyBindings: {
        'left down pagedown home': '_decrementKey',
        'right up pageup end': '_incrementKey'
      },

      /**
       * Increases value by `step` but not above `max`.
       * @method increment
       */
      increment: function() {
        this.value = this._clampValue(this.value + this.step);
      },

      /**
       * Decreases value by `step` but not below `min`.
       * @method decrement
       */
      decrement: function() {
        this.value = this._clampValue(this.value - this.step);
      },

      _updateKnob: function(value, min, max, snaps, step) {
        this.setAttribute('aria-valuemin', min);
        this.setAttribute('aria-valuemax', max);
        this.setAttribute('aria-valuenow', value);

        this._positionKnob(this._calcRatio(value));
      },

      _valueChanged: function() {
        this.fire('value-change');
      },

      _immediateValueChanged: function() {
        if (this.dragging) {
          this.fire('immediate-value-change');
        } else {
          this.value = this.immediateValue;
        }
      },

      _secondaryProgressChanged: function() {
        this.secondaryProgress = this._clampValue(this.secondaryProgress);
      },

      _expandKnob: function() {
        this._setExpand(true);
      },

      _resetKnob: function() {
        this.cancelDebouncer('expandKnob');
        this._setExpand(false);
      },

      _positionKnob: function(ratio) {
        this._setImmediateValue(this._calcStep(this._calcKnobPosition(ratio)));
        this._setRatio(this._calcRatio(this.immediateValue));

        this.$.sliderKnob.style.left = (this.ratio * 100) + '%';
        if (this.dragging) {
          this._knobstartx = this.ratio * this._w;
          this.translate3d(0, 0, 0, this.$.sliderKnob);
        }
      },

      _calcKnobPosition: function(ratio) {
        return (this.max - this.min) * ratio + this.min;
      },

      _onTrack: function(event) {
        event.stopPropagation();
        switch (event.detail.state) {
          case 'start':
            this._trackStart(event);
            break;
          case 'track':
            this._trackX(event);
            break;
          case 'end':
            this._trackEnd();
            break;
        }
      },

      _trackStart: function(event) {
        this._w = this.$.sliderBar.offsetWidth;
        this._x = this.ratio * this._w;
        this._startx = this._x;
        this._knobstartx = this._startx;
        this._minx = - this._startx;
        this._maxx = this._w - this._startx;
        this.$.sliderKnob.classList.add('dragging');
        this._setDragging(true);
      },

      _trackX: function(event) {
        if (!this.dragging) {
          this._trackStart(event);
        }

        var dx = Math.min(this._maxx, Math.max(this._minx, event.detail.dx));
        this._x = this._startx + dx;

        var immediateValue = this._calcStep(this._calcKnobPosition(this._x / this._w));
        this._setImmediateValue(immediateValue);

        // update knob's position
        var translateX = ((this._calcRatio(this.immediateValue) * this._w) - this._knobstartx);
        this.translate3d(translateX + 'px', 0, 0, this.$.sliderKnob);
      },

      _trackEnd: function() {
        var s = this.$.sliderKnob.style;

        this.$.sliderKnob.classList.remove('dragging');
        this._setDragging(false);
        this._resetKnob();
        this.value = this.immediateValue;

        s.transform = s.webkitTransform = '';

        this.fire('change');
      },

      _knobdown: function(event) {
        this._expandKnob();

        // cancel selection
        event.preventDefault();

        // set the focus manually because we will called prevent default
        this.focus();
      },

      _bardown: function(event) {
        this._w = this.$.sliderBar.offsetWidth;
        var rect = this.$.sliderBar.getBoundingClientRect();
        var ratio = (event.detail.x - rect.left) / this._w;
        var prevRatio = this.ratio;

        this._setTransiting(true);

        this._positionKnob(ratio);

        this.debounce('expandKnob', this._expandKnob, 60);

        // if the ratio doesn't change, sliderKnob's animation won't start
        // and `_knobTransitionEnd` won't be called
        // Therefore, we need to manually update the `transiting` state

        if (prevRatio === this.ratio) {
          this._setTransiting(false);
        }

        this.async(function() {
          this.fire('change');
        });

        // cancel selection
        event.preventDefault();

        // set the focus manually because we will called prevent default
        this.focus();
      },

      _knobTransitionEnd: function(event) {
        if (event.target === this.$.sliderKnob) {
          this._setTransiting(false);
        }
      },

      _updateMarkers: function(maxMarkers, min, max, snaps) {
        if (!snaps) {
          this._setMarkers([]);
        }
        var steps = Math.round((max - min) / this.step);
        if (steps > maxMarkers) {
          steps = maxMarkers;
        }
        this._setMarkers(new Array(steps));
      },

      _mergeClasses: function(classes) {
        return Object.keys(classes).filter(
          function(className) {
            return classes[className];
          }).join(' ');
      },

      _getClassNames: function() {
        return this._mergeClasses({
          disabled: this.disabled,
          pin: this.pin,
          snaps: this.snaps,
          ring: this.immediateValue <= this.min,
          expand: this.expand,
          dragging: this.dragging,
          transiting: this.transiting,
          editable: this.editable
        });
      },

      _incrementKey: function(event) {
        if (!this.disabled) {
          if (event.detail.key === 'end') {
            this.value = this.max;
          } else {
            this.increment();
          }
          this.fire('change');
        }
      },

      _decrementKey: function(event) {
        if (!this.disabled) {
          if (event.detail.key === 'home') {
            this.value = this.min;
          } else {
            this.decrement();
          }
          this.fire('change');
        }
      },

      _changeValue: function(event) {
        this.value = event.target.value;
        this.fire('change');
      },

      _inputKeyDown: function(event) {
        event.stopPropagation();
      },

      // create the element ripple inside the `sliderKnob`
      _createRipple: function() {
        this._rippleContainer = this.$.sliderKnob;
        return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this);
      },

      // Hide the ripple when user is not interacting with keyboard.
      // This behavior is different from other ripple-y controls, but is
      // according to spec: https://www.google.com/design/spec/components/sliders.html
      _focusedChanged: function(receivedFocusFromKeyboard) {
        if (receivedFocusFromKeyboard) {
          this.ensureRipple();
        }
        if (this.hasRipple()) {
          // note, ripple must be un-hidden prior to setting `holdDown`
          if (receivedFocusFromKeyboard) {
            this._ripple.style.display = '';
          } else {
            this._ripple.style.display = 'none';
          }
          this._ripple.holdDown = receivedFocusFromKeyboard;
        }
      }
    });

    /**
     * Fired when the slider's value changes.
     *
     * @event value-change
     */

    /**
     * Fired when the slider's immediateValue changes. Only occurs while the
     * user is dragging.
     *
     * To detect changes to immediateValue that happen for any input (i.e.
     * dragging, tapping, clicking, etc.) listen for immediate-value-changed
     * instead.
     *
     * @event immediate-value-change
     */

    /**
     * Fired when the slider's value changes due to user interaction.
     *
     * Changes to the slider's value due to changes in an underlying
     * bound variable will not trigger this event.
     *
     * @event change
     */
  </script>
</dom-module>
<dom-module id="jso-opencga-login" assetpath="bower_components/jsorolla/src/lib/components/opencga/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: absolute;
            box-sizing: border-box;
            padding: 30px 100px;
            left: 0;
            right: 0;
            margin: 0px auto 0px auto;
            width: 500px;
            transition: all 0.2s;
            box-shadow: 0px 0px 12px 6px rgba(0, 0, 0, 0.30);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .title {
            text-align: center;
            font-size: 25px;
        }

        .icon {
            font-size: 50px;
            color: var(--dark-primary-color);
        }

        .message {
            margin-top: 20px;
        }

        .shortcut {
            cursor: pointer;
            color: var(--dark-primary-color);
            float: right;
        }

        .right {
            float: right;
        }

        .shortcut:hover {
            text-decoration: underline;
        }

        .button {
            color: var(--dark-button-color) !important;
        }
    </style>
    <template>
        <div class="title">
            <div>
                Login
            </div>
            <div class="icon">
                <i class="fa fa-sign-in"></i>
            </div>
        </div>
        <form id="form" vertical="" layout="" on-keypress="handleFormKey">
            <label class="jso">User</label>
            <input class="jso" type="text" value="{{user::input}}" required="" pattern="[a-zA-Z0-9\.]+">

            <span hidden$="{{hideSignup}}" class="shortcut" on-click="handleSignup">Create new user...</span>
            <br>
            <label class="jso">Password</label>
            <input class="jso" type="password" value="{{password::input}}" required="">

            <span hidden$="{{hideSignup}}" class="shortcut" on-click="handleRemember">Remember password...</span>
            <br>
            <br>

            <div class="button jso-btn jso-btn-shdw" on-click="handleForm">Login</div>
            <br>
            <div hidden$="{{hideAnonymous}}">
                <span class="shortcut" on-click="handleAnonymous">Login as anonymous</span>
                <br>
                <span class="right" style="color:#888">All data will be deleted on logout</span>
            </div>
        </form>
        <div class="message">{{message}}</div>
    </template>
</dom-module>

<script>
    Polymer({
        is: "jso-opencga-login",
        properties: {
            user: {
                type: String,
                value: ''
            },
            password: {
                type: String,
                value: ''
            },
            message: {
                type: String,
                value: ''
            },
            hideSignup: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            hideAnonymous: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
        },
        handleFormKey: function(e) {
            if (e.which == 13) {
                this.handleForm();
            }
        },
        handleRemember: function(e) {
            this.fire("remember", {});
        },
        handleSignup: function(e) {
            this.fire("signup", {});
        },
        handleForm: function(e) {
            this.message = '';
            this.user = this.user.trim();
            if (this.$.form.checkValidity()) {
                this._login();
            } else {
                this.message = "Only characters from a-z, numbers and . allowed in user field."
            }
        },
        handleAnonymous: function() {
            this.fire('anonymous');
        },
        _login: function() {
            var me = this;
            console.log(this.user)
            console.log(this.password)

            OpencgaManager.users.login({
                id: this.user,
                query: {
                    password: CryptoJS.SHA1(this.password).toString()
                },
                request: {
                    success: function(response) {
                        Cookies.set('bioinfo_sid', response.response[0].result[0].sessionId);
                        Cookies.set('bioinfo_user', response.response[0].result[0].userId);
                        me.fire('login', {
                            status: true
                        });
                        me.user = null;
                        me.password = null;
                    },
                    error: function(response) {
                        //Delete all cookies
                        Cookies.expire('bioinfo_sid');
                        Cookies.expire('bioinfo_user');
                        me.message = response.error.split(":")[1];
                        if (response.errorEvent) {
                            me.message = 'Server error, try again later.';
                        }
                    }
                }
            });
        }
    });
</script>
<dom-module id="jso-opencga-signup" assetpath="bower_components/jsorolla/src/lib/components/opencga/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: absolute;
            box-sizing: border-box;
            padding: 30px 100px;
            left: 0;
            right: 0;
            margin: 0px auto 0px auto;
            width: 500px;
            box-shadow: 0px 0px 12px 6px rgba(0, 0, 0, 0.30);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .title {
            text-align: center;
            font-size: 25px;
        }

        .icon {
            font-size: 50px;
            color: var(--dark-primary-color);
        }

        .message {
            margin-top: 20px;
        }

        .button {
            color: var(--dark-button-color) !important;
        }
    </style>
    <template>
        <div class="title">
            <div>
                Create a new user
            </div>
            <div class="icon">
                <i class="fa fa-pencil-square-o"></i>
            </div>
        </div>
        <form id="form" on-keypress="handleFormKey">
            <label class="jso">User name</label>
            <input class="jso" type="text" value="{{user::input}}" required="" pattern="[a-z0-9\.]+">
            <label class="jso">E-mail</label>
            <input class="jso" type="email" value="{{email::input}}" required="">
            <br>
            <label class="jso">Create a password</label>
            <input class="jso" type="password" value="{{password::input}}" required="">
            <label class="jso">Confirm your password</label>
            <input class="jso" type="password" value="{{passwordCheck::input}}" required="">

            
            
            

            <br>
            <br>

            <div class="button jso-btn jso-btn-shdw" on-click="handleForm">Sign up</div>
        </form>
        <div class="message">{{message}}</div>
    </template>
</dom-module>


<script>
    Polymer({
        is: "jso-opencga-signup",
        properties: {
            user: {
                type: String,
                value: ''
            },
            email: {
                type: String,
                value: ''
            },
            password: {
                type: String,
                value: ''
            },
            passwordCheck: {
                type: String,
                value: ''
            },
            message: {
                type: String,
                value: ''
            }
        },
        handleFormKey: function(e) {
            if (e.which == 13) {
                this.handleForm();
            }
        },
        handleForm: function(e) {
            this.message = '';

            if (this.$.form.checkValidity()) {
                if (this.password === this.passwordCheck) {
                    this._signup();
                } else {
                    alert("Sorry, your password does not match");
                }
            } else {
                alert("Please, you should fill all the fields. If error persist, contact crew at " + CONTACT_MAIL + ".");
            }
        },
        _signup: function() {
            var me = this;
            var userid = this.user.toLowerCase();
            OpencgaManager.users.create({
                query: {
                    userId: userid,
                    name: this.user,
                    email: this.email,
                    organization: '',
                    password: CryptoJS.SHA1(this.password).toString()
                },
                request: {
                    async: false,
                    success: function(response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            var userId = response.response[0].result[0].id;
                            me.message = userId + ' created';
                            me.login()
                        } else {
                            me.message = response.response[0].errorMsg;
                            //Delete cookies
                            Cookies.expire('bioinfo_sid');
                            Cookies.expire('bioinfo_user');
                        }
                    },
                    error: function(error) {
                        if (error.error.indexOf('already') >= 0) {
                            var err = "User '" + me.user + "' already exists."
                            alert(err);
                            me.message = err;
                        } else {
                            me.message = 'Server error, try again later.';
                        }
                    }
                }
            });
        },
        login: function(e) {
            var me = this;
            this.message = '';

            OpencgaManager.users.login({
                id: this.user,
                query: {
                    password: CryptoJS.SHA1(this.password).toString()
                },
                request: {
                    async: false,
                    success: function(response) {
                        console.log(response);
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            me.sid = response.response[0].result[0].sessionId;
                            Cookies.set('bioinfo_sid', response.response[0].result[0].sessionId);
                            Cookies.set('bioinfo_user', response.response[0].result[0].userId);
                            me.createProject(me.userId, me.sid);
                            me.createMetaProject(me.userId, me.sid);
                        } else {
                            me.message = response.response[0].errorMsg;
                            //Delete all cookies
                            Cookies.expire('bioinfo_sid');
                            Cookies.expire('bioinfo_user');
                        }
                    },
                    error: function() {
                        me.message = 'Server error, try again later.';
                    }
                }
            });
        },
        createProject: function(userId, sid) {
            var me = this;
            this.message = '';

            OpencgaManager.projects.create({
                query: {
                    userId: me.user,
                    sid: me.sid,
                    name: "Default project",
                    alias: "defaultPr",
                    description: "default project",
                    organization: this.organization
                },
                request: {
                    async: false,
                    success: function(response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            //                            me.message = 'Project created sucessfully.';
                            me.projectId = response.response[0].result[0].id;
                            me.createStudy()

                        } else {
                            me.message = response.response[0].errorMsg;
                        }
                    },
                    error: function() {
                        console.log('jso-opencga-signup201:Server error, try again later.');
                    }
                }
            });
        },
        createMetaProject: function(userId, sid) {
            var me = this;
            this.message = '';

            OpencgaManager.projects.create({
                query: {
                    userId: me.user,
                    sid: me.sid,
                    name: ".meta",
                    alias: "meta",
                    description: "meta",
                    organization: this.organization
                },
                request: {
                    async: false,
                    success: function(response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            //                            me.message = 'Project created sucessfully.';
                            var projectId = response.response[0].result[0].id;
                            me.createMetaStudy(projectId)

                        } else {
                            me.message = response.response[0].errorMsg;
                        }
                    },
                    error: function() {
                        console.log('jso-opencga-signup232:Server error, try again later.');
                    }
                }
            });

        },
        createMetaStudy: function(projectId) {
            var me = this;
            this.message = '';

            OpencgaManager.studies.create({
                query: {
                    sid: me.sid,
                    name: ".meta",
                    alias: "meta",
                    description: "meta",
                    organization: this.organization,
                    type: "FAMILY",
                    projectId: projectId

                },
                request: {
                    async: false,
                    success: function(response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {

                            me.user = "";
                            me.name = "";
                            me.email = "";
                            me.organization = "";
                            me.password = "";
                            me.check = "";

                        } else {
                            me.message = response.response[0].errorMsg;
                        }
                    },
                    error: function() {
                        console.log('jso-opencga-signup270:Server error, try again later.');
                    }
                }
            });
        },
        createStudy: function(e) {
            var me = this;
            this.message = '';
            //                var studyName = "WorkSpace";

            OpencgaManager.studies.create({
                query: {
                    sid: me.sid,
                    name: "Default study",
                    alias: "defaultSt",
                    description: "default study",
                    organization: this.organization,
                    type: "FAMILY",
                    projectId: me.projectId

                },
                request: {
                    async: false,
                    success: function(response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            //                            me.message = 'Study created sucessfully.';
                            me.studyId = response.response[0].result[0].id;

                            me.fire('login', {
                                status: true
                            });
                            //                            me.createAnalysis();

                        } else {
                            me.message = response.response[0].errorMsg;
                        }
                    },
                    error: function() {
                        console.log('jso-opencga-signup306:Server error, try again later.');
                    }
                }
            });
        }
    });
</script>
<dom-module id="jso-opencga-profile" assetpath="bower_components/jsorolla/src/lib/components/opencga/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: absolute;
            box-sizing: border-box;
            padding: 30px 100px;
            left: 0;
            right: 0;
            margin: 0px auto 0px auto;
            width: 500px;
            transition: all 0.2s;
            box-shadow: 0px 0px 12px 6px rgba(0, 0, 0, 0.30);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .title {
            text-align: center;
            font-size: 25px;
        }

        .icon {
            font-size: 50px;
            color: var(--dark-primary-color);
        }

        .message {
            margin: 20px 0 0 0;
            margin-bottom: 5px;
        }
        .button{
          color:var(--dark-button-color) !important;
        }

        #formEmail {
            margin-top: 40px;
        }

        #cancel {
            font-weight: normal;
            height: auto;
            padding: 5px 10px;
            border-radius: 3px;
            margin: 0 auto;
            margin-top: 15px;
            width: 100px;
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
        }

        #cancel:hover {
            background-color: var(--light-button-color) !important;
        }
    </style>
    <template>
        <div class="title">
            <div>
                User profile
            </div>
            <div class="icon">
                <i class="fa fa-user"></i>
            </div>
        </div>
        <form id="formPassword">
            <label class="jso">Old password</label>
            <input class="jso" type="password" value="{{oldpassword::input}}" required="" pattern="[a-zA-Z0-9\.]+">
            <br>
            <label class="jso">New password</label>
            <input class="jso" type="password" value="{{password::input}}" required="" pattern="[a-zA-Z0-9\.]+">
            <label class="jso">Check password</label>
            <input class="jso" type="password" value="{{passwordCheck::input}}" required="" pattern="[a-zA-Z0-9\.]+">
            <br>

            <div class="button jso-btn jso-btn-shdw" on-click="handleChangePasswordForm">Change password</div>
        </form>

        <form id="formEmail">
            <label class="jso">New e-mail</label>
            <input class="jso" type="email" value="{{email::input}}" required="">
            <br>

            <div class="button jso-btn jso-btn-shdw" on-click="handleChangeEmailForm">Change e-mail</div>
        </form>
        <div hidden$="{{!message}}" class="message">{{message}}</div>

        <div id="cancel" class="jso-btn jso-btn-shdw" on-click="handleCancel">Cancel
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-profile",
        properties: {
            email: {
                type: String,
                value: ''
            },
            oldpassword: {
                type: String,
                value: ''
            },
            password: {
                type: String,
                value: ''
            },
            passwordCheck: {
                type: String,
                value: ''
            },
            message: {
                type: String,
                value: ''
            }
        },
        clean: function() {
            this.set('oldpassword', '');
            this.set('password', '');
            this.set('passwordCheck', '');
            this.set('message', '');
        },
        handleChangePasswordForm: function(e) {
            var me = this;
            this.message = '';

            if (this.$.formPassword.checkValidity()) {
                if (this.password === this.passwordCheck) {
                    OpencgaManager.users.updatePassword({
                        id: Cookies('bioinfo_user'),
                        query: {
                            password: CryptoJS.SHA1(this.oldpassword).toString(),
                            npassword: CryptoJS.SHA1(this.password).toString(),
                            sid: Cookies('bioinfo_sid')
                        },
                        request: {
                            success: function(response) {
                                if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                    me.message = 'Password updated';
                                } else {
                                    me.message = response.response[0].errorMsg;
                                }
                            },
                            error: function() {
                                me.message = 'Server error, try again later.';
                            }
                        }
                    });
                } else {
                    this.set('message', 'Sorry, your new password does not match.');
                }
            } else {
                this.set('message', 'Please, you should fill all the fields.');
            }
        },
        handleChangeEmailForm: function(e) {
            var me = this;
            this.message = '';

            if (this.$.formEmail.checkValidity()) {
                OpencgaManager.users.updateEmail({
                    id: Cookies('bioinfo_user'),
                    query: {
                        nemail: this.email,
                        sid: Cookies('bioinfo_sid')
                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                me.message = 'E-mail updated';
                            } else {
                                me.message = response.response[0].errorMsg;
                            }
                        },
                        error: function() {
                            me.message = 'Server error, try again later.';
                        }
                    }
                });
            }else{
              me.message = 'E-mail format is not correct';
            }
        },
        handleCancel: function(e) {
            this.fire('profilecancel');
        }
    });
</script>
<dom-module id="jso-opencga-remember" assetpath="bower_components/jsorolla/src/lib/components/opencga/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: absolute;
            box-sizing: border-box;
            padding: 30px 100px;
            left: 0;
            right: 0;
            margin: 0px auto 0px auto;
            width: 500px;
            transition: all 0.2s;
            box-shadow: 0px 0px 12px 6px rgba(0, 0, 0, 0.30);
            background-color: var(--light-primary-color);
            color: var(--primary-text-color);
        }

        .title {
            text-align: center;
            font-size: 25px;
        }

        .icon {
            font-size: 50px;
            color: var(--dark-primary-color);
        }

        .message {
            margin-top: 20px;
        }
    </style>
    <template>
        <div class="title">
            <div>
                Remember password
            </div>
            <div class="icon color-2">
                <i class="fa fa-life-ring"></i>
            </div>
        </div>
        <form id="form" vertical="" layout="" on-keypress="handleFormKey">
            <label class="jso">User ID</label>
            <input class="jso" type="text" value="{{user::input}}" required="" pattern="[a-zA-Z0-9\.]+">
            <br>
            <label class="jso">e-mail</label>
            <input class="jso" type="email" value="{{email::input}}" required="">
            <br>
            <br>

            <div class="jso-btn jso-btn-shdw" on-click="handleForm">Send email with new password</div>
        </form>

        <div class="horizontal layout center message">
            <template is="dom-if" if="{{loading}}">
                <i class="fa fa-spinner fa-spin" style="margin-right: 5px;"></i>
            </template>
            <div>{{message}}</div>
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-remember",
        properties: {
            email: {
                type: String,
                value: ''
            },
            user: {
                type: String,
                value: ''
            },
            message: {
                type: String,
                value: ''
            },
            loading: {
                type: Boolean,
                value: false
            }
        },
        //        created: function () {
        //            this.user;
        //            this.email;
        //        },
        handleFormKey: function(e) {
            if (e.which == 13) {
                this.handleForm();
            }
        },
        handleForm: function(e) {
            var me = this;
            this.message = '';
            this.loading = false;

            if (this.$.form.checkValidity()) {
                this.message = 'Processing request...';
                this.loading = true;
                OpencgaManager.users.resetPassword({
                    id: this.user,
                    query: {
                        email: this.email
                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                var userId = response.response[0].result[0].id;
                                me.message = 'An email was sent with a new password';
                            } else {
                                me.message = response.response[0].errorMsg;
                            }
                            me.loading = false;
                        },
                        error: function() {
                            me.message = 'Server error, try again later.';
                            me.loading = false;
                        }
                    }
                });
            }
        }
    });
</script>

<dom-module id="jso-opencga-header" assetpath="bower_components/jsorolla/src/lib/components/opencga/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
            cursor: default;
            width: 100%;
        }

        .main {
            position: relative;
            height: 60px;
            font-size: 18px;
            margin: 0;
            padding: 0;
            text-transform: none;
            box-shadow: 0 4px 4px 0px rgba(0, 0, 0, 0.3);
            /*background-color: inherit;*/
            background-color: var(--dark-primary-color);
            color: var(--text-primary-color);
        }

        #tools {
            position: absolute;
            top: 60px;
            width: 100%;
        }

        #left > div,
        #right > div,
        #menu-wrapper >::content > .menu div.option {
            box-sizing: border-box;
            cursor: pointer;
            text-align: center;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #left > div >::content > * {
            margin-left: 10px;
            padding: 0 0 1px 0;
        }

        #right > div,
        #menu-wrapper >::content > .menu div.option {
            margin-right: 5px;
            padding: 0 5px 1px 5px;
        }

        :host[small] #left > div,
        :host[small] #right > div,
        :host[small] #menu-wrapper >::content > .menu div.option {
            border-bottom-width: 1px;
        }

        #right > div:hover,
        #menu-wrapper >::content > .menu div.option:hover {
            border-bottom-color: var(--divider-color);
        }

        #menu-wrapper >::content > .menu div.option[active] {
            font-weight: normal;
            border-bottom-color: var(--accent-color);
        }

        :host[small] #right > div:hover,
        :host[small] #menu-wrapper >::content > .menu div.option:hover {
            border-bottom-width: 1px;
        }

        #help,
        #user {
            border-bottom: none !important;
        }

        div.title {
            font-size: 30px;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }

        div.description {
            font-size: 18px;
        }

        div.description:hover {
            cursor: default;
        }

        @media (max-width: 1250px) {
            div.title {
                font-size: 24px;
            }
            div.description {
                font-size: 14px;
            }
            .option-text {
                font-size: 0.9em;
            }
        }

        @media (max-width: 1150px) {
            div.title {
                font-size: 20px;
            }
            div.description {
                font-size: 13px;
            }
            .option-text {
                font-size: 0.8em;
            }
        }

        @media (max-width: 1050px) {
            .option-text {
                display: none;
            }
        }

        #user {
            color: var(--accent-color);
            font-weight: normal;
        }

        #icon {
            margin-top: 0px !important;
            margin-bottom: 0px !important;
        }
        /*small*/

        :host[small] .main {
            height: 32px;
            font-size: 15px;
            box-shadow: 0 2px 2px 0px rgba(0, 0, 0, 0.3);
        }

        :host[small] #tools {
            top: 32px;
        }

        :host[small] div.title {
            font-size: 22px;
        }

        :host[small] div.description {
            font-size: 15px;
        }
    </style>
    <template>
        <div id="tools">
            <jso-opencga-login id="jsoLogin" hide-signup$="{{hideSignup}}" hide-anonymous$="{{hideAnonymous}}" menu-option="login" on-login="handleLogin" on-remember="handleRemember" on-signup="handleSignup" on-anonymous="handleAnonymous">
            </jso-opencga-login>

            <jso-opencga-signup id="jsoSignup" on-login="handleLogin" menu-option="signup">
            </jso-opencga-signup>

            <jso-opencga-profile id="jsoProfile" menu-option="profile" on-profilecancel="handleCancel">
            </jso-opencga-profile>

            <jso-opencga-remember menu-option="remember">
            </jso-opencga-remember>
        </div>

        <div class="main horizontal layout center">
            <div id="left" class="horizontal layout start-justified center">
                <div on-click="handleMenu">
                    <content select=".menu-button"></content>
                </div>
                <div id="icon" data-option="home" on-click="handleMenu">
                    <content select=".icon"></content>
                </div>
                <div class="title" data-option="home" on-click="handleMenu">
                    <content select=".title"></content>
                </div>
                <div id="description" class="description" data-option="home" on-click="handleMenu">
                    <content select=".description"></content>
                </div>
            </div>
            <div id="center" class="horizontal layout flex center">
                <div id="menu-wrapper" hidden$="{{computeMenu(showMenuOnLogin, isLogged)}}" class="horizontal layout flex">
                    <content select=".menu"></content>
                </div>
            </div>
            <div id="right" class="horizontal layout end-justified center">
                <div id="user" hidden$="{{computeUser(hideLogin, isLogged)}}">
                    <span class="option-text">{{userText}}</span>
                </div>

                <div title="Upload" id="projects" data-option="projects" on-click="handleMenu" hidden$="{{computeBrowse(hideBrowse, hideLogin, isLogged)}}">
                    <span class="option-text"> upload </span>
                </div>

                <div title="Profile" id="profile" data-option="profile" on-click="handleMenu" hidden$="{{computeProfile(userText, hideSignup, hideLogin, isLogged)}}">
                    <i class="fa fa-user"></i>
                    <span class="option-text"> profile </span>
                </div>

                <div title="Logout" id="logout" on-click="handleLogoutClick" hidden$="{{computeLogout(hideLogin, isLogged)}}">
                    <i class="fa fa-sign-out"></i>
                    <span class="option-text"> logout </span>
                </div>

                <div title="Login" id="login" data-option="login" on-click="handleMenu" hidden$="{{computeLogin(hideLogin, isLogged)}}">
                    <i class="fa fa-sign-in"></i>
                    <span class="option-text"> Login </span>
                </div>

                <div title="Sign up" id="signup" data-option="signup" on-click="handleMenu" hidden$="{{computeSignup(hideSignup, hideLogin, isLogged)}}">
                    <i class="fa fa-pencil-square-o"></i>
                    <span class="option-text"> Sign up </span>
                </div>


                <div id="help">
                    <content select=".helpmenu"></content>
                </div>
            </div>
        </div>
    </template>

    
</dom-module>

<script>
    Polymer({
        is: "jso-opencga-header",
        properties: {
            checkTimeInterval: {
                type: Number,
                value: 5000,
                reflectToAttribute: true
            },
            selectedOption: {
                type: String,
                value: "home",
                notify: true,
                reflectToAttribute: true,
                observer: 'selectedOptionChanged'
            },
            hideLogin: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            hideSignup: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            /* @Deprecated */
            showMenuOnLogin: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            isLogged: {
                type: Boolean,
                value: false
            },
            hideAnonymous: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            hideBrowse: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            showJobs: {
                type: Boolean,
                value: true
            },
            userData: {
                type: Object,
                notify: true
            },
            userText: {
                type: String,
                value: ''
            },
            jobItem: {
                type: Object
            },
            selectedStudy: {
                type: Object
            },
            allowedTools: {
                type: Array
            },
            small: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            }
        },

        computeMenu: function(showMenuOnLogin, isLogged) {
            if (showMenuOnLogin) {
                return !isLogged;
            }
            return false;
        },

        computeUser: function(hideLogin, isLogged) {
            if (hideLogin) {
                return true;
            }
            return !isLogged
        },
        computeBrowse: function(hideBrowse, hideLogin, isLogged) {
            if (hideLogin || hideBrowse) {
                return true;
            }
            return !isLogged
        },
        computeProfile: function(userText, hideSignup, hideLogin, isLogged) {
            if (hideSignup || hideLogin || userText == 'anonymous') {
                return true;
            }
            return !isLogged
        },
        computeLogout: function(hideLogin, isLogged) {
            if (hideLogin) {
                return true;
            }
            return !isLogged
        },
        computeSignup: function(hideSignup, hideLogin, isLogged) {
            if (hideLogin || hideSignup) {
                return true;
            }
            return isLogged
        },
        computeLogin: function(hideLogin, isLogged) {
            if (hideLogin) {
                return true;
            }
            return isLogged
        },
        selectedOptionChanged: function(neo, old) {
            var menuItems = Polymer.dom(this.root).querySelectorAll('[menu-option]');
            for (var i = 0; i < menuItems.length; i++) {
                var item = menuItems[i];
                var currentItemValue = item.getAttribute("menu-option");
                if (neo == currentItemValue) {
                    item.removeAttribute("hidden");
                } else {
                    item.setAttribute('hidden', '');
                }
            }
        },
        //TODO
        ready: function() {
            if (!this.hideLogin) {
                if (Cookies("bioinfo_sid") && Cookies("bioinfo_user")) {
                    this.sessionInitiated();
                } else {
                    this.logout();
                }
            }
        },
        handleRemember: function(e) {
            this.selectedOption = 'remember';
        },
        handleSignup: function(e) {
            this.selectedOption = 'signup';
        },
        handleAnonymous: function(e) {
            this.anonymousSign();
        },
        handleMenu: function(e) {
            var option = e.currentTarget.dataset['option'];
            console.log(option);
            if (option) {
                this.selectedOption = option;
            }
        },
        handleJobClick: function(e) {
            this.showJobs = !this.showJobs;
        },
        handleLogoutClick: function(e) {
            this.sessionFinished();
        },
        handleSupportMenu: function(e) {
            this.$.helpMenu.classList.toggle('help-menu-shown');
        },
        handleHelpMenuMouseOut: function() {
            this.$.helpMenu.classList.remove('help-menu-shown');
        },
        handleLogin: function(e) {
            if (e.detail.status) {
                this.sessionInitiated();
            } else {
                this.sessionFinished();
            }
            this.fire('session-change');
        },
        demoLogin: function(username) {
            this.$.jsoLogin.user = username;
            this.$.jsoLogin.password = "demo";
            this.$.jsoLogin._login();
        },
        anonymousSign: function() {
            this.$.jsoSignup.user = "anonymous" + Utils.randomString(40).toLowerCase(); // all usernames must be lowercased because opencga fails  creating default projects with users like "Zaida" & "zaida".
            this.$.jsoSignup.name = "anonymous";
            this.$.jsoSignup.email = "anonymous@anonymous.anonymous";
            this.$.jsoSignup.organization = "none";
            this.$.jsoSignup.password = "anonymous";
            this.$.jsoSignup._signup();
        },
        sessionInitiated: function(e) {
            var me = this;

            this.isLogged = true;
            this.selectedOption = 'home';

            /**START OPENCGA CHECK**/
            if (!this.userInfoInterval) {
                this.getUserInfo(); //first call
                this.userInfoInterval = setInterval(function() {
                    me.getUserInfo();
                }, this.checkTimeInterval);
            }
            this.fire("login");
        },
        sessionFinished: function(e) {
            this.userData = null;
            this.showJobs = false;
            this.selectedOption = 'home';
            this.isLogged = false;
            Cookies.expire('bioinfo_sid');
            Cookies.expire('bioinfo_user');

            /**END OPENCGA CHECK**/
            clearInterval(this.userInfoInterval);
            this.userInfoInterval = null;
            this.fire("logout");
        },
        getUserInfo: function(force) {
            var me = this;
            var lastActivity = null;
            if (force != true) {
                if (this.userData != null) {
                    lastActivity = this.userData.lastActivity;
                }
            }
            var user = Cookies('bioinfo_user');
            if (!user) {
                console.log('cookie: bioinfo_user, is not set, session will be finished...');
                this.sessionFinished();
            } else {
                OpencgaManager.users.read({
                    id: user,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                        lastActivity: lastActivity
                    },
                    request: {
                        success: function(response) {
                            if ((response.response[0].errorMsg === '' || response.response[0].errorMsg == null) && response.response[0].result.length > 0) {
                                me.userData = response.response[0].result[0];
                                me.userText = me._checkUserName(me.userData);
                                console.log("userData has been modified since last call");
                            }
                            if (response.response[0].errorMsg != null && response.response[0].errorMsg.indexOf('Invalid sessionId for user') !== -1) {
                                me.sessionFinished()
                            }
                        },
                        error: function() {
                            console.log('Server error, try again later.');
                        }
                    }
                });
            }
        },
        logout: function() {
            var me = this;
            var user = Cookies('bioinfo_user');
            if (!user) {
                console.log('cookie: bioinfo_user, is not set, session will be finished...');
                this.sessionFinished();
            } else {
                OpencgaManager.users.logout({
                    id: user,
                    query: {
                        sid: Cookies('bioinfo_sid')
                    },
                    request: {
                        success: function(response) {
                            console.log(response);
                        },
                        error: function() {
                            console.log('Server error, try again later.');
                        }
                    }
                });
            }
        },
        _checkUserName: function(userData) {
            if (userData.email === 'anonymous@anonymous.anonymous') {
                return 'anonymous';
            } else {
                return userData.name;
            }
        },
        handleCancel: function(e){
          this.selectedOption = 'home';
        }
    });
</script>
<dom-module id="jso-opencga-footer" assetpath="bower_components/jsorolla/src/lib/components/opencga/">
    <style is="custom-style">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
            width: 100%;
            height: 100px;
            cursor: default;
            box-shadow: 0px 0px 5px 5px rgba(0, 0, 0, 0.3);
            padding: 10px;
            text-align: center;
            margin-bottom: 0px;
            background-color: var(--dark-primary-color);
            color: var(--text-primary-color);
        }
    </style>
    <template>
        <content></content>
    </template>
</dom-module>

<script>
    // element registration
    Polymer({
        is: "jso-opencga-footer"
    });
</script>
<dom-module id="jso-opencga-study-tree" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
        }

        :host:hover {
            background-color: #ddd;
        }

        :host[selected] > .main {
            background-color: #ccc;
        }

        .main {
            border: 1px solid transparent;
            padding-left: 12px;
        }

        .name:before {
            font-family: "FontAwesome";
            display: inline-block;
            width: 20px;
            text-align: center;
            content: '\f02d';
        }

        .arrow:before {
            font-family: "FontAwesome";
            display: inline-block;
            width: 15px;
            text-align: center;
            content: '\f0da';
        }

        .arrow[open]:before {
            content: '\f0d7';
        }

        .arrow[empty]:before {
            content: '\00a0';
        }

        .arrow {
            padding: 2px 0 2px 2px;
        }

        .name {
            padding: 2px 2px 2px 0;
        }
    </style>
    <template>
        <div class="main horizontal layout">
            <div class="arrow" empty$="{{isEmpty(study)}}" open$="{{open}}" on-click="handleArrowClick"></div>
            <div class="name flex" on-click="handleClick">{{study.name}}</div>
        </div>
        <div hidden$="{{!open}}">

        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-study-tree",
        properties: {
            study: {
                type: Object
            },
            selected: {
                type: Boolean,
                reflectToAttribute: true
            },
            open: {
                type: Boolean,
                value: false
            }
        },
        isEmpty: function (study) {
            return study.files.length <= 0;
        },
        handleClick: function (e) {
        },
        handleArrowClick: function (e) {
            if (this.study.files.length > 0) {
                this.open = !this.open;
            }
        }
    });
</script>
<dom-module id="jso-opencga-project-tree" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
        }

        :host[selected] > .main > .name {
            /*font-weight: bold;*/
        }

        .main {
            border: 1px solid transparent;
        }

        .name:before {
            font-family: "FontAwesome";
            display: inline-block;
            width: 20px;
            text-align: center;
            content: '\f0b1';
        }

        .arrow:before {
            font-family: "FontAwesome";
            display: inline-block;
            width: 12px;
            text-align: center;
            content: '\f0da';
        }

        .arrow[open]:before {
            content: '\f0d7';
        }

        .arrow[empty]:before {
            content: '\00a0';
        }

        .arrow {
            padding: 2px 0 2px 2px;
        }

        .name {
            padding: 2px 2px 2px 0;
        }

    </style>
    <template>
        <div class="main horizontal layout jso-nosel">
            <div class="arrow" empty$="{{isEmpty(project)}}" open$="{{open}}" on-click="handleArrowClick"></div>
            <div class="name flex" on-click="handleClick" on-dblclick="handleDblclick">{{project.name}}</div>
        </div>
        <div hidden$="{{!open}}">
            <template is="dom-repeat" items="{{project.studies}}">
                <jso-opencga-study-tree on-click="handleStudyClick" study="{{item}}">
                </jso-opencga-study-tree>
            </template>
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-project-tree",
        properties: {
            project: {
                type: Object
            },
            selected: {
                type: Boolean,
                reflectToAttribute: true
            },
            selectedStudy: {
                type: Object
            },
            open: {
                type: Boolean,
                value: true
            }
        },
        isEmpty: function (project) {
            return project.studies.length <= 0;
        },
        handleClick: function (e) {
            this.fire('clickproject');
//            this.selectedStudy = null;
        },
        handleDblclick: function (e) {
            this.toggleOpen();
        },
        handleArrowClick: function (e) {
            this.toggleOpen();
        },
        handleStudyClick: function (e) {
            this.selectedStudy = e.currentTarget;
            this.fire('clickstudy');
        },
        toggleOpen: function () {
            if (this.project.studies.length != 0) {
                this.open = !this.open;
            }
        }
    });
</script>
<dom-module id="jso-opencga-project-select" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        .selbox {
            box-sizing: border-box;
            background-color: #FFF;
            height: 150px;
            overflow-y: auto;
            border: 1px solid #d3d3d3;
        }

        .project-item {
            padding: 2px 5px;
        }

        .project-item:hover {
            background-color: #eee;
        }

        .project-item[data-checked] {
            background-color: #ddd;
        }

        label.jso {
            display: block;
        }

    </style>
    <template>
        <div class="horizontal layout">
            <div class="flex">
                <label class="jso">Projects:</label>

                <div class="selbox" id="projects">
                    <template is="dom-repeat" items="{{projects}}">
                        <div class="project-item" on-click="handleProjectClick" data-id$="{{item.id}}">
                            <span>{{item.name}}</span>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </template>

</dom-module>
<script>
    Polymer({
        is: "jso-opencga-project-select",
        properties: {
            projects: {
                type: Array,
                observer: 'projectsChanged'
            },
            selectedProject: {
                type: String
            }
        },
        handleProjectClick: function (e) {
            var sel = this.querySelectorAll('.project-item');
            for (var i = 0; i < sel.length; i++) {
                var el = sel[i];
                el.removeAttribute('data-checked');
            }
            this.selectedProject = e.currentTarget.dataset.id;
            e.currentTarget.setAttribute('data-checked', '')
        },
        projectsChanged: function (neo, old) {
            var found = false;
            for (var i = 0; i < neo.length; i++) {
                var p = neo[i];
                if (p.id == parseInt(this.selectedProject)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                this.selectedProject = null;
            }
        }
    });
</script>
<dom-module id="jso-opencga-create-study" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            width: 300px;
            padding: 20px 30px;
        }
    </style>
    <template>

        <jso-opencga-project-select id="projectSelect" projects="{{projects}}">
        </jso-opencga-project-select>

        <br>

        <form id="form" onsubmit="return false">

            <div>
                <label class="jso">Study type</label>
                <label class="jso-control">
                    <input value="FAMILY" type="radio" name="type" checked="">
                    <span>Family</span>
                </label>
                <label class="jso-control">
                    <input value="CASE_CONTROL" type="radio" name="type">
                    <span>Case / Control</span>
                </label>
                <label class="jso-control">
                    <input value="TRIO" type="radio" name="type">
                    <span>Trio</span>
                </label>
                <label class="jso-control">
                    <input value="PAIRED" type="radio" name="type">
                    <span>Paired</span>
                </label>
                <label class="jso-control">
                    <input value="CASE_SET" type="radio" name="type">
                    <span>Case set</span>
                </label>
                <label class="jso-control">
                    <input value="CONTROL_SET" type="radio" name="type">
                    <span>Control set</span>
                </label>
            </div>
            <br>
            <jso-opencga-input-text id="input" label="Study name:" placeholder="New study" tooltip="Please, use only the requested format: letter, numbers, spaces or underscore" pattern="^[\w ]+$" required="">
            </jso-opencga-input-text>

            
            
            
            <br>
            <input class="jso-btn jso-btn-shdw" type="submit" value="Create" on-click="handleForm">
        </form>
    </template>

</dom-module>
<script>
    Polymer({
        is: "jso-opencga-create-study",
        properties: {
            projects: {
                type: Array,
                notify: true
            },
            name: {
                type: String
            }
        },
        handleForm: function() {
            var me = this;
            if (this.$.projectSelect.selectedProject == null) {
                alert("Please select a Project");
                return;
            }

            if (this.$.form.checkValidity()) {

                // OpencgaManager.studies.create({
                //     query: {
                //         sid: Cookies('bioinfo_sid'),
                //         name: this.$.input.value,
                //         alias: this.$.input.value.replace(/ /gi, ''),
                //         description: '',
                //         organization: '',
                //         type: this.querySelector('input[name="type"]:checked').value,
                //         projectId: this.$.projectSelect.selectedProject
                //
                //     },
                //     request: {
                //         async: true,
                //         success: function(response) {
                //             if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                //                 //                                me.message = 'Study created sucessfully.';
                //                 me.name = "";
                //                 me.fire('need-refresh');
                //                 me.fire('study-created');
                //             } else {
                //                   console.log('jso-opencga-create-study102:Server error, try again later.');
                //             }
                //         },
                //         error: function() {
                //               console.log('jso-opencga-create-study106:Server error, try again later.');
                //         }
                //     }
                // });

                var url = OpencgaManager.studies.create({
                    query: {
                        sid: Cookies('bioinfo_sid'),
                        projectId: this.$.projectSelect.selectedProject
                    },
                    request: {
                        method: "POST",
                        url: true
                    }
                });

                var query = {
                    name: this.$.input.value,
                    alias: this.$.input.value.replace(/ /gi, ''),
                    description: '',
                    type: this.querySelector('input[name="type"]:checked').value,
                }

                var xhr = new XMLHttpRequest();
                xhr.open('POST', url, true);
                xhr.setRequestHeader("Content-Type", "application/json");

                xhr.onload = function(e) {
                    var response = JSON.parse(this.response);
                    if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                        me.name = "";
                        me.fire('need-refresh');
                        me.fire('study-created');
                    } else {
                        console.log('jso-opencga-create-study140:Server error, try again later.');
                    }
                };
                xhr.send(JSON.stringify([query]));
            }
        }
    });
</script>
<dom-module id="jso-opencga-create-project" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            width: 300px;
            padding: 20px 30px;
        }

    </style>
    <template>
        <form id="form" onsubmit="return false">
            <jso-opencga-input-text id="input" label="Project name:" placeholder="New project" tooltip="Please, use only the requested format: letter, numbers, spaces or underscore" pattern="^[\w ]+$" required="">
            </jso-opencga-input-text>
            <input class="jso-btn jso-btn-shdw" type="submit" value="Create" on-click="handleForm">
        </form>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-create-project",
        handleForm: function () {
            var me = this;
            if (this.$.form.checkValidity()) {
                OpencgaManager.projects.create({
                    query: {
                        userId: Cookies('bioinfo_user'),
                        sid: Cookies('bioinfo_sid'),
                        name: this.$.input.value,
                        alias: this.$.input.value.replace(/ /gi, ''),
                        description: '',
                        organization: ''
                    },
                    request: {
                        async: true,
                        success: function (response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
//                                me.message = 'Project created sucessfully.';
                                me.$.input.name = "";
                                me.fire('need-refresh');
                                me.fire('project-created');
                            } else {
                                console.log('Create Project: Server error, try again later.');
                            }
                        },
                        error: function () {
                            console.log('Create Project: Server error, try again later.');
                        }
                    }
                });
            }
//            else{
//                this.$.input.message = this.$.input.$.input.validationMessage;
//            }
        }
    });
</script>
<dom-module id="jso-opencga-sample-list-item" assetpath="bower_components/jsorolla/src/lib/components/opencga/samples/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
        }

        :host:hover {
            background-color: #ddd;
        }

        :host[selected] {
            background-color: #ccc;
        }

        .name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #source {
            color: #444;
            width: 120px;
            text-transform: capitalize;
        }

        .icon {
            margin: 2px;
            padding: 10px;
            height: 40px;
            width: 100px;
            border: 1px solid var(--divider-color);
        }

        .title {
            margin-right: 10px;
            width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .addButton {
            text-align: center;
            color: #445D76;
            margin: 2px;
            width: 50px;
            height: 18px;
            line-height: 17px;
        }

        #addSuspPanel .container {
            padding: 5px;
            height: 55px;
            width: 300px;
        }
    </style>
    <template>
        <div class="horizontal layout">
            <template is="dom-if" if="{{computeViewMode(viewMode,'list')}}">
                <div class="horizontal layout">
                    <div class="name title" title$="{{sample.name}}">{{sample.name}}</div>
                    
                </div>
                <div id="status" class="title">
                    <i class$="{{computeStatusIcon(sample.status)}}"></i>
                    <span style="">{{sample.status}}</span>
                </div>
                <div id="source" class="title" title$="{{sample.source}}">
                    <span>{{sample.source}}</span>
                </div>
                <div id="susp" class="title" title$="{{suspicious}}" hidden$="{{!enableDiagnostic}}">
                    <span hidden$="{{!isSuspAdded}}">{{suspicious}}</span>
                    <div class="jso-btn jso-btn-shdw addButton" on-click="showListICD" title="Add suspected diagnosis for this Sample" hidden$="{{isSuspAdded}}"><i class="fa fa-plus-square-o"></i>&nbsp; Add</div>
                </div>
                <div id="diag" class="title" title$="{{diagnostic}}" hidden$="{{!enableDiagnostic}}">
                    <span>{{diagnostic}}</span>
                </div>
                <div id="Cohort" class="title" hidden$="{{disableCaseControl}}">
                    <span style="">{{sample.cohort}}</span>
                </div>
            </template>
            <jso-panel id="addSuspPanel" modal="" closable="" hidden="" on-click="handleaddSuspPanelClick">
                <div class="header">
                    Add suspected diagnosis
                </div>
                <div class="container">
                    <input type="text" id="{{sample.name}}" style="width:98%">
                    <div style="margin:0 auto; margin-top:5px;" class="jso-btn jso-btn-shdw addButton" on-click="handleAddSuspicious" title="Add suspected diagnosis for this Sample" hidden$="{{isSuspAdded}}"><i class="fa fa-plus-square-o"></i>&nbsp; Add</div>
                </div>
            </jso-panel>

            <template is="dom-if" if="{{computeViewMode(viewMode,'icon')}}">
                <div class="icon">
                    <div class="name flex" title$="{{sample.name}}">{{sample.name}}</div>
                </div>
            </template>
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-sample-list-item",
        properties: {
            sample: {
                type: Object,
                notify: true,
                observer: "sampleChanged"
            },
            viewMode: {
                type: String,
                value: 'list',
                reflectToAttribute: true
            },
            confDiag: {
                type: String,
                value: ''
            },
            suspDiag: {
                type: String,
                value: ''
            },
            disableCaseControl: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            enableDiagnostic: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            isSuspAdded: {
                type: Boolean,
            }
        },
        sampleChanged: function(neo, old) {
            this.set('suspicious', "");
            this.set('diagnostic', "");
            this.set("isSuspAdded", false);
            if (neo.description != "") {
                var information = JSON.parse(neo.description);
                if (information.suspDiag != null && information.suspDiag != "") {
                    this.set("isSuspAdded", true);
                    this.set('suspicious', information.suspDiag);
                }
                if (information.confDiag != null) {
                    this.set('diagnostic', information.confDiag);
                }
            }
        },
        computeViewMode: function(viewMode, value) {
            return viewMode == value;
        },
        computeStatusIcon: function(status) {
            if (status == "INDEXING") {
                return 'fa fa-cog fa-spin';
            } else if (status == "READY") {
                return 'fa fa-check';
            } else if (status == "NONE") {
                return 'fa fa-check';
            } else {
                return '';
            }
        },
        handleSampleRename: function(e) {
            var me = this;
            var newName = e.currentTarget.innerHTML;
            if (this.sample.name != newName) {
                OpencgaManager.samples.update({
                    id: me.sample.id,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                        name: newName,
                        description: me.sample.description,
                        source: me.sample.source,
                        individualId: me.sample.individualId
                    },
                    request: {
                        async: false,
                        success: function(response) {
                            alert("The sample name has been changed succesfully.")
                        },
                        error: function() {

                        }
                    }
                });
            }
        },
        showListICD: function(e) {
            e.stopPropagation();
            if (this.sample.status == "INDEXING") {
                alert("VCF is indexing, try later");
            } else {
                this.$.addSuspPanel.hidden = false;
            }
        },
        handleAddSuspicious: function(e) {
            e.stopPropagation();
            elem = this.$.addSuspPanel.querySelectorAll('input');
            var susp = elem[0].value;
            if (confirm("Suspected diagnosis: '" + susp + "' , save?")) {
                var me = this;
                var infor = {};
                if (this.sample.description != "") {
                    infor = JSON.parse(this.sample.description);
                }
                this.set('suspicious', susp);
                if (susp != infor["suspDiag"]) {
                    infor["suspDiag"] = susp;
                    var description = JSON.stringify(infor);
                    OpencgaManager.samples.update({
                        id: me.sample.id,
                        query: {
                            sid: Cookies('bioinfo_sid'),
                            description: description,
                            source: me.sample.source,
                            individualId: me.sample.individualId
                        },
                        request: {
                            async: false,
                            success: function(response) {
                                me.$.addSuspPanel.hidden = true;
                                me.set("isSuspAdded", true);
                                alert("Suspected Diagnosis has been added succesfully.")
                            },
                            error: function() {

                            }
                        }
                    });
                }
            }
        },
        handleaddSuspPanelClick: function(e) {
            e.stopPropagation();
        }
    });
</script>
<dom-module id="jso-select-box" assetpath="bower_components/jsorolla/src/lib/components/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            overflow-y: auto;
            border: 1px solid var(--divider-color);
            background-color: #FFF;
        }

        .item {
            padding: 2px 5px;
            cursor: pointer;
        }

        .item:hover {
            background-color: var(--hover-color);
        }

        .item[data-checked] {
            background-color: var(--selected-color);
        }
    </style>
    <template>
        <template is="dom-repeat" items="{{options}}" as="option">
            <div class="item flex" data-checked$="{{isSelected(selected, option)}}" on-mousedown="handleSelect">
                <span>{{computeOptionDisplay(option)}}</span>
            </div>
        </template>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'jso-select-box',
        properties: {
            options: {
                type: Array,
                value: function() {
                    return []
                },
                observer: 'optionsChanged'
            },
            selected: {
                type: Object
            },
            selectFirst: {
                type: Boolean,
                reflectToAttribute: true,
                value: true
            },
            nameAttribute: {
                type: String,
                value: 'name'
            },
            titleAttribute: {
                type: String,
                value: 'title'
            }
        },
        computeOptionDisplay: function(option) {
            return option[this.titleAttribute];
        },
        optionsChanged: function() {
            if (this.selected != null && this.selected.name) {
                this.selectByName(this.selected.name);
            } else {
                this.selectByIndex(0);
            }
        },
        handleSelect: function(e) {
            this.set('selected', e.model.option);
            this.fire('select', this.selected);
        },
        isSelected: function(selected, current) {
            return selected == current;
        },
        selectByIndex: function(index) {
            if (this.options[index] != null) {
                this.set('selected', this.options[index]);
                this.fire('select', this.selected);
            }
        },
        selectByName: function(name) {
            var index = -1;
            for (var i = 0; i < this.options.length; i++) {
                var option = this.options[i];
                if (option[this.nameAttribute] == name) {
                    index = i;
                    break;
                }
            }
            if (index > -1) {
                this.selectByIndex(index);
            }
        }
    });
</script>
<dom-module id="jso-opencga-sample-list" assetpath="bower_components/jsorolla/src/lib/components/opencga/samples/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
    :host {
            position: relative;
            display: block;
            box-sizing: border-box;
        }

        #header,
        #bar {
            box-sizing: border-box;
            background-color: rgba(125, 125, 125, 0.1);
            padding: 3px 7px;
            border-bottom: 1px solid rgba(125, 125, 125, 0.5);
        }

        #header {
            height: 25px;
        }

        #bar {
            height: 30px;
        }

        #content.list {
            height: calc(100% - 85px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        #content.list.info {
            height: calc(100% - 145px);
        }

        #content.icon {
            height: calc(100% - 60px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        #content.icon.info {
            height: calc(100% - 120px);
        }

        jso-opencga-sample-list-item[view-mode='list'] {
            padding: 3px 7px;
            border-bottom: 1px solid rgba(125, 125, 125, 0.3);
        }

        jso-opencga-sample-list-item[view-mode='list']:last-of-type {
            border-bottom-width: 0px;
        }

        jso-opencga-sample-list-item[view-mode='icon'] {
            margin: 1px;
            height: 70px;
        }

        .upload-btn {
            color: var(--default-primary-color);
        }

        .bar > div {
            margin-right: 5px;
        }

        #fileInfo {
            box-sizing: border-box;
            height: 60px;
            background-color: var(--light-secondary-color);
            /*border-top: 1px solid var(--divider-color);*/
            padding: 5px;
            padding-left: 15px;
        }

        .data {
            color: var(--secondary-text-color);
        }

        .value {
            margin-right: 10px;
        }

        .lowercase {
            text-transform: lowercase;
        }

        .study-info {
            height: 30px;
            box-sizing: border-box;
            background-color: var(--light-secondary-color);
            border-top: 1px solid var(--divider-color);
            padding: 5px;
        }

        #sampleList {
            height: calc(100% - 40px);
        }

        jso-select-box {
            overflow-y: auto;
            height: 100px;
            width: 150px;
            margin: 5px;
        }

        jso-panel {
            height: 880px;
            width: 800px;
        }

        .chooseList {
            height: 350px;
            width: 400px;
            margin-left: 200px;
            margin-top: 5px;
        }

        .chooseSamplesList {
            overflow-y: auto;
            height: 350px;
            /*width: 80%;*/
            margin: 5px;
            border: 1px solid var(--divider-color);
        }

        .titlePreview {
            font-size: 15px;
            color: #445D76;
            margin-top: 5px;
            margin-bottom: 5px;
            border-bottom: 1px solid #445D76;
            padding: 2px;
        }

        .boxList {
            height: 350px;
            width: 200px;
            margin: 20px;
        }

        .container {
            margin: 5px;
            width: 100%;
            height: 100%
        }

        .butUpload {
            color: #445D76;
            font-weight: bold;
            font-size: 12px;
            margin: 0 auto;
            margin-top: 30px;
            width: 300px;
            background-color: #e2e9e9;
        }

        .but {
            color: #445D76;
            font-weight: bold;
            font-size: 12px;
        }

        .but > i {
            font-weight: bold;
        }

        .clear {
            margin: 5px;
            margin-left: 165px;
            width: 100px;
        }

        .msgError {
            color: #bf4747;
            font-style: italic;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }

        .importBut {
            width: 65px;
            font-size: 12px;
            color: #445D76;
            margin: 3px;
        }

        #importComponent {
            width: 350px;
            height: 450px;
        }

        .title {
            margin-right: 10px;
            width: 110px;
        }

        .description {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #variantButton {
            border-radius: 5px;
            width: 150px;
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
        }

        #variantButton:hover {
            background-color: var(--light-button-color) !important;
        }
    }
    </style>
    <template>
        <div id="bar" class="horizontal layout">
            <div id="uploadButton" class="jso-btn jso-btn-shdw upload-btn" hidden$="{{isFolderMode(mode)}}" on-click="handleUploadFile">
                <i class="fa fa-cloud-upload"></i> Upload
            </div>
            <div class="bar horizontal layout flex end-justified">
                <div class="">
                    <input id="searchInput" class="jso" type="text" style="width:100%;" placeholder="Search by name..." value="{{search::input}}">
                </div>
                <div class="jso-btn jso-btn-shdw" on-click="handleViewInfo" style="margin-right: 5px;" hidden$="{{checkSelected(selected)}}">
                    <i class="fa fa-info"></i>
                </div>
                <div class="jso-btn jso-btn-shdw" on-click="handleViewMode">
                    <i class$="{{computeViewModeIconClass(viewMode)}}"></i>
                </div>

            </div>
        </div>
        
        <div id="headerData">
            <div id="header" class="horizontal layout">
                <div class="name title">Name</div>
                <div class="status title">Status</div>
                <div class="source title">Source</div>
                <div class="title" hidden$="{{!enableDiagnostic}}">Suspected</div>
                <div class="title" hidden$="{{!enableDiagnostic}}">Diagnosis</div>
                <div id="typeC" class="title" hidden="">Type</div>
            </div>
        </div>
        
        <div id="content" class$="{{computeContentClass(viewMode,showInfo)}}">
            <div class$="{{computeClassViewMode(viewMode)}}" id="sampleList">
                <template is="dom-repeat" items="{{filteredSamples}}" class="wrap">
                    <jso-opencga-sample-list-item sample="{{item}}" on-click="handleSampleClick" view-mode="{{viewMode}}" disable-case-control="{{disableCaseControl}}" enable-diagnostic$="{{enableDiagnostic}}">
                    </jso-opencga-sample-list-item>
                </template>
            </div>
        </div>
        <div class="horizontal layout flex study-info">
            <label class="" style="margin-left:10px;">Study Type: </label>
            <div class="flex" style="font-weight:bold;color: #445D76;margin-left:5px;">{{study.type}}</div>
            <div class="msgError" title="{{indexMsg}}">{{indexMsg}}</div>
            <div id="variantButton" class="jso-btn jso-btn-shdw" on-click="handleViewVariantBrowswer" hidden$="{{!enableVariantBrowser}}" title="Explore selected samples"> Variant Browser
            </div>
            <div class="" hidden$="{{disableCaseControl}}">
                <div class="msgError">{{msgCohortsError}}</div>
                <div id="cohortesButton" class="jso-btn jso-btn-shdw but" on-click="handleChooseCaseControl" hidden=""> Choose Case/Control
                </div>
            </div>
        </div>
        <jso-panel id="choosePanel" class="" closable="" modal="" movable="" hidden="">
            <div class="header">
                Choose cases and controls samples
            </div>
            <div class="container vertical layout flex">
                <div class="titlePreview" style="width: 450px; margin-left: 170px;">Total Samples List</div>
                <div class="chooseList horizontal layout flex">
                    <div id="chooseSamplesList" class="flex chooseSamplesList">
                        <template is="dom-repeat" items="{{noChooseSampleList}}">
                            <jso-opencga-sample-list-item sample="{{item}}" on-click="handleSelectSample" data-value$="{{item.id}}">
                            </jso-opencga-sample-list-item>
                        </template>
                    </div>
                    <div class="vertical layout">
                        <div class="jso-btn jso-btn-shdw but" style="margin:5px;" data-type="case" on-click="handleAddCaseControl"> Add Case
                        </div>
                        <div class="jso-btn jso-btn-shdw but" style="margin:5px;" data-type="control" on-click="handleAddCaseControl"> Add Control
                        </div>
                    </div>
                </div>
                <div class="horizontal layout flex">
                    <div class="flex boxList">
                        <div class="titlePreview">Cases Preview List</div>
                        <div id="casesList" class="chooseSamplesList" style="height: 300px">
                            <template is="dom-repeat" items="{{caseSampleList}}">
                                <jso-opencga-sample-list-item on-dragstart="handleDrag" draggable="true" sample="{{item}}" on-click="handleSelectSample" data-value$="{{item.id}}">
                                </jso-opencga-sample-list-item>
                            </template>
                        </div>
                        <div class="jso-btn jso-btn-shdw but clear" data-type="case" on-click="handleClear"> Clear
                        </div>
                        <div class="horizontal layout" style="line-height: 28px;">
                            <div class="">Import CASES from File:
                            </div>
                            <div class="jso-btn jso-btn-shdw importBut" on-click="handleImportFile" data-type="case"><i class="fa fa-plus-square-o"></i>&nbsp; Import
                            </div>
                        </div>
                    </div>
                    <div class="vertical layout">
                        <div class="jso-btn jso-btn-shdw but" style="margin:10px; width: 150px;margin-top: 170px;" on-click="handleChangeCase">
                            <i class="fa fa-angle-double-left"></i> Change to Case
                        </div>
                        <div class="jso-btn jso-btn-shdw but" style="margin:10px; width: 150px;" on-click="handleChangeControl">
                            Change to Control <i class="fa fa-angle-double-right"></i>
                        </div>
                    </div>
                    <div class="flex boxList">
                        <div class="titlePreview">Controls Preview List</div>
                        <div id="controlsList" class="chooseSamplesList" style="height: 300px" on-drop="handleDrop" on-dragover="allowDrop">
                            <template is="dom-repeat" items="{{controlSampleList}}">
                                <jso-opencga-sample-list-item sample="{{item}}" on-click="handleSelectSample" data-value$="{{item.id}}">
                                </jso-opencga-sample-list-item>
                            </template>
                        </div>
                        <div class="jso-btn jso-btn-shdw but clear" data-type="control" on-click="handleClear"> Clear
                        </div>
                        <div class="horizontal layout" style="line-height: 28px;">
                            <div class="">Import CONTROLS from File:
                            </div>
                            <div class="jso-btn jso-btn-shdw importBut" on-click="handleImportFile" data-type="control">
                                <i class="fa fa-plus-square-o"></i>&nbsp; Import
                            </div>
                        </div>
                    </div>
                </div>
                <div class="horizontal layout flex">
                    <div class="jso-btn jso-btn-shdw butUpload" on-click="handleUpload">
                        <i class="fa fa-cloud-upload"></i> Upload
                    </div>
                </div>
            </div>
        </jso-panel>

        <jso-panel id="importComponent" modal="" closable="" movable="" hidden="">
            <div class="header">
                <i class="fa fa-plus-square-o"></i> Import
                <span>{{cohortsType}}</span> from File
            </div>
            
            <div class="container">
                <div class="horizontal layout">
                    <div class="jso-btn jso-btn-shdw" on-click="handleBrowseClick" pattern="[a-zA-Z0-9_-]+">
                        <span>Choose file...</span>
                    </div>
                    <div class="flex">
                    </div>
                    <input type="file" hidden="" id="importFile" required="" on-change="handleInputChange" disabled$="{{uploading}}">

                    <div class="jso-btn jso-btn-shdw importBut" on-click="handleImportCohorts"><i class="fa fa-plus-square-o"></i>&nbsp; Import
                    </div>
                </div>
                <div class="horizontal layout flex" style="line-height: 22px;">
                    <label class="jso">Selected file name: &nbsp;</label>

                    <div class="filename">{{fileName}}</div>
                </div>
                <div class="">
                    <div class="titlePreview">File Preview List</div>
                    <template is="dom-repeat" items="{{previewImportList}}">
                        <div style="margin-left: 10px;">{{item}}</div>
                    </template>
                </div>
            </div>
        </jso-panel>
        <div id="fileInfo" class="vertical layout" hidden="{{!showInfo}}">
            <div class="horizontal layout">
                <i class="fa fa-file-o"></i>&nbsp;
                <span>{{sampleName}}</span>
            </div>
            <div class="horizontal layout">
                <span class="data">Source: &nbsp;</span>
                <span class="value lowercase">{{sampleSource}}</span>
            </div>
            <div class="horizontal layout">
                <span class="data">Aditional Data: &nbsp;</span>
                <span class="description" title="{{sampleDescription}}">{{sampleDescription}}</span>
            </div>
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-sample-list",
        properties: {
            folder: {
                type: Object,
                notify: true,
                value: null
            },
            samples: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
                observer: 'samplesChanged'
            },
            filteredSamples: {
                type: Array,
                value: function() {
                    return [];
                },
                notify: true,
            },
            selected: {
                type: Object,
                notify: true,
                value: function() {
                    return {};
                }
            },
            study: {
                type: Object,
                value: function() {
                    return {};
                },
                observer: "studyChanged"
            },
            mode: {
                type: String,
                reflectToAttribute: true,
            },
            viewMode: {
                type: String,
                value: 'list'
            },
            showInfo: {
                type: Boolean,
                value: false
            },
            search: {
                type: String,
                value: "",
                observer: 'searchNameChanged'
            },
            caseSampleList: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
                // observer: "caseSampleListChanged"
            },
            controlSampleList: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
            },
            noChooseSampleList: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
            },
            caseCohort: {
                type: Object,
                value: function() {
                    return {};
                }
            },
            controlCohort: {
                type: Object,
                value: function() {
                    return {};
                }
            },
            msgCohortsError: {
                type: String,
                value: ""
            },
            uploading: {
                type: Boolean,
                value: false
            },
            fileName: {
                type: String,
                value: 'None'
            },
            cohortsType: {
                type: String,
                value: ""
            },
            previewImportList: {
                type: Array,
                value: function() {
                    return [];
                },
            },
            disableCaseControl: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            enableDiagnostic: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            indexMsg: {
                type: String,
                value: ""
            },
            enableVariantBrowser: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            enableMultiselect: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            }
        },
        isFolderMode: function(mode) {
            return mode === 'folder';
        },
        handleSampleClick: function(e) {
            e.stopPropagation();
            var selected = e.currentTarget;
            var sel = this.querySelectorAll("jso-opencga-sample-list-item[selected]");
            if (this.enableVariantBrowser || this.enableMultiselect) {
                selected.setAttribute("selected", "");
                for (var i = 0; i < sel.length; i++) {
                    if (sel[i] == selected) {
                        selected.removeAttribute("selected");
                    }
                }
            } else {
                for (var i = 0; i < sel.length; i++) {
                    sel[i].removeAttribute("selected");
                }
                selected.setAttribute("selected", "");
            }

            this.set("selected", selected.sample);
            this.fire('sampleselected', this.selected);
            // study - info
            this.sampleName = this.selected.name;
            this.sampleSource = this.selected.source;
            this.sampleDescription = this.selected.description;

            if (this.study.type == "CASE_CONTROL") {
                this.selected.description = "No Choose Case/Control";
                var caseSam = this.caseCohort.samples;
                var controlSam = this.controlCohort.samples;
                for (var i = 0; i < caseSam.length; i++) {
                    if (caseSam[i] == this.selected.id) {
                        this.selected.description = "CASE";
                    }
                }
                for (var i = 0; i < controlSam.length; i++) {
                    if (controlSam[i] == this.selected.id) {
                        this.selected.description = "CONTROL";
                    }
                }
            }
            this.sampleDescription = this.selected.description;
        },
        checkSelected: function(selected) {
            return selected == null;
        },
        // computeHeader: function(viewMode) {
        //     return viewMode == "list";
        // },
        computeViewModeIconClass: function(viewMode) {
            var iconClass = (this.viewMode == "list") ? "fa fa-th" : "fa fa-list";
            console.log(iconClass);
            return iconClass;
        },
        handleViewMode: function(e) {
            this.viewMode = (this.viewMode == "list") ? "icon" : "list";
            if (this.viewMode == "list") {
                this.$.headerData.hidden = false;
            } else {
                this.$.headerData.hidden = true;
            }
        },
        computeClassViewMode: function(viewMode) {

            if (viewMode == "icon") {
                return "horizontal layout wrap flex";
            } else {
                return "flex";
            }
        },
        computeContentClass: function(viewMode, showInfo) {
            if (showInfo) {
                return viewMode + " info";
            } else {
                return viewMode;
            }
        },
        handleViewInfo: function(e) {
            if (this.selected != null) {
                this.showInfo = !this.showInfo;
            }
        },

        studyChanged: function(neo, old) {

            this.sampleName = "";
            this.sampleSource = "";
            this.sampleDescription = "";
            this.set("selected", undefined);

            var sel = this.querySelectorAll("jso-opencga-sample-list-item[selected]");
            for (var i = 0; i < sel.length; i++) {
                sel[i].removeAttribute("selected");
            }
            if (neo && neo.type != null) {
                // Check Case/Control Cohorts
                if (neo.type.toUpperCase() === "CASE_CONTROL") {
                    this.$.cohortesButton.hidden = false;
                    this.$.typeC.hidden = false;
                    var cohorts = neo.cohorts;
                    var caseCohort = null;
                    var controlCohort = null;

                    for (var i = 0; i < cohorts.length; i++) {
                        var cohort = cohorts[i];
                        if (cohort.name.toUpperCase() === "ALL") {
                            continue;
                        } else if (cohort.name.toUpperCase() === "CASE") {
                            caseCohort = cohort;
                        } else if (cohort.name.toUpperCase() === "CONTROL") {
                            controlCohort = cohort;
                        }
                    }

                    if (caseCohort == null) {
                        OpencgaManager.cohorts.create({
                            query: {
                                sid: Cookies('bioinfo_sid'),
                                name: "CASE",
                                studyId: this.study.id,
                                type: "CASE_CONTROL"
                            },
                            request: {
                                async: true,
                                success: function(response) {
                                    if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                        caseCohort = response.response[0].result[0];

                                    } else {
                                        console.log('jso-opencga-sample-list635:Server error, try again later.');
                                    }
                                },
                                error: function() {
                                    console.log('jso-opencga-sample-list639:Server error, try again later.');
                                }
                            }
                        });
                    }
                    if (controlCohort == null) {
                        OpencgaManager.cohorts.create({
                            query: {
                                sid: Cookies('bioinfo_sid'),
                                name: "CONTROL",
                                studyId: this.study.id,
                                type: "CASE_CONTROL"
                            },
                            request: {
                                async: true,
                                success: function(response) {
                                    if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                        controlCohort = response.response[0].result[0];
                                    } else {
                                        console.log('jso-opencga-sample-list658:Server error, try again later.');
                                    }
                                },
                                error: function() {
                                    console.log('jso-opencga-sample-list662:Server error, try again later.');
                                }
                            }
                        });
                    }
                    this.caseCohort = caseCohort;
                    this.controlCohort = controlCohort;

                } else {
                    this.$.cohortesButton.hidden = true;
                    this.$.typeC.hidden = true;
                }
            }
        },
        samplesChanged: function(neo, old) {
            var me = this;
            console.log(this.search);
            var searchFilterSamples = this._filterBySearch(this.samples);
            this.set('filteredSamples', searchFilterSamples);
            if (this.study != null && this.filteredSamples != "") {
                var studyId = this.study.id;
                var sampleIds = [];
                for (var i = 0; i < this.filteredSamples.length; i++) {
                    sampleIds.push(this.filteredSamples[i].id);
                }
                OpencgaManager.files.search({
                    query: {
                        sid: Cookies('bioinfo_sid'),
                        studyId: studyId,
                        status: "READY",
                        sampleIds: sampleIds.join(",")
                    },
                    request: {
                        async: true,
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                for (var j = 0; j < response.response[0].result.length; j++) {
                                    var result = response.response[0].result[j];
                                    if (result.index != null && result.index.status == "INDEXING") {
                                        for (var k = 0; k < me.filteredSamples.length; k++) {
                                            if (me.filteredSamples[k].source == result.name) {
                                                me.set("filteredSamples." + k + ".status", "INDEXING");
                                            }
                                        }
                                        var msg = result.name + " is indexing";
                                        me.set('indexMsg', msg);
                                    } else {
                                        for (var k = 0; k < me.filteredSamples.length; k++) {
                                            var status = (result.index) ? result.index.status : "NOT INDEXED";
                                            if (me.filteredSamples[k].source == result.name) {
                                                me.set("filteredSamples." + k + ".status", status);
                                            }
                                        }
                                        me.set('indexMsg', "");
                                    }
                                }
                            } else {
                                console.log('jso-opencga-sample-list719:Server error, try again later.');
                            }
                        },
                        error: function() {
                            console.log('jso-opencga-sample-list723:Server error, try again later.');
                        }
                    }
                });

            }

            this.set('msgCohortsError', " ");

            if (this.study != null && this.study.type === "CASE_CONTROL") {
                this.set('caseSampleList', []);
                this.set('controlSampleList', []);
                this.noChooseSampleList = Utils.clone(this.filteredSamples);
                var caseList = this.caseCohort.samples;
                var controlList = this.controlCohort.samples;

                for (var i = 0; i < this.filteredSamples.length; i++) {
                    this.set("filteredSamples." + i + ".cohort", "Not defined");
                }

                if (caseList == "" && controlList == "") {
                    this.set('msgCohortsError', "Cases/Controls are not defined");
                } else {
                    var arrayDelete = [];
                    for (var i = 0; i < this.noChooseSampleList.length; i++) {
                        var sample = this.noChooseSampleList[i];
                        for (var j = 0; j < caseList.length; j++) {
                            if (caseList[j] == sample.id) {
                                this.push('caseSampleList', sample);
                                arrayDelete.push(i);
                                this.set("filteredSamples." + i + ".cohort", "CASE");
                            }
                        }

                        for (var j = 0; j < controlList.length; j++) {
                            if (controlList[j] == sample.id) {
                                this.push('controlSampleList', sample);
                                arrayDelete.push(i);
                                this.set("filteredSamples." + i + ".cohort", "CONTROL");
                            }
                        }
                    }
                    var n = 0;
                    for (var i = 0; i < arrayDelete.length; i++) {
                        this.splice('noChooseSampleList', arrayDelete[i] - n, 1);
                        n++;
                    }
                }
            }
            // this.studyChanged();
        },
        searchNameChanged: function(neo, old) {
            this.samplesChanged();
        },
        _filterBySearch: function(samples) {
            if (this.search == "") {
                return samples;
            }
            var filteredSamples = [];
            for (var i = 0; i < samples.length; i++) {
                var sample = samples[i];
                if (sample.name.toLowerCase().search(this.search.toLowerCase()) >= 0) {
                    filteredSamples.push(sample);
                }
            }
            return filteredSamples;
        },

        handleChooseCaseControl: function(e) {
            this.$.choosePanel.hidden = false;
        },
        handleSelectSample: function(e) {
            var sel = this.querySelectorAll("jso-opencga-sample-list-item[selected]");
            e.currentTarget.setAttribute("selected", "");
            for (var i = 0; i < sel.length; i++) {
                if (sel[i].dataset.value === e.currentTarget.dataset.value) {
                    sel[i].removeAttribute("selected");
                }
            }
        },
        handleAddCaseControl: function(e) {
            var sel = this.$.chooseSamplesList.querySelectorAll("jso-opencga-sample-list-item[selected]");
            for (var i = 0; i < sel.length; i++) {
                var sample = sel[i].sample;
                if (e.currentTarget.dataset.type === "case") {
                    this.push('caseSampleList', sample);
                    sel[i].removeAttribute("selected");
                    sel[i].hidden = true;
                } else if (e.currentTarget.dataset.type === "control") {
                    this.push('controlSampleList', sample);
                    sel[i].removeAttribute("selected");
                    sel[i].hidden = true;
                }
            }
            console.log(this.caseSampleList)
            console.log(this.controlSampleList)
        },
        handleUpload: function(e) {
            var me = this;
            this._setCohorts("CASE", this.caseSampleList, this.caseCohort.id);
            this._setCohorts("CONTROL", this.controlSampleList, this.controlCohort.id);
            alert('Cases/Controls are defined successfully');
            this.fire('need-refresh');
            this.$.choosePanel.hidden = true;
        },
        _setCohorts: function(type, list, cohortId) {
            var me = this;
            if (list != "") {
                var sampleIdList = [];
                for (var i = 0; i < list.length; i++) {
                    var sampleId = list[i].id;
                    sampleIdList.push(sampleId);
                }
                var samples = sampleIdList.join(",");
                if (type == "CASE") {
                    var caseCohort = {};
                    OpencgaManager.cohorts.update({
                        id: cohortId,
                        query: {
                            sid: Cookies('bioinfo_sid'),
                            samples: samples
                        },
                        request: {
                            async: true,
                            success: function(response) {
                                if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                    me.set('caseCohort', response.response[0].result[0]);
                                } else {
                                    console.log('jso-opencga-sample-list851:Server error, try again later.');
                                }
                            },
                            error: function() {
                                console.log('jso-opencga-sample-list855:Server error, try again later.');
                            }
                        }
                    });

                } else if (type == "CONTROL") {
                    var controlCohort = {};
                    OpencgaManager.cohorts.update({
                        id: cohortId,
                        query: {
                            sid: Cookies('bioinfo_sid'),
                            samples: samples
                        },
                        request: {
                            async: true,
                            success: function(response) {
                                if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                    me.set('controlCohort', response.response[0].result[0]);
                                } else {
                                    console.log('jso-opencga-sample-list874:Server error, try again later.');
                                }
                            },
                            error: function() {
                                console.log('jso-opencga-sample-list878:Server error, try again later.');
                            }
                        }
                    });
                }
            }
        },
        handleChangeControl: function(e) {
            var selCases = this.$.casesList.querySelectorAll("jso-opencga-sample-list-item[selected]");

            for (var i = 0; i < selCases.length; i++) {
                var sample = selCases[i].sample;
                this.push('controlSampleList', sample);
                selCases[i].removeAttribute("selected");
                for (var k = 0; k < this.caseSampleList.length; k++) {
                    if (selCases[i].dataset.value == this.caseSampleList[k].id) {
                        this.splice('caseSampleList', k, 1);
                    }
                }
            }
        },
        handleChangeCase: function(e) {
            var selControls = this.$.controlsList.querySelectorAll("jso-opencga-sample-list-item[selected]");
            for (var i = 0; i < selControls.length; i++) {
                var sample = selControls[i].sample;
                this.push('caseSampleList', sample);
                selControls[i].removeAttribute("selected");
                for (var k = 0; k < this.controlSampleList.length; k++) {
                    if (selControls[i].dataset.value == this.controlSampleList[k].id) {
                        this.splice('controlSampleList', k, 1);
                    }
                }
            }
        },
        allowDrop: function(ev) {
            console.log("allow drop");
            ev.preventDefault();
        },
        handleDrag: function(e) {
            console.log(e.currentTarget.sample);
            var data = JSON.stringify(e.currentTarget.sample);
            console.log(data);
            e.dataTransfer.setData("hola", "adios");
            e.dataTransfer.setData("sample", data);
        },
        handleDrop: function(e) {
            e.preventDefault();
            console.log("handle DROP")
            var data = JSON.parse(e.dataTransfer.getData("sample"));
            console.log(data);
            // this.controlSampleList.push(data);
            this.push("controlSampleList", data);
            // ev.target.appendChild(document.getElementById(data));
        },
        handleClear: function(e) {
            var samplesOrigin = this.$.chooseSamplesList.querySelectorAll("jso-opencga-sample-list-item");
            if (e.currentTarget.dataset.type === "case") {
                for (var j = 0; j < this.caseSampleList.length; j++) {
                    var sample = this.caseSampleList[j];
                    this.push('noChooseSampleList', sample);
                }
                this.set('caseSampleList', []);

            } else if (e.currentTarget.dataset.type === "control") {
                for (var j = 0; j < this.controlSampleList.length; j++) {
                    var sample = this.controlSampleList[j];
                    this.push('noChooseSampleList', sample);
                }
                this.set('controlSampleList', []);
            }
        },
        handleImportFile: function(e) {
            if (e.currentTarget.dataset.type == "case") {
                this.cohortsType = "CASES";
            } else if (e.currentTarget.dataset.type == "control") {
                this.cohortsType = "CONTROLS";
            }
            this.$.importComponent.hidden = !this.$.importComponent.hidden;
        },
        handleImportCohorts: function(file) {
            var cohort = "";
            if (this.cohortsType == "CASES") {
                cohort = 'caseSampleList';
            } else if (this.cohortsType == "CONTROLS") {
                cohort = 'controlSampleList';
            }
            var arrayDelete = [];
            var n = 0;
            for (var i = 0; i < this.previewImportList.length; i++) {
                var sampleName = this.previewImportList[i];
                for (var k = 0; k < this.noChooseSampleList.length; k++) {
                    if (this.noChooseSampleList[k].name === sampleName) {
                        this.push(cohort, this.noChooseSampleList[k]);
                        arrayDelete.push(k);
                    }
                }
            }
            for (var i = 0; i < arrayDelete.length; i++) {
                this.splice('noChooseSampleList', arrayDelete[i] - n, 1);
                n++;
            }
            this.$.importComponent.hidden = true;
        },
        handleBrowseClick: function(e) {
            if (this.uploading == false) {
                this.$.importFile.click();
            }
        },
        handleInputChange: function(e) {
            if (this.uploading == false) {
                this.set('fileName', this.$.importFile.files[0].name);
                this.set('previewImportList', []);
                var file = this.$.importFile.files[0];
                var me = this;
                var log = [];
                var line = 0;

                if (file != null && this.fileName != "None") {

                    var _navigator = new FileNavigator(file);
                    var indexToStartWith = 0;

                    _navigator.readSomeLines(indexToStartWith, function linesReadHandler(err, index, lines, eof, progress) {
                        if (err) {
                            return;
                        }
                        for (var i = 0; i < lines.length; i++) {
                            var line = lines[i];
                            var sampleName = line;
                            me.push('previewImportList', sampleName);
                            line++;
                        }
                        if (eof) {
                            return;
                        }
                        _navigator.readSomeLines(index + lines.length, linesReadHandler);
                    })
                }
            }
        },
        handleUploadFile: function(e) {
            if (this.study != null) {
                this.fire('upload-file');
            } else {
                alert("You must select a study before uploading a file.")
            }
        },
        handleViewVariantBrowswer: function(e) {
            this.fire('viewvariantbrowser');
        }
    });
</script>
<dom-module id="jso-opencga-sample-browser" assetpath="bower_components/jsorolla/src/lib/components/opencga/samples/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            transition: all 0.2s;
            background-color: inherit;
            width: 100%;
            height: 500px;
        }

        #topbar,
        #botbar {
            box-sizing: border-box;
            height: 30px;
            padding: 0 7px;
            line-height: 30px;
            background-color: var(--light-secondary-color);
        }

        #topbar {
            border-bottom: 1px solid rgba(130, 130, 130, 0.4);
        }

        #botbar {
            border-top: 1px solid rgba(130, 130, 130, 0.4);
        }

        #main {
            position: relative;
            height: calc(100% - 60px);
        }

        #mainmenu {
            position: absolute;
            box-sizing: border-box;
            width: 175px;
            height: 100%;
            border-right: 1px solid rgba(130, 130, 130, 0.4);
        }

        #mainmenubar {
            box-sizing: border-box;
            background-color: rgba(125, 125, 125, 0.1);
            padding: 3px 7px;
            height: 30px;
            border-bottom: 1px solid rgba(125, 125, 125, 0.5);
        }

        #mainmenucontent {
            height: calc(100% - 30px);
            overflow-y: auto;
        }

        #maincontent {
            position: absolute;
            left: 175px;
            top: 0;
            width: calc(100% - 175px);
            height: 100%;
            white-space: nowrap;
        }

        #maininfo {
            box-sizing: border-box;
            width: 150px;
            height: 100%;
            border-left: 1px solid rgba(130, 130, 130, 0.4);
            word-wrap: break-word;
        }

        .project-menu-item {}

        #breadcrums {
            box-sizing: border-box;
            padding-left: 5px;
        }

        #breadcrums > span.clickable:hover {
            cursor: pointer;
            text-decoration: underline;
        }

        #breadcrums > .projectbread {}
        /*#breadcrums > span:not(:last-of-type)::after {*/
        /*font-family: 'FontAwesome';*/
        /*content: '\f105';*/
        /*margin-left: 5px;*/
        /*}*/

        jso-opencga-sample-list {
            height: 100%;
        }

        jso-opencga-create-project,
        jso-opencga-create-study {
            width: 300px;
            box-sizing: border-box;
            background-color: #fafafa;
            padding: 20px 30px;
        }

        jso-opencga-upload-file {
            box-sizing: border-box;
            background-color: #fafafa;
            /*padding: 20px 30px;*/
        }

        .bar > div {
            margin-right: 5px;
        }

        #filePreview .container {
            width: 800px;
            height: 600px;
            overflow-y: auto;
            overflow-x: auto;
        }

        .wrapped-text {
            white-space: pre-wrap;
        }
    </style>
    <template>
        <div id="topbar" class="horizontal layout center">
            <div id="breadcrums" class="flex">
                /
                <span class="projectbread">{{selectedProject.project.name}}</span>
                &nbsp; <i hidden="" hidden$="{{computeAngleIcon(selectedStudy)}}" class="fa fa-caret-right"></i> &nbsp;
                <span class="clickable" on-click="handleStudyBreadcrum">{{selectedStudy.study.name}}</span>

                <template is="dom-repeat" items="{{folders}}">
                    &nbsp;<i class="fa fa-angle-right"></i>&nbsp;
                    <span class="clickable" on-click="handleBreadcrumClick" folder="{{item}}">{{item.name}}</span>
                </template>

            </div>
            <div hidden$="{{!loading}}">
                <i class="fa fa-circle-o-notch fa-spin"></i>
            </div>
        </div>

        <div id="main" class="flex">
            <div id="mainmenu">
                <div id="mainmenubar" class="horizontal layout">
                    <div class="bar horizontal layout flex">
                        <template is="dom-if" if="{{!disableNewProject}}">
                            <div class="jso-btn jso-btn-shdw" on-click="handleCreateProject">
                                <i class="fa fa-briefcase"></i> +
                            </div>
                        </template>
                        <template is="dom-if" if="{{!disableNewStudy}}">

                            <div class="jso-btn jso-btn-shdw" on-click="handleCreateStudy">
                                <i class="fa fa-book"></i> +
                            </div>
                        </template>
                    </div>
                    <div class="bar horizontal layout">
                    </div>
                </div>
                <div id="mainmenucontent">
                    <template is="dom-repeat" items="{{projects}}" filter="isHidden">
                        <jso-opencga-project-tree on-clickstudy="handleStudyClick" project="{{item}}">
                        </jso-opencga-project-tree>
                    </template>
                </div>
            </div>
            <div id="maincontent">
                <jso-opencga-sample-list on-sampleselected="handleSampleSelect" study="{{selectedStudy.study}}" samples="{{samples}}" filtered-samples="{{filteredSamples}}" disable-case-control$="{{disableCaseControl}}" enable-variant-browser$="{{enableVariantBrowser}}" enable-multiselect$="{{enableMultiselect}}" on-upload-file="handleUploadFile" enable-diagnostic$="{{enableDiagnostic}}">
                </jso-opencga-sample-list>
            </div>
        </div>


        <div id="botbar" class="horizontal layout">
            <div class="flex"></div>


        </div>

        <jso-panel modal="" movable="" closable="" hidden="" id="uploadFilePanel">
            <div class="header">
                <i class="fa fa-cloud-upload"></i> &nbsp; Upload file
            </div>
            <jso-opencga-upload-file class="container" id="uploadFile" on-file-uploaded="handleFileUploaded" projects="{{projects}}" selected-project="{{selectedProject.project}}" selected-study="{{selectedStudy.study}}" selected-folder="{{folder}}" bioformats="{{bioformats}}"></jso-opencga-upload-file>
        </jso-panel>

        <jso-panel modal="" closable="" hidden="" id="createProjectPanel">
            <div class="header">
                <i class="fa fa-briefcase"></i> &nbsp; Create project
            </div>
            <div class="container">
                <jso-opencga-create-project id="createProject" on-project-created="handleProjectCreated"></jso-opencga-create-project>
            </div>
        </jso-panel>

        <jso-panel modal="" closable="" hidden="" id="createStudyPanel">
            <div class="header">
                <i class="fa fa-book"></i> &nbsp; Create study
            </div>
            <div class="container">
                <jso-opencga-create-study id="createStudy" on-study-created="handleStudyCreated" projects="{{projects}}"></jso-opencga-create-study>
            </div>
        </jso-panel>

        <jso-panel modal="" closable="" hidden="" id="filePreview">
            <div class="header">
                <i class="fa fa-book"></i> File Preview
            </div>
            <div class="container">
                <code class="wrapped-text">{{contentData}}</code>
            </div>
        </jso-panel>

    </template>

</dom-module>
<script>
    Polymer({
        is: "jso-opencga-sample-browser",
        properties: {
            projects: {
                type: Array,
                notify: true,
                observer: 'projectsChanged'
            },
            selectedProject: {
                type: Object,
                notify: true,
                observer: 'selectedProjectChanged'
            },
            selectedStudy: {
                type: Object,
                notify: true,
                observer: 'selectedStudyChanged'
            },
            selectedSample: {
                type: Object,
                notify: true,
                value: function() {
                    return {};
                }
            },
            folder: {
                type: Object,
                notify: true
            },
            folders: {
                type: Array,
                notify: true,
                value: function() {
                    return []
                }
            },
            samples: {
                type: Array,
                notify: true

            },
            filteredSamples: {
                type: Array,
                value: function() {
                    return [];
                },
                notify: true,
            },
            bioformats: {
                type: Array,
                value: function() {
                    return [];
                },
                notify: true
            },
            showHidden: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            disableNewProject: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            disableNewStudy: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            contentData: {
                type: String,
                value: ""
            },
            mode: {
                type: String,
                reflectToAttribute: true,
                value: ""
            },
            loading: {
                type: Boolean,
                value: false
            },
            disableCaseControl: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            enableDiagnostic: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            enableVariantBrowser: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            enableAutoIndex: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            }
        },
        ready: function() {
            var me = this;
            if (this._parentJsoPanel != null) {
                this._parentJsoPanel.addEventListener('hidden', function(e) {
                    if (e.detail == false) {
                        me._setInitialSelection();
                    }
                });
            }
        },
        projectsChanged: function(neo, old) {
            this.async(function() {
                this._setInitialSelection();
            }, 100);
        },
        _setInitialSelection: function() {

            if (this._parentJsoPanel != null && this._parentJsoPanel.hidden === false) {
                if (this.selectedProject == null) {
                    var el = Polymer.dom(this.root).querySelector('jso-opencga-project-tree');
                    this.set('selectedProject', el);
                }
                if (this.selectedProject != null && this.selectedStudy == null) {
                    var el = Polymer.dom(this.selectedProject.root).querySelector('jso-opencga-study-tree');
                    this.set('selectedStudy', el);
                }
                if (this.selectedStudy) {
                    this._showStudyFolder();
                }

            }
        },
        selectedStudyChanged: function(neo, old) {
            if (old) old.selected = false;
            if (neo) neo.selected = true;

            this.set('selectedSample', undefined);
            this._showStudyFolder();
        },
        selectedProjectChanged: function(neo, old) {
            if (old) old.selected = false;
            if (neo) neo.selected = true;
        },
        handleStudyClick: function(e) {
            if (this.selectedStudy !== e.currentTarget.selectedStudy) {
                this.files = [];
            }
            this.set('selectedProject', e.currentTarget);
            this.set('selectedStudy', e.currentTarget.selectedStudy);
        },
        handleSampleSelect: function(e) {
            this.selectedSample = e.detail;
        },
        handleStudyBreadcrum: function(e) {
            this.files = [];
            this._showStudyFolder();
        },
        handleBreadcrumClick: function(e) {
            var me = this;
            this.folder = e.currentTarget.folder;

            while (this.folder !== this.folders[this.folders.length - 1]) {
                this.pop('folders');
            }
            this.selectedSample = {};
        },
        handleCreateProject: function(e) {
            this.$.createProjectPanel.hidden = !this.$.createProjectPanel.hidden;
        },
        handleCreateStudy: function(e) {
            this.$.createStudyPanel.hidden = !this.$.createProjectPanel.hidden;
        },

        handleProjectCreated: function(e) {
            this.$.createProjectPanel.hidden = true;
        },
        handleStudyCreated: function(e) {
            this.$.createStudyPanel.hidden = true;
        },
        handleLoading: function(e) {
            this.fire("loading")
        },

        /* Private methods */
        computeAngleIcon: function(el) {
            if (el) {
                return false;
            }
            return true;
        },
        _showStudyFolder: function() {
            var me = this;
            this.loading = true;
            if (me.selectedStudy != null) {
                me._getSamples(me.selectedStudy.study.id, function(samples) {
                    me.set('samples', samples);
                    me.loading = false;
                    if (me.enableAutoIndex && me.samples.length > 0) {
                        me.autoIndex();
                    }

                });
            }else{
              me.loading = false;
            }
        },
        _getSamples: function(studyId, callback) {
            var me = this;
            var samples;

            OpencgaManager.studies.samples({
                id: studyId,
                query: {
                    sid: Cookies('bioinfo_sid'),
                },
                request: {
                    async: true,
                    success: function(response) {

                        // console.log(response);
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            samples = response.response[0].result;
                            callback(samples);
                        } else {
                            console.log(response.response[0].errorMsg);
                        }
                    },
                    error: function() {
                        console.log('jso-opencga-sample-browser455:Server error, try again later.');
                    }
                }
            });
        },

        isHidden: function(project) {
            if (this.showHidden) {
                return true;
            } else {
                return project.name.charAt(0) != ".";
            }
        },
        handleUploadFile: function(e) {
            this.$.uploadFilePanel.hidden = !this.$.uploadFilePanel.hidden;
        },
        handleFileUploaded: function(e) {
            this._showStudyFolder();
            this.$.uploadFilePanel.hidden = true;
        },
        autoIndex: function() {
            var sampleFiles = {};
            var me = this;
            var n = 0;
            for (var i = 0; i < this.samples.length; i++) {
                var sample = this.samples[i];
                if (sample.status == null) {
                    if (sampleFiles[sample.source] == null) {
                        sampleFiles[sample.source] = 1;
                        n++;
                    }
                }
            }
            if (n > 0) {
                var studyId = this.selectedStudy.study.id;
                OpencgaManager.studies.files({
                    id: studyId,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                    },
                    request: {
                        async: true,
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                var result = response.response[0].result;
                                for (var i = 0; i < result.length; i++) {
                                    if (result[i].type == "FILE") {
                                        if (sampleFiles[result[i].name] != null && result[i].index == null) {
                                            me._indexFile(result[i].id);
                                        }
                                    }
                                }
                            } else {
                                console.log(response.response[0].errorMsg);
                            }
                        },
                        error: function() {
                            console.log('jso-opencga-sample-browser512:Server error, try again later.');
                        }
                    }
                });
            }
        },
        _indexFile: function(fileId) {
            var me = this;
            OpencgaManager.files.index({
                id: fileId,
                query: {
                    sid: Cookies('bioinfo_sid'),
                    storageEngine: "mongodb",
                },
                request: {
                    success: function(response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            console.log("index");
                            console.log(response);
                            me._showStudyFolder();
                        } else {
                            console.log(response.response[0].errorMsg);
                        }
                    },
                    error: function() {
                        console.log('jso-opencga-sample-browser537:Server error, try again later.');
                    }
                }
            });
        }
    });
</script>
<dom-module id="jso-opencga-study-select" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            background-color: #FFF;
            overflow-y: auto;
            border: 1px solid #d3d3d3;
            height:150px;
        }

        .study-item, .project-item {
            padding: 2px 5px;
        }

        .project-item {
            color: #555;
        }

        .study-item {
            padding-left: 15px;
        }

        .study-item:hover {
            background-color: #eee;
        }

        .study-item[data-checked] {
            background-color: #ddd;
        }

        label.jso {
            display: block;
        }

    </style>
    <template>
        <template is="dom-repeat" items="{{projects}}" as="project">
            <div class="project-item" on-click="handleProjectClick">{{project.name}}</div>
            <template is="dom-repeat" items="{{project.studies}}" as="study">
                <div class="study-item" on-click="handleStudyClick">
                    <span>{{study.name}}</span>
                </div>
            </template>
        </template>
    </template>

</dom-module>
<script>
    Polymer({
        is: "jso-opencga-study-select",
        properties: {
            projects: {
                type: Array,
                observer: 'projectsChanged'
            },
            selectedStudy: {
                type: Object,
//                notify:true,
                observer: 'selectedStudyChanged'
            }
        },
        handleStudyClick: function (e) {
            this.selectedStudy = e.model.study;

            this._cleanStudiesSelection();
            e.currentTarget.setAttribute('data-checked', '')
        },
        projectsChanged: function (neo, old) {
//            var found = false;
//            for (var i = 0; i < neo.length; i++) {
//                var p = neo[i];
//                for (var j = 0; j < p.studies.length; j++) {
//                    var s = p.studies[j];
//                    if (s.id == parseInt(this.selectedStudy.id)) {
//                        found = true;
//                        break;
//                    }
//                }
//            }
//            if (!found) {
//                this.selectedStudy = null;
//            }
        },
//        selectStudy:function(study){
//            this._cleanStudiesSelection();
//
//        },
        _cleanStudiesSelection:function(){
            var sel = this.querySelectorAll('.study-item');
            for (var i = 0; i < sel.length; i++) {
                var el = sel[i];
                el.removeAttribute('data-checked');
            }
        },
        selectedStudyChanged: function (neo, old) {
            if(neo != null) {
                var sel = this.querySelectorAll('.study-item');
                for (var i = 0; i < sel.length; i++) {
                    var el = sel[i];
                    el.removeAttribute('data-checked');
                    if (this.selectedStudy.id == el.dataset.id) {
                        el.setAttribute('data-checked', '');
                    }
                }
            }

//            var found = false;
//            for (var i = 0; i < neo.length; i++) {
//                var p = neo[i];
//                for (var j = 0; j < p.studies.length; j++) {
//                    var s = p.studies[j];
//                    if (s.id == parseInt(this.selectedStudy)) {
//                        found = true;
//                        break;
//                    }
//                }
//            }
        }
    });
</script>
<dom-module is="jso-opencga-bioformat">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            box-sizing: border-box;
            display: block;
            padding: 5px;
        }

        .zeroLevel {
            color: #888;
            margin-left: 1px
        }

        .firstLevel {
            margin-left: 3px
        }

        .secondLevel {
            margin-left: 5px
        }

        .thirdLevel {
            color: #000;
            margin-left: 7px
        }

        input[name=bioformat]:disabled + span,
        input[name=bioformat]:disabled + span:before {
            color: #d3d3d3 !important;
            /*display: none !important;*/
        }

        .url {
            margin-left: 2px;
            color: var(--dark-button-color);
            cursor: pointer;
        }
        .url:hover {
            color: var(--light-button-color);
        }
    </style>
    <template>

        <template is="dom-repeat" items="{{bioformats}}" as="bioformat">
            <template is="dom-if" if="{{!bioformat.value}}">
                <div class="zeroLevel">
                    <span>{{bioformat.text}}</span>
                </div>
            </template>
            <template is="dom-if" if="{{bioformat.value}}">
                <div class="firstLevel">
                    <label class="jso-control" title="{{bioformat.hint}}">
                        <input type="radio" name="bioformat" on-change="handleRadioChange" value="{{bioformat.value}}" checked$="{{isChecked(bioformats, bioformat)}}">
                        <span>
                            <span>{{bioformat.text}}</span>
                            <i id="url" hidden$="{{!checkUrl(bioformat)}}" class="fa fa-info-circle url" on-click="handleUrl"></i>
                        </span>
                    </label>
                </div>
            </template>
        </template>


        

        

        
        

        
        

        
        


        

        
        

        
        

        
        
        


        

        
        


        
        


        

        
        


        

        
        

        
        

        
        

        
        

        
        

    </template>

</dom-module>
<script>
    Polymer({
        is: 'jso-opencga-bioformat',
        properties: {
            bioformats: {
                type: Array,
                observer: 'bioformatsChanged'
            },
            hideBioformats: {
                type: Boolean,
                value: false
            },
            selectedBioformat: {
                type: Object,
                observer: 'selectedDioformatsChanged'
            }
        },
        isChecked: function(bioformats, bioformat) {
            if (Array.isArray(bioformats) && bioformats.length === 1) {
                this.selectedBioformat = bioformats[0];
                return true;
            } else {
                return false
            }
        },
        bioformatsChanged: function(neo, old) {
            var radios = Polymer.dom(this).querySelectorAll('input[name="bioformat"]');
            for (var i = 0; i < radios.length; i++) {
                var radio = radios[i];
                if (this.bioformats == null) {
                    radio.disabled = false;
                } else {
                    if (this.bioformats.indexOf(radio.value) >= 0) {
                        console.log(radio.value)
                        radio.disabled = false;
                    } else {
                        radio.disabled = true;
                    }
                }
            }
        },
        selectedDioformatsChanged: function(neo, old) {
            this.fire('selected-bioformat-change');
        },
        handleRadioChange: function(e) {
            this.set('selectedBioformat', e.model.bioformat);
        },
        getSelected: function() {
            return this.selectedBioformat;
            //            var selectedBioformat = "";
            //            var radioButton = this.querySelector('input[name="bioformat"]:checked');
            //            if (radioButton == null)
            //                selectedBioformat = "";
            //            else
            //                selectedBioformat = radioButton.value;
            //            return selectedBioformat;
        },
        checkUrl: function(bioformat) {
            return bioformat.url != null;
        },
        handleUrl: function(e) {
            window.open(e.model.bioformat.url, '_blank');
        }

    });
</script>
<dom-module id="jso-opencga-upload-file" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        jso-study-select {
            height: 150px;
        }

        #main {
            position: relative;
            box-sizing: border-box;
            padding: 15px 25px 20px 25px;
        }

        .uploadbar {
            position: relative;
            height: 20px;
            border: 1px solid #d3d3d3;
            background-color: white;
            line-height: 20px;
        }

        .uploadprogress {
            position: absolute;
            top: 0px;
            left: 0px;
            height: 100%;
            width: 100%;
            background-color: #eaeaea;
            /*margin-top: 10px;*/
        }

        .uploadtext {
            position: absolute;
            text-align: center;
            top: 0px;
            left: 0px;
            height: 100%;
            width: 100%;
        }

        #bioformatsBox {
            position: relative;
            box-sizing: border-box;
            height: 250px;
            width: 200px;
            border: 1px solid var(--divider-color);
            background-color: var(--text-primary-color);
        }

        #filename {
            padding: 2px 4px;
            border: 1px solid var(--divider-color);
            background-color: var(--hover-color);
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            max-width: 360px;
        }

        .right {
            margin-left: 15px;
            display: block;
            position: relative;
            box-sizing: border-box;
            width: 440px;
        }

        #validator {
            border: 1px solid var(--divider-color);
            height: 250px;
        }

        #openFileButton {
            width: 200px;
        }

        #uploadButton,
        #openFileButton {
            width: 200px;
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
        }

        #uploadButton:hover,
        #openFileButton:hover {
            background-color: var(--light-button-color) !important;
        }

        #recheckButton {
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
        }

        #recheckButton:hover {
            background-color: var(--light-button-color) !important;
        }

        #footer {
            box-sizing: border-box;
            height: 30px;
            padding: 0 7px;
            background-color: var(--light-secondary-color);
            border-top: 1px solid var(--divider-color);
        }
    </style>
    <template>
        <div id="main" class="vertical layout">
            <div hidden$="{{!showSelectStudy}}">
                <label class="jso">Studies:</label>
                <jso-opencga-study-select id="studySelect" selected-study="{{selectedStudy}}" projects="{{projects}}">
                </jso-opencga-study-select>
                <br>
            </div>

            <div hidden$="{{showSelectStudy}}">
                <label class="jso">File path:</label>

                <div>
                    /
                    <span>{{selectedProject.name}}</span>/
                    <span>{{selectedStudy.name}}</span>/
                    <span>{{selectedFolder.name}}</span>
                </div>
                <br>
            </div>

            <div class="horizontal layout">
                <div>
                    <label class="jso">File upload:</label>
                    <div id="openFileButton" class="jso-btn jso-btn-shdw" on-click="handleBrowseClick">
                        Choose file...
                    </div>
                </div>
                <div class="flex" style="margin-left:15px;position:relative;">
                    <label class="jso">Selected file:</label>
                    <div class="horizontal layout flex">
                        <div id="filename" class="flex" title="{{fileName}}">{{fileName}}</div>
                        <div id="recheckButton" class="jso-btn jso-btn-shdw" on-click="handleRecheck">
                            Revalidate
                        </div>
                    </div>
                    <input type="file" hidden="" id="fileInput" required="" on-change="handleInputChange" disabled$="{{uploading}}">
                </div>
            </div>

            <br>

            <div class="horizontal layout">
                <div hidden$="{{hideBioformats}}">
                    <label class="jso">Bioformat:</label>
                    <div id="bioformatsBox">
                        <jso-opencga-bioformat id="bioformatSelect" bioformats="{{bioformats}}" on-selected-bioformat-change="handleSelectedBioformatChange"></jso-opencga-bioformat>
                    </div>
                </div>

                
                <div class="right vertical layout">
                    <label class="jso">File validation log:</label>
                    <jso-validator id="validator" bioformats="{{bioformats}}" on-end="handleValidatorEnd" on-stop="handleValidatorStop"></jso-validator>
                </div>
            </div>

            <br>
            <div class="horizontal layout">
                <form id="form">
                    <div id="uploadButton" class="jso-btn jso-btn-shdw" on-click="handleUpload"><i class="fa fa-cloud-upload"></i> Upload</div>
                    
                </form>
                <div class="flex" style="margin-left:15px;position:relative;">
                    <div class="uploadbar flex">
                        <div id="progressBar" class="uploadprogress"></div>
                        <div class="uploadtext">
                            <span hidden$="{{!uploading}}">
                                <i class="fa fa-spinner fa-spin"></i>
                                <span>{{percentProgress}}</span> % </span>
                        </div>
                        <br>
                    </div>
                </div>
            </div>
        </div>
        <div id="footer" class="horizontal layout center">
            &nbsp;
            <span id="message">{{message}}</span>
        </div>

    </template>

</dom-module>
<script>
    Polymer({
        is: "jso-opencga-upload-file",
        properties: {
            fileName: {
                type: String,
                value: 'None'
            },
            projects: {
                type: Array,
                notify: true
            },
            selectedProject: {
                type: Object,
                observer: "selectedProjectChanged"
            },
            selectedStudy: {
                type: Object,
                value: null,
                observer: "selectedStudyChanged"
            },
            selectedFolder: {
                type: Object,
                observer: "selectedFolderChanged"
            },
            disableIndex: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            bioformats: {
                type: Array,
                value: function() {
                    return [];
                }
            },
            uploading: {
                type: Boolean,
                value: false
            },
            percentProgress: {
                type: Number,
                value: 0,
                observer: 'percentProgressChanged'
            },
            message: {
                type: String,
                value: ''
            },
            hideBioformats: {
                type: Boolean,
                value: false
            },
            showSelectStudy: {
                type: Boolean,
                value: true
            },
            validating: {
                type: Boolean,
                value: false
            },
            // hideValidationLog: {
            //     type: Boolean,
            //     value: true,
            //     observer: 'hideValidationLogChanged'
            // },
        },
        ready: function(e) {
            var me = this;
            if (this.bioformats.length == 0) {
                /*** Check number of bioformats in order to show the bioformat chooser ***/
                // console.log("No bioformats selected")
                this.checkBioformats();
            }

            if (this._parentJsoPanel) {
                this._parentJsoPanel.addEventListener("close", function(e) {
                    me.$.validator.reset();
                });
            }
        },
        checkBioformats: function() {
            var numberOfBioformats = 0;
            var bioformatIdx;
            for (var i = 0; i < this.bioformats.length; i++) {
                var format = this.bioformats[i];
                if (format.key) {
                    numberOfBioformats++;
                    bioformatIdx = i;
                }
            }
            if (numberOfBioformats == 1) {
                this.hideBioformats = true;
                this.selectedBioformat = this.bioformats[bioformatIdx];
                // if (this.selectedBioformat.validator != null) {
                //     this.hideValidationLog = false;
                // }
            }
            if (numberOfBioformats == 0) {
                this.hideBioformats = true;
                this.selectedBioformat = {
                    value: 'NONE',
                    text: 'NONE'
                };
                // this.hideValidationLog = true;
            }
        },
        handleSelectedBioformatChange: function(e) {
            // if (this.$.bioformatSelect.selectedBioformat != null && this.$.bioformatSelect.selectedBioformat.validator != null) {
            //     this.hideValidationLog = false;
            // } else {
            //     this.hideValidationLog = true;
            // }
        },
        hideValidationLogChanged: function(e) {
            if (this._parentJsoPanel) {
                this._parentJsoPanel._center();
            }
        },
        handleBrowseClick: function(e) {
            if (this.uploading == false) {
                this.$.fileInput.value = null;
                this.fileName = "None";
                this.$.validator.reset();
                this.$.fileInput.click();
            }
        },
        handleInputChange: function() {
            if (this.uploading == false) {

                var inputFile = this.$.fileInput.files[0];
                this.fileName = inputFile.name

                if (window.VCF_VALIDATOR== null || window.VCF_VALIDATOR == true) {
                  this.validate();
                } else {
                  this.handleValidatorEnd();
                }

                // console.log(inputFile.type)
            }
        },
        handleUpload: function() {
            var file = this.$.fileInput.files[0];
            if (file == null) {
                this.message = "No file selected."
                return;
            }
            if (this.uploading == true) {
                this.message = "Upload already in progress."
                return;
            }
            if (this.validating == false) {

                if (this.$.validator.errorCount > 0) {
                    this.message = "The file contains errors."
                    return;
                }
                if (this.$.validator.warningCount > 0) {
                    if (confirm("File contains warning messages, are you sure?")) {
                        this.handleForm();
                        return;
                    }
                }
                this.handleForm();
            }
        },
        handleForm: function() {
            var me = this;
            if (this.uploading == false) {

                /* Check bioformat */
                var selBioformat;
                if (this.$.bioformatSelect.selectedBioformat != null) {
                    selBioformat = this.$.bioformatSelect.selectedBioformat;
                }
                if (this.selectedBioformat != null) {
                    selBioformat = this.selectedBioformat;
                }
                if (selBioformat == null) {
                    alert("Please select a bioformat");
                    return;
                }

                var selStudy;
                if (this.$.studySelect.selectedStudy != null) {
                    selStudy = this.$.studySelect.selectedStudy;
                }
                if (this.selectedStudy != null) {
                    selStudy = this.selectedStudy;
                }
                if (selStudy == null) {
                    alert("Please select a study");
                    return;
                }

                var folder = "";
                if (this.selectedFolder != null) {
                    folder = this.selectedFolder.path;
                }
                if (this.$.form.checkValidity()) {
                    this.uploading = true;
                    this.message = '';
                    var config = {
                        inputFile: this.$.fileInput.files[0],
                        fileName: this.fileName.replace(/[^a-zA-Z0-9._\-]/g, "_"),
                        userId: Cookies("bioinfo_user"),
                        sid: Cookies("bioinfo_sid"),
                        studyId: selStudy.id,
                        relativeFilePath: folder + this.fileName,
                        fileFormat: 'PLAIN',
                        bioFormat: selBioformat.value,
                        description: '',
                        callbackProgress: function(chunk, total, response) {
                            me.percentProgress = Math.round((chunk.id / total) * 100);
                            if (chunk.last) {
                                me.message = "Upload complete.";
                                me.percentProgress = 0;
                                me.uploading = false;
                                me.$.fileInput.value = null;
                                me.fileName = 'None';
                                me.$.validator.reset();
                                me.fire('need-refresh');

                                var uploadedFile = response.response[0].result[0];
                                me.async(function() {
                                    me.fire('file-uploaded', uploadedFile);
                                }, 50);
                                //                                me._indexFile(uploadedFile);
                            }
                        },
                        error: function(msg) {
                            me.percentProgress = 0;
                            me.$.fileInput.value = null;
                            me.fileName = 'None';
                            me.$.validator.reset();
                            me.uploading = false;
                            me.message = msg;
                        }
                    };
                    OpencgaManager.files.upload2(config);
                } else {
                    alert("Please select a file");
                    return;
                }
            }
        },
        percentProgressChanged: function(neo, old) {
            this.$.progressBar.style.width = neo + '%';
        },
        selectedProjectChanged: function(neo, old) {},
        selectedStudyChanged: function(neo, old) {
            this.fileName = "None";
            if (this.selectedStudy == null)
                this.showSelectStudy = true;
            else
                this.showSelectStudy = false;
        },
        selectedFolderChanged: function(neo, old) {
            this.fileName = "None";
        },

        _indexFile: function(file) {
            console.log(file.id);
            if (!this.disableIndex) {
                OpencgaManager.files.index({
                    id: file.id,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                        storageEngine: "mongodb"
                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                console.log("index");
                                console.log(response);
                            } else {
                                //                                me.message = response.response[0].errorMsg;
                            }
                        },
                        error: function() {
                            console.log('jso-opencga-upload-file473:Server error, try again later.');
                        }
                    }
                });
            } else {
                console.log("Disabled Index");
            }
        },

        validate: function(e) {
            /* Check bioformat */
            if (this.validating == false) {
                this.validating = true;
                var selBioformat;
                if (this.$.bioformatSelect.selectedBioformat != null) {
                    selBioformat = this.$.bioformatSelect.selectedBioformat;
                }
                if (this.selectedBioformat != null) {
                    selBioformat = this.selectedBioformat;
                }
                if (selBioformat == null) {
                    alert("Please select a bioformat");
                    this.validating = false;
                    return;
                }

                /* Validate bioformat */
                var file = this.$.fileInput.files[0];

                if (selBioformat != null && file != null) {
                    this.$.validator.reset();
                    var validator;

                    if (selBioformat.validator) {
                        if (typeof selBioformat.validator !== "function") {
                            alert("Validator '" + selBioformat.validator + "' not recognized.");
                            return;
                        }
                        validator = new selBioformat.validator({});
                    } else {
                        validator = new Validator({});
                    }

                    this.$.validator.validator = validator;
                    this.$.validator.setFile(file);
                    this.$.validator.validate();
                } else {
                    this.validating = false;
                }
            }

        },

        handleValidatorEnd: function(e) {
            alert('Validation has finished succesfully. Check errors or click on upload button');
            this.validating = false;
        },

        handleValidatorStop: function(e) {
            alert('Validation has been stopped.');
            this.validating = false;

            if (this._wantRevalidate == true) {
                this._wantRevalidate = null;
                this.revalidate();
            }
        },

        tplEq: function(prop, value) {
            return prop == value;
        },

        handleRecheck: function() {
            // this.$.validator.reset();
            // this.validate();
            if (this.validating == true) {
                this._wantRevalidate = true;
                this.$.validator.stop();
            } else {
                this.revalidate();
            }
        },
        revalidate: function() {
            this.$.validator.reset();
            this.validate();
        }

    });
</script>
<dom-module id="jso-opencga-file-preview" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: auto;
            width: 800px;
            height: 600px;
            padding: 10px;
        }

        .wrapped-text {
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
    <template>
        <code class="wrapped-text">{{contentData}}</code>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-file-preview",
        properties: {
            selectedStudy: {
                type: Object,
                observer: 'selectedStudyChanged'
            },
            file: {
                type: Object,
                value: function() {
                    return null;
                },
                observer: 'fileChanged'
            },
            contentData: {
                type: String,
                value: ""
            },
            _start: {
                type: Number,
                value: 0
            },
            _limit: {
                type: Number,
                value: 100
            },
            _pageSize: {
                type: Number,
                value: 100
            },
            _end: {
                type: Boolean,
                value: false
            }
        },
        listeners: {
            'scroll': 'handleScroll'
        },
        ready: function() {
            var me = this;
            if (this._parentJsoPanel) {
                this._parentJsoPanel.addEventListener('close', function(e) {
                    me._clear();
                });
            }
        },
        loadPage: function() {

            var data;
            OpencgaManager.files.content({
                id: this.file.id,
                query: {
                    sid: Cookies('bioinfo_sid'),
                    limit: this._limit,
                    start: this._start
                },
                request: {
                    async: false,
                    success: function(response) {
                        data = response;
                    },
                    error: function() {

                    }
                }
            });

            if (data) {
                this.contentData =
                    this.contentData = this.contentData + data;
            } else {
                this._end = true;
            }
        },
        handleScroll: function(e) {
            var el = e.currentTarget;
            if (el.offsetHeight + el.scrollTop >= el.scrollHeight) {
                if (!this._end) {
                    this._start = this._limit;
                    this._limit = this._start + this._pageSize;
                    this.loadPage();
                }
            }
        },
        fileChanged: function(neo, old) {
            if (neo != null) {
                this._clear();
                this.loadPage();
            }
        },
        _clear: function() {
            this.contentData = "";
            this._start = 0;
            this._limit = 100;
            this._end = false;
            this.scrollTop = 0;
        }
    });
</script>
<dom-module id="jso-opencga-create-folder" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
        }

        .message {
            margin-top: 5px;
        }

    </style>
    <template>
        <form id="form" class="vertical layout" on-keypress="handleFormKey">
            
            <label class="jso"> Folder name</label>
            <input class="jso" type="text" id="name" value="{{newFolderName::input}}" required="" pattern="[a-zA-Z0-9_-]+">
            <br>

            <div class="jso-btn jso-btn-shdw" on-click="handleForm">Create</div>
            <br>
        </form>
        <div>{{message}}</div>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'jso-opencga-create-folder',
        properties: {
            folder: {
                type: Object,
                notify: true,
                value: null
            },
            study: {
                type: Object
            },
            message: {
                type: String,
                value: ''
            },
            newFolderName: {
                type: String,
                value: ''
            },
        },
        handleFormKey: function (e) {
            if (e.which == 13) {
                e.preventDefault();
                this.handleForm();
            }
        },
        handleForm: function (e) {
            var me = this;
            this.message = '';

            if (this.$.form.checkValidity()) {
                OpencgaManager.files.createFolder({
                    query: {
                        sid: Cookies('bioinfo_sid'),
                        folder: this.folder.path + this.newFolderName,
                        studyId: this.study.id

                    },
                    request: {
                        success: function (response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                me.message = '';
                                me.name = '';
                                me.fire('need-refresh');
                                me.fire('folder-created');
                            } else {
                                me.message = response.response[0].errorMsg;
                            }
                        },
                        error: function () {
                            console.log('jso-opencga-create-folder76:Server error, try again later.');
                        }
                    }
                });
            } else {
                this.message = 'Only letters, numbers or slash(-,_) admitted';
            }
        }
    });
</script>
<dom-module id="jso-opencga-folder-list-item" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
        }

        :host:hover {
            background-color: #ddd;
        }

        :host[selected] {
            background-color: #ccc;
        }

        #name {
            width: calc(100% - 160px);
        }

        #creationDate {
            color: #444;
            width: 80px;
            text-align: center;
        }

        #size {
            color: #444;
            width: 80px;
            text-align: center;
        }

        .filename {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            width: 100%;
        }

        .icon {
            padding: 0 5px 0 2px;
        }

        .creationDate {
            color: #444;
            width: 80px;
            text-align: center;
        }

        #status {
            color: #444;
            width: 80px;
            text-transform: capitalize;
            text-align: center;
        }

        .fa-cog {
            color: var(--default-primary-color);
        }

        .huge-icon {
            font-size: 30px;
            font-weight: lighter !important;
            margin: 2px;
            padding: 10px;
            height: 25px;
        }

        .icon-mode-elem {
            padding: 0 5px 0 2px;
            width: 60px;
            text-align: center;
        }
    </style>
    <template>
        <template is="dom-if" if="{{computeViewMode(viewMode, 'list')}}">
            <div id="list" class="horizontal layout">
                <div id="name" class="horizontal layout">
                    <div class="icon"><i class$="{{computeIcon(file)}}"></i></div>
                    <div class="filename" title$="{{file.name}}">{{file.name}}</div>
                </div>
                <div class="creationDate">{{computeDate(file)}}</div>
                <div id="status">
                    <i class$="{{computeStatusIcon(file)}}"></i>
                    <span>{{computeStatus(file)}}</span>
                </div>
            </div>
        </template>
        <template is="dom-if" if="{{computeViewMode(viewMode, 'icon')}}">
            <div class="vertical layout flex icon-mode-elem" title$="{{file.name}}">
                <div class="icon huge-icon"><i class$="{{computeIcon(file)}}"></i></div>
                <div class="filename">{{file.name}}</div>
            </div>
        </template>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-folder-list-item",
        properties: {
            file: {
                type: Object,
                notify: true
            },
            indexableBioFormats: {
                type: Array,
                value: ['VARIANT', 'ALIGNMENT']
            },
            viewMode: {
                type: String,
                value: 'list',
                reflectToAttribute: true
            }
        },
        computeDate: function(file) {
            var date = new Date(Date.parse(Utils.parseDate(file.creationDate)));
            return Utils.months[date.getMonth()] + " " + date.getDate() + ", " + date.getFullYear();
        },
        computeIcon: function(file) {
            var iconMap = {
                "FOLDER": 'fa fa-folder',
                "DIRECTORY": 'fa fa-folder',
                "FILE": 'fa fa-file-o'
            };

            return iconMap[file.type];
        },
        computeStatusIcon: function(file) {
            var iconMap = {
                "INDEXING": 'fa fa-cog fa-spin',
                "READY": 'fa fa-check',
                "NONE": 'fa fa-check'
            };
            if (file.index) {
                return iconMap[file.index.status];
            }
            return '';
        },
        computeStatus: function(file) {
            if (file.index && this.indexableBioFormats.indexOf(file.bioformat) != -1) {
                return file.index.status;
            }
            return '--';
        },
        computeViewMode: function(viewMode, value) {
            return viewMode == value;
        }
    });
</script>
<dom-module id="jso-opencga-folder-list" assetpath="bower_components/jsorolla/src/lib/components/opencga/files/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
        }

        #header,
        #bar {
            box-sizing: border-box;
            background-color: var(--light-secondary-color);
            padding: 3px 7px;
            border-bottom: 1px solid var(--divider-color);
        }

        #header {
            height: 25px;
        }

        #bar {
            height: 30px;
        }

        #content.list {
            height: calc(100% - 55px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        #content.list.info {
            height: calc(100% - 115px);
        }

        #content.icon {
            height: calc(100% - 30px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        #content.icon.info {
            height: calc(100% - 90px);
        }

        .name {}

        .creationDate {
            color: #444;
            width: 80px;
            text-align: center;
        }

        .status {
            color: #444;
            width: 95px;
            text-align: center;
        }

        jso-opencga-folder-list-item[view-mode='list'] {
            padding: 3px 7px;
            border-bottom: 1px solid rgba(125, 125, 125, 0.3);
        }

        jso-opencga-folder-list-item[view-mode='list']:last-of-type {
            border-bottom-width: 0px;
        }

        jso-opencga-folder-list-item[view-mode='icon'] {
            margin: 1px;
            height: 70px;
        }

        #createfolder {
            box-sizing: border-box;
            width: 300px;
            background-color: #fafafa;
            padding: 20px 30px;
        }

        .upload-btn {
            color: var(--default-primary-color);
        }

        .bar > div {
            margin-right: 5px;
        }

        #fileInfo {
            box-sizing: border-box;
            height: 60px;
            background-color: var(--light-secondary-color);
            border-top: 1px solid var(--divider-color);
            padding: 5px;
        }

        .data {
            color: var(--secondary-text-color);
        }

        .value {
            margin-right: 10px;
        }

        .lowercase {
            text-transform: lowercase;
        }
    </style>
    <template>
        <div id="bar" class="horizontal layout">
            <div class="bar horizontal layout flex">
                <div class="jso-btn jso-btn-shdw" hidden$="{{checkBack(folder)}}" on-click="handleBack">
                    <i class="fa fa-arrow-left"></i>
                </div>

                <div class="jso-btn jso-btn-shdw upload-btn" hidden$="{{isFolderMode(mode)}}" on-click="handleUploadFile">
                    <i class="fa fa-cloud-upload"></i> Upload
                </div>

                <div class="jso-btn jso-btn-shdw" hidden$="{{checkFolder(folder)}}" on-click="handleCreateFolder">
                    <i class="fa fa-folder"></i> +
                </div>
                <div class="jso-btn jso-btn-shdw" hidden$="{{checkSelected(selected)}}" on-click="handleDeleteFile">
                    <i class="fa fa-trash"></i>
                </div>
                <div class="jso-btn jso-btn-shdw" hidden$="{{checkSelectedFile(selected)}}" on-click="handlePreviewFile">
                    <i class="fa fa-eye"></i>
                </div>
            </div>
            <div class="horizontal layout">
                <div class="jso-btn jso-btn-shdw" on-click="handleViewInfo" style="margin-right: 5px;" hidden$="{{checkSelected(selected)}}">
                    <i class="fa fa-info"></i>
                </div>
                <div class="jso-btn jso-btn-shdw" on-click="handleViewMode" hidden$="{{disableIconView}}">
                    <i class$="{{computeViewModeIconClass(viewMode)}}"></i>
                </div>
                
                
                
                <div class="jso-btn jso-btn-shdw" hidden$="{{handleHiddenIndex(selected)}}" on-click="handleIndexFile">
                    <i class="fa fa-cog"></i>&nbsp;Index
                </div>
            </div>
        </div>

        <template is="dom-if" if="{{computeHeader(viewMode)}}">
            <div id="header" class="horizontal layout">
                <div class="name flex">Name</div>
                <div class="creationDate">Date</div>
                <div class="status">Status</div>
            </div>
        </template>
        <div id="content" class$="{{computeContentClass(viewMode,showInfo)}}">
            <div class$="{{computeClassViewMode(viewMode)}}">
                <template is="dom-repeat" items="{{files}}" filter="checkFilters" observe="type">
                    <jso-opencga-folder-list-item file="{{item}}" on-dblclick="handleFileDblClick" on-click="handleFileClick" view-mode="{{viewMode}}">
                    </jso-opencga-folder-list-item>
                </template>
            </div>
        </div>

        <div id="fileInfo" class="vertical layout" hidden="{{!showInfo}}">
            <div class="horizontal layout">
                <i class="fa fa-file-o" hidden="{{isFile}}"></i>
                <i class="fa fa-folder" hidden="{{!isFile}}"></i>&nbsp;
                <span>{{fileName}}</span>
            </div>
            <div class="horizontal layout">
                <span class="data">Type: &nbsp;</span>
                <span class="value lowercase">{{fileType}}</span>
                <span class="data">Bioformat: &nbsp;</span>
                <span class="value lowercase">{{fileBioformat}}</span>
                <span class="data">Status: &nbsp;</span>
                <span class="value">{{computeIndex(selected)}}</span>
            </div>
            <div class="horizontal layout">
                <span class="data">Creation Date: &nbsp;</span>
                <span>{{fileDate}}</span>
            </div>
        </div>

        <jso-panel modal="" closable="" hidden="" id="createFolderModal">
            <div class="header"><i class="fa fa-folder"></i> &nbsp; Create folder</div>
            <jso-opencga-create-folder class="container" id="createfolder" on-folder-created="handleFolderCreated" folder="{{folder}}" study="{{study}}">
            </jso-opencga-create-folder>
        </jso-panel>


    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-folder-list",
        properties: {
            folder: {
                type: Object,
                notify: true,
                value: null
            },
            files: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                }
            },
            selected: {
                type: Object,
                notify: true,
                value: function() {
                    return null;
                }
            },
            study: {
                type: Object,
                observer: 'studyChanged'
            },
            mode: {
                type: String,
                reflectToAttribute: true,
            },
            viewMode: {
                type: String,
                value: 'list'
            },
            showInfo: {
                type: Boolean,
                value: false
            },
            disableIconView: {
                type: Boolean,
                value: false
            },
            isFile: {
                type: Boolean,
                value: false
            }
        },
        handleUploadFile: function(e) {
            if (this.study != null) {
                var fileIndex = false;
                for (var i = 0; i < this.files.length; i++) {
                    if (this.files[i].index != null && this.files[i].index.status == "INDEXING") {
                        fileIndex = true;
                        alert("Wait until any file is Indexing");
                        break;
                    }
                }
                if (fileIndex == false) {
                    this.fire('upload-file');
                }
            } else {
                alert("You must select a study before uploading a file.")
            }
        },
        handleCreateFolder: function(e) {
            if (this.$.createFolderModal.hasAttribute('hidden')) {
                this.$.createFolderModal.removeAttribute('hidden');
            } else {
                this.$.createFolderModal.setAttribute('hidden', '');
            }
        },
        handleFolderCreated: function(e) {
            this.$.createFolderModal.setAttribute('hidden', '');
        },
        handleDeleteFile: function(e) {
            if (confirm("Are you sure?")) {
                this._deleteFile();

            }
        },
        handleIndexFile: function(e) {
            this._indexFile();
        },
        _autoIndexfile: function(file) {
            this.selected = file;
            this._indexFile();
        },
        handleFileClick: function(e) {

            this.selected = e.currentTarget.file;
            var sel = this.querySelector("jso-opencga-folder-list-item[selected]");
            if (sel) {
                sel.removeAttribute('selected');
            }
            e.currentTarget.setAttribute('selected', '');
            this.fire('fileselect', this.selected);

            this.fileName = this.selected.name;
            this.fileType = this.selected.type;
            if (this.fileType == "FOLDER" || this.fileType == "DIRECTORY") {
                this.isFile = true;
            } else {
                this.isFile = false;
            }
            this.fileBioformat = this.selected.bioformat;

            var date = new Date(Date.parse(Utils.parseDate(this.selected.creationDate)));
            this.fileDate = date.toLocaleString("en-us", {
                month: "short"
            }) + " " + date.getDate() + ", " + date.getFullYear() + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();

        },
        handleFileDblClick: function(e) {
            var file = e.currentTarget.file;
            if (file.type == 'FOLDER' || file.type == "DIRECTORY") {
                this.fire('openfolder', file);
            } else if (file.type == "FILE") {
                this.fire('previewfile', file);
            }

        },
        handlePreviewFile: function(e) {
            if (this.selected) {
                this.fire('previewfile', this.selected);
            }
        },
        handleBack: function() {
            this.fire('back');
        },
        checkFolder: function(folder) {
            return folder == null;
        },
        checkBack: function(folder) {
            if (folder == null) {
                return true
            } else {
                if (folder.name == '.') {
                    return true;
                }
            }
            return false;
        },
        checkSelected: function(selected) {
            return selected == null;
        },
        checkSelectedFile: function(selected) {
            return selected == null || selected.type != "FILE";
        },
        handleHiddenIndex: function(selected) {
            if (selected == null) {
                return true;
            } else {
                if (selected.type == 'FOLDER' || selected.type == "DIRECTORY") {
                    return true;
                }
                if (selected.index != null && selected.index.status !== 'NONE') {
                    return true
                } else {
                    if (selected.bioformat !== "VARIANT" && selected.bioformat !== "ALIGNMENT") {
                        return true
                    }
                }
            }

            return false;
        },
        checkFilters: function(item) {
            return true;
            //            return item.bioformat == "VARIANT";
        },
        isFolderMode: function(mode) {
            return mode === 'folder';
        },

        /**/
        _deleteFile: function() {
            var me = this;
            if (this.selected) {
                OpencgaManager.files.delete({
                    id: this.selected.id,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                console.log("delete");
                                console.log(response);

                                me.fire('need-refresh');
                            } else {
                                console.log(response.response[0].errorMsg);
                            }
                        },
                        error: function() {
                            console.log('jso-opencga-folder-list374:Server error, try again later.');
                        }
                    }
                });
            }
        },
        _indexFile: function() {
            var me = this;
            if (this.selected) {
                OpencgaManager.files.index({
                    id: this.selected.id,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                        storageEngine: "mongodb",

                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                console.log("index");
                                console.log(response);
                                me.fire('need-refresh');
                            } else {
                                console.log(response.response[0].errorMsg);
                            }
                        },
                        error: function() {
                            console.log('jso-opencga-folder-list401:Server error, try again later.');
                        }
                    }
                });
            }
        },
        computeHeader: function(viewMode) {
            return viewMode == "list";
        },
        computeViewModeIconClass: function(viewMode) {
            var iconClass = (this.viewMode == "list") ? "fa fa-th" : "fa fa-list";
            return iconClass;
        },
        handleViewMode: function(e) {
            this.viewMode = (this.viewMode == "list") ? "icon" : "list";
        },
        computeClassViewMode: function(viewMode) {
            if (viewMode == "icon") {
                return "horizontal layout wrap";
            } else {
                return "";
            }
        },
        computeContentClass: function(viewMode, showInfo) {
            if (showInfo) {
                return viewMode + " info";
            } else {
                return viewMode;
            }
        },
        handleViewInfo: function(e) {
            if (this.selected != null) {
                this.showInfo = !this.showInfo;
            }
        },
        computeIndex: function(selected) {
            if (this.fileName != "") {
                if (selected != null && selected.index != null && (selected.bioformat == "VARIANT" || selected.bioformat == "ALIGNMENT")) {
                    return selected.index.status;
                } else {
                    return "--";
                }
            }
            return "";

        },
        studyChanged: function() {
            this.fileName = "";
            this.fileType = "";
            this.fileBioformat = "";
            this.fileDate = "";
        }

    });
</script>
<dom-module id="jso-opencga-sample-info" assetpath="bower_components/jsorolla/src/lib/components/opencga/files-new/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            position: relative;
            display: block;
            box-sizing: border-box;
            height: 100%;
            border-top: 1px solid var(--divider-color);
        }

        #sampleList,
        #sampleSelectedList {
            box-sizing: border-box;
            overflow-y: auto;
            height: calc(100% - 59px);
            /*height: 145px;*/
            border: 1px solid #ddd;
            /*width: 232px;*/
        }

        #sampleSelectedList {
            height: calc(100% - 35px);
        }

        #sampleList {
            border-top: 0;
        }

        .sam {
            width: 48%;
            padding: 5px;
        }

        .study-info {
            height: 30px;
            box-sizing: border-box;
            background-color: var(--light-secondary-color);
            border-top: 1px solid var(--divider-color);
            padding: 5px;
        }

        .sample-info,
        .family-info {
            height: calc(100% - 30px);
            box-sizing: border-box;
        }

        .variantButton,
        #familySaveButton,
        #familyButton {
            border-radius: 5px;
            width: 150px;
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
            margin: 5px;
        }

        #addButton {
            width: 25px;
            font-size: 15px;
            color: #435f7a;
            margin-left: 5px;
            font-weight: bold;
        }

        #clearButton {
            width: 50px;
            color: #435f7a;
            font-weight: bold;
        }

        .variantButton:hover,
        #familySaveButton:hover,
        #familyButton:hover {
            background-color: var(--light-button-color) !important;
        }

        .msgError {
            color: #bf4747;
            font-style: italic;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }

        .fileName {
            font-weight: bold;
            color: #445D76;
            margin-left: 5px;
            width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .check {
            border: 1px solid var(--divider-color);
            border-right: 0;
            padding-left: 6px;
        }

        .tabwrap {
            box-sizing: border-box;
            position: relative;
            border: 1px solid var(--divider-color);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
            height: 100%;
        }

        .tab {
            height: 20px;
            line-height: 20px;
            font-size: 14px;
            width: 150px;
            padding: 5px 10px;
            color: #666;
            text-align: center;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
        }

        .tab[data-checked] {
            background-color: #fff;
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
            color: #222;
            border: 1px solid #ddd;
            border-bottom: 1px solid transparent;
            box-shadow: 1px -1px 1px rgba(0, 0, 0, 0.1);
        }

        .tab:hover {
            color: #8ba7a7;
            font-weight: bold;
        }

        #submenu {
            background-color: #e2e9e9;
            padding-left: 10px;
            padding-top: 10px;
        }

        #information {
            position: relative;
            height: calc(100% - 40px);
        }

        #information > div {
            position: relative;
            height: 100%;
        }

        #connectFamilyPanel {
            height: 500px;
            width: 1000px;
        }

        #connectFamilyPanel .container {
            padding: 5px;
        }

        jso-select {
            width: 100px;
        }

        .columnFam {
            width: 100px;
            padding: 3px;
            margin-left: 5px;
        }

        .nameSam {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-left: 10px;
        }

        .preview {
            width: 40%;
            height: 90%;
            margin-left: 15px;
        }

        .tableSample {
            /*width: 60%;*/
            height: 100%;
        }

        #familySamplesList {
            overflow-y: auto;
            height: 80%
        }

        #familyInfo >div {
            border: 1px solid transparent;
            height: 20px;
            width: 100%;
        }

        #familyInfo >div[selected] {
            border: 1px solid #8ba7a7;
            background: #8ba7a7;
        }

        #familyInfo >div:hover {
            border: 1px solid #ccc;
            background: #ccc;
        }

        svg {
            font: 10px sans-serif;
        }

        .linage {
            fill: none;
            stroke: #000;
        }

        .marriage {
            fill: none;
            stroke: black;
        }

        .man {
            border: 1px solid black;
            background-color: white;
        }

        .woman {
            border: 1px solid black;
            border-radius: 10px;
            background-color: white;
        }

        .emphasis {
            font-style: italic;
        }

        p {
            padding: 0;
            margin: 0;
        }

        .proband {
            background-color: black;
            color: white;
        }

        #previewFamilyTree {
            height: 400px;
            width: 600px;
        }
    </style>
    <template>
        <div class="tabwrap">
            <div id="submenu" class="horizontal layout">
                <div class="tab" on-click="handleOptions" data-value="samples" data-checked$="{{computeOptions(option, 'samples')}}">
                    Samples
                </div>
                <div class="tab" on-click="handleOptions" data-value="family" data-checked$="{{computeOptions(option, 'family')}}" hidden="{{!isFamilyStudy(study)}}">
                    Families
                </div>
                <div class="tab flex" style="cursor:default"></div>
            </div>
            <div id="information">
                <div hidden$="{{!computeOptions(option, 'samples')}}" id="samples">
                    <div class="sample-info horizontal layout">
                        <div class="sam">
                            <div class="horizontal layout center" style="height:25px">
                                <label>Samples from: </label>
                                <div class="flex fileName">{{fileName}}</div>
                            </div>
                            <div class="horizontal layout center" style="height:100%">
                                <div class="" style="width:calc(100% - 25px);height:100%">
                                    <div class="horizontal layout center">
                                        <label class="jso-control horizontal layout check">
                                            <input id="checkButton" class="jso" type="checkbox" on-change="handleToggle">
                                            <span></span>
                                        </label>
                                        <input style="height:24px" id="searchInput" class="jso" type="text" placeholder="Search by name..." value="{{search::input}}">
                                    </div>
                                    <div id="sampleList" class="">
                                        <template is="dom-repeat" items="{{filteredSamples}}">
                                            <label class="horizontal layout center jso-control">
                                                <input class="jso" type="checkbox" sample="{{item}}">
                                                <span>{{item.name}}</span>(
                                                <span style="margin-left:5px;" class="nameSam" title="{{item.source}}">{{item.source}}</span>)
                                            </label>
                                        </template>
                                    </div>
                                </div>
                                <div id="addButton" class="jso-btn jso-btn-shdw" on-click="handleAddSample" title="Add selected samples"><i class="fa fa-arrow-right" aria-hidden="true"></i>
                                </div>
                            </div>
                        </div>
                        <div class="sam right">
                            <div class="horizontal layout center" style="height:25px">
                                <label>Selected Samples: </label>
                                <div class="flex">
                                </div>
                                <div id="clearButton" class="jso-btn jso-btn-shdw" on-click="handleClearSamples" title="Clear all selected samples">Clear
                                </div>
                            </div>
                            <div id="sampleSelectedList">
                                <template is="dom-repeat" items="{{sampleSelected}}">
                                    <div class="horizontal layout center jso-control" style="margin-top:2px;">
                                        <i style="margin-left:5px;" class="fa fa-times" sample="{{item.id}}" on-click="handleRemoveSample" title="Remove sample in selected sample list"></i>&nbsp;
                                        <span style="margin-left:5px;">{{item.name}}</span>&nbsp;(
                                        <span style="margin-left:5px;" class="nameSam" title="{{item.source}}">{{item.source}}</span>)
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                    <div class="study-info horizontal layout center">
                        <label class="" style="margin-left:5px;">Study Type: </label>
                        <div class="flex" style="font-weight:bold;color: #445D76;margin-left:5px;">{{study.type}}</div>
                        <div class="msgError" title="{{indexMsg}}">{{indexMsg}}</div>
                        <div class="horizontal layout center end-justified">
                            <div id="familyButton" class="jso-btn jso-btn-shdw" on-click="handleViewConnectFamily" title="Connect selected samples in a Family" hidden="{{!isFamilyStudy(study)}}"> Connect Family
                            </div>
                            <div id="variantButton" class="jso-btn jso-btn-shdw variantButton" on-click="handleViewVariantBrowswer" title="Explore selected samples"> Variant Browser
                            </div>
                        </div>
                    </div>
                </div>
                <div hidden$="{{!computeOptions(option, 'family')}}" id="family">
                    <div class="horizontal layout" style="border-bottom:1px solid grey">
                        <label class="columnFam">Name</label>
                        <label class="columnFam" style="margin-left:10px">Samples</label>
                    </div>
                    <div id="familyInfo" class="family-info" style="overflow-y: auto;">
                        <template is="dom-repeat" items="{{familyListUserSaved}}">
                            <div class="horizontal layout center flex" value$="{{item.name}}" data-list$="{{item.family}}" on-click="handleSelectedAttribute" on-dblclick="handlepreviewFamilyTree">
                                <div class="columnFam nameSam" title="{{item.name}}">{{item.name}}
                                </div>
                                <div class="columnFam nameSam flex horizontal layout" title="{{_getSamplesFamName(item.samplesInfo)}}">{{_getSamplesFamName(item.samplesInfo)}}
                                </div>
                            </div>
                        </template>
                    </div>
                    <div class="study-info horizontal layout center">
                        <label class="" style="margin-left:5px;">Study Type: </label>
                        <div class="flex" style="font-weight:bold;color: #445D76;margin-left:5px;">{{study.type}}</div>
                        <div class="msgError" title="{{indexMsg}}">{{indexMsg}}</div>
                        <div class="horizontal layout center end-justified">
                            <div data-value="family" class="jso-btn jso-btn-shdw variantButton" on-click="handleViewVariantBrowswer" title="Explore selected family"> Variant Browser
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <jso-panel id="previewFamilyTree" modal="" closable="" hidden="">
            <div class="header"><i class="fa fa-eye" aria-hidden="true"></i>&nbsp; Family Tree Preview
            </div>
            <div class="container" style="padding: 10px;">
                <div style="border: 1px solid grey; height:95%">
                    <div id="familyPreviewPanel"></div>
                </div>
            </div>
        </jso-panel>
        <jso-panel id="connectFamilyPanel" modal="" closable="" hidden="">
            <div class="header"><i class="fa fa-users" aria-hidden="true"></i>&nbsp; Connect Family
            </div>
            <div class="container horizontal layout center flex">
                <div class="tableSample">
                    <div class="horizontal layout" style="border-bottom:1px solid grey">
                        <label class="columnFam">Sample</label>
                        <label class="columnFam" style="width:70px">Proband</label>
                        <label class="columnFam">Gender</label>
                        <label class="columnFam">Father</label>
                        <label class="columnFam">Mother</label>
                        <label class="columnFam" style="width:50px">Add</label>
                    </div>
                    <div id="familySamplesList">
                        <template is="dom-repeat" items="{{sampleSelected}}">
                            <div data-id$="{{item.id}}" class="horizontal layout center jso-control sample" style="margin-top:2px;">
                                <div class="columnFam nameSam" value="{{item}}" title="{{item.name}}">{{item.name}}</div>
                                <div class="columnFam" style="width:50px;">
                                    <label class="horizontal layout center jso-control">
                                        <input type="checkbox" class="jso proband" name="name" value="">
                                        <span></span>
                                    </label>
                                </div>
                                <div class="columnFam">
                                    <jso-select class="gender">
                                        <jso-option value="Male">Male
                                        </jso-option>
                                        <jso-option value="Female">Female
                                        </jso-option>
                                    </jso-select>
                                </div>
                                <div class="columnFam">
                                    <jso-select class="father">
                                        <jso-option value="-">-
                                        </jso-option>
                                        <template is="dom-repeat" items="{{sampleSelected}}" as="sample">
                                            <jso-option value="{{sample.name}}">{{sample.name}}
                                            </jso-option>
                                        </template>
                                    </jso-select>
                                </div>
                                <div class="columnFam">
                                    <jso-select class="mother">
                                        <jso-option value="-">-
                                        </jso-option>
                                        <template is="dom-repeat" items="{{sampleSelected}}" as="sample">
                                            <jso-option value="{{sample.name}}">{{sample.name}}
                                            </jso-option>
                                        </template>
                                    </jso-select>
                                </div>
                                <div class="columnFam" style="width:50px;">
                                    <label class="horizontal layout center jso-control">
                                        <input type="checkbox" class="jso addFam" name="add" value="" on-click="addToFamilyPreview">
                                        <span></span>
                                    </label>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
                <div class="preview">
                    <div class="" style="border: 1px solid grey; height:95%">
                        <div id="familyPreview"></div>
                    </div>
                    <div class="horizontal layout center end-justified" style="margin-top:5px;">
                        
                        <div id="familySaveButton" class="jso-btn jso-btn-shdw" on-click="handleSaveFamily" title="Save Family"> Save Family
                        </div>
                    </div>
                </div>
            </div>
        </jso-panel>
    </template>
</dom-module>
<script>
    Polymer({
        is: "jso-opencga-sample-info",
        properties: {
            selectedFile: {
                type: Object,
                value: function() {
                    return {};
                },
                observer: "selectedFileChanged"
            },

            filteredSamples: {
                type: Array,
                value: function() {
                    return [];
                },
                notify: true,
            },
            sampleSelected: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                }
            },
            sampleMap: {
                type: Object,
                value: function() {
                    return {};
                }
            },
            samples: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
                observer: 'samplesChanged'
            },
            search: {
                type: String,
                value: "",
                observer: 'searchNameChanged'
            },
            study: {
                type: Object,
                observer: 'studyChanged'
            },
            indexMsg: {
                type: String,
                value: ""
            },
            option: {
                type: String,
                value: 'samples'
            },
            familyListNameMap: {
                type: Object,
                value: function() {
                    return {};
                }
            },
            familyListUserSaved: {
                type: Array,
                value: function() {
                    return [];
                }
            },
            studyInfo: {
                type: Object,
                value: function() {
                    return {};
                }
            },
            lastFamilySelected: {
                type: Object
            },
            familyMap: {
                type: Array,
                observer: 'familyMapChanged'
            },
            familyMapPreview: {
                type: Array,
                observer: 'familyMapPreviewChanged'
            }
        },
        ready: function() {
            this.scopeSubtree(this.$.familyPreview, true);
            this.scopeSubtree(this.$.familyPreviewPanel, true);
        },
        handleOptions: function(e) {
            this.option = e.target.dataset.value;
        },
        computeOptions: function(option, value) {
            return option === value;
        },
        isFamilyStudy: function(study) {
            if (study.type != null && study.type.toUpperCase() == "FAMILY") {
                return true;
            } else {
                return false;
            }
        },
        selectedFileChanged: function(neo, old) {
            var me = this;
            if (neo) {
                this.set('fileName', neo.name);
                this.handleDeselectAll();
                var sams = [];
                var els = this.$.sampleList.querySelectorAll("input:checked");
                for (var i = 0; i < els.length; i++) {
                    els[i].checked = false;
                }
                for (var i = 0; i < neo.sampleIds.length; i++) {
                    var s = this._getSamplesInfo(neo.sampleIds[i]);
                    if (s != null) {
                        if (neo.index != null && neo.index.status == "INDEXING") {
                            s.status = "INDEXING";
                            var msg = neo.name + " is indexing";
                            me.set('indexMsg', msg);
                        } else {
                            s.status = (neo.index) ? neo.index.status : "NOT INDEXED";
                            me.set('indexMsg', "");
                        }
                    }
                    sams.push(s);
                }
                this.set("samples", sams);
            }

        },
        _getSamplesInfo: function(samplesIds) {
            var me = this;
            var sample = null;
            OpencgaManager.samples.info({
                id: samplesIds,
                query: {
                    sid: Cookies('bioinfo_sid'),
                },
                request: {
                    async: false,
                    success: function(response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            sample = response.response[0].result[0];
                        } else {
                            console.log('Server error, try again later.');
                        }
                    },
                    error: function() {
                        console.log('Server error, try again later.');
                    }
                }
            });
            return sample;
        },

        samplesChanged: function(neo, old) {
            var me = this;
            var searchFilterSamples = this._filterBySearch(this.samples);
            this.set('filteredSamples', searchFilterSamples);
        },
        _filterBySearch: function(samples) {
            if (this.search == "") {
                return samples;
            }
            var filteredSamples = [];
            for (var i = 0; i < samples.length; i++) {
                var sample = samples[i];
                if (sample.name.toLowerCase().search(this.search.toLowerCase()) >= 0) {
                    filteredSamples.push(sample);
                }
            }
            return filteredSamples;
        },
        handleViewVariantBrowswer: function(e) {
            var me = this;
            if (e.currentTarget.dataset.value == "family") {
                if (this.lastFamilySelected != null) {
                    this.fire('viewvariantbrowserfam', {
                        samples: me.lastFamilySelected.samplesInfo
                    });
                }
            } else {
                this.set("sampleSelected", this.sampleSelected);
                this.fire('viewvariantbrowser');
            }
        },
        searchNameChanged: function(neo, old) {
            this.samplesChanged();
        },
        studyChanged: function(neo, old) {
            this.set('fileName', "");
            this.set("sampleMap", {});
            this.set("sampleSelected", []);
            this.set("filteredSamples", []);
            this.handleDeselectAll();
            this.handleRefreshFamilyList();
        },
        handleRemoveSample: function(e) {
            var id = e.currentTarget.sample;
            this.sampleMap[id] = null;
            for (var i = 0; i < this.sampleSelected.length; i++) {
                if (this.sampleSelected[i].id == id) {
                    this.splice('sampleSelected', i, 1);
                    break;
                }
            }

        },
        handleAddSample: function(e) {
            var sel = this.$.sampleList.querySelectorAll("input:checked");
            for (var i = 0; i < sel.length; i++) {
                var sample = sel[i].sample;
                if (sample.status == "READY") {
                    if (this.sampleMap[sample.id] == null) {
                        this.sampleMap[sample.id] = true;
                        this.push("sampleSelected", sel[i].sample);
                    }
                } else {
                    alert("All selected samples must be READY! Select samples from VCF in READY status.");
                }
            }
        },
        handleToggle: function(e) {
            if (e.currentTarget.checked) {
                this.handleSelectAll();
            } else {
                this.handleDeselectAll();
            }
        },
        handleSelectAll: function() {
            var select = this.$.sampleList.querySelectorAll("input");
            for (var i = 0; i < select.length; i++) {
                select[i].checked = true;
            }
        },
        handleDeselectAll: function() {
            this.$.checkButton.checked = false;
            var select = this.$.sampleList.querySelectorAll("input");
            for (var i = 0; i < select.length; i++) {
                select[i].checked = false;
            }
        },
        handleClearSamples: function(e) {
            this.set("sampleSelected", []);
            this.set("sampleMap", {});
        },
        handleViewConnectFamily: function(e) {
            if (this.sampleSelected.length > 0) {
                this.$.connectFamilyPanel.hidden = false;
            } else {
                alert("Select at least one sample.")
            }
        },
        handleSaveFamily: function() {
            var me = this;
            new StvDialog().prompt("Family Name: ", function(confirm, name) {
                if (confirm) {
                    if (me.familyListNameMap[name] == null) {
                        me._saveFamilyList(name);
                    } else {
                        new StvDialog().alert("A family with the same name already exists", function() {
                            me.handleSaveFamily();
                        });
                    }
                }
            });
        },
        _saveFamilyList: function(name) {
            var me = this;
            var family = this._createFamilySimpleJson();

            if (family != null) {
                this.familyListNameMap[name] = true;

                var familyObject = {
                    name: name,
                    samplesInfo: family
                };
                OpencgaManager.studies.info({
                    id: me.study.id,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                me.studyInfo = response.response[0].result[0];
                                if (me.studyInfo.attributes["biertool"] == null) {
                                    me.studyInfo.attributes["biertool"] = {};
                                }
                                if (me.studyInfo.attributes["biertool"]["family"] == null) {
                                    me.studyInfo.attributes["biertool"]["family"] = [];
                                }
                                me.studyInfo.attributes["biertool"]["family"].push(familyObject);
                                me.push('familyListUserSaved', familyObject);
                                new StvDialog().alert("Family saved successfull.");
                                me.$.connectFamilyPanel.hidden = true;
                                me.updatestudyInfo();
                            } else {
                                console.log(response.response[0].errorMsg);
                            }
                        },
                        error: function() {
                            console.log('Server error, try again later.');
                        }
                    }
                });
            }
        },
        _createFamilySimpleJson: function() {
            var array = []
            var samples = this.$.familySamplesList.querySelectorAll("div.sample");
            for (var i = 0; i < samples.length; i++) {
                var sampleDiv = samples[i];
                if (sampleDiv.querySelector(".addFam").checked == true) {
                    var elem = {
                        name: sampleDiv.querySelector(".nameSam").value.name,
                        proband: sampleDiv.querySelector(".proband").checked,
                        gender: sampleDiv.querySelector(".gender").value,
                        father: sampleDiv.querySelector(".father").value,
                        mother: sampleDiv.querySelector(".mother").value,
                        id: sampleDiv.querySelector(".nameSam").value.id,
                        source: sampleDiv.querySelector(".nameSam").value.source,
                        status: sampleDiv.querySelector(".nameSam").value.status,
                        marriages: []
                    };
                    var cl = "man"
                    if (elem.gender == "Female") {
                        cl = "woman";
                    }
                    if (elem.proband == true) {
                        cl = cl + " " + "proband";
                    }
                    elem["class"] = cl;
                    array.push(elem);
                }
            }
            return array;
        },
        _createFamilyJson: function() {
            var hash = {};
            var samples = this.$.familySamplesList.querySelectorAll("div.sample");
            for (var i = 0; i < samples.length; i++) {
                var sampleDiv = samples[i];
                if (sampleDiv.querySelector(".addFam").checked == true) {
                    var elem = {
                        name: sampleDiv.querySelector(".nameSam").value.name,
                        proband: sampleDiv.querySelector(".proband").checked,
                        gender: sampleDiv.querySelector(".gender").value,
                        father: sampleDiv.querySelector(".father").value,
                        mother: sampleDiv.querySelector(".mother").value,
                        id: sampleDiv.querySelector(".nameSam").value.id,
                        source: sampleDiv.querySelector(".nameSam").value.source,
                        status: sampleDiv.querySelector(".nameSam").value.status,
                        marriages: []
                    };
                    var cl = "man"
                    if (elem.gender == "Female") {
                        cl = "woman";
                    }
                    if (elem.proband == true) {
                        cl = cl + " " + "proband";
                    }
                    elem["class"] = cl;
                    hash[elem.name] = elem;
                }
            }
            // Manage marriages
            for (var key in hash) {
                var elem = hash[key];
                var f = elem.father;
                var m = elem.mother;

                if (f in hash) {
                    if (m in hash) {
                        hash[f] = this._addMarriage(hash[f], elem, hash[m]);
                    }
                }
                if (m in hash) {
                    if (f in hash) {
                        hash[m] = this._addMarriage(hash[m], elem, hash[f]);
                    }
                }
            }
            return hash;
        },
        _addMarriage: function(father, child, mother) {
            if (father.marriages.length == 0) {
                father.marriages.push({
                    'spouse': mother,
                    'children': []
                });
            }
            for (var i = 0; i < father.marriages.length; i++) {
                if (father.marriages[i].spouse.name == mother.name) {
                    father.marriages[i].children.push(child);
                }
            }

            return father;

        },
        _createFamilyMap: function() {
            var family = this._createFamilyJson();
            var familyArray = [];
            for (var key in family) {
                var elem = family[key];
                if ((elem.father == "-" || elem.mother == "-")) {
                    var flag = false;
                    for (var i = 0; i < familyArray.length; i++) {
                        var m = familyArray[i].marriages;
                        for (var j = 0; j < m.length; j++) {
                            if (m[j].spouse.name == elem.name) {
                                flag = true;
                            }
                        }
                    }
                    if (flag == false) {
                        familyArray.push(elem);
                    }
                }
            }
            this.set('familyMap', familyArray);
        },
        familyMapChanged: function(neo, old) {
            if (neo) {
                if (this.$.familyPreview.firstElementChild != null) {
                    this.$.familyPreview.removeChild(this.$.familyPreview.firstElementChild);
                }
                var arrayAux = [];
                arrayAux.push(neo[0]);

                dTree.init(neo, {
                    target: this.$.familyPreview,
                    debug: false,
                    width: 385,
                    height: 395,
                    margin: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    },
                    nodeWidth: 100,
                    styles: {
                        node: 'node',
                        linage: 'linage',
                        marriage: 'marriage',
                        text: 'nodeText'
                    }
                });
            }
        },
        updatestudyInfo: function() {
            var me = this;
            var url = OpencgaManager.studies.update({
                id: me.study.id,
                query: {
                    sid: Cookies('bioinfo_sid'),
                },
                request: {
                    method: "POST",
                    url: true
                }
            });
            console.log(url);
            console.log(this.studyInfo.attributes)
            var data = {
                'attributes': {
                    "biertool": this.studyInfo.attributes.biertool
                }
            };

            var xhr = new XMLHttpRequest();
            xhr.open('POST', url, true);
            xhr.setRequestHeader("Content-Type", "application/json");

            xhr.onload = function(e) {
                console.log(JSON.parse(this.response));
            };
            xhr.send(JSON.stringify(data));
        },
        handleRefreshFamilyList: function() {
            this.familyListNameMap = {};
            this.familyListUserSaved = []
            var me = this;
            OpencgaManager.studies.info({
                id: me.study.id,
                query: {
                    sid: Cookies('bioinfo_sid'),
                },
                request: {
                    success: function(response) {
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            if (response.response[0].result[0].attributes.biertool != null && response.response[0].result[0].attributes.biertool.family != null) {
                                var familyList = response.response[0].result[0].attributes.biertool.family;
                                me.set('familyListUserSaved', familyList);
                                for (var i = 0; i < familyList.length; i++) {
                                    me.familyListNameMap[familyList[i].name] = true;
                                }
                            }
                        } else {
                            console.log(response.response[0].errorMsg);
                        }
                    },
                    error: function() {
                        console.log('Server error, try again later.');
                    }
                }
            });
        },
        handleSelectedAttribute: function(e) {
            var els = this.$.familyInfo.querySelectorAll("div");
            for (var i = 0; i < els.length; i++) {
                els[i].removeAttribute("selected", "");
            }
            e.currentTarget.setAttribute("selected", "");
            this.lastFamilySelected = e.model.item;
        },
        _getSamplesFamName: function(samples) {
            var array = [];
            for (var i = 0; i < samples.length; i++) {
                array.push(samples[i].name);
            }
            return array.join(",");
        },
        addToFamilyPreview: function(e) {
            this._createFamilyMap();
        },
        handlepreviewFamilyTree: function(e) {
            this.$.previewFamilyTree.hidden = false;

            var samples = e.model.item.samplesInfo;
            if(samples[0].marriages[0]!=null && samples[0].marriages[0].spouse!=null){
              this.set('familyMapPreview', samples);
            }else{
              this._generatePreviewFamily(samples);
            }
        },
        _createFamilyJsonPreview: function(samples) {
            var hash = {};
            for (var i = 0; i < samples.length; i++) {
                hash[samples[i].name] = samples[i];
            }

            for (var key in hash) {
                var elem = hash[key];
                var f = elem.father;
                var m = elem.mother;

                if (f in hash) {
                    if (m in hash) {
                        hash[f] = this._addMarriage(hash[f], elem, hash[m]);
                    }
                }
                if (m in hash) {
                    if (f in hash) {
                        hash[m] = this._addMarriage(hash[m], elem, hash[f]);
                    }
                }
            }
            return hash;

        },
        _generatePreviewFamily: function(samples) {
            var hash = this._createFamilyJsonPreview(samples);
            var familyArray = [];
            for (var key in hash) {
                var elem = hash[key];
                if ((elem.father == "-" || elem.mother == "-")) {
                    var flag = false;
                    for (var i = 0; i < familyArray.length; i++) {
                        var m = familyArray[i].marriages;
                        for (var j = 0; j < m.length; j++) {
                            if (m[j].spouse.name == elem.name) {
                                flag = true;
                            }
                        }
                    }
                    if (flag == false) {
                        familyArray.push(elem);
                    }
                }
            }

            this.set('familyMapPreview', familyArray);
        },
        familyMapPreviewChanged: function(neo, old) {
            if (neo) {
                if (this.$.familyPreviewPanel.firstElementChild != null) {
                    this.$.familyPreviewPanel.removeChild(this.$.familyPreviewPanel.firstElementChild);
                }
                var arrayAux = [];
                arrayAux.push(neo[0]);

                dTree.init(arrayAux, {
                    target: this.$.familyPreviewPanel,
                    debug: false,
                    width: 385,
                    height: 395,
                    margin: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    },
                    nodeWidth: 100,
                    styles: {
                        node: 'node',
                        linage: 'linage',
                        marriage: 'marriage',
                        text: 'nodeText'
                    }
                });
            }
        }

    });
</script>
<dom-module id="jso-opencga-file-browser" assetpath="bower_components/jsorolla/src/lib/components/opencga/files-new/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            height: 100%;
            width: 100%;
            transition: all 0.2s;
            background-color: inherit;
        }

        #topbar,
        #botbar {
            box-sizing: border-box;
            height: 30px;
            line-height: 30px;
            padding: 0 7px;
            background-color: var(--light-secondary-color);
        }

        #topbar {
            border-bottom: 1px solid rgba(130, 130, 130, 0.4);
        }

        #botbar {
            border-top: 1px solid rgba(130, 130, 130, 0.4);
        }

        #main {
            position: relative;
            height: calc(100% - 60px);
        }

        #mainmenu {
            position: absolute;
            box-sizing: border-box;
            width: 175px;
            height: 100%;
            border-right: 1px solid rgba(130, 130, 130, 0.4);
        }

        #mainmenubar {
            box-sizing: border-box;
            background-color: rgba(125, 125, 125, 0.1);
            padding: 3px 7px;
            height: 30px;
            border-bottom: 1px solid rgba(125, 125, 125, 0.5);
        }

        #mainmenucontent {
            height: calc(100% - 30px);
            overflow-y: auto;
        }

        #maincontent {
            position: absolute;
            left: 175px;
            top: 0;
            width: calc(100% - 175px);
            height: 100%;
            white-space: nowrap;
        }

        #breadcrums {
            box-sizing: border-box;
            padding-left: 5px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #breadcrums > span.clickable:hover {
            cursor: pointer;
            text-decoration: underline;
        }

        #breadcrums > .projectbread {}

        jso-opencga-folder-list {
            height: 55%;
        }
        jso-opencga-sample-info {
            height: 45%;
        }

        jso-opencga-create-project,
        jso-opencga-create-study {
            width: 300px;
            box-sizing: border-box;
            background-color: #fafafa;
            padding: 20px 30px;
        }

        jso-opencga-upload-file {
            box-sizing: border-box;
            background-color: #fafafa;
        }

        .bar > div {
            margin-right: 5px;
        }
    </style>
    <template>
        <div id="topbar" class="horizontal layout center">
            <div id="breadcrums" class="flex">
                /
                <span class="projectbread">{{selectedProject.project.name}}</span>
                &nbsp; <i hidden="" hidden$="{{computeAngleIcon(selectedStudy)}}" class="fa fa-caret-right"></i> &nbsp;
                <span class="clickable" on-click="handleStudyBreadcrum">{{selectedStudy.study.name}}</span>

                <template is="dom-repeat" items="{{folders}}">
                    &nbsp;<i class="fa fa-angle-right"></i>&nbsp;
                    <span class="clickable" on-click="handleBreadcrumClick" folder="{{item}}">{{item.name}}</span>
                </template>

            </div>
            <div hidden$="{{!loading}}">
                <i class="fa fa-circle-o-notch fa-spin"></i>
            </div>
        </div>

        <div id="main" class="flex">
            <div id="mainmenu">
                <div id="mainmenubar" class="horizontal layout">
                    <div class="bar horizontal layout flex">
                        <template is="dom-if" if="{{!disableNewProject}}">
                            <div class="jso-btn jso-btn-shdw" on-click="handleCreateProject">
                                <i class="fa fa-briefcase"></i> +
                            </div>
                        </template>
                        <template is="dom-if" if="{{!disableNewStudy}}">

                            <div class="jso-btn jso-btn-shdw" on-click="handleCreateStudy">
                                <i class="fa fa-book"></i> +
                            </div>
                        </template>
                    </div>
                    <div class="bar horizontal layout">
                    </div>
                </div>
                <div id="mainmenucontent">
                    <template is="dom-repeat" items="{{projects}}" filter="isHidden">
                        <jso-opencga-project-tree on-clickstudy="handleStudyClick" project="{{item}}">
                        </jso-opencga-project-tree>
                    </template>
                </div>
            </div>
            <div id="maincontent">
                <jso-opencga-folder-list id="opencgaFolderList" on-fileselect="handleFileSelect" on-openfolder="handleOpenFolder" on-upload-file="handleUploadFile" on-back="handleBackFolder" on-need-refresh="refreshFolderFiles" on-previewfile="handlePreviewFile" study="{{selectedStudy.study}}" folder="{{folder}}" files="{{files}}" mode="{{mode}}" disable-icon-view="{{disableIconView}}">
                </jso-opencga-folder-list>
                <jso-opencga-sample-info on-sampleselected="handleSampleSelect" sample-selected="{{sampleSelected}}" selected-file="{{selectedFile}}" study="{{selectedStudy.study}}"></jso-opencga-sample-info>
            </div>
        </div>


        <div id="botbar" class="horizontal layout center">
            <div class="flex"></div>
            <div hidden$="{{!checkFileModeOk(mode,selectedFile)}}" class="jso-btn jso-btn-shdw" style="width:100px;" on-click="handleFileModeOk">
                OK
            </div>
            <content id="customButtons" select=".custom-button"></content>
        </div>

        <jso-panel modal="" movable="" closable="" hidden="" id="uploadFilePanel">
            <div class="header">
                <i class="fa fa-cloud-upload"></i> &nbsp; Upload file
            </div>
            <jso-opencga-upload-file class="container" id="uploadFile" on-file-uploaded="handleFileUploaded" projects="{{projects}}" selected-project="{{selectedProject.project}}" selected-study="{{selectedStudy.study}}" selected-folder="{{folder}}" bioformats="{{bioformats}}"></jso-opencga-upload-file>
        </jso-panel>

        <jso-panel modal="" closable="" hidden="" id="createProjectPanel">
            <div class="header">
                <i class="fa fa-briefcase"></i> &nbsp; Create project
            </div>
            <div class="container">
                <jso-opencga-create-project id="createProject" on-project-created="handleProjectCreated"></jso-opencga-create-project>
            </div>
        </jso-panel>

        <jso-panel modal="" closable="" hidden="" id="createStudyPanel">
            <div class="header">
                <i class="fa fa-book"></i> &nbsp; Create study
            </div>
            <div class="container">
                <jso-opencga-create-study id="createStudy" on-study-created="handleStudyCreated" projects="{{projects}}"></jso-opencga-create-study>
            </div>
        </jso-panel>

        <jso-panel modal="" closable="" hidden="" id="filePreviewPanel">
            <div class="header">
                <i class="fa fa-eye"></i> File Preview
            </div>
            <jso-opencga-file-preview class="container" id="filePreview"></jso-opencga-file-preview>
        </jso-panel>

    </template>

</dom-module>
<script>
    Polymer({
        is: "jso-opencga-file-browser",
        properties: {
            projects: {
                type: Array,
                notify: true,
                observer: 'projectsChanged'
            },
            selectedProject: {
                type: Object,
                notify: true,
                observer: 'selectedProjectChanged'
            },
            selectedStudy: {
                type: Object,
                notify: true,
                observer: 'selectedStudyChanged'
            },
            selectedFile: {
                type: Object,
                notify: true,
                value: function() {
                    return null;
                }
            },
            folder: {
                type: Object,
                notify: true
            },
            folders: {
                type: Array,
                notify: true,
                value: function() {
                    return []
                }
            },
            files: {
                type: Array,
                notify: true
            },
            bioformats: {
                type: Array,
                value: function() {
                    return [];
                },
                notify: true
            },
            showHidden: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            disableNewProject: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            disableNewStudy: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            disableIconView: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            contentData: {
                type: String,
                value: ""
            },
            mode: {
                type: String,
                reflectToAttribute: true,
                value: ""
            },
            enableSelectOk: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            loading: {
                type: Boolean,
                value: false
            },
            enableAutoIndex: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },
            sampleSelected: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                }
            },
        },
        ready: function() {
            var me = this;
            if (this._parentJsoPanel != null) {
                this._parentJsoPanel.addEventListener('hidden', function(e) {
                    if (e.detail == false) {
                        me._setInitialSelection();
                    }
                });
            }
            var els = this.$.botbar.querySelectorAll('.custom-button');
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                el.setAttribute('hidden', '');
            }

        },
        checkFileModeOk: function(mode, selectedFile) {
            if (this.enableSelectOk == true) {
                if (mode === 'file' && selectedFile != null && selectedFile.id != null && selectedFile.type == 'FILE') {
                    return true;
                }
                if (mode === 'folder' && selectedFile != null && selectedFile.id != null && selectedFile.type == 'FOLDER') {
                    return true;
                }
            }
            return false;
        },
        handleFileModeOk: function(e) {
            this._parentJsoPanel.hidden = true;
            this.fire('ok-click');
        },
        projectsChanged: function(neo, old) {
            if (this.projects == null || this.projects.length === 0) {
                this.reset();
            }
            this.async(function() {
                this._setInitialSelection();
            }, 100);
        },
        _setInitialSelection: function() {
            if (this._parentJsoPanel != null && this._parentJsoPanel.hidden === false) {
                if (this.selectedProject == null) {
                    var el = Polymer.dom(this.root).querySelector('jso-opencga-project-tree');
                    this.set('selectedProject', el);
                }
                if (this.selectedProject != null && this.selectedStudy == null) {
                    var el = Polymer.dom(this.selectedProject.root).querySelector('jso-opencga-study-tree');
                    this.set('selectedStudy', el);
                }
                if (this.folder && this.selectedStudy) {
                    this.refreshFolderFiles();
                }
            }
        },
        selectedStudyChanged: function(neo, old) {
            if (old) old.selected = false;
            if (neo) neo.selected = true;

            this.selectedFile = null;
            this.files = [];
            if (neo != null) {
                this._showStudyFolder();
            }
        },
        selectedProjectChanged: function(neo, old) {
            if (old) old.selected = false;
            if (neo) neo.selected = true;
        },
        handleStudyClick: function(e) {
            if (this.selectedStudy !== e.currentTarget.selectedStudy) {
                this.files = [];
            }
            this.set('selectedProject', e.currentTarget);
            this.set('selectedStudy', e.currentTarget.selectedStudy);
        },
        handleFileSelect: function(e) {
            this.selectedFile = e.detail;
            this._checkCustomButtons();
        },
        handleOpenFolder: function(e) {
            var me = this;
            this.folder = e.detail;
            this.push('folders', this.folder);
            this.files = [];
            this.refreshFolderFiles();
        },
        refreshFolderFiles: function() {
            var me = this;
            this.loading = true;
            var f = this.files[0];
            this._getFilesInFolder(this.selectedStudy.study.id, this.folder.id, function(files) {
                me.files = files;
                me.loading = false;
                if (me.enableAutoIndex) {
                    if (f.name !== me.files[0].name && me.files[0].index == null && me.files[0].type == "FILE") {
                        me.$.opencgaFolderList._autoIndexfile(me.files[0]);
                    }
                }
                //                console.log(files);
            });
        },
        handleStudyBreadcrum: function(e) {
            this.files = [];
            this._showStudyFolder();
        },
        handleBreadcrumClick: function(e) {
            var me = this;
            this.folder = e.currentTarget.folder;

            while (this.folder !== this.folders[this.folders.length - 1]) {
                this.pop('folders');
            }
            this.files = [];
            this.refreshFolderFiles();
        },
        handleBackFolder: function(e) {
            var me = this;
            this.pop('folders');
            this.files = [];
            if (this.folders.length > 0) {
                this.set('folder', this.folders[this.folders.length - 1]);
                this.refreshFolderFiles();
            } else {
                this._showStudyFolder();
            }
        },

        handleUploadFile: function(e) {
            this.$.uploadFilePanel.hidden = !this.$.uploadFilePanel.hidden;
        },
        handleCreateProject: function(e) {
            this.$.createProjectPanel.hidden = !this.$.createProjectPanel.hidden;
        },
        handleCreateStudy: function(e) {
            this.$.createStudyPanel.hidden = !this.$.createProjectPanel.hidden;
        },

        handleFileUploaded: function(e) {
            this.refreshFolderFiles();
            this.$.uploadFilePanel.hidden = true;
        },
        handleProjectCreated: function(e) {
            this.$.createProjectPanel.hidden = true;
        },
        handleStudyCreated: function(e) {
            this.$.createStudyPanel.hidden = true;
        },
        handleLoading: function(e) {
            this.fire("loading")
        },
        reset: function() {
            this.set('selectedProject', undefined);
            this.set('selectedStudy', undefined);
            this.set('selectedFile', undefined);
            this.set('folder', undefined);
            this.set('folders', []);
            this.set('files', []);
            this.set('contentData', '');
            this.set('loading', false);
        },

        /* Private methods */
        computeAngleIcon: function(el) {
            if (el) {
                return false;
            }
            return true;
        },
        _showStudyFolder: function() {
            var me = this;
            this.loading = true;
            this._getStudyFolder(this.selectedStudy.study.id, function(folder) {
                me.set('folders', []);
                me.folder = folder;
                me._getFilesInFolder(me.selectedStudy.study.id, me.folder.id, function(files) {
                    me.files = files;
                    me.loading = false;
                    //                    console.log(files);
                });
            });
        },
        _getStudyFolder: function(studyId, callback) {
            var me = this;
            this.message = '';
            var folder;
            OpencgaManager.files.search({
                query: {
                    sid: Cookies('bioinfo_sid'),
                    studyId: studyId,
                    name: '.'
                },
                request: {
                    async: true,
                    success: function(response) {
                        // console.log(response);
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            folder = response.response[0].result[0];
                            callback(folder);
                        } else {
                            console.log(response.response[0].errorMsg);
                        }
                    },
                    error: function() {
                        console.log('Server error, try again later.');
                    }
                }
            });
        },
        _getFilesInFolder: function(studyId, folderId, callback) {
            var me = this;
            var files;

            var bfList = [];
            if (this.bioformats > 0) {
                var bfList = ['NONE'];
                for (var i = 0; i < this.bioformats.length; i++) {
                    var bf = this.bioformats[i];
                    bfList.push(bf.value);
                }
            }

            var query = {
                sid: Cookies('bioinfo_sid'),
                //                    status:'READY,STAGED,MISSING',
                status: 'READY',
                type: 'FILE,FOLDER',
                studyId: studyId
            };

            if (bfList > 0 && (this.mode === 'file' || this.mode === 'folder')) {
                query.bioformat = bfList.join(',');
            }

            OpencgaManager.files.list({
                id: folderId,
                query: query,
                request: {
                    async: true,
                    success: function(response) {
                        // console.log(response);
                        if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                            files = me._filterFiles(response.response[0].result);
                            //                            files = response.response[0].result;
                            callback(files);
                        } else {
                            console.log(response.response[0].errorMsg);
                        }
                    },
                    error: function() {
                        console.log('Server error, try again later.');
                    }
                }
            });
        },
        _filterFiles: function(files) {
            var bfList = [];
            for (var i = 0; i < this.bioformats.length; i++) {
                var bf = this.bioformats[i];
                bfList.push(bf.value);
            }

            files.sort(function(a, b) {
                return b.creationDate.localeCompare(a.creationDate);
            });
            var filesFiltered = [];
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                // console.log(file.name + ' ' + file.id);
                // console.log(file);
                if (
                    // file.bioformat == 'ALIGNMENT' &&
                    (
                        file.name.charAt(0) == '.' ||
                        file.name == 'command_line.sh' ||
                        file.name.indexOf('sge_err.job') != -1 ||
                        file.name.indexOf('sge_out.job') != -1 ||
                        Utils.endsWith(file.name, '.annot.json.gz') ||
                        Utils.endsWith(file.name, '.file.json.gz') ||
                        Utils.endsWith(file.name, '.variants.stats.json.gz') ||
                        Utils.endsWith(file.name, '.source.stats.json.gz') ||
                        Utils.endsWith(file.name, '.bam.bai') ||
                        Utils.endsWith(file.name, '.bam.coverage.json.gz') ||
                        Utils.endsWith(file.name, '.bam.mean-coverage.json.gz') ||
                        (file.bioformat == 'VARIANT' && file.format == 'AVRO') ||
                        Utils.endsWith(file.name, '.snappy')
                    )
                ) {
                    continue;
                }

                if (this.mode == 'folder') {
                    if (file.type != 'FOLDER') {
                        continue;
                    }
                } else if (this.mode == 'file' && bfList.length > 0) {
                    if (file.type == 'FILE' && bfList.indexOf(file.bioformat) == -1) {
                        continue;
                    }
                }

                filesFiltered.push(file);
            }
            return filesFiltered;
        },
        isHidden: function(project) {
            if (this.showHidden) {
                return true;
            } else {
                return project.name.charAt(0) != ".";
            }
        },
        handlePreviewFile: function(e) {
            this.$.filePreviewPanel.show();
            this.$.filePreview.file = this.selectedFile;
        },
        _checkCustomButtons: function() {
            var els = this.$.botbar.querySelectorAll('.custom-button');
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                var found = false;
                var exts = el.getAttribute('file-ext').split(',');
                for (var j = 0; j < exts.length; j++) {
                    var ext = exts[j];
                    if (Utils.endsWithIgnoreCase(this.selectedFile.name, ext)) {
                        found = true;
                        break;
                    }
                }
                if (found) {
                    el.removeAttribute('hidden');
                } else {
                    el.setAttribute('hidden', '');
                }
            }

        }
    });
</script>
<dom-module id="stv-filter-position" assetpath="bower_components/stevia-elements/src/filter/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        textarea {
            resize: none;
            width: 100%;
        }

        .importBut {
            width: 65px;
            font-size: 12px;
            margin: 3px;
            color: #445D76;
            font-weight: bold;
        }

        #genePanelBrowser {
            width: 800px;
            min-height: 500px;
            height: calc(100vh - 300px);
        }

        .file {
            text-align: center;
            color: #445D76;
            margin: 5px;
            width: 100px;
            height: 20px;
            line-height: 17px;
        }

        #geneTable,
        #geneTablePreview {
            min-height: 400px;
            height: 90%;
            width: 100%;
        }

        #genes-tab {
            height: calc(100vh - 300px);
            min-height: 450px;
            width: 35%;
            margin-top: 5px;
            padding-top: 10px;
            overflow-y: auto;
        }

        #genes-list {
            height: calc(100vh - 400px);
            min-height: 400px;
            width: 60%;
            margin: 15px 10px;
            border: 1px solid #d3d3d3;
        }

        stv-table::shadow .table-row {
            height: 25px;
        }

        stv-table::shadow {
            font-size: 11px;
        }

        stv-table::shadow .table-pager > input {
            width: 40px !important;
        }

        .form {
            font-size: 11px;
        }

        .form .header {
            font-size: 12px;
        }

        .form .container {
            width: 100%;
        }

        #appPanel .container #geneListPreview .container {
            min-width: 700px;
            width: 100%;
            min-height: 500px;
            height: 80%;
            overflow-y: auto;
            overflow-x: auto;
        }

        #panelAppDiseases {
            margin: 5px;
            min-height: 400px;
            height: 90%;
            width: 55%;
            border: 1px solid #d3d3d3;
            box-sizing: border-box;
        }

        #panelAppGenes {
            margin: 5px;
            min-height: 400px;
            height: 90%;
            width: 40%;
            border: 1px solid #d3d3d3;
            box-sizing: border-box;
        }

        .add-but {
            font-size: 13px;
            background-color: #ed9c33 !important;
            color: #FFFFFF !important;
            text-align: center;
            height: 30px;
            width: 150px;
            line-height: 30px;
            margin-top: 10px;
        }
    </style>
    <template>
        <stv-form-box collapsible$="{{collapsible}}" collapsed$="{{collapsed}}">
            <div class="header">
                Position
            </div>
            <div class="container" style="width:90%">
                <label class="stv">Chromosomal location:</label>
                <textarea class="stv" id="region" name="region" placeholder="1:1-1000000,2:1-1000000" value="{{regionValue::change}}" rows="3">                </textarea>

                <div class="horizontal layout" hidden$="{{!enableImportbed}}">
                    <div class="flex"></div>
                    <label class="stv" style="margin-top: 4px;">Import from BED:</label>
                    <div class="stv-btn stv-btn-shdw importBut" on-click="showImportComponent"><i class="fa fa-plus-square-o"></i>&nbsp; Import
                    </div>
                </div>

                <label class="stv">Gene:</label>
                <textarea class="stv" id="gene" name="gene" placeholder="BRCA2,PPL" value="{{geneValue::change}}" rows="3">                </textarea>
                <div class="horizontal layout" hidden$="{{!enableGenepanel}}">
                    <div class="flex" style="margin-top: 4px;">
                    </div>
                    <div class="stv-btn stv-btn-shdw importBut" style="width: 120px;" on-click="showGenepanel">
                        Gene Panel Browser
                    </div>
                </div>

                <label class="stv" hidden$="{{!enableSnpid}}">SNPId:</label>
                <textarea class="stv" id="snpId" name="snpId" placeholder="rs9988179,rs140361978" value="{{snpIdValue::change}}" rows="3" hidden$="{{!enableSnpid}}">                </textarea>
            </div>
        </stv-form-box>

        <stv-panel id="importComponent" modal="" closable="" hidden="">
            <div class="header">
                <i class="fa fa-plus-square-o"></i> Import File
            </div>
            <stv-import-file id="importFile" class="container" on-importfile="handleImportFile" bioformat="{{bedBioformat}}"></stv-import-file>
        </stv-panel>

        <stv-panel id="genePanelBrowser" modal="" closable="" hidden="">
            <div class="header">Gene Panel Browser
            </div>
            <div class="container horizontal layout flex">
                <div id="genes-tab" class="vertical layout">
                    <stv-form-box collapsible="" class="form">
                        <div class="header">
                            Genes &nbsp;
                        </div>
                        <div class="container">
                            <textarea class="jso sgenesTextArea" name="geneTextArea" id="geneTextArea" rows="3" placeholder="BRCA2,PPL"></textarea>
                            <div class="horizontal layout">
                                <div class="flex"></div>
                                <div class="stv-btn stv-btn-shdw file" on-click="handleClickGeneTextAreaButton">
                                    <i class="fa fa-plus-square-o"></i>&nbsp; Add Genes
                                </div>
                            </div>
                        </div>
                    </stv-form-box>
                    <stv-form-box collapsible="" class="form">
                        <div class="header">
                            Import from Gene List &nbsp;
                        </div>
                        <div class="container">
                            <stv-select id="importGenesFromList" style="width:150px;margin-top:5px;margin-left:5px">
                                <stv-option value=" "></stv-option>
                                <template is="dom-repeat" items="{{geneListUserSaved}}">
                                    <stv-option value$="{{item.name}}" data-list$="{{item.list}}">{{item.name}}</stv-option>
                                </template>
                            </stv-select>

                            <div class="horizontal layout">
                                <div class="stv-btn stv-btn-shdw file" on-click="handlePreviewList" style="width:105px;"> &nbsp; <i class="fa fa-eye"></i>&nbsp;View List
                                </div>
                                <div class="flex"></div>
                                <div class="stv-btn stv-btn-shdw file" on-click="handeLoadGeneList" style="width:105px;"><i class="fa fa-plus-square-o"></i>&nbsp; Import
                                </div>
                            </div>
                        </div>
                    </stv-form-box>
                    <stv-form-box collapsible="" class="form">
                        <div class="header">
                            Import from Panel App &nbsp;
                        </div>
                        <div class="container horizontal layout">
                            <li class="flex" style="margin-top:8px">Panel App</li>
                            <div class="stv-btn stv-btn-shdw file" on-click="handleImportAppPanel"><i class="fa fa-plus-square-o"></i>&nbsp; Import
                            </div>
                        </div>
                    </stv-form-box>
                </div>

                <div id="genes-list">
                    <stv-table id="geneTable" columns="{{geneColumns}}" data="{{geneList}}" enable-edit="" hide-column-selector="" enable-paging="" page-size="13" on-removerow="handleRemoveElement"></stv-table>
                    <div class="horizontal layout" style="border-top: 1px solid #d3d3d3;">
                        <div class="flex"></div>
                        <div class="stv-btn stv-btn-shdw file" on-click="handleSaveGeneList">Save Gene List</div>
                        <div class="stv-btn stv-btn-shdw file" on-click="handleClickGeneListClear">Clear</div>
                    </div>
                    <div class="horizontal layout flex" style="width: 100%">
                        <div class="flex">
                        </div>
                        <div class="stv-btn stv-btn-shdw add-but" on-click="handleAddSelected"> Add Selected Genes
                        </div>
                    </div>
                </div>
            </div>
        </stv-panel>
        <stv-panel modal="" closable="" hidden="" id="geneListPreview">
            <div class="header">
                <i class="fa fa-eye"></i> Panel Preview
            </div>
            <div class="container">
                <stv-table id="geneTablePreview" columns="{{geneColumnsPreview}}" data="{{geneListPreview}}" enable-edit="" hide-column-selector="" enable-paging="" page-size="13" on-removerow="handleRemoveElement"></stv-table>
            </div>
        </stv-panel>
        <stv-panel modal="" movable="" fixed="" closable="" hidden="" id="appPanel">
            <div class="header">
                <i class="fa fa-plus-square-o"></i> Import from PanelApp
            </div>
            <div class="stv-formcontent horizontal layout container">
                <div id="panelAppDiseases" class="vertical layout">
                    <stv-table class="flex" id="panelAppSelectedDisease" enable-filter="" columns="{{panelAppDiseasesColumns}}" data="{{panelAppDiseases}}" on-selected="handlePanelAppSelected" enable-select="" enable-paging="" hide-column-selector="" style="height:450px" page-size="12"></stv-table>

                    <div class="horizontal layout">
                        <div class="flex"></div>
                        <a href="https://bioinfo.extge.co.uk/crowdsourcing/PanelApp/" target="_blank">
                            <div class="stv-btn stv-btn-shdw file" style="width: 150px"> &gt;&gt;More info
                                &lt;&lt; </div>
                        </a>
                        </div>
                    </div>
                    <div id="panelAppGenes" class="vertical layout">
                        <stv-table class="flex" id="panelAppSelectedGenes" columns="{{panelAppGenesColumns}}" data="{{panelAppGenes}}" enable-select="" hide-column-selector="" enable-paging="" style="height:450px"></stv-table>
                        <div class="horizontal layout">
                            <div class="stv-btn stv-btn-shdw file" on-click="handlePanelAppAddGenes"><i class="fa fa-plus-square-o"></i>&nbsp;Add Genes
                            </div>
                        </div>
                    </div>
                </div>
        </stv-panel>

    </template>
    <script>
        Polymer({
            is: "stv-filter-position",
            properties: {
                regionValue: {
                    type: String,
                    notify: true,
                    value: ''
                },
                geneValue: {
                    type: String,
                    notify: true,
                    value: ''
                },
                snpIdValue: {
                    type: String,
                    notify: true,
                    value: ''
                },
                collapsible: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                collapsed: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false,
                },
                bedBioformat: {
                    type: Object,
                    value: {
                        text: "BED",
                        value: "BED",
                        validator: BEDValidator
                    }
                },
                enableImportbed: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                enableGenepanel: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                enableSnpid: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                geneList: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                geneMap: {
                    type: Array,
                    value: function() {
                        return {};
                    }
                },
                panelAppDiseases: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                panelAppGenes: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                userInfo: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },
                geneListNameMap: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },
                geneListUserSaved: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                }
            },
            ready: function() {
                this.panelAppDiseases = BIOINFO_TEAM_PANELAPP_DISEASES;
                this.handleRefreshGeneList();
                this.geneColumns = [{
                    name: 'name',
                    title: 'Name',
                    width: 120
                }, {
                    name: 'chr',
                    title: 'Chr',
                    defaultValue: '.',
                    width: 80
                }, {
                    name: 'start',
                    title: 'Start',
                    defaultValue: '.',
                    width: 110
                }, {
                    name: 'end',
                    title: 'End',
                    defaultValue: '.',
                    width: 110
                }, {
                    name: '',
                    title: '',
                    type: 'action',
                    width: 50
                }];
                this.geneColumnsPreview = [{
                    name: 'name',
                    title: 'Name',
                    width: 120
                }, {
                    name: 'chr',
                    title: 'Chr',
                    defaultValue: '.',
                    width: 80
                }, {
                    name: 'start',
                    title: 'Start',
                    defaultValue: '.',
                    width: 110
                }, {
                    name: 'end',
                    title: 'End',
                    defaultValue: '.',
                    width: 110
                }];
                this.panelAppDiseasesColumns = [{
                    name: 'Name',
                    title: 'Disease',
                    width: 220

                }, {
                    name: 'Number_of_Genes',
                    title: 'NGenes',
                    width: 100
                }, {
                    name: 'CurrentVersion',
                    title: 'Version',
                    width: 100
                }];
                this.panelAppGenesColumns = [{
                    name: "GeneSymbol",
                    title: "Gene",
                    width: 180
                }, {
                    name: "LevelOfConfidence",
                    title: "Level Of Confidence",
                    width: 170
                }];

            },
            checkRegion: function() {
                var regions = [];
                if (this.regionValue) {
                    var region = this.regionValue.replace(/chromosome/gi, "").replace(/chrom/gi, "").replace(/chro/gi, "").replace(/chr/gi, "").replace(/ch/gi, "");
                    var aux = region.split(/,|\n|\r/);
                    for (var i = 0; i < aux.length; i++) {
                        regionName = aux[i];
                        if (regionName != '') {
                            var re = /^(\w+)(:(\d+)-(\d+))?$/;
                            if (re.test(regionName)) {
                                var groups = regionName.match(re);
                                if (groups.length == 5) {
                                    var chr = groups[1].toUpperCase();
                                    if (chr == "X" || chr == "Y" || chr == "MT") {
                                        regionName = regionName.toUpperCase();
                                    }
                                    var start = parseInt(groups[3]);
                                    var end = parseInt(groups[4]);
                                    if (start > end) {
                                        new StvDialog().alert("Malformed Region: " + regionName + ", END must be greater than or equal to START");
                                        return -1;
                                    } else {
                                        regions.push(regionName);
                                    }
                                } else if (groups.length == 2) {
                                    var chr = groups[1].toUpperCase();
                                    if (chr == "X" || chr == "Y" || chr == "MT") {
                                        chr = chr.toUpperCase();
                                    }
                                    regions.push(chr);
                                } else {
                                    new StvDialog().alert("Malformed Region: " + regionName);
                                    return -1;
                                }
                            } else {
                                new StvDialog().alert("Malformed Region: " + regionName);
                                return -1;
                            }
                        }
                    }
                    var regionQuery = regions.join(",");
                    return regionQuery;
                } else {
                    return null;
                }
            },
            checkGene: function(cb) {
                var geneQuery = this.geneValue.toUpperCase().replace(/\n/gi, ',');
                if (geneQuery != '') {
                    CellBaseManager.get({
                        species: 'hsapiens',
                        category: 'feature',
                        subCategory: 'gene',
                        resource: 'info',
                        async: false,
                        query: geneQuery,
                        params: {
                            include: "name"
                        },
                        success: function(data) {
                            if (data.response && data.response.length > 0) {
                                var flag = false;
                                for (var i = 0; i < data.response.length; i++) {
                                    var elem = data.response[i];
                                    if (elem.result.length == 0) {
                                        new StvDialog().alert("Gene '" + elem.id + "' not exits");
                                        flag = true;
                                        break;
                                    }
                                }
                                if (flag) {
                                    cb(-1);
                                } else {
                                    cb(geneQuery);
                                }
                            }
                        }
                    });
                } else {
                    cb(null);
                }
            },
            checkSNPId: function() {
                var ids = [];
                if (this.snpIdValue) {
                    ids = this.snpIdValue.toLowerCase().split(/,|\n/);
                    var idsQuery = ids.join(",");
                    return idsQuery;
                } else {
                    return null;
                }
            },
            clear: function() {
                //Region
                this.$.region.value = "";
                this.regionValue = "";

                // Gene
                this.$.gene.value = "";
                this.geneValue = "";

                // SNPId
                if (this.enableSnpid) {
                    this.$.snpId.value = "";
                    this.snpIdValue = "";
                }
            },
            load: function(hf) {
                var filterName = [];
                // Region
                if (hf.region != "" && hf.region != null) {
                    this.$.region.value = hf.region;
                    this.regionValue = hf.region;
                    filterName.push("Chromosomal Location: (" + hf.region + ") ");
                }

                // Gene
                if (hf.gene != "" && hf.gene != null) {
                    this.$.gene.value = hf.gene;
                    this.geneValue = hf.gene;
                    filterName.push("Genes: (" + hf.gene + ") ");
                }

                // SNPId
                if (this.enableSnpid) {
                    if (hf.ids != "" && hf.ids != null) {
                        this.$.snpId.value = hf.ids;
                        this.snpIdValue = hf.ids;
                        filterName.push("SNPId: (" + hf.ids + ") ");
                    }
                }

                return filterName;
            },
            showImportComponent: function() {
                this.$.importComponent.hidden = false;
            },
            handleImportFile: function() {
                var file = this.$.importFile.$.fileInput.files[0];

                if (!(this.$.importFile.$.validator.errorCount > 0)) {
                    this.handleGenesImportBed(file);
                    this.$.importComponent.hidden = true;
                }
            },
            handleGenesImportBed: function(bed_file) {
                var me = this;

                var log = [];
                var line = 0;

                if (bed_file != null) {

                    var _navigator = new LineNavigator(bed_file);

                    var indexToStartWith = 0;

                    var re = /^(\w+)(:(\d+)-(\d+))?$/;

                    _navigator.readSomeLines(indexToStartWith, function linesReadHandler(err, index, lines, eof, progress) {
                        if (err) {
                            return;
                        }
                        console.log(lines.length);

                        for (var i = 0; i < lines.length; i++) {
                            var line = lines[i];

                            if (line.indexOf("#") < 0 && line != '') {
                                var fields = line.split("\t");
                                var chr = fields[0];
                                var start = fields[1];
                                var end = fields[2];
                                var gene = {
                                    name: chr + ":" + start + "-" + end,
                                    chr: chr,
                                    start: start,
                                    end: end
                                };
                              if (re.test(gene.name)) {                                
                                me.regionValue += gene.name + ",";
                              }

                            }

                            line++;
                        }

                        if (eof) {
                            return;
                        }

                        _navigator.readSomeLines(index + lines.length, linesReadHandler);

                    })

                }
            },
            showGenepanel: function() {
                this.$.genePanelBrowser.hidden = false;
            },
            handleClickGeneTextAreaButton: function(e) {
                var geneName = [];
                var me = this;
                var textAreaValue = this.$.geneTextArea.value.toUpperCase();
                var splits = textAreaValue.split(/,|\n/);
                var genes = [];

                for (var i = 0; i < splits.length; i++) {
                    if (splits[i] != '') {
                        geneName.push(splits[i]);
                    }
                }

                if (geneName.length > 0) {
                    CellBaseManager.get({
                        species: 'hsapiens',
                        category: 'feature',
                        subCategory: 'gene',
                        resource: 'info',
                        async: false,
                        query: geneName.join(","),
                        params: {
                            include: "name,chromosome,start,end"
                        },
                        success: function(data) {
                            if (data.response && data.response.length > 0) {
                                for (var i = 0; i < data.response.length; i++) {
                                    var elem = data.response[i];
                                    if (elem.result.length > 0) {
                                        for (var j = 0; j < elem.result.length; j++) {
                                            var row = data.response[i].result[j];
                                            var gene = {
                                                name: row.name,
                                                chr: row.chromosome,
                                                start: row.start,
                                                end: row.end
                                            };
                                            if (me.geneMap[gene.name] == null) {
                                                me.geneMap[gene.name] = true;
                                                me.push('geneList', gene);
                                            }
                                        }
                                    } else {
                                        new StvDialog().alert("Gene '" + elem.id + "' not exits");
                                    }
                                }
                            }
                        }
                    });
                }

                this.$.geneTextArea.value = '';
            },
            handleRemoveElement: function(e) {
                var key = e.detail.row.name;
                this.geneMap[key] = null;
            },
            handleClickGeneListClear: function(e) {
                this.geneMap = {};
                this.geneList = [];
            },
            handleImportAppPanel: function(e) {
                this.$.appPanel.hidden = false;
            },
            handlePanelAppAddGenes: function(e) {
                var me = this;
                this.$.geneTable.setLoading(true);
                setTimeout(function() {
                    var lowLevel = false;
                    for (var i = 0; i < me.$.panelAppSelectedGenes.selected.length; i++) {
                        var elem = me.$.panelAppSelectedGenes.selected[i];
                        if (elem.LevelOfConfidence == 'LowEvidence') {
                            lowLevel = true;
                        }
                    }
                    if (lowLevel) {
                        new StvDialog().confirm("Your selection contains genes with low level of confidence. Do you want to continue?", function(answer) {
                            if (answer == true) {
                                me._addGenesPanelApp(me.$.panelAppSelectedGenes.selected);
                            } else {
                                return;
                            }

                        });
                    } else {
                        if (me.$.panelAppSelectedGenes.selected.length == 0) {
                            new StvDialog().alert("Any selected gene");
                            me.$.geneTable.setLoading(false);
                            return;
                        } else {
                            me._addGenesPanelApp(me.$.panelAppSelectedGenes.selected);
                        }
                    }
                }, 50)
            },
            _addGenesPanelApp: function(sgenes) {
                var geneName = [];
                for (var i = 0; i < sgenes.length; i++) {
                    geneName[i] = sgenes[i].GeneSymbol;
                }
                geneName = geneName.join(",");
                var me = this;
                CellBaseManager.get({
                    species: 'hsapiens',
                    category: 'feature',
                    subCategory: 'gene',
                    resource: 'info',
                    async: false,
                    query: geneName,
                    params: {
                        include: "name,chromosome,start,end"
                    },
                    success: function(data) {

                        if (data.response && data.response.length > 0) {

                            for (var i = 0; i < data.response.length; i++) {
                                var elem = data.response[i];
                                // if (elem.result.length > 0) {
                                var row = data.response[i].result[0];
                                var gene = {
                                    name: row.name,
                                    chr: row.chromosome,
                                    start: row.start,
                                    end: row.end
                                };
                                if (me.geneMap[gene.name] == null) {
                                    me.geneMap[gene.name] = true;
                                    me.push('geneList', gene);
                                }
                                // } else {
                                //     genes.push({
                                //         name: elem.id
                                //     });
                                // }
                            }
                        }
                    }
                });
                this.$.appPanel.hidden = true;
                this.panelAppGenes = [];
                this.$.panelAppSelectedGenes.selected = [];
                this.$.panelAppSelectedDisease.selected = [];
                this.$.geneTable.setLoading(false);
            },
            handlePanelAppSelected: function(e) {
                var me = this;
                this.$.panelAppSelectedGenes.selected = [];
                var selectedPanelAppDisease = e.detail.length > 0 ? e.detail[0] : {};
                if (selectedPanelAppDisease.Name && selectedPanelAppDisease.Name !== "") {
                    var query = "https://bioinfo.extge.co.uk/crowdsourcing/WebServices/get_panel/" + selectedPanelAppDisease.Name + "/?format=json"
                    $.ajax({
                        url: query,
                        dataType: 'json',
                        async: false,
                        success: function(response, textStatus, jqXHR) {
                            me.set("panelAppGenes", response.result.Genes);
                        }
                    });
                }
            },
            handleAddSelected: function(e) {
                var genes = [];
                for (var i = 0; i < this.geneList.length; i++) {
                    genes.push(this.geneList[i].name);
                }
                this.set('geneValue', genes.join(","));
                this.$.genePanelBrowser.hidden = true;
                this.handleClickGeneListClear();
            },
            handleSaveGeneList: function() {
                var me = this;
                new StvDialog().prompt("Gene List Name: ", function(confirm, name) {
                    if (confirm) {
                        if (me.geneListNameMap[name] == null) {
                            me._saveGeneList(name);
                        } else {
                            new StvDialog().alert("A list with the same name already exists", function() {
                                me.handleSaveGeneList();
                            });
                        }
                    }
                });
            },
            _saveGeneList: function(name) {
                var me = this;
                me.geneListNameMap[name] = true;

                var geneObject = {
                    name: name,
                    list: Object.keys(me.geneMap).join(",")
                };
                OpencgaManager.users.info({
                    id: Cookies('bioinfo_user'),
                    query: {
                        sid: Cookies('bioinfo_sid'),
                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                me.userInfo = response.response[0].result[0];
                                if (me.userInfo.attributes["biertool"] == null) {
                                    me.userInfo.attributes["biertool"] = {};
                                }
                                if (me.userInfo.attributes["biertool"]["genes"] == null) {
                                    me.userInfo.attributes["biertool"]["genes"] = [];
                                }
                                me.userInfo.attributes["biertool"]["genes"].push(geneObject);
                                me.push('geneListUserSaved', geneObject);
                                me.updateUserInfo();
                            } else {
                                console.log(response.response[0].errorMsg);
                            }
                        },
                        error: function() {
                            console.log('Server error, try again later.');
                        }
                    }
                });
            },
            updateUserInfo: function() {
                var me = this;
                var url = OpencgaManager.users.update({
                    id: me.userInfo.id,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                    },
                    request: {
                        method: "POST",
                        url: true
                    }
                });
                console.log(url);
                console.log(this.userInfo.attributes)
                var data = {
                    'attributes': {
                        "biertool": this.userInfo.attributes.biertool
                    }
                };

                var xhr = new XMLHttpRequest();
                xhr.open('POST', url, true);
                xhr.setRequestHeader("Content-Type", "application/json");

                xhr.onload = function(e) {
                    console.log(JSON.parse(this.response));
                };
                xhr.send(JSON.stringify(data));
            },
            handleRefreshGeneList: function() {
                this.geneListNameMap = {};
                this.geneListUserSaved = []
                var me = this;
                OpencgaManager.users.info({
                    id: Cookies('bioinfo_user'),
                    query: {
                        sid: Cookies('bioinfo_sid'),
                    },
                    request: {
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                if (response.response[0].result[0].attributes.biertool != null && response.response[0].result[0].attributes.biertool.genes != null) {
                                    var geneList = response.response[0].result[0].attributes.biertool.genes;
                                    me.set('geneListUserSaved', geneList);
                                    for (var i = 0; i < geneList.length; i++) {
                                        me.geneListNameMap[geneList[i].name] = true;
                                    }
                                }
                            } else {
                                console.log(response.response[0].errorMsg);
                            }
                        },
                        error: function() {
                            console.log('Server error, try again later.');
                        }
                    }
                });
            },
            handeLoadGeneList: function(e) {
                var me = this;
                if (this.$.importGenesFromList.value != " ") {
                    var geneName = this.$.importGenesFromList.selectedOption.dataset.list;
                    if (geneName != "") {
                        CellBaseManager.get({
                            species: 'hsapiens',
                            category: 'feature',
                            subCategory: 'gene',
                            resource: 'info',
                            async: false,
                            query: geneName,
                            params: {
                                include: "name,chromosome,start,end"
                            },
                            success: function(data) {
                                if (data.response && data.response.length > 0) {
                                    for (var i = 0; i < data.response.length; i++) {
                                        var elem = data.response[i];
                                        if (elem.result.length > 0) {
                                            for (var j = 0; j < elem.result.length; j++) {
                                                var row = data.response[i].result[j];
                                                var gene = {
                                                    name: row.name,
                                                    chr: row.chromosome,
                                                    start: row.start,
                                                    end: row.end
                                                };
                                                if (me.geneMap[gene.name] == null) {
                                                    me.geneMap[gene.name] = true;
                                                    me.push('geneList', gene);
                                                }
                                            }
                                        } else {
                                            new StvDialog().alert("Gene '" + elem.id + "' not exits");
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            },
            handlePreviewList: function(e) {
                this.set('geneListPreview', []);
                var me = this;
                if (this.$.importGenesFromList.value != " ") {
                    var geneName = this.$.importGenesFromList.selectedOption.dataset.list;
                    if (geneName != "") {
                        CellBaseManager.get({
                            species: 'hsapiens',
                            category: 'feature',
                            subCategory: 'gene',
                            resource: 'info',
                            async: false,
                            query: geneName,
                            params: {
                                include: "name,chromosome,start,end"
                            },
                            success: function(data) {
                                if (data.response && data.response.length > 0) {
                                    for (var i = 0; i < data.response.length; i++) {
                                        var elem = data.response[i];
                                        if (elem.result.length > 0) {
                                            for (var j = 0; j < elem.result.length; j++) {
                                                var row = data.response[i].result[j];
                                                var gene = {
                                                    name: row.name,
                                                    chr: row.chromosome,
                                                    start: row.start,
                                                    end: row.end
                                                };
                                                me.push('geneListPreview', gene);
                                            }
                                            me.$.geneListPreview.hidden = false;
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }

        });
    </script>
</dom-module>
<dom-module id="stv-filter-scores" assetpath="bower_components/stevia-elements/src/filter/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        .inputValue {
            width: 170px;
            margin-left: 4px;
        }

        stv-select {
            width: 45px;
            margin-right: 3px;
            align-self: center;
        }

        paper-slider.sliderBar {
            color: #a0a0a0;
            --paper-slider-knob-color: #445D76;
            --paper-slider-active-color: #445D76;
            --paper-slider-pin-color: #445D76;
            --paper-input-container-focus-color: #445D76;
            width: 125%;
        }

        paper-slider::shadow #input {
            width: calc(20vh - 40px);
            font-size: 13px;
        }
    </style>
    <template>
        <stv-form-box collapsible$="{{collapsible}}" collapsed$="{{collapsed}}">
            <div class="header">
                Protein Substitution Scores
            </div>
            <div class="container">
                <div class="">
                    <label class="stv-control">
                        <input class="stv" type="checkbox" on-change="handleSelectDefaultValues">
                        <span>Select default values</span>
                    </label>
                </div>
                <div>
                    <label class="stv">SIFT</label>

                    <div class="horizontal layout">
                        <stv-select name="sift_op" id="sift_op">
                            <stv-option value="<" selected="">
                                &lt;</stv-option>
                                    <stv-option value="<=">
                                        &lt;=</stv-option>
                                            <stv-option value=">">&gt;</stv-option>
                                            <stv-option value=">=">&gt;=</stv-option>
                        </stv-select>
                        <paper-slider pin="" min="0" max="1" step="0.001" value="0" class="sliderBar" id="sift" editable="" on-value-change="sliderChange"></paper-slider>
                    </div>
                </div>
                <div>
                    <label class="stv">Polyphen</label>
                    <div class="horizontal layout">
                        <stv-select name="polyphen_op" id="polyphen_op">
                            <stv-option value="<" selected="">
                                &lt;</stv-option>
                                    <stv-option value="<=">
                                        &lt;=</stv-option>
                                            <stv-option value=">">&gt;</stv-option>
                                            <stv-option value=">=">&gt;=</stv-option>
                        </stv-select>
                        <paper-slider pin="" min="0" max="1" step="0.001" value="0" class="sliderBar" id="polyphen" editable="" on-value-change="sliderChange"></paper-slider>
                    </div>
                </div>
                <label class="stv">CADD</label>
                <div class="horizontal layout">
                    <stv-select name="cadd_op" id="cadd_op">
                        <stv-option value="<" selected="">
                            &lt;</stv-option>
                                <stv-option value="<=">
                                    &lt;=</stv-option>
                                        <stv-option value=">">&gt;</stv-option>
                                        <stv-option value=">=">&gt;=</stv-option>
                    </stv-select>
                    <paper-slider pin="" min="-100" max="100" step="0.01" value="0" class="sliderBar" id="cadd" editable="" on-value-change="sliderChange"></paper-slider>
                </div>
            </div>
        </stv-form-box>
    </template>
</dom-module>
<script>
    Polymer({
        is: "stv-filter-scores",
        properties: {
            collapsible: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            collapsed: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
            },
            siftValue: {
                type: Number,
            },
            polyphenValue: {
                type: Number,
            },
            caddValue: {
                type: Number,
            },
        },
        checkSift: function() {
            var sift = parseFloat(this.siftValue);
            if (!isNaN(sift)) {
                sift = this.$.sift_op.value + sift;
                return sift;
            } else {
                return null;
            }
        },
        checkPolyphen: function() {
            var polyphen = parseFloat(this.polyphenValue);
            if (!isNaN(polyphen)) {
                polyphen = this.$.polyphen_op.value + polyphen;
                return polyphen;
            } else {
                return null;
            }
        },
        checkCADD: function() {
            var cadd = parseFloat(this.caddValue);
            if (!isNaN(cadd)) {
                cadd = this.$.cadd_op.value + cadd;
                return cadd;
            } else {
                return null;
            }
        },
        clear: function() {
            // Sift
            this.$.sift.value = 0;
            this.siftValue = "";
            this.$.sift_op.value = "<";

            // Polyphen
            this.$.polyphen.value = 0;
            this.polyphenValue = "";
            this.$.polyphen_op.value = "<";

            // CADD
            this.$.cadd.value = 0;
            this.caddValue = "";
            this.$.cadd_op.value = "<";

        },
        load: function(hf) {
            var filterName = [];
            // Sift
            if (hf.sift != "" && hf.sift != null) {
                this._loadScore(hf, "sift");
                filterName.push("Sift" + hf.sift + " ");
            }

            // Polyphen
            if (hf.polyphen != "" && hf.polyphen != null) {
                this._loadScore(hf, "polyphen");
                filterName.push("Polyphen" + hf.polyphen + " ");
            }
            // CADD
            if (hf.functional != "" && hf.functional != null) {
                this._loadCadd(hf.functional);
                filterName.push(hf.functional + " ");
            }
            if (hf.cadd != "" && hf.cadd != null) {
                this._loadScore(hf, "cadd");
                filterName.push("CADD" + hf.cadd + " ");
            }

            return filterName;
        },
        _loadScore: function(hf, score) {
            var aux = hf[score].split("");
            var val = "";
            var valOp = "";
            var n = 0;
            for (var i = 0; i < 2; i++) {
                if (isNaN(aux[i])) {
                    valOp += aux[i];
                    n++;
                }
            }
            for (var i = n; i < aux.length; i++) {
                val += aux[i];
            }
            this.$[score + "_op"].value = valOp;
            this.$[score].value = parseFloat(val);
            var id = score + "Value";
            this[id] = val;
        },
        _loadCadd: function(cadd) {
            var aux = cadd.split("");
            var val = "";
            var valOp = "";
            var n = 8;
            for (var i = 8; i < 10; i++) {
                if (isNaN(aux[i]) && aux[i] != "-") {
                    valOp += aux[i];
                    n++;
                }
            }
            for (var i = n; i < aux.length; i++) {
                val += aux[i];
            }
            this.$["cadd_op"].value = valOp;
            this.$["cadd"].value = parseFloat(val);
            var id = "caddValue";
            this.caddValue = val;
        },
        sliderChange: function(e) {
            var id = e.currentTarget.id + "Value";
            this.set(id, e.currentTarget.value);
        },
        handleSelectDefaultValues: function(e) {
            if (e.currentTarget.checked == true) {
                this.set("siftValue", 0.05);
                this.$["sift"].value = 0.05;
                this.$["sift_op"].value = "<";
                this.set("polyphenValue", 0.95);
                this.$["polyphen"].value = 0.95;
                this.$["polyphen_op"].value = ">";
                this.set("caddValue", 20);
                this.$["cadd"].value = 20;
                this.$["cadd_op"].value = "<";
            }else{
              this.clear();
            }

        }
    });
</script>
<dom-module id="stv-filter-conservation" assetpath="bower_components/stevia-elements/src/filter/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        .inputValue {
            width: 170px;
            margin-left: 4px;
        }

        stv-select {
            width: 45px;
            margin-right: 3px;
            align-self: center;
        }

        paper-slider.sliderBar {
            color: #a0a0a0;
            --paper-slider-knob-color: #445D76;
            --paper-slider-active-color: #445D76;
            --paper-slider-pin-color: #445D76;
            --paper-input-container-focus-color: #445D76;
            width: 125%;
        }

        paper-slider::shadow #input {
            width: calc(20vh - 40px);
            font-size: 13px;
        }
    </style>
    <template>
        <stv-form-box collapsible$="{{collapsible}}" collapsed$="{{collapsed}}">
            <div class="header">
                Conservation
            </div>
            <div class="container">
                <div>
                    <label class="jso">PhyloP</label>

                    <div class="horizontal layout">
                        <stv-select name="phylop_op" id="phylop_op">
                            <stv-option value="<" selected="">
                                &lt;</stv-option>
                                    <stv-option value="<=">
                                        &lt;=</stv-option>
                                            <stv-option value=">">&gt;</stv-option>
                                            <stv-option value=">=">&gt;=</stv-option>
                        </stv-select>
                        <paper-slider pin="" step="0.001" min="-1000" max="1000" value="0" class="sliderBar" id="phylop" editable="" on-value-change="sliderChange"></paper-slider>
                    </div>
                </div>

                <div>
                    <label class="jso">PhastCons</label>
                    <div class="horizontal layout">
                        <stv-select name="phastcons_op" id="phastcons_op">
                            <stv-option value="<" selected="">
                                &lt;</stv-option>
                                    <stv-option value="<=">
                                        &lt;=</stv-option>
                                            <stv-option value=">">&gt;</stv-option>
                                            <stv-option value=">=">&gt;=</stv-option>
                        </stv-select>
                        <paper-slider pin="" step="0.001" min="-1000" max="1000" value="0" class="sliderBar" id="phastcons" editable="" on-value-change="sliderChange"></paper-slider>
                    </div>
                </div>

                <div>
                    <label class="jso">GERP</label>
                    <div class="horizontal layout">
                        <stv-select name="gerp_op" id="gerp_op">
                            <stv-option value="<" selected="">
                                &lt;</stv-option>
                                    <stv-option value="<=">
                                        &lt;=</stv-option>
                                            <stv-option value=">">&gt;</stv-option>
                                            <stv-option value=">=">&gt;=</stv-option>
                        </stv-select>
                        <paper-slider pin="" step="0.01" min="-100" max="100" value="0" class="sliderBar" id="gerp" editable="" on-value-change="sliderChange"></paper-slider>
                    </div>
                </div>
            </div>
        </stv-form-box>
    </template>
</dom-module>
<script>
    Polymer({
        is: "stv-filter-conservation",
        properties: {
            collapsible: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            collapsed: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
            },
            phylopValue: {
                type: Number,
            },
            phastconsValue: {
                type: Number,
            },
            gerpValue: {
                type: Number,
            },
        },

        checkPhylop: function(mode) {
            //mode=1 --> conservation
            //mode=2 --> phylop && phastcons
            var phylop = parseFloat(this.phylopValue);
            if (!isNaN(phylop)) {
                if (mode == 1) {
                    phylop = "phylop" + this.$.phylop_op.value + phylop;
                } else if (mode == 2) {
                    phylop = this.$.phylop_op.value + phylop;
                }
                return phylop;
            } else {
                return null;
            }
        },
        checkPhastcons: function(mode) {
            //mode=1 --> conservation
            //mode=2 --> phylop && phastcons
            var phastcons = parseFloat(this.phastconsValue);
            if (!isNaN(phastcons)) {
                if (mode == 1) {
                    phastcons = "phastCons" + this.$.phastcons_op.value + phastcons;
                } else if (mode == 2) {
                    phastcons = this.$.phastcons_op.value + phastcons;
                }
                return phastcons;
            } else {
                return null;
            }
        },
        checkGerp: function() {
            var gerp = parseFloat(this.gerpValue);
            if (!isNaN(gerp)) {
                gerp = this.$.gerp_op.value + gerp;
                return gerp;
            } else {
                return null;
            }
        },
        clear: function() {
            // Phylop
            this.$.phylop.value = 0;
            this.phylopValue = "";
            this.$.phylop_op.value = "<";
            // Phastcons
            this.$.phastcons.value = 0;
            this.phastconsValue = "";
            this.$.phastcons_op.value = "<";
            // gerp
            this.$.gerp.value = 0;
            this.gerpValue = "";
            this.$.gerp_op.value = "<";
        },
        load: function(hf, mode) {
            //mode=1 --> conservation
            //mode=2 --> phylop && phastcons

            var filterName = [];
            if (mode == 1) {
                // Phylop, Phastcons y Gerp
                if (hf.conservation != "" && hf.conservation != null) {
                    aux = hf.conservation.split(",");
                    if (aux[0].search("phastCons") >= 0) {
                        var p = aux[0].split("");
                        var val = "";
                        var valOp = "";
                        var n = 9;
                        for (var i = 9; i < 11; i++) {
                            if (isNaN(p[i]) && p[i] != "-") {
                                valOp += p[i];
                                n++;
                            }
                        }
                        for (var i = n; i < p.length; i++) {
                            val += p[i];
                        }
                        this.$.phastcons_op.value = valOp;
                        this.$.phastcons.value = parseFloat(val);
                        this.phastconsValue = parseFloat(val);
                        if (aux[1]) {
                            var p = aux[1].split("");
                            var val = "";
                            var valOp = "";
                            var n = 6;
                            for (var i = 6; i < 8; i++) {
                                if (isNaN(p[i]) && p[i] != "-") {
                                    valOp += p[i];
                                    n++;
                                }
                            }
                            for (var i = n; i < p.length; i++) {
                                val += p[i];
                            }
                            this.$.phylop_op.value = valOp;
                            this.$.phylop.value = parseFloat(val);
                            this.phylopValue = parseFloat(val);
                        }
                        if (aux[2]) {
                            var p = aux[2].split("");
                            var val = "";
                            var valOp = "";
                            var n = 4;
                            for (var i = 4; i < 6; i++) {
                                if (isNaN(p[i]) && p[i] != "-") {
                                    valOp += p[i];
                                    n++;
                                }
                            }
                            for (var i = n; i < p.length; i++) {
                                val += p[i];
                            }
                            this.$.gerp_op.value = valOp;
                            this.$.gerp.value = parseFloat(val);
                            this.gerppValue = parseFloat(val);
                        }
                    }
                    if (aux[0].search("phylop") >= 0) {
                        var p = aux[0].split("");
                        var val = "";
                        var valOp = "";
                        var n = 6;
                        for (var i = 6; i < 8; i++) {
                            if (isNaN(p[i]) && p[i] != "-") {
                                valOp += p[i];
                                n++;
                            }
                        }
                        for (var i = n; i < p.length; i++) {
                            val += p[i];
                        }
                        this.$.phylop_op.value = valOp;
                        this.$.phylop.value = parseFloat(val);
                        this.phylopValue = parseFloat(val);
                        if (aux[1]) {
                            var p = aux[1].split("");
                            var val = "";
                            var valOp = "";
                            var n = 4;
                            for (var i = 4; i < 6; i++) {
                                if (isNaN(p[i]) && p[i] != "-") {
                                    valOp += p[i];
                                    n++;
                                }
                            }
                            for (var i = n; i < p.length; i++) {
                                val += p[i];
                            }
                            this.$.gerp_op.value = valOp;
                            this.$.gerp.value = parseFloat(val);
                            this.gerppValue = parseFloat(val);
                        }
                    }
                    if (aux[0].search("gerp") >= 0) {
                        var p = aux[0].split("");
                        var val = "";
                        var valOp = "";
                        var n = 4;
                        for (var i = 4; i < 6; i++) {
                            if (isNaN(p[i]) && p[i] != "-") {
                                valOp += p[i];
                                n++;
                            }
                        }
                        for (var i = n; i < p.length; i++) {
                            val += p[i];
                        }
                        this.$.gerp_op.value = valOp;
                        this.$.gerp.value = parseFloat(val);
                        this.gerppValue = parseFloat(val);
                    }

                    //filterName
                    filterName.push(aux[0] + " ");
                    if (aux[1] != null) {
                        filterName.push(aux[1] + " ");
                    }
                    if (aux[2] != null) {
                        filterName.push(aux[2] + " ");
                    }

                }
            } else if (mode == 2) {
                // Phylop
                if (hf.phylop != "" && hf.phylop != null) {
                    var aux = hf.phylop.split("");
                    var val = "";
                    var valOp = "";
                    var n = 0;
                    for (var i = 0; i < 2; i++) {
                        if (isNaN(aux[i]) && aux[i] != "-") {
                            valOp += aux[i];
                            n++;
                        }
                    }
                    for (var i = n; i < aux.length; i++) {
                        val += aux[i];
                    }
                    this.$.phylop_op.value = valOp;
                    this.$.phylop.value = parseFloat(val);
                    this.phylopValue = parseFloat(val);
                    filterName.push("Phylop" + hf.phylop + " ");
                }
                // Phastcons
                if (hf.phastcons != "" && hf.phastcons != null) {
                    var aux = hf.phastcons.split("");
                    var val = "";
                    var valOp = "";
                    var n = 0;
                    for (var i = 0; i < 2; i++) {
                        if (isNaN(aux[i]) && aux[i] != "-") {
                            valOp += aux[i];
                            n++;
                        }
                    }
                    for (var i = n; i < aux.length; i++) {
                        val += aux[i];
                    }
                    this.$.phastcons_op.value = valOp;
                    this.$.phastcons.value = parseFloat(val);
                    this.phastconsValue = parseFloat(val);
                    filterName.push("Phastcons" + hf.phastcons + " ");
                }
            }

            return filterName;
        },
        loadGerp: function(hf) {
            filterName = "";
            if (hf.gerp != "" && hf.gerp != null) {
                this._loadScore(hf, "gerp");
                filterName = "GERP" + hf.gerp + " ";
            }
            return filterName;
        },
        _loadScore: function(hf, score) {
            var aux = hf[score].split("");
            var val = "";
            var valOp = "";
            var n = 0;
            for (var i = 0; i < 2; i++) {
                if (isNaN(aux[i])) {
                    valOp += aux[i];
                    n++;
                }
            }
            for (var i = n; i < aux.length; i++) {
                val += aux[i];
            }
            this.$[score + "_op"].value = valOp;
            this.$[score].value = parseFloat(val);
            var id = score + "Value";
            this.id = hf.dp;
        },
        sliderChange: function(e) {
            var id = e.currentTarget.id + "Value";
            this.set(id, e.currentTarget.value);
        },
    });
</script>
<dom-module id="stv-filter-consequencetypes" assetpath="bower_components/stevia-elements/src/filter/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        .inputValue {
            width: 170px;
            margin-left: 4px;
        }

        .popus {
            font-weight: bold;
            cursor: pointer;
        }

        .numFilter {
            /*padding: 1px 7px;*/
            background-color: #445D76;
            border-radius: 50%;
            color: #fff;
            font-weight: bold;
            font-size: 12px;
            margin-left: 10px;
            margin-top: 2px;
            line-height: 20px;
            height: 20px;
            width: 20px;
            text-align: center;
        }
    </style>
    <template>
        <stv-form-box collapsible$="{{collapsible}}" collapsed$="{{collapsed}}">
            <div class="header">
                Consequence Type
            </div>
            <div id="consequenceTypes" class="container vertical layout">
                <div class="horizontal layout">
                    <label class="stv popus" on-click="handleCollapseAction" data-type="ct_high" style="color:#b30000" title="The variant is assumed to have high (disruptive) impact in the protein, probably causing protein truncation, loss of function or triggering nonsense mediated decay."><i class$="{{ct_high}}"></i> High</label>
                    <label class="stv-control horizontal layout">
                        <input class="stv " type="checkbox" name="ct_high" data-type="ct_high" on-change="handleToggle">
                        <span></span>
                    </label>
                </div>
                <div id="ct_high" hidden="">
                    <template is="dom-repeat" items="{{ctHigh}}">
                        <label class="stv-control horizontal layout">
                            <input class="stv" value="{{item.value}}" data-name$="{{item.name}}" type="checkbox" name="consequence_type">
                            <span title$="{{item.description}}">{{item.name}}</span>
                            <span class="numFilter" hidden$="{{!enableResult}}">{{item.num}}</span>
                        </label>
                    </template>
                </div>
                <div class="horizontal layout">
                    <label class="stv popus" on-click="handleCollapseAction" data-type="ct_moderate" style="color:#ff751a" title="A non-disruptive variant that might change protein effectiveness."><i class$="{{ct_moderate}}"></i> Moderate</label>
                    <label class="stv-control horizontal layout">
                        <input class="stv " type="checkbox" name="ct_moderate" data-type="ct_moderate" on-change="handleToggle">
                        <span></span>
                    </label>
                </div>
                <div id="ct_moderate" hidden="">
                    <template is="dom-repeat" items="{{ctModerate}}">
                        <label class="stv-control horizontal layout">
                            <input class="stv" value="{{item.value}}" data-name$="{{item.name}}" type="checkbox" name="consequence_type">
                            <span title$="{{item.description}}">{{item.name}}</span>
                            <span class="numFilter" hidden$="{{!enableResult}}">{{item.num}}</span>
                        </label>
                    </template>
                </div>
                <div class="horizontal layout">
                    <label class="stv popus" on-click="handleCollapseAction" data-type="ct_low" style="color:#008000" title="Assumed to be mostly harmless or unlikely to change protein behaviour."><i class$="{{ct_low}}"></i> Low</label>
                    <label class="stv-control horizontal layout">
                        <input class="stv " type="checkbox" name="ct_low" data-type="ct_low" on-change="handleToggle">
                        <span></span>
                    </label>
                </div>
                <div id="ct_low" hidden="">
                    <template is="dom-repeat" items="{{ctLow}}">
                        <label class="stv-control horizontal layout">
                            <input class="stv" value="{{item.value}}" data-name$="{{item.name}}" type="checkbox" name="consequence_type">
                            <span title$="{{item.description}}">{{item.name}}</span>
                            <span class="numFilter" hidden$="{{!enableResult}}">{{item.num}}</span>
                        </label>
                    </template>
                </div>
                <div class="horizontal layout">
                    <label class="stv popus" on-click="handleCollapseAction" data-type="ct_modifier" style="color:#005b99" title="Usually non-coding variants or variants affecting non-coding genes, where predictions are difficult or there is no evidence of impact."><i class$="{{ct_modifier}}"></i> Modifier</label>
                    <label class="stv-control horizontal layout">
                        <input class="stv " type="checkbox" name="ct_modifier" data-type="ct_modifier" on-change="handleToggle">
                        <span></span>
                    </label>
                </div>
                <div id="ct_modifier" hidden="">
                    <template is="dom-repeat" items="{{ctModifier}}">
                        <label class="stv-control horizontal layout">
                            <input class="stv" value="{{item.value}}" data-name$="{{item.name}}" type="checkbox" name="consequence_type">
                            <span title$="{{item.description}}">{{item.name}}</span>
                            <span class="numFilter" hidden$="{{!enableResult}}">{{item.num}}</span>
                        </label>
                    </template>
                </div>
            </div>
        </stv-form-box>
    </template>
</dom-module>
<script>
    Polymer({
        is: "stv-filter-consequencetypes",
        properties: {
            collapsible: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            collapsed: {
                type: Boolean,
                reflectToAttribute: true,
                value: false,
            },
            consequenceTypes: {
                type: Array,
                value: function() {
                    return CONSEQUENCE_TYPES;
                }
            },
            data: {
                type: Array,
                value: function() {
                    return [];
                },
                observer: "dataChanged"
            },
            ctHigh: {
                type: Array,
                value: function() {
                    return [];
                }
            },
            ct_high: {
                type: String,
                value: "fa fa-angle-double-right minus"
            },
            ctModerate: {
                type: Array,
                value: function() {
                    return [];
                }
            },
            ct_moderate: {
                type: String,
                value: "fa fa-angle-double-right minus"
            },
            ctLow: {
                type: Array,
                value: function() {
                    return [];
                }
            },
            ct_low: {
                type: String,
                value: "fa fa-angle-double-right minus"
            },
            ctModifier: {
                type: Array,
                value: function() {
                    return [];
                }
            },
            ct_modifier: {
                type: String,
                value: "fa fa-angle-double-right minus"
            },
            enableResult: {
                type: Boolean,
                value: false
            }
        },
        ready: function() {
            if (this.enableResult == false) {
                for (var k = 0; k < this.consequenceTypes.length; k++) {
                    this._checkGroup(this.consequenceTypes[k]);
                }

            }
        },
        dataChanged: function(neo, old) {
            if (this.enableResult == true) {
                if (neo != null && neo.length > 0 && this.consequenceTypes != null) {
                    for (var k = 0; k < this.consequenceTypes.length; k++) {
                        this.consequenceTypes[k].num = 0;
                        for (var i = 0; i < neo.length; i++) {
                            var ct = neo[i].ct.split(",");
                            for (var n = 0; n < ct.length; n++) {
                                if (this.consequenceTypes[k].name.toLowerCase() == ct[n].toLowerCase()) {
                                    this.set("consequenceTypes." + k + ".num", this.consequenceTypes[k].num + 1);
                                }
                            }
                        }
                        this._checkGroup(this.consequenceTypes[k]);
                    }
                }
            }
        },
        _checkGroup: function(ct) {
            if (ct.impact == "high") {
                this.push("ctHigh", ct);
            } else if (ct.impact == "moderate") {
                this.push("ctModerate", ct);
            } else if (ct.impact == "low") {
                this.push("ctLow", ct);
            } else {
                this.push("ctModifier", ct);
            }
        },
        checkConsequenceTypes: function(mode) {
            //mode 1: value
            //mode 2: name
            var cts = [];
            var els = this.$.consequenceTypes.querySelectorAll("input[name='consequence_type']:checked");
            for (var i = 0; i < els.length; i++) {
                var ctInput = els[i];
                if (mode == 1) {
                    cts.push(ctInput.value);
                } else if (mode == 2) {
                    cts.push(ctInput.dataset.name);
                }
            }
            if (cts.length > 0) {
                return cts;
            } else {
                return null;
            }
        },
        clear: function() {
            var els = this.$.consequenceTypes.querySelectorAll("input:checked");
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                el.checked = false;
            }
        },
        load: function(hf, mode) {
            //mode 1: value
            //mode 2: name
            var filterName = [];
            if (hf["annot-ct"] != "" && hf["annot-ct"] != null) {
                var ctName = [];
                var cts = hf["annot-ct"].split(",");
                var ct_op = this.$.consequenceTypes.querySelectorAll("input[name='consequence_type']");
                for (var i = 0; i < cts.length; i++) {
                    var ct = cts[i];
                    for (var j = 0; j < ct_op.length; j++) {
                        if (mode == 1) {
                            if (ct_op[j].value.search(ct) >= 0) {
                                ct_op[j].checked = true;
                                ctName.push(ct_op[j].dataset.name);
                            }
                        } else if (mode == 2) {
                            if (ct_op[j].dataset.name.search(ct) >= 0) {
                                ct_op[j].checked = true;
                                ctName.push(ct_op[j].dataset.name);
                            }
                        }
                    }
                }
                filterName.push("Consequence Types: " + ctName.join(",") + " ");
            }
            return filterName;
        },
        handleCollapseAction: function(e) {
            var id = e.currentTarget.dataset.type;
            this.$[id].hidden = !this.$[id].hidden;
            if (this.$[id].hidden) {
                this[id] = "fa fa-angle-double-right minus";
            } else {
                this[id] = "fa fa-angle-double-down minus";
            }
        },
        handleToggle: function(e) {
            e.stopPropagation();
            if (e.currentTarget.checked) {
                this.handleSelectAll(e);
            } else {
                this.handleDeselectAll(e);
            }
        },
        handleSelectAll: function(e) {
            e.stopPropagation();
            var type = e.currentTarget.dataset.type;
            if (this.$[type].hidden == true) {
                this.handleCollapseAction(e);
            }
            var select = this.$[type].querySelectorAll("input");
            for (var i = 0; i < select.length; i++) {
                select[i].checked = true;
            }
        },
        handleDeselectAll: function(e) {
            e.stopPropagation();
            var type = e.currentTarget.dataset.type;
            var select = this.$[type].querySelectorAll("input");
            for (var i = 0; i < select.length; i++) {
                select[i].checked = false;
            }
        }
    });
</script>
<dom-module id="stv-go" assetpath="bower_components/stevia-elements/src/ontology/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            min-width: 700px;
            max-height: 500px;
            padding: 10px;
        }

        .but {
            color: #445D76;
            text-align: center;
            height: 20px;
            width: 115px;
            line-height: 20px;
            margin-top: 5px;
        }

        #goList {
            margin: 5px;
            height: 80%;
            width: 95%;
        }

        #allGO,
        #selectedGO {
            width: 95%;
            min-height: 345px;
            height: calc(100vh - 450px);
            border: 1px solid #d3d3d3;
        }

        .allGO {
            width: 50%;
            margin-right: 10px;
        }

        .selectedGO {
            width: 50%;
            margin-left: 10px;
        }

        .titlePreview {
            color: #445D76;
            margin-bottom: 5px;
            border-bottom: 1px solid #445D76;
        }

        stv-table {
            font-size: 12px;
        }

        .legend {
            border: 1px solid #d3d3d3;
            padding: 5px;
        }

        .legend div {
            margin-right: 40px;
        }

        .legend i {
            font-size: 15px;
        }

        .add-but {
            font-size: 13px;
            background-color: #ed9c33 !important;
            color: #FFFFFF !important;
            text-align: center;
            height: 30px;
            width: 150px;
            line-height: 30px;
            margin-top: 10px;
        }

        .treeGO {
            overflow-y: auto;
            min-height: 350px;
            height: calc(100vh - 450px);
            width: 80%;
            margin: 10px;
            padding: 5px;
        }
    </style>
    <template>
        <div class="horizontal layout" style="margin-bottom:5px">
            <div class="stv-btn stv-btn-shdw but" on-click="handleView" data-value="go" data-checked$="{{computeView(view, 'go')}}"> <i class="fa fa-list"></i>&nbsp; Select GO </div>
            <div class="stv-btn stv-btn-shdw but" on-click="handleView" data-value="hierarchy" data-checked$="{{computeView(view, 'hierarchy')}}"> <i class="fa fa-eye"></i>&nbsp; View Hierarchy </div>
        </div>
        <div id="goList" hidden$="{{!computeView(view, 'go')}}">
            <div class="horizontal layout">
                <div class="allGO">
                    <stv-table id="allGO" class="flex" columns="{{goColumns}}" request="{{request}}" enable-remote="" enable-select="" enable-filter="" enable-paging="" hide-column-selector="" page-size="15"></stv-table>
                    <div class="stv-btn stv-btn-shdw but" on-click="handleAddGO"><i class="fa fa-plus-square-o"></i>&nbsp; Add
                    </div>
                </div>
                <div class="selectedGO">
                    <stv-table id="selectedGO" class="flex" columns="{{goSelectedColumns}}" data="{{selectedGO}}" enable-paging="" hide-column-selector="" on-removerow="handleRemoveElement">
                    </stv-table>
                    <div class="stv-btn stv-btn-shdw but" on-click="handleClearSelected">
                        Clear
                    </div>
                </div>
            </div>
            <div class="horizontal layout flex" style="width: 100%">
                <div class="flex">
                </div>
                <div class="stv-btn stv-btn-shdw add-but" on-click="handleAddSelected"> Add Selected GO
                </div>
            </div>
        </div>
        <div hidden$="{{!computeView(view, 'hierarchy')}}" style="width: 95%">
            <div class="treeGO">
                <stv-ontology-tree id="treeGO">
                </stv-ontology-tree>
            </div>
            <div class="horizontal layout flex" style="width: 100%">
                <div class="flex">
                </div>
                <div class="stv-btn stv-btn-shdw add-but" on-click="handleAddSelected"> Add Selected GO
                </div>
            </div>
        </div>
    </template>

    <script>
        Polymer({
            is: "stv-go",
            properties: {
                view: {
                    type: String,
                    value: 'go'
                },
                selectedGO: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                url: {
                    type: String,
                    value: "",
                    observer: 'urlChanged'
                },
                goValue: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },
                mapSelectedGo: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },
                request: {
                    type: Object
                },
                numTotalResults: {
                    type: Number,
                    notify: true
                },
            },
            ready: function() {
                var me = this;
                this.getGO();
                this.getFirstGo();

                this.goColumns = [{
                    name: 'id',
                    title: 'ID',
                    type: 'text',
                    width: 120
                }, {
                    name: 'name',
                    title: 'Name',
                    type: 'text',
                    width: 280
                }];
                this.goSelectedColumns = [{
                    name: 'id',
                    title: 'ID',
                    type: 'text',
                    width: 120
                }, {
                    name: 'name',
                    title: 'Name',
                    type: 'text',
                    width: 230
                }, {
                    name: '',
                    title: '',
                    type: 'action',
                    width: 50
                }];
            },
            handleView: function(e) {
                this.view = e.target.dataset.value;
            },
            computeView: function(view, value) {
                return view === value;
            },
            handleAddGO: function(e) {
                for (var i = 0; i < this.$.allGO.selected.length; i++) {
                    var go = this.$.allGO.selected[i];
                    if (this.mapSelectedGo[go.id] == null) {
                        this.mapSelectedGo[go.id] = go;
                        this.push('selectedGO', go);
                    }
                }
            },
            handleClearSelected: function(e) {
                this.selectedGO = [];
                this.mapSelectedGo = {};
            },
            handleAddSelected: function(e) {
                var gos = [];
                this.goValue = [];
                var els = this.$.treeGO.querySelectorAll('stv-ontology-tree-item[selected]');
                if (els.length > 0) {
                    for (var i = 0; i < els.length; i++) {
                        if (this.mapSelectedGo[els[i].file.id] == null) {
                            this.mapSelectedGo[els[i].file.id] = els[i].file;
                            gos.push(els[i].file);
                        }
                    }
                    this.set('goValue', gos);
                } else {
                    this.set('goValue', this.selectedGO);
                }
                this.fire('added');
            },
            handleRemoveElement: function(e) {
                var key = e.detail.row.id;
                this.mapSelectedGo[key] = null;
            },
            getGO: function() {
                var me = this;
                var url = BiodbManager.go.fetch({
                    request: {
                        url: true
                    }
                });
                this.url = url;
                console.log(url);
            },

            urlChanged: function(neo, old) {
                var me = this;
                if (neo == null || neo == "") {
                    return;
                }
                this.request = {
                    url: this.url,
                    parse: function(response) {
                        return me._parse(response);
                    },
                    parseTotal: function(response) {
                        var total = me._parseTotal(response);

                        me.set('numTotalResults', total);
                        return total;
                    },
                };
            },
            _parse: function(response) {
                var me = this;
                if (response.result != null) {
                    data = response.result;
                } else {
                    data = [];
                }
                return data;
            },
            _parseTotal: function(response) {
                var total = 0;
                if (response.result != null) {
                    total = response.numTotalResults;
                }
                return total;
            },
            getFirstGo: function() {
                var me = this;
                if (localStorage.bioinfo_biertool_go) {
                    //Coger el arbol del local storage
                    this.$.treeHPO.tree = treeJSON.parse(localStorage.bioinfo_biertool_go);
                } else {
                    //Llamar al WS
                    BiodbManager.go.info({
                        query: {
                            id: "GO:0008150,GO:0003674,GO:0016043"
                        },
                        request: {
                            success: function(response) {
                                if (response.error === '' || response.error.msg == "") {
                                    me.$.treeGO.tree = response.result;
                                    // localStorage.bioinfo_team_diseases = JSON.stringify(response.result);
                                } else {
                                    console.log(response.error.msg);
                                }
                            },
                            error: function() {
                                console.log('Server error, try again later.');
                            }
                        }
                    });
                }
            }
        })
    </script>
</dom-module>
<dom-module id="stv-hpo" assetpath="bower_components/stevia-elements/src/ontology/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            min-width: 700px;
            max-height: 500px;
            padding: 10px;
        }

        .but {
            color: #445D76;
            text-align: center;
            height: 20px;
            width: 115px;
            line-height: 20px;
            margin-top: 5px;
        }

        #hpoList {
            margin: 5px;
            height: 80%;
            width: 95%;
        }

        #allHPO,
        #selectedHPO {
            width: 95%;
            min-height: 345px;
            height: calc(100vh - 450px);
            border: 1px solid #d3d3d3;
        }

        .allHPO {
            width: 50%;
            margin-right: 10px;
        }

        .selectedHPO {
            width: 50%;
            margin-left: 10px;
        }

        .titlePreview {
            color: #445D76;
            margin-bottom: 5px;
            border-bottom: 1px solid #445D76;
        }

        stv-table {
            font-size: 12px;
        }

        .legend {
            border: 1px solid #d3d3d3;
            padding: 5px;
        }

        .legend div {
            margin-right: 40px;
        }

        .legend i {
            font-size: 15px;
        }

        .add-but {
            font-size: 13px;
            background-color: #ed9c33 !important;
            color: #FFFFFF !important;
            text-align: center;
            height: 30px;
            width: 150px;
            line-height: 30px;
            margin-top: 10px;
        }

        .treeHPO {
            overflow-y: auto;
            min-height: 350px;
            height: calc(100vh - 450px);
            width: 80%;
            margin: 10px;
            padding: 5px;
        }
    </style>
    <template>
        <div class="horizontal layout" style="margin-bottom:5px">
            <div class="stv-btn stv-btn-shdw but" on-click="handleView" data-value="hpo" data-checked$="{{computeView(view, 'hpo')}}"> <i class="fa fa-list"></i>&nbsp; Select HPO </div>
            <div class="stv-btn stv-btn-shdw but" on-click="handleView" data-value="hierarchy" data-checked$="{{computeView(view, 'hierarchy')}}"> <i class="fa fa-eye"></i>&nbsp; View Hierarchy </div>
        </div>
        <div id="hpoList" hidden$="{{!computeView(view, 'hpo')}}">
            <div class="horizontal layout">
                <div class="allHPO">
                    <stv-table id="allHPO" class="flex" columns="{{hpoColumns}}" request="{{request}}" enable-remote="" enable-select="" enable-filter="" enable-paging="" hide-column-selector="" page-size="15"></stv-table>
                    <div class="stv-btn stv-btn-shdw but" on-click="handleAddHPO"><i class="fa fa-plus-square-o"></i>&nbsp; Add
                    </div>
                </div>
                <div class="selectedHPO">
                    <stv-table id="selectedHPO" class="flex" columns="{{hpoSelectedColumns}}" data="{{selectedHPO}}" enable-paging="" hide-column-selector="" on-removerow="handleRemoveElement">
                    </stv-table>
                    <div class="stv-btn stv-btn-shdw but" on-click="handleClearSelected">
                        Clear
                    </div>
                </div>
            </div>
            <div class="horizontal layout flex" style="width: 100%">
                <div class="flex">
                </div>
                <div class="stv-btn stv-btn-shdw add-but" on-click="handleAddSelected"> Add Selected HPO
                </div>
            </div>
        </div>
        <div hidden$="{{!computeView(view, 'hierarchy')}}" style="width: 95%">
            <div class="treeHPO">
                <stv-ontology-tree id="treeHPO">
                </stv-ontology-tree>
            </div>
            <div class="horizontal layout flex" style="width: 100%">
                <div class="flex">
                </div>
                <div class="stv-btn stv-btn-shdw add-but" on-click="handleAddSelected"> Add Selected HPO
                </div>
            </div>
        </div>
    </template>

    <script>
        Polymer({
            is: "stv-hpo",
            properties: {
                view: {
                    type: String,
                    value: 'hpo'
                },
                url: {
                    type: String,
                    value: "",
                    observer: 'urlChanged'
                },
                selectedHPO: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                hpoValue: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },
                mapSelectedHpo: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },
                request: {
                    type: Object
                },
                numTotalResults: {
                    type: Number,
                    notify: true
                },
            },
            ready: function() {
                var me = this;
                this.getHPO();
                this.getFirstHpo();

                this.hpoColumns = [{
                    name: 'id',
                    title: 'ID',
                    type: 'text',
                    width: 120
                }, {
                    name: 'name',
                    title: 'Name',
                    type: 'text',
                    width: 280
                }];
                this.hpoSelectedColumns = [{
                    name: 'id',
                    title: 'ID',
                    type: 'text',
                    width: 120
                }, {
                    name: 'name',
                    title: 'Name',
                    type: 'text',
                    width: 230
                }, {
                    name: '',
                    title: '',
                    type: 'action',
                    width: 50
                }];
            },
            handleView: function(e) {
                this.view = e.target.dataset.value;
            },
            computeView: function(view, value) {
                return view === value;
            },
            handleAddHPO: function(e) {
                for (var i = 0; i < this.$.allHPO.selected.length; i++) {
                    var hpo = this.$.allHPO.selected[i];
                    if (this.mapSelectedHpo[hpo.id] == null) {
                        this.mapSelectedHpo[hpo.id] = true;
                        this.push('selectedHPO', hpo);
                    }
                }
            },
            handleClearSelected: function(e) {
                this.selectedHPO = [];
                this.mapSelectedHpo = {};
            },
            handleAddSelected: function(e) {
                var hpos = [];
                this.hpoValue = [];
                var els = this.$.treeHPO.querySelectorAll('stv-ontology-tree-item[selected]');
                if (els.length > 0) {
                    for (var i = 0; i < els.length; i++) {
                        if (this.mapSelectedHpo[els[i].file.id] == null) {
                            this.mapSelectedHpo[els[i].file.id] = true;
                            hpos.push(els[i].file);
                        }
                    }
                    this.set('hpoValue', hpos);
                } else {
                    this.set('hpoValue', this.selectedHPO);
                }
                this.fire('added');
            },
            handleRemoveElement: function(e) {
                var key = e.detail.row.id;
                this.mapSelectedHpo[key] = null;
            },
            getHPO: function() {
                var me = this;
                var url = BiodbManager.hpo.fetch({
                    request: {
                        url: true
                    }
                });
                this.url = url;
                console.log(url);
            },

            urlChanged: function(neo, old) {
                var me = this;
                if (neo == null || neo == "") {
                    return;
                }
                this.request = {
                    url: this.url,
                    parse: function(response) {
                        return me._parse(response);
                    },
                    parseTotal: function(response) {
                        var total = me._parseTotal(response);

                        me.set('numTotalResults', total);
                        return total;
                    },
                };
            },
            _parse: function(response) {
                var me = this;
                if (response.result != null) {
                    data = response.result;
                } else {
                    data = [];
                }
                return data;
            },
            _parseTotal: function(response) {
                var total = 0;
                if (response.result != null) {
                    total = response.numTotalResults;
                }
                return total;
            },
            getFirstHpo: function() {
                var me = this;
                if (localStorage.bioinfo_biertool_hpo) {
                    //Coger el arbol del local storage
                    this.$.treeHPO.tree = treeJSON.parse(localStorage.bioinfo_biertool_hpo);
                } else {
                    //Llamar al WS
                    BiodbManager.hpo.info({
                        query: {
                            id: "HP:0000001"
                        },
                        request: {
                            success: function(response) {
                                if (response.error === '' || response.error.msg == "") {
                                    me.$.treeHPO.tree = response.result;
                                    // localStorage.bioinfo_team_diseases = JSON.stringify(response.result);
                                } else {
                                    console.log(response.error.msg);
                                }
                            },
                            error: function() {
                                console.log('Server error, try again later.');
                            }
                        }
                    });
                }
            }
        });
    </script>
</dom-module>
<dom-module id="stv-diseases-search" assetpath="bower_components/stevia-elements/src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            min-width: 700px;
            max-height: 500px;
            padding: 10px;
        }

        .but {
            color: #445D76;
            text-align: center;
            height: 20px;
            width: 115px;
            line-height: 20px;
            margin-top: 5px;
        }

        #allDiseases,
        #selectedDiseases {
            width: 95%;
            min-height: 345px;
            height: calc(100vh - 450px);
            border: 1px solid #d3d3d3;
        }

        .allDiseases {
            width: 50%;
            margin-right: 10px;
        }

        .selectedDiseases {
            width: 50%;
            margin-left: 10px;
        }

        .add-but {
            font-size: 13px;
            background-color: #ed9c33 !important;
            color: #FFFFFF !important;
            text-align: center;
            height: 30px;
            width: 150px;
            line-height: 30px;
            margin-top: 10px;
        }
    </style>
    <template>
        <div class="disease horizontal layout">
            <div class="allDiseases">
                <stv-table id="allDiseases" class="flex" columns="{{allDiseaseColumns}}" request="{{request}}" enable-remote="" enable-select="" enable-filter="" enable-paging="" hide-column-selector="" page-size="15"></stv-table>
                <div class="stv-btn stv-btn-shdw but" on-click="handleAddSelectedDiseases"><i class="fa fa-plus-square-o"></i>&nbsp; Add
                </div>
            </div>
            <div class="selectedDiseases">
                <stv-table id="selectedDiseases" class="flex" columns="{{diseaseColumns}}" data="{{selectedDisease}}" enable-paging="" hide-column-selector="" on-removerow="handleRemoveElement">
                </stv-table>
                <div class="stv-btn stv-btn-shdw but" on-click="handleClearSelectedDiseases">
                    Clear
                </div>
            </div>
        </div>
        <div class="horizontal layout flex" style="width: 100%">
            <div class="flex">
            </div>
            <div class="stv-btn stv-btn-shdw add-but" on-click="handleAddSelected"> Add Selected
            </div>
        </div>

    </template>

    <script>
        Polymer({
            is: "stv-diseases-search",
            properties: {
                selectedDisease: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                mapSelectedDisease: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },
                diseaseValue: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },
                url: {
                    type: String,
                    value: "",
                    observer: 'urlChanged'
                },
                request: {
                    type: Object
                },
                numTotalResults: {
                    type: Number,
                    notify: true
                },
            },
            ready: function() {
                var me = this;
                this.getDiseases();

                this.allDiseaseColumns = [{
                    name: 'phenotype',
                    title: 'Phenotype',
                    type: 'text',
                    width: 450
                        // }, {
                        //     name: 'source',
                        //     title: 'Source',
                        //     type: 'select',
                        //     options: ["clinvar", "cosmic"],
                        //     width: 125
                }];
                this.diseaseColumns = [{
                    name: 'phenotype',
                    title: 'Phenotype',
                    type: 'text',
                    width: 415
                        // }, {
                        //     name: 'source',
                        //     title: 'Source',
                        //     type: 'select',
                        //     options: ["clinvar", "cosmic"],
                        //     width: 110
                }, {
                    name: '',
                    title: '',
                    type: 'action',
                    width: 30
                }];
            },
            handleAddSelectedDiseases: function() {
                for (var i = 0; i < this.$.allDiseases.selected.length; i++) {
                    var disease = this.$.allDiseases.selected[i];
                    if (this.mapSelectedDisease[disease.phenotype] == null) {
                        this.mapSelectedDisease[disease.phenotype] = true;
                        this.push('selectedDisease', disease);
                    }
                }
            },
            handleClearSelectedDiseases: function(e) {
                this.selectedDisease = [];
                this.mapSelectedDisease = {};
            },
            handleAddSelected: function(e) {
                this.set('diseaseValue', this.selectedDisease);
                this.fire('added');
            },
            handleRemoveElement: function(e) {
                var key = e.detail.row.phenotype;
                this.mapSelectedDisease[key] = null;

            },
            getDiseases: function() {
                var me = this;
                var url = BiodbManager.clinical.fetch({
                    request: {
                        url: true
                    }
                });
                this.url = url;
                console.log(url);
            },

            urlChanged: function(neo, old) {
                var me = this;
                if (neo == null || neo == "") {
                    return;
                }
                this.request = {
                    url: this.url,
                    parse: function(response) {
                        return me._parse(response);
                    },
                    parseTotal: function(response) {
                        var total = me._parseTotal(response);

                        me.set('numTotalResults', total);
                        return total;
                    },
                };
            },
            _parse: function(response) {
                var me = this;
                if (response.result != null) {
                    data = response.result;
                } else {
                    data = [];
                }
                return data;
            },
            _parseTotal: function(response) {
                var total = 0;
                if (response.result != null) {
                    total = response.numTotalResults;
                }
                return total;
            },
        })
    </script>
</dom-module>
<dom-module id="bier-variant-filter" assetpath="src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            width: 260px;
            padding-left: 10px;
        }

        #filter_form {
            overflow-y: auto;
            height: 100%;
            margin: 0px;
        }

        #bar {
            padding: 0 3px 5px 0;
        }

        #bar > .stv-btn {
            margin: 0px 2px;
        }

        .segregation.sampleName {
            width: 100px;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }

        input.segregation,
        .segregationValue {
            margin-left: 3px;
        }

        textarea {
            resize: none;
            width: 100%;
        }

        stv-tooltip::shadow #messageInfo::shadow {
            height: 500px;
            width: 500px;
            background-color: #e2e9e9;
            border: 1px solid #e2e9e9;
            color: black;
            font-style: normal;
        }

        stv-tooltip::shadow .closeInfo::shadow {
            margin-left: 490px;
        }

        #filterHistoryTable > div:hover {
            background-color: #8ba7a7;
            border: 1px solid #8ba7a7;
        }

        #filter-name {
            text-overflow: ellipsis;
            width: 300px;
            white-space: nowrap;
            overflow: hidden;
        }

        .tit {
            margin-top: 10px;
            border-bottom: 1px solid #445D76;
            font-weight: bold;
        }

        .name {
            width: 300px;
        }

        .num {
            width: 100px;
        }

        .clear-but {
            width: 100px;
            background-color: #f0f4f4 !important;
        }

        .searchBut {
            width: 100px;
            font-size: 12px;
            color: #445D76;
            margin: 3px;
        }

        .minus {
            color: #2F65F4;
            font-size: 12px;
            padding: 0 2px;
            cursor: pointer;
        }

        .minus:hover {
            color: #445D76;
            font-weight: bold;
        }

        .popus {
            font-weight: bold;
            cursor: pointer;
        }

        #hpoPanel,
        #goPanel,
        #createNewPanel {
            min-width: 700px;
            min-height: 500px;
            height: calc(100vh - 300px);
            width: 60%;
            font-size: 12px;
        }

        .exclude {
            color: #666;
            margin-bottom: 5px;
        }

        .butstyle {
            border-radius: 4px;
            width: 100px;
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
        }

        .butstyle:hover {
            background-color: var(--light-button-color) !important;
        }

        #filterHistoryTooltip {
            border-radius: 4px;
            background-color: var(--dark-button-color) !important;
            color: var(--text-primary-color) !important;
        }

        #filterHistoryTooltip:hover {
            background: var(--accent-color) !important;
        }

        stv-select {
            width: 45px;
            margin-right: 3px;
            align-self: center;
        }

        paper-slider.sliderBar {
            color: #a0a0a0;
            --paper-slider-knob-color: #445D76;
            --paper-slider-active-color: #445D76;
            --paper-slider-pin-color: #445D76;
            --paper-input-container-focus-color: #445D76;
            width: 125%;
        }

        paper-slider::shadow #input {
            width: calc(20vh - 40px);
            font-size: 13px;
        }

        .tissueList {
            height: 250px;
            overflow-y: auto;
            width: 200px;
            margin-top: 10px;
        }

        .linage {
            fill: none;
            stroke: #000;
        }

        .marriage {
            fill: none;
            stroke: black;
        }

        .man {
            border: 1px solid black;
            background-color: white;
        }

        .woman {
            border: 1px solid black;
            border-radius: 10px;
            background-color: white;
        }

        .emphasis {
            font-style: italic;
        }

        p {
            padding: 0;
            margin: 0;
        }

        .proband {
            background-color: black;
            color: white;
        }
        svg {
            font: 10px sans-serif;
            height: 150px;
            width: 210px;
        }
    </style>
    <template>
        <form id="filter_form">
            <div id="bar" class="horizontal layout">
                <stv-tooltip id="filterHistoryTooltip" class="stv-btn stv-btn-shdw" title="Filters History" icon="filter">
                    <div class="stv-btn stv-btn-shdw clear-but" title="Clear Filters History" on-click="clearFiltersHistory">
                        Clear
                    </div>
                    <div class="horizontal layout flex">
                        <span class="tit num"> Date </span>
                        <span class="name tit"> Name </span>
                        <span class="tit num"> Found</span>
                    </div>
                    <div id="filterHistoryTable">
                        <template is="dom-repeat" items="{{historyFilters}}">
                            <div class="horizontal layout flex" on-click="loadFilter" data-filter="{{item.filter}}" title="{{item.name}}">
                                <span class="num">{{item.date}} </span>
                                <span id="filter-name" class="name">{{item.name}} </span>
                                <span class="num">{{item.found}}</span>
                            </div>
                        </template>
                    </div>
                </stv-tooltip>
                <div class="stv-btn stv-btn-shdw flex butstyle" on-click="clearForm">Clear</div>
                <div class="stv-btn stv-btn-shdw flex butstyle" on-click="handleSubmitClick">Search</div>
            </div>
            <stv-form-box collapsible="" id="segregationForm" hidden="{{!isFamilyStudy(study)}}">
                <div class="header">
                    Inheritance
                </div>
                <div class="container" style="overflow-y:auto;max-height:300px;min-height:200px">
                    <div id="inheritance" style="margin-bottom:15px;">
                        <div style="margin-bottom:5px;">Type of inheritance:</div>
                        <jso-select id="inheritanceOptions" on-change="handleInheritanceChanged">
                            <jso-option value="-">-</jso-option>
                            <jso-option value="dominant">dominant
                            </jso-option>
                            <jso-option value="recessive">recessive
                            </jso-option>
                            <jso-option value="linkedX">linked to X
                            </jso-option>
                            <jso-option value="linkedY">linked to Y
                            </jso-option>
                        </jso-select>
                    </div>
                    <div id="segregationHeader" class="horizontal layout">
                        <div class="segregation sampleName"></div>
                        <div class="segregation segregationValue flex">0/0</div>
                        <div class="segregation segregationValue flex">0/1</div>
                        <div class="segregation segregationValue flex">1/1</div>
                        <div class="segregation segregationValue flex">. / .</div>
                    </div>
                    <div id="segregation" class="vertical layout">
                        <template is="dom-repeat" items="{{samples}}">
                            <div class="horizontal layout">
                                <div class="segregation sampleName" title="{{item.name}}">{{item.name}}</div>
                                <label class="stv-control flex">
                                    <input type="checkbox" name="{{item.name}}" value="0/0,0|0">
                                    <span></span>
                                </label>
                                <label class="stv-control flex">
                                    <input type="checkbox" name="{{item.name}}" value="0/1,0|1,1/0,1|0">
                                    <span></span>
                                </label>
                                <label class="stv-control flex">
                                    <input type="checkbox" name="{{item.name}}" value="1/1,1|1">
                                    <span></span>
                                </label>
                                <label class="stv-control flex">
                                    <input type="checkbox" name="{{item.name}}" value="-1/-1,-1|-1">
                                    <span></span>
                                </label>
                            </div>
                        </template>
                    </div>
                    <div id="familyPreviewDiv" class="preview" style="height: 140px;margin-top: 10px;">
                        <div class="" style="border: 1px solid grey; height:95%">
                            <div id="familyPreview"></div>
                        </div>
                    </div>
                </div>
            </stv-form-box>

            <stv-form-box collapsible="" collapsed="" hidden="{{!isPairedStudy(study)}}">
                <div class="header">
                    Somatic Filter
                </div>
                <div class="container">
                    <div class="horizontal layout">
                        <div class="segregation sampleName"></div>
                        <div class="segregation segregationValue flex">Somatic</div>
                        <div class="segregation segregationValue flex" style="margin-left:15px;">Germinal</div>
                    </div>
                    <div id="somatic" class="vertical layout">
                        <template is="dom-repeat" items="{{samples}}">
                            <div class="horizontal layout">
                                <div class="segregation sampleName" title="{{item.name}}">{{item.name}}</div>
                                <label class="stv-control flex">
                                    <input class="stv" type="radio" name="{{item.name}}" data-file$="{{item.source}}" value="somatic">
                                    <span style="margin-left:15px;"></span>
                                </label>
                                <label class="stv-control flex">
                                    <input class="stv" type="radio" name="{{item.name}}" data-file$="{{item.source}}" value="germinal">
                                    <span style="margin-left:15px;"></span>
                                </label>
                            </div>
                        </template>
                    </div>
                </div>
            </stv-form-box>

            <stv-filter-position id="filterPosition" collapsible="" enable-importbed="" enable-snpid="" enable-genepanel="" style="font-size:12px"></stv-filter-position>

            <stv-form-box collapsible="" collapsed="">
                <div class="header">
                    Type
                </div>
                <div id="type_op" class="container">
                    <div style="margin-left:5px" class="horizontal layout">
                        <label class="stv-control">
                            <input class="stv" value="SNV,SNP" type="checkbox">
                            <span>SNV</span>
                        </label>
                        <label class="stv-control" style="margin-left:14px">
                            <input class="stv" value="MNV" type="checkbox">
                            <span>MNV</span>
                        </label>
                    </div>
                    <div style="margin-left:5px" class="horizontal layout">
                        <label class="stv-control">
                            <input class="stv" value="INDEL" type="checkbox">
                            <span>INDEL</span>
                        </label>
                        <label class="stv-control" style="margin-left:2px">
                            <input class="stv" value="SV" type="checkbox">
                            <span>SV</span>
                        </label>
                    </div>
                    <div style="margin-left:5px" class="horizontal layout">
                        <label class="stv-control">
                            <input class="stv" value="CNV" type="checkbox">
                            <span>CNV</span>
                        </label>
                    </div>
                </div>
            </stv-form-box>

            <stv-form-box collapsible="" collapsed="">
                <div class="header">
                    Population Freqs.
                </div>
                <div class="container">
                    <i class$="{{phase_3}}" on-click="handleCollapseAction" data-type="phase_3"></i>
                    <label class="stv popus" on-click="handleCollapseAction" data-type="phase_3">1000 Genomes population phase 3</label>
                    <div id="phase_3" hidden="">
                        <label class="stv">All populations MAF [ALL]</label>
                        <div class="horizontal layout">
                            <stv-select name="1000GENOMES_phase_3_ALL_op" id="1000GENOMES_phase_3_ALL_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="1000GENOMES_phase_3_ALL" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                        <label class="stv">American MAF [AMR]</label>
                        <div class="horizontal layout">
                            <stv-select name="1000GENOMES_phase_3_AMR_op" id="1000GENOMES_phase_3_AMR_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="1000GENOMES_phase_3_AMR" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                        <label class="stv">South Asian MAF [SAS]</label>
                        <div class="horizontal layout">
                            <stv-select name="1000GENOMES_phase_3_SAS_op" id="1000GENOMES_phase_3_SAS_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="1000GENOMES_phase_3_SAS" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                        <label class="stv">East Asian MAF [EAS]</label>
                        <div class="horizontal layout">
                            <stv-select name="1000GENOMES_phase_3_EAS_op" id="1000GENOMES_phase_3_EAS_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="1000GENOMES_phase_3_EAS" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                        <label class="stv">African MAF [AFR]</label>
                        <div class="horizontal layout">
                            <stv-select name="1000GENOMES_phase_3_AFR_op" id="1000GENOMES_phase_3_AFR_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="1000GENOMES_phase_3_AFR" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                        <label class="stv">European MAF [EUR]</label>
                        <div class="horizontal layout">
                            <stv-select name="1000GENOMES_phase_3_EUR_op" id="1000GENOMES_phase_3_EUR_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="1000GENOMES_phase_3_EUR" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                    </div>
                    <br>
                    <i class$="{{esp_6500}}" on-click="handleCollapseAction" data-type="esp_6500"></i>
                    <label class="stv popus" on-click="handleCollapseAction" data-type="esp_6500">ESP 6500</label>
                    <div id="esp_6500" hidden="">
                        <label class="stv">European american MAF</label>
                        <div class="horizontal layout">
                            <stv-select name="ESP_6500_EA_op" id="ESP_6500_EA_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="ESP_6500_EA" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                        <label class="stv">African american MAF</label>
                        <div class="horizontal layout">
                            <stv-select name="ESP_6500_AA_op" id="ESP_6500_AA_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="ESP_6500_AA" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                    </div>
                    <br>
                    <i class$="{{exac}}" on-click="handleCollapseAction" data-type="exac"></i>
                    <label class="stv popus" on-click="handleCollapseAction" data-type="exac">EXAC</label>
                    <div id="exac" hidden="">
                        <label class="stv">EXAC MAF</label>
                        <div class="horizontal layout">
                            <stv-select name="EXAC_ALL_op" id="EXAC_ALL_op">
                                <stv-option value="<" selected="">
                                    &lt;</stv-option>
                                        <stv-option value="<=">
                                            &lt;=</stv-option>
                                                <stv-option value=">">&gt;</stv-option>
                                                <stv-option value=">=">&gt;=</stv-option>
                            </stv-select>
                            <paper-slider pin="" min="0" max="1" step="0.000001" value="0" class="sliderBar" id="EXAC_ALL" editable="" on-value-change="sliderChange"></paper-slider>
                        </div>
                    </div>
                </div>
            </stv-form-box>

            <stv-filter-scores id="filterScores" collapsible="" collapsed="" style="font-size:12px"></stv-filter-scores>

            <stv-filter-conservation id="filterConservation" collapsible="" collapsed="" style="font-size:12px"></stv-filter-conservation>

            <stv-filter-consequencetypes id="filterCT" collapsible="" collapsed="" style="font-size:12px"></stv-filter-consequencetypes>

            <stv-form-box collapsible="" collapsed="">
                <div class="header">
                    Gene Ontology
                </div>
                <div class="container">
                    <label class="stv">Filter by GO id:</label>
                    <div class="horizontal layout" hidden="">
                        <label class="exclude">Exclude Selected</label>
                        <label>
                            <input id="goExclude" value="exclude" type="checkbox" class="stv">
                            <span></span>
                        </label>
                    </div>
                    <textarea class="stv" id="go" name="go" value="{{goSearch::change}}" rows="3" placeholder="GO:0000001,GO:0001177" disabled="">                    </textarea>
                    <div class="horizontal layout" style="color: #666;margin-top:2px;line-height:28px;">
                        Search GO: &nbsp;
                        <div class="stv-btn stv-btn-shdw searchBut" on-click="showGO" title="Search GO"><i class="fa fa-search" aria-hidden="true"></i>
                        </div>
                    </div>
                </div>
            </stv-form-box>
            <stv-form-box collapsible="" collapsed="">
                <div class="header">
                    Human Phenotype Ontology
                </div>
                <div class="container">
                    <label class="stv">Filter by HPO id:</label>
                    <div class="horizontal layout" hidden="">
                        <label class="exclude">Exclude Selected</label>
                        <label>
                            <input id="hpoExclude" value="exclude" type="checkbox" class="stv">
                            <span></span>
                        </label>
                    </div>
                    <textarea class="stv" id="hpo" name="hpo" value="{{hpoSearch::change}}" rows="3" placeholder="HP:0000001,HP:3000079" disabled="">                    </textarea>
                    <div class="horizontal layout" style="color: #666;margin-top:2px;line-height:28px;">
                        Search HPO: &nbsp;
                        <div class="stv-btn stv-btn-shdw searchBut" on-click="showHPO" title="Search HPO"><i class="fa fa-search" aria-hidden="true"></i>
                        </div>
                    </div>
                </div>
            </stv-form-box>

            <stv-form-box collapsible="" collapsed="">
                <div class="header">
                    Diagnostic by disease
                </div>
                <div class="container">
                    <label class="stv">Selected diseases:</label>
                    <textarea class="stv" id="disease" name="disease" value="{{diseaseSearch::change}}" rows="3" placeholder="Carcinoma, Retinitis Pigmentosa" disabled="">                    </textarea>
                    <div class="horizontal layout" style="color: #666;margin-top:2px;line-height:28px;">
                        Search disease: &nbsp;
                        <div class="stv-btn stv-btn-shdw searchBut" on-click="showCreatePanel" title="Search disease"><i class="fa fa-search" aria-hidden="true"></i>
                        </div>
                    </div>
                </div>
            </stv-form-box>
            <stv-form-box collapsible="" collapsed="">
                <div class="header">
                    Tissue
                </div>
                <div class="container">
                    <label class="stv-control flex">
                        <input class="stv" type="radio" name="tissue" value="protein" checked="">
                        <span style="margin-left:15px;">Human Protein Atlas</span>
                    </label>
                    
                    <div class="tissueList">
                        <template is="dom-repeat" items="{{proteinTissues}}">
                            <label class="stv-control horizontal layout">
                                <input class="stv" value="{{item}}" data-name$="{{item.name}}" type="checkbox" name="consequence_type">
                                <span title$="{{item.name}}">{{item.name}}</span>
                            </label>
                        </template>
                    </div>
                </div>
            </stv-form-box>

            <stv-panel id="importComponent" modal="" closable="" hidden="">
                <div class="header">
                    <i class="fa fa-plus-square-o"></i> Import File
                </div>
                <stv-opencga-import-file id="importFile" class="container" on-end="handleImportFile" bioformat="{{bedBioformat}}"></stv-opencga-import-file>
            </stv-panel>
            <stv-panel id="goPanel" modal="" closable="" hidden="">
                <div class="header">
                    <i class="fa fa-search" aria-hidden="true"></i> Gene Ontology
                </div>
                <div class="container" style="width:100%">
                    <stv-go go-value="{{goValue}}" on-added="showGO"></stv-go>
                </div>
            </stv-panel>
            <stv-panel id="hpoPanel" modal="" closable="" hidden="">
                <div class="header">
                    <i class="fa fa-search" aria-hidden="true"></i> Human Phenotype Ontology
                </div>
                <div class="container" style="width:100%">
                    <stv-hpo hpo-value="{{hpoValue}}" on-added="showHPO"></stv-hpo>
                </div>
            </stv-panel>
            <stv-panel id="createNewPanel" modal="" closable="" hidden="">
                <div class="header">
                    <i class="fa fa-search" aria-hidden="true"></i> Create new Panel for diagnostic
                </div>
                <div class="container" style="width:100%">
                    <stv-diseases-search disease-value="{{diseaseValue}}" on-added="showCreatePanel">
                </stv-diseases-search></div>
            </stv-panel>
        </form>
    </template>
</dom-module>
<script>
    Polymer({
        is: "bier-variant-filter",
        properties: {
            url: {
                type: String,
                notify: true,
                value: ''
            },
            study: {
                type: Object,
                value: function() {
                    return {};
                },
                observer: 'studyChanged'
            },
            samples: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
                observer: 'samplesChanged'
            },
            regionValue: {
                type: String,
                notify: true,
                value: ''
            },
            geneValue: {
                type: String,
                notify: true,
                value: ''
            },
            snpIdValue: {
                type: String,
                notify: true,
                value: ''
            },
            goValue: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
                observer: 'goValueChanged'
            },
            goSearch: {
                type: String,
                notify: true,
                value: '',
            },
            hpoValue: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
                observer: 'hpoValueChanged'
            },
            hpoSearch: {
                type: String,
                notify: true,
                value: '',
            },
            diseaseValue: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
                observer: 'diseaseValueChanged'
            },
            diseaseSearch: {
                type: String,
                notify: true,
                value: '',
            },
            fileName: {
                type: String,
                notify: true,
                value: 'Choose file...'
            },
            consequenceTypes: {
                type: Array,
                value: function() {
                    return CONSEQUENCE_TYPES;
                }
            },
            historyFilters: {
                type: Array,
                value: function() {
                    return [];
                },
            },
            hash: {
                type: Object,
                value: function() {
                    return {};
                },
            },
            numTotalResults: {
                type: Object,
                observer: "resultsChanged"
            },
            bedBioformat: {
                type: Object,
                value: {
                    text: "BED",
                    value: "BED",
                    validator: BEDValidator
                }
            },
            query: {
                type: Object,
                notify: true,
                value: function() {
                    return {};
                },
            },
            phase_3: {
                type: String,
                value: "fa fa-angle-double-right minus"
            },
            esp_6500: {
                type: String,
                value: "fa fa-angle-double-right minus"
            },
            exac: {
                type: String,
                value: "fa fa-angle-double-right minus"
            },
            filesId: {
                type: Array,
                value: function() {
                    return [];
                },
                observer: "filesIdChanged"
            },
            proteinTissues: {
                type: Array,
                value: function() {
                    return [];
                },
                observer: "proteinTissuesChanged"
            },
            familyMap: {
                type: Array,
                observer: 'familyMapChanged'
            }
        },
        ready: function() {
            this.scopeSubtree(this.$.familyPreview, true);
            var me = this;
            if (localStorage.bioinfo_bierApp_filter_history) {
                this.hash = JSON.parse(localStorage.bioinfo_bierApp_filter_history);
                if (Array.isArray(this.hash)) {
                    localStorage.bioinfo_bierApp_filter_history = "";
                    this.hash = {};
                }
            } else {
                localStorage.bioinfo_bierApp_filter_history = [];
            }
            BiodbManager.tissue.fetch({
                query: {
                    skip: 0,
                    limit: 60
                },
                request: {
                    success: function(response) {
                        if (response.error === '' || response.error.msg == "") {
                            var aux = [];
                            for (var i = 0; i < response.result.length; i++) {
                                aux.push(response.result[i]);
                            }
                            me.set('proteinTissues', aux);
                        } else {
                            console.log(response.error.msg);
                        }
                    },
                    error: function() {
                        console.log('Server error, try again later.');
                    }
                }
            });

        },
        proteinTissuesChanged: function(neo, old) {},
        studyChanged: function(neo, old) {
            if (neo && neo.id != null) {
                // if (this.study.type == "CASE_CONTROL") {
                //     this.$.segregationForm.hidden = true;
                // } else {
                //     this.$.segregationForm.hidden = false;
                // }
                this.historyFilters = this.hash[neo.id];
                this.clearForm();
            }
        },
        isPairedStudy: function(study) {
            if (study.type != null && study.type.toUpperCase() == "PAIRED") {
                return true;
            } else {
                return false;
            }
        },
        isFamilyStudy: function(study) {
            if (study.type != null && study.type.toUpperCase() == "FAMILY") {
                return true;
            } else {
                return false;
            }
        },
        samplesChanged: function(neo, old) {
          if(neo && neo.length>0){
            this.$.familyPreviewDiv.hidden=true;
            if(neo[0].marriages!=null){
              this.$.familyPreviewDiv.hidden=false;
              if(neo[0].marriages[0]!=null && neo[0].marriages[0].spouse!=null){
                this.set('familyMap', neo);
              }else{
                this._createFamilyMap(neo);
              }
            }
          }
            this.clearForm();
        },
        _createFamilyJson: function(samples) {
            var hash = {};
            for (var i = 0; i < samples.length; i++) {
                hash[samples[i].name] = samples[i];
            }

            for (var key in hash) {
                var elem = hash[key];
                var f = elem.father;
                var m = elem.mother;

                if (f in hash) {
                    if (m in hash) {
                        hash[f] = this._addMarriage(hash[f], elem, hash[m]);
                    }
                }
                if (m in hash) {
                    if (f in hash) {
                        hash[m] = this._addMarriage(hash[m], elem, hash[f]);
                    }
                }
            }
            return hash;
        },
        _addMarriage: function(father, child, mother) {
            if (father.marriages.length == 0) {
                father.marriages.push({
                    'spouse': mother,
                    'children': []
                });
            }
            for (var i = 0; i < father.marriages.length; i++) {
                if (father.marriages[i].spouse.name == mother.name) {
                    father.marriages[i].children.push(child);
                }
            }

            return father;

        },
        _createFamilyMap: function(samples) {
            var family = this._createFamilyJson(samples);
            var familyArray = [];
            for (var key in family) {
                var elem = family[key];
                if ((elem.father == "-" || elem.mother == "-")) {
                    var flag = false;
                    for (var i = 0; i < familyArray.length; i++) {
                        var m = familyArray[i].marriages;
                        for (var j = 0; j < m.length; j++) {
                            if (m[j].spouse.name == elem.name) {
                                flag = true;
                            }
                        }
                    }
                    if (flag == false) {
                        familyArray.push(elem);
                    }
                }
            }
            this.set('familyMap', familyArray);
        },
        familyMapChanged: function(neo, old) {
            if (neo) {
                if (this.$.familyPreview.firstElementChild != null) {
                    this.$.familyPreview.removeChild(this.$.familyPreview.firstElementChild);
                }
                var arrayAux = [];
                arrayAux.push(neo[0]);

                dTree.init(arrayAux, {
                    target: this.$.familyPreview,
                    debug: false,
                    width: 385,
                    height: 395,
                    margin: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    },
                    nodeWidth: 100,
                    styles: {
                        node: 'node',
                        linage: 'linage',
                        marriage: 'marriage',
                        text: 'nodeText'
                    }
                });
            }
        },
        resultsChanged: function(neo, old) {
            if (neo != -1) {
                var query = this.query;
                var numTotalResults = neo;
                /* Filter History */
                var filterHistory = [];
                if (this.study.id in this.hash) {
                    filterHistory = this.hash[this.study.id];
                }
                this.set("historyFilters", filterHistory);

                var newFilter = JSON.stringify(query);
                var _load = -1;
                for (var i = 0; i < this.historyFilters.length && _load == -1; i++) { // Check if the fitler has been selected from the history
                    var elem = this.historyFilters[i];
                    if (elem != null) {
                        var oldFilter = JSON.stringify(this.historyFilters[i].filter);
                        if (newFilter == oldFilter) {
                            _load = i;
                        }
                    }
                }

                if (_load == -1) { // This filter is new (has not been selected from the history)
                    if (query.genotype != null || query.region != null || query.gene != null || query.ids != null || query.type != "" || query['annot-population-maf'] != null || query.sift != null || query.polyphen != null || query.functional != null || query.hpo != null || query["clinical-data"] != null || query.go != null || query.conservation != null || query["annot-ct"] != null) {
                        var dateAux = new Date();
                        var minAux = dateAux.getMinutes();
                        if (minAux < 10) {
                            minAux = "0" + minAux;
                        }
                        var date = dateAux.getDate() + '/' + (dateAux.getMonth() + 1) + ' ' + dateAux.getHours() + ':' + minAux;
                        name = this.loadForm(query);
                        var found = numTotalResults;
                        var hf = {};
                        hf = {
                            date: date,
                            name: name,
                            filter: query,
                            found: found
                        };

                        var filters = new FilterHistory(20, filterHistory);
                        filters.unshift(hf);
                        this.set("historyFilters", filters);
                        this.hash[this.study.id] = this.historyFilters;

                        localStorage.bioinfo_bierApp_filter_history = JSON.stringify(this.hash);
                    }
                } else { // HistoryFilter contains this filter. We need to change the date and push to top
                    var pos = _load;

                    var filters = new FilterHistory(20, this.historyFilters);
                    var filter = filters[pos];
                    var dateAux = new Date();
                    var minAux = dateAux.getMinutes();
                    if (minAux < 10) this
                    minAux = "0" + minAux;

                    var date = dateAux.getDate() + '/' + (dateAux.getMonth() + 1) + ' ' + dateAux.getHours() + ':' + minAux;

                    filter.date = date;

                    var aux = filters[pos];
                    filters[pos] = filters[0];
                    filters[0] = aux;

                    this.set("historyFilters", filters);
                    this.hash[this.study.id] = this.historyFilters;

                    localStorage.bioinfo_bierApp_filter_history = JSON.stringify(this.hash);
                    this.clearForm();
                    this.loadForm(query);
                }
            }
        },
        goValueChanged: function(neo, old) {
            if (neo) {
                var goName = [];
                for (var i = 0; i < neo.length; i++) {
                    goName.push(neo[i].name);
                }
                this.goSearch = goName.join(",");
            }
        },
        hpoValueChanged: function(neo, old) {
            if (neo) {
                var hpoName = [];
                for (var i = 0; i < neo.length; i++) {
                    hpoName.push(neo[i].name);
                }
                this.hpoSearch = hpoName.join(",");
            }
        },
        diseaseValueChanged: function(neo, old) {
            if (neo) {
                var diseaseName = [];
                for (var i = 0; i < neo.length; i++) {
                    diseaseName.push(neo[i].phenotype);
                }
                this.diseaseSearch = diseaseName.join(",");
            }
        },
        handleFeatureSelected: function(e) {
            var item = e.detail;
            if (item) {
                var values = this.$.gene.value.split(',').filter(function(el) {
                    return el.length != 0
                });
                values.push(item.name);
                values = values.filter(function(item, index, inputArray) {
                    return inputArray.indexOf(item) == index;
                });
                this.$.gene.value = values.join(",");
            }
        },
        clearForm: function() {
            // this.url = "";
            /* samples */
            this.$.inheritanceOptions.value = "-";
            var els = this.$.segregation.querySelectorAll("input:checked");
            for (var i = 0; i < els.length; i++) {
                els[i].checked = false;
            }

            //SomaticVsGerminal
            var els = this.$.somatic.querySelectorAll("input");
            for (var i = 0; i < els.length; i++) {
                els[i].checked = false;
            }

            // GO
            this.$.go.value = "";
            this.goValue = "";
            this.goSearch = "";
            this.$.goExclude.checked = false;
            // HPO
            this.$.hpo.value = "";
            this.hpoValue = "";
            this.hpoSearch = "";
            this.$.hpoExclude.checked = false;
            // Diseases
            this.$.disease.value = "";
            this.diseaseValue = "";
            this.diseaseSearch = "";

            this.$.filterPosition.clear();

            // Type
            var types = this.$.type_op.querySelectorAll("input:checked");
            for (var i = 0; i < types.length; i++) {
                var type = types[i];
                type.checked = false;
            }

            // Freqs

            this.$["1000GENOMES_phase_3_ALL"].value = 0;
            this["1000GENOMES_phase_3_ALL"] = "";
            this.$["1000GENOMES_phase_3_ALL_op"].value = "<";
            this.$["1000GENOMES_phase_3_AMR"].value = 0;
            this["1000GENOMES_phase_3_AMR"] = "";
            this.$["1000GENOMES_phase_3_AMR_op"].value = "<";
            this.$["1000GENOMES_phase_3_SAS"].value = 0;
            this["1000GENOMES_phase_3_SAS"] = "";
            this.$["1000GENOMES_phase_3_SAS_op"].value = "<";
            this.$["1000GENOMES_phase_3_EAS"].value = 0;
            this["1000GENOMES_phase_3_EAS"] = "";
            this.$["1000GENOMES_phase_3_EAS_op"].value = "<";
            this.$["1000GENOMES_phase_3_AFR"].value = 0;
            this["1000GENOMES_phase_3_AFR"] = "";
            this.$["1000GENOMES_phase_3_AFR_op"].value = "<";
            this.$["1000GENOMES_phase_3_EUR"].value = 0;
            this["1000GENOMES_phase_3_EUR"] = "";
            this.$["1000GENOMES_phase_3_EUR_op"].value = "<";

            this.$["ESP_6500_EA"].value = 0;
            this["ESP_6500_EA"] = "";
            this.$["ESP_6500_EA_op"].value = "<";
            this.$["ESP_6500_AA"].value = 0;
            this["ESP_6500_AA"] = "";
            this.$["ESP_6500_AA_op"].value = "<";
            this.$["EXAC_ALL"].value = 0;
            this["EXAC_ALL"] = "";
            this.$["EXAC_ALL_op"].value = "<";

            // Sift
            // Polyphen
            // cadd
            this.$.filterScores.clear();

            // Phylop
            // Phastcons
            this.$.filterConservation.clear();

            /* Consequence Types */
            this.$.filterCT.clear();
        },
        handleSubmitClick: function() {
            var me = this;
            this.$.filterPosition.checkGene(function(geneQuery) {
                me.submitForm(geneQuery);
            });
        },
        submitForm: function(geneQuery) {
            var query = {};

            // Region
            var regionQuery = this.$.filterPosition.checkRegion();
            if (regionQuery == -1) {
                return;
            } else if (regionQuery != null) {
                query["region"] = regionQuery;
            }

            // SNPId
            var idsQuery = this.$.filterPosition.checkSNPId();
            if (idsQuery != null) {
                query["ids"] = idsQuery;
            }

            // Genes
            // var geneQuery = this.$.filterPosition.checkGene();
            if (geneQuery == -1) {
                return;
            } else if (geneQuery != null) {
                query["gene"] = geneQuery;
            }

            //SomaticVsGerminal
            var els = this.$.somatic.querySelectorAll("input");
            var querySom = [];
            var queryaux = [];
            for (var i = 0; i < els.length; i++) {
                var el = els[i];
                if (el.checked == true) {
                    if (el.value == "germinal") {
                        queryaux.push(el.name + ":germinal");
                        querySom.push(el.name + ":" + "0/0,0|0");
                    } else if (el.value == "somatic") {
                        queryaux.push(el.name + ":somatic");
                        querySom.push(el.name + ":" + "0/1,0|1,1/0,1|0,1/1,1|1");
                    }
                }
            }
            if (querySom.length > 0) {
                query['somatic'] = queryaux.join(";");
                query.genotype = querySom.join(";");
            }

            // GO
            var gosMap = {};
            for (var i = 0; i < this.goValue.length; i++) {
                gosMap[this.goValue[i].id] = true;
                if (this.goValue[i].children != null) {
                    if (Object.keys(this.goValue[i].children).length > 0) {
                        for (var j = 0; j < this.goValue[i].children.length; j++) {
                            this.goValue.push(this.goValue[i].children[j]);
                        }
                    }
                }
            }
            if (this.goSearch != "") {
                if (this.goValue == "") {
                    query["go"] = this.goSearch;
                } else {
                    query["go"] = Object.keys(gosMap).join(",");
                }
            }

            // HPO
            var hposMap = {};
            for (var i = 0; i < this.hpoValue.length; i++) {
                hposMap[this.hpoValue[i].id] = true;
                if (this.hpoValue[i].children != null) {
                    if (Object.keys(this.hpoValue[i].children).length > 0) {
                        for (var j = 0; j < this.hpoValue[i].children.length; j++) {
                            this.hpoValue.push(this.hpoValue[i].children[j]);
                        }
                    }
                }
            }
            if (this.hpoSearch != "") {
                if (this.hpoValue == "") {
                    query["hpo"] = this.hpoSearch;
                } else {
                    query["hpo"] = Object.keys(hposMap).join(",");
                }
            }

            //diseases
            if (this.diseaseSearch != "") {
                query["clinical-data"] = this.diseaseSearch;
            }

            // Genotypes
            var genotypes = [];
            for (var i = 0; i < this.samples.length; i++) {
                var sampleName = this.samples[i].name;
                var els = this.$.segregation.querySelectorAll("input[name='" + sampleName + "']:checked");

                var gtValues = [];
                for (var j = 0; j < els.length; j++) {
                    var el = els[j].value.split(",");
                    for (var k = 0; k < el.length; k++) {
                        gtValues.push(el[k]);
                    }
                }
                if (gtValues.length > 0) {
                    var aux = sampleName + ":" + gtValues.join(",");
                    genotypes.push(aux);
                }
            }

            if (genotypes.length > 0) {
                query.genotype = genotypes.join(";");
            }

            // Consequence Types
            var cts = this.$.filterCT.checkConsequenceTypes(1);
            if (cts != null) {
                query["annot-ct"] = cts.join(",");
            }

            // Protein Substitution Scores
            var sift = this.$.filterScores.checkSift();
            if (sift == -1) {
                return;
            } else if (sift != null) {
                query["sift"] = sift;
            }
            var polyphen = this.$.filterScores.checkPolyphen();
            if (polyphen == -1) {
                return;
            } else if (polyphen != null) {
                query["polyphen"] = polyphen;
            }
            var cadd = this.$.filterScores.checkCADD();
            if (cadd == -1) {
                return;
            } else if (cadd != null) {
                query["functional"] = "cadd_raw" + cadd;
            }

            var phastcons = this.$.filterConservation.checkPhastcons(1);
            var phylop = this.$.filterConservation.checkPhylop(1);
            var gerp = this.$.filterConservation.checkGerp();
            if (phastcons != null || phylop != null || gerp != null) {
                var conservation = [];
                if (phastcons != null) {
                    conservation.push(phastcons);
                }
                if (phylop != null) {
                    conservation.push(phylop);
                }

                if (gerp != null) {
                    conservation.push("gerp" + gerp);
                }
                query["conservation"] = conservation.join(",");
            }

            // Population Frequencies

            // Population minor allele frequency: {study}:{population}[<|>|<=|>=]{number}
            var popFreq = [];

            // 1000GENOMES_phase_3
            if (this.$["1000GENOMES_phase_3_ALL"].value != "") {
                popFreq.push(this._getPopulationQuery("1000GENOMES_phase_3", "ALL", "phase3"));
            }
            if (this.$["1000GENOMES_phase_3_AMR"].value != "") {
                popFreq.push(this._getPopulationQuery("1000GENOMES_phase_3", "AMR", "phase3"));
            }
            if (this.$["1000GENOMES_phase_3_SAS"].value != "") {
                popFreq.push(this._getPopulationQuery("1000GENOMES_phase_3", "SAS", "phase3"));
            }
            if (this.$["1000GENOMES_phase_3_EAS"].value != "") {
                popFreq.push(this._getPopulationQuery("1000GENOMES_phase_3", "EAS", "phase3"));
            }
            if (this.$["1000GENOMES_phase_3_AFR"].value != "") {
                popFreq.push(this._getPopulationQuery("1000GENOMES_phase_3", "AFR", "phase3"));
            }
            if (this.$["1000GENOMES_phase_3_EUR"].value != "") {
                popFreq.push(this._getPopulationQuery("1000GENOMES_phase_3", "EUR", "phase3"));
            }

            //ESP_6500
            if (this.$["ESP_6500_EA"].value != "") {
                popFreq.push(this._getPopulationQuery("ESP_6500", "EA", "ESP"));
            }
            if (this.$["ESP_6500_AA"].value != "") {
                popFreq.push(this._getPopulationQuery("ESP_6500", "AA", "ESP"));
            }

            if (this.$["EXAC_ALL"].value != "") {
                popFreq.push(this._getPopulationQuery("EXAC", "ALL", "exac"));
            }

            if (popFreq.length > 0) {
                query['annot-population-maf'] = popFreq.join(";");
                if (query['annot-population-maf'].indexOf("error") >= 0) {
                    return;
                }
            }

            // Type
            var types = this.$.type_op.querySelectorAll("input:checked");
            var typesAux = [];
            if (types != "") {
                for (var i = 0; i < types.length; i++) {
                    typesAux.push(types[i].value);
                }
                query["type"] = typesAux;
            }

            // Samples
            var sampleNames = [];
            for (var i = 0; i < this.samples.length; i++) {
                var sample = this.samples[i];
                sampleNames.push(sample.name);

            }

            var sampleQuery = sampleNames.join(",");
            query.returnedSamples = sampleQuery;

            query.timeout = 30000;

            this.set('query', query);

            console.log(query);
            this.search(query);
            // this.clearForm();

        },

        _getPopulationQuery: function(study, population, type) {
            var value = parseFloat(this.$[study + "_" + population].value);
            var value_op = this.$[study + "_" + population + "_op"].value;
            value = study + ":" + population + value_op + value;
            return value;
        },
        _setPopulationValue: function(population, value) {
            var aux = value.split("");
            var n = 0;
            var pop = "";
            for (i = 0; i < 5; i++) {
                if (isNaN(aux[i]) && aux[i] != '.') {
                    pop += aux[i];
                    n++;
                }
            }
            var val = "";
            if (pop.length == 4) {
                this.$[population + "_op"].value = aux[3];
            } else if (pop.length == 5) {
                this.$[population + "_op"].value = aux[3] + aux[4];
            }
            for (var i = n; i < aux.length; i++) {
                val += aux[i];
            }
            this.$[population].value = val;
        },

        search: function(query) {
            query.sid = Cookies("bioinfo_sid");
            query.skipCount = false;
            query.sort = true;

            //****//
            var sampleFiles = {};
            var filesIdAux = [];
            var me = this;
            var n = 0;

            for (var i = 0; i < this.samples.length; i++) {
                var sample = this.samples[i];
                if (sample.status == 'READY') {
                    if (sampleFiles[sample.source] == null) {
                        sampleFiles[sample.source] = 1;
                        n++;
                    }
                }
            }
            if (n > 0) {
                var studyId = this.study.id;
                OpencgaManager.studies.files({
                    id: studyId,
                    query: {
                        sid: Cookies('bioinfo_sid'),
                    },
                    request: {
                        async: true,
                        success: function(response) {
                            if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                var result = response.response[0].result;
                                for (var i = 0; i < result.length; i++) {
                                    if (result[i].type == "FILE") {
                                        if (sampleFiles[result[i].name] != null && result[i].index != null && result[i].index.status == 'READY') {
                                            filesIdAux.push(result[i].id);
                                        }
                                    }
                                }
                                me.set('filesId', filesIdAux);
                            } else {
                                console.log(response.response[0].errorMsg);
                            }
                        },
                        error: function() {
                            console.log('Server error, try again later.');
                        }
                    }
                });
            }

        },
        filesIdChanged: function(neo, old) {
            if (neo.length > 0) {
                this.query.files = neo.join(',');
                this.query.returnedStudies = this.study.id;
                //TODO fsalavert: fix
                //            query.sessionId = Cookies("bioinfo_sid");
                var url = OpencgaManager.studies.variants({
                    id: this.study.id,
                    query: this.query,
                    request: {
                        url: true
                    }
                });

                console.log(url.length);
                if (url.length < 8000) {
                    this.url = url;
                    console.log(url);
                } else {
                    alert('Url too long');
                }
            }
        },
        loadForm: function(hf) {
            var filterName = [];

            // Samples
            if (hf.genotype != "" && hf.genotype != null) {
                var gtName = {};
                var sample_op = this.$.segregation.querySelectorAll("input");
                var gts = hf.genotype.split(";");
                for (var i = 0; i < gts.length; i++) {
                    var gt = gts[i].split(":");
                    var sampleName = gt[0];
                    var sample = gt[1].split(",");
                    for (var j = 0; j < sample_op.length; j++) {
                        if (sample_op[j].name == sampleName) {
                            for (var k = 0; k < sample.length; k++) {
                                if (sample_op[j].value.indexOf(sample[k]) >= 0) {
                                    sample_op[j].checked = true;
                                    if (gtName[sampleName] == null) {
                                        gtName[sampleName] = [];
                                    }
                                    gtName[sampleName].push(sample[k]);
                                }
                            }
                        }
                    }
                }
                filterName.push("Genotype: " + JSON.stringify(gtName).replace("{", "").replace("}", "").replace(/"/gi, "") + " ");
            }
            if (hf.somatic != "" && hf.somatic != null) {
                var els = this.$.somatic.querySelectorAll("input");
                var som = hf.somatic.split(";");
                for (var i = 0; i < som.length; i++) {
                    var n = som[i].split(":")
                    for (var j = 0; j < els.length; j++) {
                        if (els[j].name == n[0] && els[j].value == n[1]) {
                            els[j].checked = true;
                        }
                    }
                }
                filterName.push("Somatic: " + hf.somatic);
            }

            if (hf.go != "" && hf.go != null) {
                this.set('goSearch', hf.go);
                filterName.push("GO: " + hf.go);
            }
            if (hf.hpo != "" && hf.hpo != null) {
                this.set('hpoSearch', hf.hpo);
                filterName.push("HPO: " + hf.hpo);
            }
            if (hf["clinical-data"] != "" && hf["clinical-data"] != null) {
                this.set('diseaseSearch', hf["clinical-data"]);
                filterName.push("Disease: " + hf["clinical-data"]);
            }

            // Region
            // Genes
            // SNPId
            var fP = this.$.filterPosition.load(hf);
            if (fP.length > 0) {
                for (var i = 0; i < fP.length; i++) {
                    filterName.push(fP[i]);
                }
            }

            // Types
            if (hf.type != "" && hf.type != null) {
                var type_op = this.$.type_op.querySelectorAll("input");
                for (var i = 0; i < hf.type.length; i++) {
                    var type = hf.type[i];
                    for (var j = 0; j < type_op.length; j++) {
                        if (type_op[j].value.search(type) >= 0) {
                            type_op[j].checked = true;
                        }
                    }
                }
                filterName.push("Type: " + hf.type.join(",") + " ");
            }

            //Populaions
            if (hf['annot-population-maf'] != "" && hf['annot-population-maf'] != null) {
                var pops = hf['annot-population-maf'].split(";");
                for (var i = 0; i < pops.length; i++) {
                    var type = pops[i].split(":");
                    if (type[0] == "1000GENOMES_phase_3") {
                        if (pops[i].indexOf("ALL") >= 0) {
                            this._setPopulationValue("1000GENOMES_phase_3_ALL", type[1]);
                        } else if (pops[i].indexOf("AMR") >= 0) {
                            this._setPopulationValue("1000GENOMES_phase_3_AMR", type[1]);
                        } else if (pops[i].indexOf("SAS") >= 0) {
                            this._setPopulationValue("1000GENOMES_phase_3_SAS", type[1]);
                        } else if (pops[i].indexOf("EAS") >= 0) {
                            this._setPopulationValue("1000GENOMES_phase_3_EAS", type[1]);
                        } else if (pops[i].indexOf("AFR") >= 0) {
                            this._setPopulationValue("1000GENOMES_phase_3_AFR", type[1]);
                        } else if (pops[i].indexOf("EUR") >= 0) {
                            this._setPopulationValue("1000GENOMES_phase_3_EUR", type[1]);
                        }
                    } else if (type[0] == "EXAC") {
                        this._setPopulationValue("EXAC_ALL", type[1]);
                    } else if (type[0] == "ESP_6500") {
                        if (pops[i].indexOf("EA") >= 0) {
                            this._setPopulationValue("ESP_6500_EA", type[1]);
                        } else if (pops[i].indexOf("AA") >= 0) {
                            this._setPopulationValue("ESP_6500_AA", type[1]);
                        }
                    }
                }
                filterName.push("Population: " + hf['annot-population-maf'] + " ");
            }

            // Sift
            // Polyphen
            // cadd
            var fS = this.$.filterScores.load(hf);
            if (fS.length > 0) {
                for (var i = 0; i < fS.length; i++) {
                    filterName.push(fS[i]);
                }
            }

            // Phylop, Phastcons y Gerp
            var fC = this.$.filterConservation.load(hf, 1);
            if (fC.length > 0) {
                for (var i = 0; i < fC.length; i++) {
                    filterName.push(fC[i]);
                }
            }
            // Consequence Types
            var fCT = this.$.filterCT.load(hf, 1);
            if (fCT.length > 0) {
                for (var i = 0; i < fCT.length; i++) {
                    filterName.push(fCT[i]);
                }
            }

            return filterName.join(" AND ");
        },
        loadFilter: function(e) {
            e.stopPropagation();
            this.clearForm();
            this.loadForm(e.currentTarget.dataFilter);
            this.$.filterHistoryTooltip.handleClose(e);
            this.handleSubmitClick();

        },
        clearFiltersHistory: function(e) {
            e.stopPropagation();
            var me = this;
            new StvDialog().confirm("Are you sure?", function(answer) {
                if (answer == true) {
                    me.historyFilters = [];
                    delete(me.hash[me.study.id]);
                    localStorage.bioinfo_bierApp_filter_history = JSON.stringify(me.hash);
                } else {
                    return;
                }
            });

        },
        handleGenesImportBed: function(bed_file) {
            var me = this;

            var log = [];
            var line = 0;

            if (bed_file != null) {

                var _navigator = new FileNavigator(bed_file);

                var indexToStartWith = 0;

                _navigator.readSomeLines(indexToStartWith, function linesReadHandler(err, index, lines, eof, progress) {
                    if (err) {
                        return;
                    }
                    console.log(lines.length);

                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i];

                        if ((line.indexOf("#") < 0 && line.indexOf("browser") < 0 && line.indexOf("track") < 0) && line != '') {
                            var fields = line.split("\t");
                            var chr = fields[0];
                            var start = fields[1];
                            var end = fields[2];
                            var gene = {
                                name: chr + ":" + start + "-" + end,
                                chr: chr,
                                start: start,
                                end: end
                            };

                            me.regionValue += gene.name + ",";
                        }

                        line++;
                    }

                    if (eof) {
                        return;
                    }

                    _navigator.readSomeLines(index + lines.length, linesReadHandler);

                })

            }
        },
        handleImportFile: function() {
            var file = this.$.importFile.$.fileInput.files[0];

            if (!(this.$.importFile.$.validator.errorCount > 0)) {
                this.handleGenesImportBed(file);
                this.$.importComponent.hidden = true;
            }
        },
        showImportComponent: function() {
            this.$.importComponent.hidden = false;
        },
        handleCollapseAction: function(e) {
            var id = e.currentTarget.dataset.type;
            this.$[id].hidden = !this.$[id].hidden;
            if (this.$[id].hidden) {
                this[id] = "fa fa-angle-double-right minus";
            } else {
                this[id] = "fa fa-angle-double-down minus";
            }
        },
        showGO: function() {
            this.$.goPanel.hidden = !this.$.goPanel.hidden;
        },
        showHPO: function() {
            this.$.hpoPanel.hidden = !this.$.hpoPanel.hidden;
        },
        showCreatePanel: function() {
            this.$.createNewPanel.hidden = !this.$.createNewPanel.hidden;
        },
        sliderChange: function(e) {
            var id = e.currentTarget.id + "Value";
            this.set(id, e.currentTarget.value);
        },
        handleInheritanceChanged: function(e) {
            var els = this.$.segregation.querySelectorAll("input:checked");
            for (var i = 0; i < els.length; i++) {
                els[i].checked = false;
            }
            var inheritance = e.currentTarget.value;
            if (inheritance != "-") {
                this._getSegregation(this.samples, inheritance);
            }
        },
        _getSegregation: function(samples, inheritance) {
            var array = [];
            var gtName = {};
            var sample_op = this.$.segregation.querySelectorAll("input");

            if (inheritance == "dominant") {
                for (var i = 0; i < samples.length; i++) {
                    for (var j = 0; j < sample_op.length; j++) {
                        if (sample_op[j].name == samples[i].name) {
                            if (samples[i].proband == false) {
                                if (sample_op[j].value == "0/0,0|0") {
                                    sample_op[j].checked = true;
                                }
                            } else {
                                if (sample_op[j].value == "0/1,0|1,1/0,1|0" || sample_op[j].value == "1/1,1|1") {
                                    sample_op[j].checked = true;
                                }
                            }
                        }
                    }
                }
            } else if (inheritance == "recessive") {
                for (var i = 0; i < samples.length; i++) {
                    for (var j = 0; j < sample_op.length; j++) {
                        if (sample_op[j].name == samples[i].name) {
                            if (samples[i].proband == true) {
                                if (sample_op[j].value == "1/1,1|1") {
                                    sample_op[j].checked = true;
                                }
                            } else {
                                if (sample_op[j].value == "0/1,0|1,1/0,1|0") {
                                    sample_op[j].checked = true;
                                }
                                if (samples[i].father != "-" && samples[i].mother != "-") {
                                    if (sample_op[j].value == "0/0,0|0") {
                                        sample_op[j].checked = true;
                                    }
                                }
                            }
                        }
                    }
                }

            } else if (inheritance == "linkedX") {
                for (var i = 0; i < samples.length; i++) {
                    if (samples[i].gender == "Male") {
                        for (var j = 0; j < sample_op.length; j++) {
                            if (sample_op[j].name == samples[i].name) {
                                if (samples[i].proband == false) {
                                    if (sample_op[j].value == "0/0,0|0") {
                                        sample_op[j].checked = true;
                                    }
                                } else {
                                    if (sample_op[j].value == "1/1,1|1") {
                                        sample_op[j].checked = true;
                                    }
                                }
                            }
                        }
                    } else {
                        for (var j = 0; j < sample_op.length; j++) {
                            if (sample_op[j].name == samples[i].name) {
                                if (samples[i].proband == true) {
                                    if (sample_op[j].value == "1/1,1|1") {
                                        sample_op[j].checked = true;
                                    }
                                } else {
                                    if (sample_op[j].value == "0/1,0|1,1/0,1|0" || sample_op[j].value == "0/0,0|0") {
                                        sample_op[j].checked = true;
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (inheritance == "linkedY") {
                for (var i = 0; i < samples.length; i++) {
                    if (samples[i].gender == "Male") {
                        for (var j = 0; j < sample_op.length; j++) {
                            if (sample_op[j].name == samples[i].name) {
                                if (samples[i].proband == false) {
                                    if (sample_op[j].value == "0/0,0|0") {
                                        sample_op[j].checked = true;
                                    }
                                } else {
                                    if (sample_op[j].value == "1/1,1|1") {
                                        sample_op[j].checked = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    });
</script>
<dom-module id="bier-variant-grid" assetpath="src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
        }

        .title {
            font-size: 22px;
            border-bottom: thin solid #edebe3;
            /*margin: 7px 5px;*/
        }

        stv-table {
            overflow-y: auto;
            border: 1px solid #d3d3d3;
        }

        stv-table::shadow #list {
            height: 300px;
            overflow-x: auto
        }

        stv-table::shadow {
            font-size: 11px;
        }
    </style>
    <template>

        <stv-table id="table" enable-resize="" enable-export$="{{enableExport}}" enable-paging="" enable-remote="" enable-select="" enable-loading="" request="{{request}}" on-rowclick="handleRowClick"></stv-table>
    </template>

</dom-module>
<script>
    Polymer({
        is: "bier-variant-grid",
        properties: {
            url: {
                type: String,
                notify: true,
                value: '',
                observer: 'urlChanged'
            },
            study: {
                type: Object,
                value: function() {
                    return {};
                },
                observer: 'studyChanged'
            },
            samples: {
                type: Array,
                notify: true,
                value: function() {
                    return [];
                },
                observer: 'samplesChanged'
            },
            request: {
                type: Object
            },
            numTotalResults: {
                type: Number,
                notify: true
            },
            enableExport: {
                type: Boolean,
                reflectToAttribute: true,
                value: false
            },
            query: {
                type: Object,
                value: function() {
                    return {};
                }
            }
        },
        _columns: [{
            name: 'variant',
            title: "Variant",
            width: 100,
            formula: function(row) {
                return row.chromosome + ":" + row.start;
            }
        }, {
            name: 'alleles',
            title: 'Alleles',
            width: 100,
            formula: function(row) {
                return row.reference + ">" + row.alternate;
            }
        }, {
            name: 'snpId',
            title: 'SNP Id',
            width: 80,
            defaultValue: '.',
            formula: function(row) {
                var links = [];
                if (row.ids.length > 0) {
                    for (var i = 0; i < row.ids.length; i++) {
                        if (row.ids[i] == '.') {
                            return '.';
                        }
                        var url = "http://www.ensembl.org/Homo_sapiens/Variation/Explore?r=" + row.chromosome + ":" + row.start + "-" + row.end + ";v=" + row.ids[i] + ";vdb=variation";
                        links.push('<a href="' + url + '" target="_blank">' + row.ids[i] + '</a>');
                    }

                    return links.join(",");
                } else {
                    return '.';
                }
            },
            sort: function(a, b) {
                var rsnum_a = parseInt(a.id.replace('rs', ''));
                var rsnum_b = parseInt(b.id.replace('rs', ''));
                return rsnum_a - rsnum_b;
            }
        }, {
            name: 'genes',
            title: 'Genes',
            width: 150,
            defaultValue: '.',
            formula: function(row) {
                if (row.genes != null) {
                    var genes = row.genes.split(",");
                    var links = [];
                    for (var i = 0; i < genes.length; i++) {
                        if (genes[i] == '.') {
                            return '.';
                        }
                        var url = "http://www.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=" + genes[i] + ";r=" + row.chromosome + ":" + row.start + "-" + row.end;
                        links.push('<a href="' + url + '" target="_blank">' + genes[i] + '</a>');
                    }

                    return links.join(",");
                } else {
                    return '.';
                }
            }
        }, {
            name: 'type',
            title: 'Type',
            width: 50,
            defaultValue: '.'
        }, {
            name: 'samples',
            title: 'Samples',
            width: 100
        }, {
            name: 'ct',
            title: 'Conseq. Type',
            width: 300
        }, {
            name: 'dp',
            title: 'DP',
            width: 50,
            defaultValue: '.'

        }, {
            name: 'sift',
            title: 'SIFT',
            width: 50,
            defaultValue: '.',
            styleFormula: function(row) {
                var style = {
                    backgroundColor: '#8ccd8c',
                    color: '#fff'
                };
                if (row.sift == null) {
                    style.backgroundColor = '#76afd5';
                } else if (row.sift <= 0.05) {
                    style.backgroundColor = '#f47070';
                }
                return style;
            },
        }, {
            name: 'polyphen',
            title: 'Polyphen',
            width: 50,
            defaultValue: '.',
            styleFormula: function(row) {

                var style = {
                    backgroundColor: '#8ccd8c',
                    color: '#fff'
                };
                if (row.polyphen == null) {
                    style.backgroundColor = '#76afd5';
                } else if (row.polyphen >= 0.95) {
                    style.backgroundColor = '#f47070';
                }
                return style;
            }
        }, {
            name: 'cadd',
            title: 'CADD',
            width: 50,
            defaultValue: '.'
        }, {
            name: 'phylop',
            title: 'phyloP',
            width: 50,
            defaultValue: '.'
        }, {
            name: 'phastCons',
            title: 'PhastCons',
            width: 57,
            defaultValue: '.'
        }, {
            name: 'gerp',
            title: 'GERP',
            width: 50,
            defaultValue: '.'
        }, {
            name: '1000GENOMES_phase_3',
            title: '1000G MAF(phase 3)',
            defaultValue: '.',
            width: 300,
            columns: [{
                name: "ALL",
                title: "ALL",
                width: 50,
                formula: function(row) {
                    if (row['1000GENOMES_phase_3'] && row['1000GENOMES_phase_3'].ALL) {
                        return row['1000GENOMES_phase_3'].ALL;
                    } else {
                        return ".";
                    }
                }
            }, {
                name: "AMR",
                title: "AMR",
                width: 50,
                formula: function(row) {
                    if (row['1000GENOMES_phase_3'] && row['1000GENOMES_phase_3'].AMR) {
                        return row['1000GENOMES_phase_3'].AMR;
                    } else {
                        return ".";
                    }
                }
            }, {
                name: "SAS",
                title: "SAS",
                width: 50,
                formula: function(row) {
                    if (row['1000GENOMES_phase_3'] && row['1000GENOMES_phase_3'].SAS) {
                        return row['1000GENOMES_phase_3'].SAS;
                    } else {
                        return ".";
                    }
                }
            }, {
                name: "EAS",
                title: "EAS",
                width: 50,
                formula: function(row) {
                    if (row['1000GENOMES_phase_3'] && row['1000GENOMES_phase_3'].EAS) {
                        return row['1000GENOMES_phase_3'].EAS;
                    } else {
                        return ".";
                    }
                }
            }, {
                name: "AFR",
                title: "AFR",
                width: 50,
                formula: function(row) {
                    if (row['1000GENOMES_phase_3'] && row['1000GENOMES_phase_3'].AFR) {
                        return row['1000GENOMES_phase_3'].AFR;
                    } else {
                        return ".";
                    }
                }
            }, {
                name: "EUR",
                title: "EUR",
                width: 50,
                formula: function(row) {
                    if (row['1000GENOMES_phase_3'] && row['1000GENOMES_phase_3'].EUR) {
                        return row['1000GENOMES_phase_3'].EUR;
                    } else {
                        return ".";
                    }
                }
            }]
        }, {
            name: 'ESP_6500',
            title: 'ESP 650',
            defaultValue: '.',
            width: 100,
            columns: [{
                name: "EA",
                title: "Eur.Ame.",
                width: 50,
                formula: function(row) {
                    if (row['ESP_6500'] && row['ESP_6500'].EA) {
                        return row['ESP_6500'].EA;
                    } else {
                        return ".";
                    }
                }
            }, {
                name: "AA",
                title: "Afr.Ame",
                width: 50,
                formula: function(row) {
                    if (row['ESP_6500'] && row['ESP_6500'].AA) {
                        return row['ESP_6500'].AA;
                    } else {
                        return ".";
                    }
                }
            }]

        }, {
            name: 'exac',
            title: 'EXAC',
            width: 50,
            defaultValue: '.',
            formula: function(row) {
                if (row.exac != null && row.exac != '.') {
                    var url = "http://exac.broadinstitute.org/variant/" + row.chromosome + "-" + row.start + "-" + row.reference + "-" + row.alternate;
                    return '<a href="' + url + '" target="_blank">' + row.exac + '</a>'
                } else {
                    return '.';
                }
            }
        }, {
            name: 'phenotype',
            title: 'Phenotype',
            defaultValue: '.',
            width: 600,
            columns: [{
                name: "clinvar",
                title: "Clinvar",
                width: 200,
                formula: function(row) {
                    if (row.phenotype && row.phenotype.clinvar) {
                        return row.phenotype.clinvar;
                    } else {
                        return ".";
                    }
                }
            }, {
                name: "cosmic",
                title: "Cosmic",
                width: 200,
                formula: function(row) {
                    if (row.phenotype && row.phenotype.cosmic) {
                        return row.phenotype.cosmic;
                    } else {
                        return ".";
                    }
                }
            }, {
                name: "gwas",
                title: "GWAS",
                width: 200,
                formula: function(row) {
                    return ".";
                }
            }]
        }],
        studyChanged: function(neo, old) {
            if (neo && neo.id != null) {
                this.$.table.clear();
                this._updateColumns();
            }
        },
        samplesChanged: function(neo, old) {
            this.request = null;
            this.$.table.clear();
            this._updateColumns();
        },
        _updateColumns: function() {

            var sampleColumns = [];
            var colWidth = 80;

            if (this.study.type == "CASE_CONTROL") {
                this._columns.splice(5, 1);
                this.$.table.columns = this._columns;
                return;
            }

            for (var i = 0; i < this.samples.length; i++) {
                var sample = this.samples[i].name;
                var f = "return row.studies[0].samplesData[" + i + "][0]";
                sampleColumns.push({
                    name: sample,
                    title: sample,
                    width: colWidth,
                    formula: new Function("row", f),
                });
            }
            this._columns[5].columns = sampleColumns;
            this._columns[5].width = sampleColumns.length * colWidth;

            this.$.table.columns = this._columns;

            this.$.table.exportParsers.headerParser = function(columns) {
                var headerLine = this.comment;

                for (var i = 0; i < 5; i++) {
                    headerLine += columns[i].title + this.separator;
                }

                for (var i = 0; i < columns[5].columns.length; i++) {
                    var sampleColumn = columns[5].columns[i];
                    headerLine += sampleColumn.title + this.separator;

                }

                for (var i = 6; i < 14; i++) {
                    headerLine += columns[i].title + this.separator;
                }

                for (var i = 0; i < columns[14].columns.length; i++) {
                    var sampleColumn = columns[14].columns[i];
                    headerLine += columns[14].title + " " + sampleColumn.title + this.separator;
                }
                for (var i = 0; i < columns[15].columns.length; i++) {
                    var sampleColumn = columns[15].columns[i];
                    headerLine += columns[15].title + " " + sampleColumn.title + this.separator;
                }
                headerLine += columns[16].title + this.separator;
                for (var i = 0; i < columns[17].columns.length; i++) {
                    var sampleColumn = columns[17].columns[i];
                    headerLine += columns[17].title + " " + sampleColumn.title + this.separator;
                }
                return headerLine;
            };

            var getValue = function(row, key) {
                if (key in row && row[key] != null && row[key] != "") {
                    return row[key];
                } else {
                    return ".";
                }
            }

            this.$.table.exportParsers.dataParser = function(columns, row) {
                var dataLine = "";

                dataLine += row.chromosome + ":" + row.start + this.separator;
                dataLine += row.reference + ">" + row.alternate + this.separator;
                dataLine += getValue(row, "snpId") + this.separator;
                dataLine += getValue(row, "genes") + this.separator;
                dataLine += getValue(row, "type") + this.separator;

                for (var i = 0; row.studies && row.studies[0] && row.studies[0].samplesData && i < row.studies[0].samplesData.length; i++) {
                    var genotype = row.studies[0].samplesData[i];
                    dataLine += genotype + this.separator;
                }

                dataLine += getValue(row, "ct") + this.separator;
                dataLine += getValue(row, "dp") + this.separator;
                dataLine += getValue(row, "sift") + this.separator;
                dataLine += getValue(row, "polyphen") + this.separator;
                dataLine += getValue(row, "cadd") + this.separator;
                dataLine += getValue(row, "phylop") + this.separator;
                dataLine += getValue(row, "phastCons") + this.separator;
                dataLine += getValue(row, "gerp") + this.separator;

                dataLine += getValue(row["1000GENOMES_phase_3"], "ALL") + this.separator;
                dataLine += getValue(row["1000GENOMES_phase_3"], "AMR") + this.separator;
                dataLine += getValue(row["1000GENOMES_phase_3"], "SAS") + this.separator;
                dataLine += getValue(row["1000GENOMES_phase_3"], "EAS") + this.separator;
                dataLine += getValue(row["1000GENOMES_phase_3"], "AFR") + this.separator;
                dataLine += getValue(row["1000GENOMES_phase_3"], "EUR") + this.separator;

                dataLine += getValue(row["ESP_6500"], "EA") + this.separator;
                dataLine += getValue(row["ESP_6500"], "AA") + this.separator;

                dataLine += getValue(row, "exac") + this.separator;

                if (row.phenotype) {
                    dataLine += getValue(row["phenotype"], "clinvar") + this.separator;
                    dataLine += getValue(row["phenotype"], "cosmic") + this.separator;
                    dataLine += getValue(row["phenotype"], "gwas") + this.separator;

                } else {
                    dataLine += "." + this.separator + "." + this.separator + "."
                }

                return dataLine;
            }
        },
        handleRowClick: function(e) {
            console.log(e.detail.row);
        },
        urlChanged: function(neo, old) {
            var me = this;
            if (neo == null || neo == "") {
                return;
            }
            this.request = {
                url: this.url,
                auxTotalCount: -1,
                parse: function(response) {
                    return me._parse(response);
                },
                parseTotal: function(response) {
                    var total = me._parseTotal(response);

                    me.numTotalResults = total;

                    if (this.auxTotalCount == -1) {
                        this.auxTotalCount = total;

                        this.url = this.url.replace("&skipCount=false", "");

                    } else {
                        me.numTotalResults = this.auxTotalCount;
                        total = me.numTotalResults;
                    }

                    me.set('numTotalResults', -1);
                    me.set('numTotalResults', total);
                    return total;
                },
            };
        },
        _parse: function(response) {
            var me = this;
            if (response.response != null) {
                var data = response.response[0].result;
                console.log(data);

                for (var i = 0; i < data.length; i++) {
                    var variant = data[i];
                    if (variant.annotation) {
                        var annotation = variant.annotation;

                        // consequenceTypes
                        if (annotation.consequenceTypes != null) {
                            var ctsAux = {};
                            var siftAux = null;
                            var polyphenAux = null;
                            var genesAux = {};

                            for (var j = 0; j < annotation.consequenceTypes.length; j++) {
                                var ct = annotation.consequenceTypes[j];
                                if (ct.sequenceOntologyTerms) {
                                    for (var k = 0; k < ct.sequenceOntologyTerms.length; k++) {
                                        var so = ct.sequenceOntologyTerms[k].name;
                                        ctsAux[so] = so;
                                    }
                                }

                                // SIFT & Polyphen
                                if (ct.proteinVariantAnnotation && polyphenAux == null && siftAux == null) {
                                    if (ct.proteinVariantAnnotation.substitutionScores && (siftAux == null || polyphenAux == null)) {
                                        if (ct.proteinVariantAnnotation.substitutionScores[0] && ct.proteinVariantAnnotation.substitutionScores[1]) {
                                            var pol = ct.proteinVariantAnnotation.substitutionScores[0].score;
                                            var si = ct.proteinVariantAnnotation.substitutionScores[1].score;
                                            if (eval(pol + this.query.polyphen) && eval(si + this.query.sift)) {
                                                polyphenAux = pol;
                                                siftAux = si;
                                            } else if (eval(pol + this.query.polyphen) && this.query.sift == null) {
                                                polyphenAux = pol;
                                                siftAux = si;
                                            } else if (eval(si + this.query.sift) && this.query.polyphen == null) {
                                                polyphenAux = pol;
                                                siftAux = si;
                                            } else if (this.query.sift == null && this.query.polyphen == null) {
                                                polyphenAux = pol;
                                                siftAux = si;
                                            }
                                        }
                                    }
                                }

                                // genes
                                if (ct.geneName) {
                                    var gn = ct.geneName;
                                    genesAux[gn] = gn;
                                }
                            }

                            var cts = Object.keys(ctsAux);
                            if (cts.length > 0) {
                                variant.ct = cts.join(",");
                            }
                            var genes = Object.keys(genesAux);
                            if (genes.length > 0) {
                                variant.genes = genes.join(",");
                            }

                            variant.sift = siftAux;
                            variant.polyphen = polyphenAux;
                        }

                        // Conservation
                        if (annotation.conservation != null) {
                            var phylopAux = null;
                            var phastConsAux = null;
                            var gerpConsAux = null;
                            for (var j = 0; j < annotation.conservation.length; j++) {
                                var cons = annotation.conservation[j];
                                if (cons.source.toLowerCase() == "phastcons") {
                                    phastConsAux = cons.score.toFixed(3);
                                } else if (cons.source.toLowerCase() == "phylop") {
                                    phylopAux = cons.score.toFixed(3);
                                } else if (cons.source.toLowerCase() == "gerp") {
                                    gerpAux = cons.score.toFixed(3);
                                }
                            }
                            variant.phylop = phylopAux;
                            variant.phastCons = phastConsAux;
                            variant.gerp = gerpAux;

                        }

                        //CADD
                        if (annotation.functionalScore != null) {
                        var caddAux = null;
                        for (var j = 0; j < annotation.functionalScore.length; j++) {
                            var fs = annotation.functionalScore[j];
                            if (fs.source.toLowerCase() == "cadd_raw") {
                                caddAux = fs.score.toFixed(3);
                            }
                        }
                        variant.cadd = caddAux;
                        }

                        // Population Frequencies
                        if (annotation.populationFrequencies != null) {
                            variant['ESP_6500'] = {};
                            // variant['1000GENOMES_phase_1'] = {};
                            variant['1000GENOMES_phase_3'] = {};
                            for (var j = 0; j < annotation.populationFrequencies.length; j++) {
                                var freq = annotation.populationFrequencies[j];
                                if (freq.study == "ESP6500") {
                                    if (freq.population == "EA") {
                                        variant['ESP_6500'].EA = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    } else if (freq.population == "AA") {
                                        variant['ESP_6500'].AA = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    }

                                } else if (freq.study == "1kG_phase3") {
                                    if (freq.population == "ALL") {
                                        variant['1000GENOMES_phase_3'].ALL = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    } else if (freq.population == "SAS") {
                                        variant['1000GENOMES_phase_3'].SAS = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    } else if (freq.population == "EAS") {
                                        variant['1000GENOMES_phase_3'].EAS = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    } else if (freq.population == "AMR") {
                                        variant['1000GENOMES_phase_3'].AMR = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    } else if (freq.population == "AFR") {
                                        variant['1000GENOMES_phase_3'].AFR = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    } else if (freq.population == "EUR") {
                                        variant['1000GENOMES_phase_3'].EUR = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    }
                                } else if (freq.study == "EXAC") {
                                    if (freq.population == "ALL") {
                                        variant.exac = (Math.min(freq.refAlleleFreq, freq.altAlleleFreq)).toFixed(3);
                                    }
                                }
                            }
                        }

                        // Phenotype
                        if (annotation.variantTraitAssociation != null) {
                            var phenClinvarAux = {};
                            var phenCosmicAux = {};
                            var vta = annotation.variantTraitAssociation;
                            // Clinvar
                            if (vta.clinvar != null) {
                                for (var k = 0; k < vta.clinvar.length; k++) {
                                    var phen = vta.clinvar[k].traits;
                                    for (var l = 0; l < phen.length; l++) {
                                        var p = phen[l].toLowerCase();
                                        if (p != "not specified" && p != "allhighlypenetrant") {
                                            phenClinvarAux[p] = p;
                                        }
                                    }
                                }
                            }
                            // Cosmic
                            if (vta.cosmic != null) {
                                for (var k = 0; k < vta.cosmic.length; k++) {
                                    var phen = vta.cosmic[0].primaryHistology.toLowerCase();
                                    phenCosmicAux[phen] = phen;
                                }
                            }

                            // GWAS

                            variant.phenotype = {};
                            var phenCosmic = Object.keys(phenCosmicAux);
                            if (phenCosmic.length > 0) {
                                variant.phenotype.cosmic = phenCosmic.join(",");
                            }
                            var phenClinvar = Object.keys(phenClinvarAux);
                            if (phenClinvar.length > 0) {
                                variant.phenotype.clinvar = phenClinvar.join(",");
                            }
                        }

                        // SNPid
                        if (annotation.xrefs != null) {
                            var snpIdAux = null;
                            for (var j = 0; j < annotation.xrefs.length; j++) {
                                if (annotation.xrefs[j].source == "dbSNP") {
                                    snpIdAux = annotation.xrefs[j].id;
                                }
                            }
                            if (snpIdAux != null) {
                                variant.snpId = snpIdAux;
                            }
                        }

                    }

                    // Type
                    if (variant.type) {
                        var typeAux = variant.type;
                        variant.type = typeAux;
                    }

                    //DP
                    if (variant.studies) {
                        if (variant.studies[0].files) {
                            if (variant.studies[0].files[0].attributes) {
                                var dpAux = variant.studies[0].files[0].attributes["DP"];
                                variant.dp = dpAux;
                            }
                        }
                    }

                }

            } else {
                data = [];
            }
            return data;
        },
        _parseTotal: function(response) {
            if (response.response != null) {
                var total = response.response[0].numTotalResults;
            } else {
                total = 0;
            }
            return total;
        },
        // _getAdditionalInfo: function(variant) {
        //     var me = this;
        //     var variant = variant.chromosome + ":" + variant.start + ":" + variant.reference + ":" + variant.alternate;
        //     var caddAux = null;
        //     CellBaseManager.get({
        //         species: 'hsapiens',
        //         category: 'genomic',
        //         subCategory: 'variant',
        //         resource: 'annotation',
        //         query: variant,
        //         async: false,
        //         success: function(response) {
        //             if (response.response[0].result[0]) {
        //                 var row = response.response[0].result[0];
        //             }
        //         }
        //     });
        //     return caddAux;
        // }
    });
</script>
<dom-module id="stv-variant-effect" assetpath="bower_components/stevia-elements/src/variant/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        stv-table {
            box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.2);
            overflow-y: hidden;
        }
        
        stv-table::shadow #list {
            min-height: 200px;
        }

        stv-table::shadow {
            font-size: 11px;
        }

        stv-table::shadow .table-row {
            height: 25px;
        }

        stv-table::shadow .table-header-field > .name.stv-table {
            padding: 4px 0;
        }
    </style>
    <template>
        <stv-table id="table" hidden$="{{isEmpty}}" on-rowclick="handleRowClick" enable-export="" enable-paging=""></stv-table>
        <div hidden$="{{!isEmpty}}" style="padding:20px 50px;">
            No effect found.
        </div>
    </template>
</dom-module>

<script>
    Polymer({
        is: 'stv-variant-effect',
        properties: {
            row: {
                type: Object,
                observer: 'rowChanged'
            },
            isEmpty: {
                value: false,
                type: Boolean
            }
        },
        ready: function() {
            this.$.table.columns = this._columns;
        },
        _columns: [{
                name: "geneName",
                title: "Gene Name",
                defaultValue: '.'
            }, {
                name: "ensemblGeneId",
                title: "Ensembl Gene Id",
                cellTemplate: "ensemblGeneIdTemplate",
                width: 150,
                defaultValue: '.'
            }, {
                name: "ensemblTranscriptId",
                title: "Ensembl Transcript Id",
                cellTemplate: 'ensemblTranscriptIdTemplate',
                width: 150,
                defaultValue: '.'
            }, {
                name: "so",
                title: "Conseq. type",
                formula: function(row) {
                    var aux = {};
                    if (row.soName && row.soAccession) {

                        aux.soName = row.soName;
                        aux.soAccession = row.soAccession;
                    }
                    return aux.soName;
                },
                width: 300
            },
            {
                name: "codon",
                title: "Codon",
                width: 60,
                defaultValue: '.'
            }, {
                name: "strand",
                title: "Strand",
                defaultValue: '.'
            }, {
                name: "biotype",
                title: "Biotype",
                defaultValue: '.'
            }, {
                name: "cdnaPosition",
                title: "cDna Position",
                width: 80,
                defaultValue: '.'
            }, {
                name: "cdsPosition",
                title: "cds Position",
                width: 80,
                defaultValue: '.'
            }, {
                name: "aaPosition",
                title: "AA Position",
                width: 80,
                formula: function(row) {
                    try {
                        var pva = row.proteinVariantAnnotation;
                        var res = (pva.position) ? pva.position : ".";
                        return res;
                    } catch (e) {
                        return ".";
                    }
                }
            }, {
                name: "aaChange",
                title: "AA Change",
                width: 80,
                formula: function(row) {
                    try {
                        var pva = row.proteinVariantAnnotation;
                        var res = pva.reference + " > " + pva.alternate;
                        return res;
                    } catch (e) {
                        return ".";
                    }
                }

            }, {
                name: "sift",
                title: "Sift",
                formula: function(row) {
                    var pva = row.proteinVariantAnnotation;
                    if (pva != null && Object.keys(pva).length > 0) {
                        var pss = pva.substitutionScores;
                        if (pss != null && pss.length > 0) {
                            for (var i = 0; i < pss.length; i++) {
                                var elem = pss[i];
                                if (elem.source.toLowerCase() == "sift") {
                                    return elem.score;
                                }
                            }
                        }
                    }
                    return ".";
                },
                width: 80
            }, {
                name: "polyphen",
                title: "Polyphen",
                formula: function(row) {
                    var pva = row.proteinVariantAnnotation;
                    if (pva != null && Object.keys(pva).length > 0) {
                        var pss = pva.substitutionScores;
                        if (pss != null && pss.length > 0) {
                            for (var i = 0; i < pss.length; i++) {
                                var elem = pss[i];
                                if (elem.source.toLowerCase() == "polyphen") {
                                    return elem.score;
                                }
                            }
                        }
                    }

                    return ".";
                },
                width: 100
            }
        ],

        rowChanged: function(neo, old) {
            var me = this;
            this.$.table.currentPage = 1;
            if (neo) {
                var variant = neo.chromosome + ":" + neo.start + ":" + neo.reference + ":" + neo.alternate;
                CellBaseManager.get({
                    species: 'hsapiens',
                    category: 'genomic',
                    subCategory: 'variant',
                    resource: 'annotation',
                    query: variant,
                    //                    query: "19:45411941:T:C",
                    async: false,
                    success: function(response) {
                        try {
                            me.$.table.data = me.parseFunction(response.response[0].result[0].consequenceTypes);
                            me.isEmpty = (me.$.table.data.length > 0) ? false : true;
                        } catch (e) {
                            me.$.table.data = [];
                            me.isEmpty = true;
                        }
                    }
                });
            }
        },
        parseFunction: function(data) {
            var res = [];

            for (var i = 0; i < data.length; i++) {
                var elem = data[i];

                for (var j = 0; j < elem.sequenceOntologyTerms.length; j++) {
                    var soTerm = elem.sequenceOntologyTerms[j];
                    var aux = stv.utils.clone(elem);
                    aux.soName = soTerm.name;
                    aux.soAccession = soTerm.accession;

                    res.push(aux);
                }
            }
            return res;
        }
    });
</script>
<dom-module id="stv-variant-frequencies" assetpath="bower_components/stevia-elements/src/variant/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        stv-table {
            box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.2);
            overflow-y: hidden;
        }

        stv-table::shadow #list {
            min-height: 200px;
        }

        stv-table::shadow {
            font-size: 11px;
        }

        stv-table::shadow .table-row {
            height: 25px;
        }

        stv-table::shadow .table-header-field > .name.stv-table {
            padding: 4px 0;
        }

        #mafChart {
            border: 1px solid rgba(125, 125, 125, 0.4);
            box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.2);
            margin: 0 auto;
            overflow-x: auto;
            height: 350px;
        }

    </style>
    <template>
        <div hidden$="{{isEmpty}}" class="horizontal layout wrap center-justified">
            <stv-table id="table" enable-export="" enable-paging=""></stv-table>
            <div id="mafChart" hidden=""></div>
        </div>
        <div hidden$="{{!isEmpty}}" style="padding:20px 50px;">
            No frequencies found.
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'stv-variant-frequencies',
        properties: {
            row: {
                type: Object,
                observer: 'rowChanged'
            },
            isEmpty: {
                value: false,
                type: Boolean
            }
        },
        ready: function () {
            this.$.table.columns = this._columns;
        },
        _columns: [{
            name: "study",
            title: "Study",
            width: 150
        }, {
            name: "population",
            title: "Population",
            width: 150
        }, {
            name: "refAllele",
            title: "Ref. Allele",
            width: 50
        }, {
            name: "altAllele",
            title: "Alt. Allele",
            width: 50
        }, {
            name: "refAlleleFreq",
            title: "Ref. Allele Freq.",
            cellTemplate: 'alleleFreqCT',
            formula: function (row) {
                var val = ".";
                if (row.refAlleleFreq != null) {
                    val = row.refAlleleFreq.toFixed(3);
                }
                return val;
            },
            width: 70
        }, {
            name: "altAlleleFreq",
            title: "Alt. Allele Freq.",
            formula: function (row) {
                var val = ".";
                if (row.altAlleleFreq != null) {
                    val = row.altAlleleFreq.toFixed(3);
                }
                return val;
            },
            width: 70
        }, {
            name: "maf",
            title: "MAF",
            formula: function (row) {
                return Math.min(row.refAlleleFreq, row.altAlleleFreq).toFixed(3);
            },
            width: 70
        }],
        rowChanged: function (neo, old) {
            var me = this;

            this.$.table.currentPage = 1;

            if (neo) {
                var variant = neo.chromosome + ":" + neo.start + ":" + neo.reference + ":" + neo.alternate;
                CellBaseManager.get({
                    species: 'hsapiens',
                    category: 'genomic',
                    subCategory: 'variant',
                    resource: 'annotation',
                    query: variant,
                    //                    query: "19:45411941:T:C",
                    async: false,
                    success: function (response) {
                        try {
                            me.$.table.data = response.response[0].result[0].populationFrequencies;
                            me.isEmpty = (me.$.table.data.length <= 0);
                        } catch (e) {
                            me.$.table.data = [];
                            me.isEmpty = true;
                        }
                    }
                });

                var data = [];
                var cat = [];
                for (var i = 0; i < me.$.table.data.length; i++) {
                    var elem = me.$.table.data[i];
                    var maf = parseFloat(Math.min(elem.refAlleleFreq, elem.altAlleleFreq).toFixed(3));
                    data.push(maf);
                    cat.push(elem.study + "/" + elem.population);

                }

                var polarChart = new Highcharts.Chart({
                    chart: {
                        polar: true,
                        renderTo: this.$.mafChart
                    },
                    credits: {
                        enabled: false
                    },
                    legend: {
                        enabled: false
                    },
                    title: {
                        text: "Minor Allele Frequency",
                        x: -80
                    },
                    xAxis: {
                        categories: cat,
                        tickmarkPlacement: 'on',
                        lineWidth: 1
                    },

                    yAxis: {
                        gridLineInterpolation: 'polygon',
                        lineWidth: 0,
                        max: 0.5
                    },

                    series: [{
                        type: 'area',
                        name: "MAF",
                        data: data,
                        pointPlacement: 'on'
                    }]

                });
                this.$.mafChart.hidden = false;
            }
        }
    });
</script>
<dom-module id="stv-variant-phenotype" assetpath="bower_components/stevia-elements/src/variant/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        stv-table {
            box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.2);
            overflow-y: hidden;
        }

        stv-table::shadow #list {
            min-height: 200px;
        }

        stv-table::shadow {
            font-size: 11px;
        }

        stv-table::shadow .table-row {
            height: 25px;
        }

        stv-table::shadow .table-header-field > .name.stv-table {
            padding: 4px 0;
        }
    </style>
    <template>
        <label class="stv">Clinvar:</label>
        <stv-table id="clinvarTable" hidden$="{{isClinvarEmpty}}" enable-export="" enable-resize=""></stv-table>
        <div hidden$="{{!isClinvarEmpty}}" style="padding:20px 50px;">
            No results found.
        </div>
        <br>
        <label class="stv">Cosmic:</label>
        <stv-table id="cosmicTable" hidden$="{{isCosmicEmpty}}" enable-export=""></stv-table>
        <div hidden$="{{!isCosmicEmpty}}" style="padding:20px 50px;">
            No results found.
        </div>
        <br>
        <label class="stv">GWAS:</label>
        <stv-table id="gwasTable" hidden$="{{isGwasEmpty}}" enable-export=""></stv-table>
        <div hidden$="{{!isGwasEmpty}}" style="padding:20px 50px;">
            No results found.
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'stv-variant-phenotype',
        properties: {
            row: {
                type: Object,
                observer: 'rowChanged'
            },
            isCosmicEmpty: {
                value: false,
                type: Boolean
            },
            isGwasEmpty: {
                value: false,
                type: Boolean
            },
            isClinvarEmpty: {
                value: false,
                type: Boolean
            }
        },
        ready: function () {
            this.$.cosmicTable.columns = this._cosmicColumns;
            this.$.gwasTable.columns = this._gwasColumns;
            this.$.clinvarTable.columns = this._clinvarColumns;
        },
        _cosmicColumns: [{
            name: "geneName",
            title: "Gene name"
        }, {
            name: "histologySubtype",
            title: "Histology subtype"
        }, {
            name: "mutationID",
            title: "Mutation ID"
        }, {
            name: "mutationSomaticStatus",
            title: "Mutation somatic status",
            width: 300
        }, {
            name: "primaryHistology",
            title: "Primary histology"
        }, {
            name: "primarySite",
            title: "Primary site"
        }, {
            name: "sampleSource",
            title: "Sample source"
        }, {
            name: "siteSubtype",
            title: "Site subtype"
        }, {
            name: "tumourOrigin",
            title: "Tumour origin"
        }],
        _gwasColumns: [{
            name: "reportedGenes",
            title: "R eported genes"
        }, {
            name: "riskAlleleFrequency",
            title: "Risk allele frequency",
        }, {
            name: "snpIdCurrent",
            title: "snp ID current"
        }, {
            name: "traits",
            title: "Traits",
            width: 300
        }],
        _clinvarColumns: [{
            name: "accession",
            title: "Accession"
        }, {
            name: "clinicalSignificance",
            title: "Clinical significance",
            width: 100
        }, {
            name: "geneNames",
            title: "Gene name"
        }, {
            name: "reviewStatus",
            title: "Review status",
            width: 300
        }, {
            name: "traits",
            title: "Traits",
            width: 300
        }],
        rowChanged: function (neo, old) {
            var me = this;

            this.$.cosmicTable.currentPage = 1;
            this.$.gwasTable.currentPage = 1;
            this.$.clinvarTable.currentPage = 1;

            if (neo) {
                var variant = neo.chromosome + ":" + neo.start + ":" + neo.reference + ":" + neo.alternate;
                CellBaseManager.get({
//                            version: 'v3',
                    species: 'hsapiens',
                    category: 'genomic',
                    subCategory: 'variant',
                    resource: 'annotation',
                    query: variant,
//                    query:"19:45411941:T:C",
                    async: false,
                    success: function (response) {
                        try {
                            var dataCosmic = [];
                            var dataGwas = [];
                            var dataClinvar = [];

                            var clinicalData = response.response[0].result[0].variantTraitAssociation;

                            if (!clinicalData) {

                                me.$.cosmicTable.data = [];
                                me.$.gwasTable.data = [];
                                me.$.clinvarTable.data = [];

                                me.isCosmicEmpty = true;
                                me.isGwasEmpty = true;
                                me.isClinvarEmpty = true;
                                return;
                            }

                            if (clinicalData.cosmic != null) {
                                for (var i = 0; i < clinicalData.cosmic.length; i++) {
                                    var cosmic = clinicalData.cosmic[i];
                                    dataCosmic.push(cosmic);
                                }
                            }
                            if (clinicalData.gwas != null) {
                                for (var i = 0; i < clinicalData.gwas.length; i++) {
                                    var gwas = clinicalData.gwas[i];
                                    dataGwas.push(gwas);
                                }
                            }
                            if (clinicalData.clinvar != null) {
                                for (var i = 0; i < clinicalData.clinvar.length; i++) {
                                    var clinvar = clinicalData.clinvar[i];
                                    dataClinvar.push(clinvar);
                                }
                            }
                            me.$.cosmicTable.data = dataCosmic;
                            me.$.gwasTable.data = dataGwas;
                            me.$.clinvarTable.data = dataClinvar;

                            me.isCosmicEmpty = (me.$.cosmicTable.data.length > 0) ? false : true;
                            me.isGwasEmpty = (me.$.gwasTable.data.length > 0) ? false : true;
                            me.isClinvarEmpty = (me.$.clinvarTable.data.length > 0) ? false : true;

                        } catch (e) {
                            console.log(e);
                            me.$.cosmicTable.data = [];
                            me.$.gwasTable.data = [];
                            me.$.clinvarTable.data = [];

                            me.isCosmicEmpty = true;
                            me.isGwasEmpty = true;
                            me.isClinvarEmpty = true;
                        }
                    }
                });
            }
        }
    });
</script>
<dom-module id="stv-variant-overview" assetpath="bower_components/stevia-elements/src/variant/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        #legend {
            margin: 0 auto;
            width: 50%;
        }
    </style>
    <template>
        <div class="horizontal layout">
            <div id="overview" on-rowclick="handleRowClick">
                <label id="selectMSG">Please, select a row for see variant data.</label>
            </div>
            <div id="legend">
                <i class="fa fa-lightbulb-o" aria-hidden="true" style="font-size:16px;color:#32b0cd"></i>
                <br>- All values are normalized between zero and one.
                <br>- Values closest to one are deleterious and closest to zero are benign.
                <br>- Polyphen and Sift are opposed, but in this case, Sift has been calculated as 1 - Sift.
            </div>
        </div>
    </template>
    <script>
        Polymer({
            is: 'stv-variant-overview',
            properties: {
                row: {
                    type: Object,
                    observer: 'rowChanged'
                },
                params: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                }
            },
            rowChanged: function(neo, old) {
                if (neo) {
                    this.params = [];
                    var variant = neo.chromosome + ":" + neo.start + ":" + neo.reference + ":" + neo.alternate;
                    var me = this;
                    CellBaseManager.get({
                        species: 'hsapiens',
                        category: 'genomic',
                        subCategory: 'variant',
                        resource: 'annotation',
                        query: variant,
                        async: false,
                        success: function(response) {
                            if (response.response[0].result[0]) {
                                var row = response.response[0].result[0];
                                if (row.functionalScore) {
                                    me._getScores(row.functionalScore);
                                }
                                if (row.conservation) {
                                    me._getScores(row.conservation);
                                }
                                if (row.consequenceTypes) {
                                    var ct = row.consequenceTypes;
                                    var n = 0;
                                    for (var i = 0; i < ct.length; i++) {
                                        if (ct[i].proteinVariantAnnotation && ct[i].proteinVariantAnnotation.substitutionScores) {
                                            if (ct[i].proteinVariantAnnotation.substitutionScores.length == 2 && n == 0) {
                                                n++;
                                                me._getScores(ct[i].proteinVariantAnnotation.substitutionScores);
                                            }
                                        }
                                    }

                                }
                                me._createPolarChart(row);
                            }
                        }
                    });
                }
            },
            _createPolarChart: function(row) {
                this.$.selectMSG.hidden = true;
                var me = this;
                var variant = row.chromosome + ":" + row.start + ":" + row.reference + ":" + row.alternate;
                var categories = [];
                var data = [];
                var color = '#76afd5';
                var sift = null;
                var polyphen = null;
                for (var i = 0; i < this.params.length; i++) {
                    categories.push(this.params[i].source);
                    if (this.params[i].source == "sift") {
                        sift = this.params[i].score;
                    }
                    if (this.params[i].source == "polyphen") {
                        polyphen = this.params[i].score;
                        data.push(this._parseFloat(this.params[i].score));
                    } else {
                        data.push(1 - this._parseFloat(this.params[i].score));
                    }
                }
                if (sift != null && polyphen != null) {
                    color = '#8ccd8c';
                    if (sift <= 0.05 && polyphen >= 0.95) {
                        color = '#f47070';
                    } else if (sift <= 0.05 || polyphen >= 0.95) {
                        color = '#f59f67';
                    }
                }

                var chart = new Highcharts.Chart({
                    chart: {
                        polar: true,
                        type: 'line',
                        renderTo: me.$.overview,
                        width: 510,
                        height: 300

                    },
                    credits: {
                        enabled: false
                    },
                    legend: {
                        enabled: false
                    },
                    title: {
                        text: variant,
                        x: -80
                    },
                    xAxis: {
                        categories: categories,
                        tickmarkPlacement: 'on',
                        lineWidth: 1
                    },

                    yAxis: {
                        gridLineInterpolation: 'polygon',
                        lineWidth: 0,
                        min: 0,
                        max: 1
                    },

                    series: [{
                        type: 'area',
                        name: variant,
                        data: data,
                        color: color,
                        pointPlacement: 'on'
                    }]

                });
            },
            _parseFloat: function(data) {
                var aux = parseFloat(data);
                aux = isNaN(aux) ? null : aux;
                return aux;
            },
            _getScores: function(data) {
                for (var i = 0; i < data.length; i++) {
                    var elem = data[i];
                    var aux = Utils.clone(elem);
                    aux.score = Math.abs(elem.score);
                    if (aux.score > 1) {
                        aux.score = 1 / aux.score;
                    }
                    aux.source = elem.source;

                    this.params.push(aux);
                }
            }
        })
    </script>
</dom-module>
<dom-module id="stv-variant-hpo" assetpath="bower_components/stevia-elements/src/variant/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        stv-table {
            box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.2);
            overflow-y: hidden;
        }

        stv-table::shadow #list {
            min-height: 200px;
        }

        stv-table::shadow #list {
            min-height: 200px;
        }

        stv-table::shadow {
            font-size: 11px;
        }

        stv-table::shadow .table-row {
            height: 25px;
        }

        stv-table::shadow .table-header-field > .name.stv-table {
            padding: 4px 0;
        }
    </style>
    <template>
        <stv-table id="table" hidden$="{{isEmpty}}" on-rowclick="handleRowClick" enable-export="" enable-paging=""></stv-table>
        <div hidden$="{{!isEmpty}}" style="padding:20px 50px;">
            No HPO found.
        </div>
    </template>
</dom-module>

<script>
    Polymer({
        is: 'stv-variant-hpo',
        properties: {
            row: {
                type: Object,
                observer: 'rowChanged'
            },
            isEmpty: {
                value: false,
                type: Boolean
            }
        },
        ready: function() {
            this.$.table.columns = this._columns;
        },
        _columns: [{
            name: "id",
            title: "OMIM id",
            width: 150,
            defaultValue: '.'
        }, {
            name: "name",
            title: "Name",
            width: 300,
            defaultValue: '.'
        }, {
            name: "hpo",
            title: "HPO id",
            width: 150,
            defaultValue: '.'
        }],

        rowChanged: function(neo, old) {
            var me = this;
            this.$.table.currentPage = 1;
            if (neo) {
                var variant = neo.chromosome + ":" + neo.start + ":" + neo.reference + ":" + neo.alternate;
                CellBaseManager.get({
                    species: 'hsapiens',
                    category: 'genomic',
                    subCategory: 'variant',
                    resource: 'annotation',
                    query: variant,
                    //                    query: "19:45411941:T:C",
                    async: false,
                    success: function(response) {
                        try {
                            me.$.table.data = me.parseFunction(response.response[0].result[0].geneTraitAssociation);
                            me.isEmpty = (me.$.table.data.length > 0) ? false : true;
                        } catch (e) {
                            me.$.table.data = [];
                            me.isEmpty = true;
                        }
                    }
                });
            }
        },
        parseFunction: function(data) {
            var res = [];

            for (var i = 0; i < data.length; i++) {
                if (data[i].source == "hpo") {
                    res.push(data[i]);
                }
            }
            return res;
        }
    });
</script>
<dom-module id="bier-variant-browser" assetpath="src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            height: 100%;
            width: 100%;
            background-color: #fff;
            overflow-y: scroll;
        }

        .title {
            font-size: 20px;
            padding: 10px 0 5px 0;
            border-bottom: thin solid #edebe3;
            margin-bottom: 10px;
            margin-left: 12px;
            color: #204854;
        }

        #right {
            margin-left: 5px;
            margin-right: 5px;
            width: calc( 100% - 275px);
        }

        bier-variant-grid,
        jso-genome-viewer-element,
        bier-variant-effect {
            box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.2);
        }

        .tabs {
            margin: 5px 15px 0 0;
            padding: 0 2px;
            border-bottom: 1px solid transparent;
            color: #666;
            cursor: pointer;
        }

        .tabs:hover {
            border-bottom: 1px solid #8ba7a7;
            color: #8ba7a7;
            font-weight: bold;
        }

        .tabs[selected] {
            border-bottom: 2px solid #225e71;
            color: #222;
            font-size: 13px;
        }
    </style>
    <template>
        <div class="title">
            <span>Study:</span>
            <span>{{study.name}}</span>
        </div>
        <div class="horizontal layout">
            <bier-variant-filter id="variantFilter" url="{{url}}" study="{{study}}" samples="{{samples}}" query="{{query}}" num-total-results="{{numTotalResults}}" on-clearform="handleClearForm"></bier-variant-filter>
            <div id="right">
                <bier-variant-grid id="variantGrid" enable-export="" url="{{url}}" query="{{query}}" study="{{study}}" samples="{{samples}}" num-total-results="{{numTotalResults}}" on-rowclick="handleRowClick"></bier-variant-grid>

                <div class="title" style="margin-left:0;font-size:18px;">
                    Variant Data
                </div>
                <div id="menu" class="horizontal layout">
                    <div class="tabs" on-click="handleMenuClick" data-option="overview">Overview</div>
                    <div class="tabs" on-click="handleMenuClick" data-option="gv">Genomic context</div>
                    <div class="tabs" on-click="handleMenuClick" data-option="frequency">Pop. Frequencies</div>
                    <div class="tabs" on-click="handleMenuClick" data-option="phenotype">Phenotype</div>
                    <div class="tabs" on-click="handleMenuClick" data-option="effect">Effect</div>
                    <div class="tabs" on-click="handleMenuClick" data-option="hpo">HPO</div>
                </div>

                <br>

                <div id="tools">
                    <stv-variant-overview id="overview"></stv-variant-overview>
                    <jso-genome-viewer-element id="gv" hidden=""></jso-genome-viewer-element>
                    <stv-variant-frequencies id="frequency" hidden=""></stv-variant-frequencies>
                    <stv-variant-phenotype id="phenotype" hidden=""></stv-variant-phenotype>
                    <stv-variant-effect id="effect" hidden=""></stv-variant-effect>
                    <stv-variant-hpo id="hpo" hidden=""></stv-variant-hpo>
                </div>
                <br>
            </div>
        </div>
    </template>
    <script>
        Polymer({
            is: 'bier-variant-browser',
            properties: {
                url: {
                    type: String,
                    notify: true,
                    value: ''
                },
                file: {
                    type: Object
                },
                study: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },
                samples: {
                    type: Array,
                    notify: true,
                    value: function() {
                        return [];
                    }
                },
                selectedMenuTool: {
                    type: Object,
                    observer: 'selectedMenuChanged'
                },
                enableExport: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                },
                query: {
                    type: Object,
                    notify: true,
                    value: function() {
                        return {};
                    }
                }
            },
            created: function() {
                var observer = new MutationObserver(function(mutations) {
                    if (this.hasAttribute('hidden')) {
                        this.$.gv.setAttribute('hidden', '');
                    } else {
                        this.$.gv.removeAttribute('hidden');
                    }
                }.bind(this));
                observer.observe(this, {
                    attributes: true,
                    attributeFilter: ['hidden']
                });
            },
            ready: function() {
                this.selectedMenuTool = this.$.menu.querySelector('div');

                this.async(function() {
                    this.$.gv.createGenomeViewer();
                    var seq = this.$.gv.genomeViewer.trackListPanel.tracks[2];
                    this.$.gv.genomeViewer.draw();

                    this.genomeViewer = this.$.gv.genomeViewer;
                });
            },
            selectedMenuChanged: function(neo, old) {
                if (old) {
                    old.removeAttribute('selected');
                    this.$[old.dataset.option].setAttribute('hidden', '');
                }
                if (neo) {
                    neo.setAttribute('selected', '');
                    this.$[neo.dataset.option].removeAttribute('hidden');
                }
            },
            handleMenuClick: function(e) {
                this.selectedMenuTool = e.currentTarget;
            },
            handleRowClick: function(e) {
                this.$.gv.genomeViewer.setRegion(e.detail.row);
                this.$.overview.row = e.detail.row;
                this.$.frequency.row = e.detail.row;
                this.$.phenotype.row = e.detail.row;
                this.$.effect.row = e.detail.row;
                this.$.hpo.row = e.detail.row;
            },
            handleDataGridSelected: function(oldValue, newValue) {
                var me = this;
                var reg = newValue.chromosome + ":" + newValue.start + "-" + newValue.end;
                var region = new Region(reg);

                // update Effect
                var variant = newValue.chromosome + ":" + newValue.start + ":" + newValue.reference + ":" + newValue.alternate;
                this.variantEffect = variant;
                // this.$.jsoVariantStats.stats = newValue.sourceEntries[me.studyId + "_" + me.fileId].stats;

                this.$.gvEl.genomeViewer.setRegion(region);
            },

        })
    </script>
</dom-module>
<dom-module id="biertool-home" assetpath="src/">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            box-sizing: border-box;
            font-size: 20px;
            /*font-weight: 300;*/
            padding-top: 2vh;
            color: #768187;
        }

        #main {
            margin: 0px auto 0px auto;
            max-width: 785px;
            padding: 2vh;
        }

        #image {
            width: 200px;
            margin: 10px;
        }

        #button {
            font-weight: 400;
            height: auto;
            margin: 20px;
            padding: 20px 30px;
            font-size: 26px;
            border-radius: 5px;
            background-color: var(--dark-button-color);
        }

        #button:hover {
            background-color: var(--light-button-color);
        }

        .application {
            font-size: 70px;
        }

        .description {
            font-size: 24px;
            line-height: 40px;
            padding-top: 30px;
            padding-bottom: 10px;
            text-transform: uppercase;
            text-align: center;
        }

        @media (max-width: 1100px) {
            #image {
                width: 230px;
            }
        }

        @media (max-width: 800px) {
            #image {
                width: 150px;
            }
            .megatitle {
                font-size: 50px;
            }
        }

        .paragraph {
            text-align: justify;
            padding: 10px 0;
        }

        .paragraph2 {
            font-size: 14px;
            padding: 0 0 10px 0;
        }

        .title {
            font-size: 30px;
            padding-top: 30px;
            padding-bottom: 10px;
        }

        .title2 {
            padding-top: 20px;
            padding-bottom: 10px;
        }

        .b {
            font-weight: 400;
        }

        a,
        a:visited {
            text-decoration: none;
        }

        .tutorialBut {
            text-align: center;
            background-color: var(--dark-button-color);
            color: var(--light-primary-color);
            font-weight: 400;
            height: auto;
            margin: 20px;
            padding: 20px 30px;
            font-size: 20px;
            border-radius: 5px;
        }

        .tutorialBut:hover {
            background-color: var(--accent-color);
        }
    </style>
    <template>

        <div id="main">
            <div class="horizontal layout center-justified center">
                <div>
                    <img id="image" src="images/bier-text.svg">
                </div>
                <div class="vertical layout center">
                    <div class="application vertical layout center">
                        BIER Tool
                    </div>
                    <br>
                    <div class="stv-btn stv-btn-shdw tutorialBut">
                        <a href="https://github.com/babelomics/bierapp/wiki/tutorial" target="_blank">
                            <i class="fa fa-compass"></i> &nbsp; Getting Started
                        </a>
                    </div>
                </div>
            </div>

            <div class="title">Overview</div>
            <div class="paragraph">
                Welcome to the gene/variant prioritization tool of the BIER (the Team of BioInformatic for Rare Diseases). This interactive tool allows finding genes affected by deleterious variants that segregate along family pedigrees, case-controls or sporadic samples.
            </div>

            <div class="title2">Supported by</div>
            <div class="paragraph">
                <img style="margin:3px;height:35px;" src="images/logobier.jpg">
                <img style="margin:3px;height:35px;" src="images/logo_ciberer.jpg">
                <img style="margin:3px;height:35px;" src="images/logo_cipf.png">
                <img style="margin:3px;height:35px;" src="images/logoBabelomics.svg">
                <img style="margin:3px;height:35px;" src="images/LOGO_Micinn_Isciii.jpg">
                <img style="margin:3px;height:35px;" src="images/logo_inb.png">
                <img style="margin:3px;height:35px;" src="images/logo_elixir.jpg">
            </div>

            <div class="title2">Note:</div>
            <div class="paragraph2">
                <span>{{versionNav}}</span>
                <stv-tooltip type="{{tooltipType}}">{{versionMsg}}</stv-tooltip>
                <br>BierTool web application makes an intensive use of the HTML5 standard and other cutting-edge web technologies such as Web Components, so only modern web browsers are fully supported, these include Chrome 36+, Firefox 32+, IE 10+, Safari 7+ and Opera 24+.
            </div>
        </div>


    </template>
    <script>
        Polymer({
            is: 'biertool-home',
            handleStart: function() {
                this.fire('start');
            },
            annonymousLogin: function() {
                this.fire('annonymous');
            },
            ready: function() {
                this.versionNav = "You are currently using ";
                this.tooltipType = "info";
                this.versionMsg = "Your browser version is suitable for the proper functioning of the tool."
                var nav = navigator.userAgent.toLowerCase();
                if (/opr\/(\d+\.?)+/.test(nav)) {
                    var aux = /opr\/((\d+\.?)+)/.exec(nav);
                    if (aux[1].split(".")[0] < 32) {
                        this.tooltipType = "warn";
                        this.versionMsg = "Your browser version is outdated. The tool may not work properly."
                    } else if (aux[1].split(".")[0] < 24) {
                        this.tooltipType = "error";
                        this.versionMsg = "Your browser version is deprecated. The tool will not work correctly."
                    }
                    this.versionNav += aux[0].replace("opr", "Opera");
                } else if (/firefox\/(\d+\.?)+/.test(nav)) {
                    var aux = /firefox\/((\d+\.?)+)/.exec(nav);
                    if (aux[1].split(".")[0] < 45) {
                        this.tooltipType = "warn";
                        this.versionMsg = "Your browser version is outdated. The tool may not work properly."
                    } else if (aux[1].split(".")[0] < 32) {
                        this.tooltipType = "error";
                        this.versionMsg = "Your browser version is deprecated. The tool will not work correctly."
                    }
                    this.versionNav += aux[0];
                } else if (/msie (\d+\.?)+/.test(nav) || /rv\:(\d+\.?)+/.test(nav)) {
                    var aux = /msie ((\d+\.?)+)/.exec(nav);
                    if (aux == null) {
                        aux = /rv\:((\d+\.?)+)/.exec(nav);
                        this.versionNav += aux[0].replace("rv:", "Internet Explorer");
                    } else {
                        this.versionNav += aux[0].replace("msie", "Internet Explorer");
                    }
                    if (aux[1].split(".")[0] < 11) {
                        this.tooltipType = "warn";
                        this.versionMsg = "Your browser version is outdated. The tool may not work properly."
                    } else if (aux[1].split(".")[0] < 10) {
                        this.tooltipType = "error";
                        this.versionMsg = "Your browser version is deprecated. The tool will not work correctly."
                    }
                } else if (/edge\/(\d+\.?)+/.test(nav)) {
                    var aux = /edge\/((\d+\.?)+)/.exec(nav);
                    if (aux[1].split(".")[0] < 12) {
                        this.tooltipType = "warn";
                        this.versionMsg = "Your browser version is outdated. The tool may not work properly."
                    } else if (aux[1].split(".")[0] < 10) {
                        this.tooltipType = "error";
                        this.versionMsg = "Your browser version is deprecated. The tool will not work correctly."
                    }
                    this.versionNav += aux[0];
                } else if (/safari\/(\d+\.?)+/.test(nav) && nav.indexOf("chrome") == -1) {
                    var aux = /version\/((\d+\.?)+)/.exec(nav);
                    if (aux[1].split(".")[0] < 8) {
                        this.tooltipType = "warn";
                        this.versionMsg = "Your browser version is outdated. The tool may not work properly."
                    } else if (aux[1].split(".")[0] < 7) {
                        this.tooltipType = "error";
                        this.versionMsg = "Your browser version is deprecated. The tool will not work correctly."
                    }
                    this.versionNav += aux[0];
                } else if (/chrome\/(\d+\.?)+/.test(nav)) {
                    var aux = /chrome\/((\d+\.?)+)/.exec(nav);
                    if (aux[1].split(".")[0] < 49) {
                        this.tooltipType = "warn";
                        this.versionMsg = "Your browser version is outdated. The tool may not work properly."
                    } else if (aux[1].split(".")[0] < 36) {
                        this.tooltipType = "error";
                        this.versionMsg = "Your browser version is deprecated. The tool will not work correctly."
                    }
                    this.versionNav += aux[0];
                } else {
                    this.versionNav = "You are currently using an unsupported browser";
                    this.tooltipType = "warn";
                    this.versionMsg = "Your browser may not be compatible with the tool. The tool may not work properly."
                }
                if (nav.indexOf("_64") >= 0) {
                    this.versionNav += " (64-bits)"
                } else if (nav.indexOf("_32") >= 0) {
                    this.versionNav += " (32-bits)"
                }
            }
        })
    </script>
</dom-module>
<script>// This filterHistory class is based on bennadel's FixedQueue (https://gist.github.com/bennadel/9760671 )
function FilterHistory(size, initialValues) {
    // If there are no initial arguments, default it to
    // an empty value so we can call the constructor in
    // a uniform way.
    size = (size) ? size : 20;
    initialValues = (initialValues || []);
    // Create the fixed queue array value.
    var queue = Array.apply(null, initialValues);
    // Store the fixed size in the queue.
    queue.fixedSize = size;
    // Add the class methods to the queue. Some of these have
    // to override the native Array methods in order to make
    // sure the queue lenght is maintained.
    queue.push = FilterHistory.push;
    queue.splice = FilterHistory.splice;
    queue.unshift = FilterHistory.unshift;
    // Trim any initial excess from the queue.
    FilterHistory.trimTail.call(queue);
    // Return the new queue.
    return (queue);
}

// I trim the queue down to the appropriate size, removing
// items from the beginning of the internal array.
FilterHistory.trimHead = function () {
    // Check to see if any trimming needs to be performed.
    if (this.length <= this.fixedSize) {
        // No trimming, return out.
        return;
    }
    // Trim whatever is beyond the fixed size.
    Array.prototype.splice.call(
        this,
        0, (this.length - this.fixedSize)
    );
};
// I trim the queue down to the appropriate size, removing
// items from the end of the internal array.
FilterHistory.trimTail = function () {
    // Check to see if any trimming needs to be performed.
    if (this.length <= this.fixedSize) {
        // No trimming, return out.
        return;
    }
    // Trim whatever is beyond the fixed size.
    Array.prototype.splice.call(
        this,
        this.fixedSize, (this.length - this.fixedSize)
    );
};

// I synthesize wrapper methods that call the native Array
// methods followed by a trimming method.
FilterHistory.wrapMethod = function (methodName, trimMethod) {
    // Create a wrapper that calls the given method.
    var wrapper = function () {
        // Get the native Array method.
        var method = Array.prototype[methodName];
        // Call the native method first.
        var result = method.apply(this, arguments);
        // Trim the queue now that it's been augmented.
        trimMethod.call(this);
        // Return the original value.
        return (result);
    };
    // Return the wrapper method.
    return (wrapper);
};
// Wrap the native methods.
FilterHistory.push = FilterHistory.wrapMethod(
    "push",
    FilterHistory.trimHead
);
FilterHistory.splice = FilterHistory.wrapMethod(
    "splice",
    FilterHistory.trimTail
);
FilterHistory.unshift = FilterHistory.wrapMethod(
    "unshift",
    FilterHistory.trimTail
);
</script></div><dom-module id="biertool-element">
    <style is="custom-style" include="iron-flex iron-flex-reverse iron-flex-alignment iron-flex-factors iron-positioning">
        :host {
            display: block;
            position: relative;
            cursor: default;
            font-size: 13px;
            background-color: var(--light-primary-color);
            height: 100%;
            width: 100%;
        }

        jso-opencga-header {
            position: absolute;
            top: 0;
        }

        jso-opencga-footer {
            position: absolute;
            bottom: 0;
            height: 60px;
        }

        .content {
            position: absolute;
            width: 100%;
            top: 60px;
            /*height: calc(100vh - 60px);*/
            /*background-color: transparent;*/
        }

        #fileBrowserPanel {
            position: absolute;
            top: 0px;
            left: 0;
            width: 700px;
            height: 600px;
            min-width: 600px;
            min-height: 500px;
        }

        #sampleBrowserPanel {
            position: absolute;
            left: 0;
            top: 0;
            width: 600px;
        }

        #dropmenu {
            position: fixed !important;
            right: 10px !important;
            top: 50px !important;
            width: 200px;
            left: calc(100vw - 210px) !important;
        }

        @media (max-width: 1100px) {
            .option-text {
                display: none;
            }
        }

        .userid {
            color: var(--accent-color);
            font-size: 16px;
        }

        #description {
            color: var(--accent-color);
            font-weight: normal;
        }

        biertool-home {
            height: calc(100vh - 160px);
            overflow-y: auto;
        }

        biertool-form,
        stv-report {
            height: calc(100vh - 60px);
            overflow-y: auto;
        }

        bier-variant-browser {
            height: calc(100vh - 60px);
            overflow-y: scroll;
        }
    </style>
    <template>

        <div class="content" menu-option="home">
            <biertool-home id="home" on-start="handleHomeStart" islogged="{{isLogged}}"></biertool-home>
        </div>
        <div id="jobContent" class="content" menu-option="job">
            <stv-report id="report"></stv-report>
        </div>
        <div class="content" menu-option="home,variantbrowser">
            <stv-panel id="fileBrowserPanel" hidden="" collapsible="" movable="" closable="" expandible="" resizable="" on-hidden="handlePanelHidden">
                <div class="header">
                    <i class="fa fa-cloud"></i>&nbsp; Browse my data
                </div>
                <jso-opencga-file-browser enable-auto-index="" class="container" id="browser" projects="{{projects}}" bioformats="{{bioformats}}" mode="file" on-need-refresh="handleUserNeedRefresh" on-viewvariantbrowser="handleSampleSelect2" on-viewvariantbrowserfam="handleVariantBrowserFam" sample-selected="{{sampleSelected}}"></jso-opencga-file-browser>
            </stv-panel>
            
            <stv-feedback id="feedback" hidden="" on-feedbackend="handleFeedback"></stv-feedback>
        </div>

        <div class="content" menu-option="variantbrowser" style="height: 100%;">
            <bier-variant-browser id="variantBrowser"></bier-variant-browser>
        </div>

        <jso-opencga-header id="jsoHeader" selected-option="{{selectedOption}}" user-data="{{userData}}" on-logout="handleLogout" hide-jobs="" hide-browse="" show-menu-on-login="">
            <div class="icon">
                <img src="images/bier-text.svg" style="height: 50px;margin: 5px 0px 0 0;">
            </div>
            <div class="title horizontal layout center" style="margin-left:15px;">
                BIER Tool
            </div>
            <span id="description" class="description">
                0.0.1
            </span>

            <div id="menu" class="menu horizontal layout center flex">
                
                <div style="margin-left:4vw;"></div>
                <div class="option" on-click="handleMenuOption" data-option="home" title="Go to home page">
                    <i class="fa fa-home"></i>
                    <span class="option-text">Home</span>
                </div>
                <div title="Browse my data" class="option" on-click="handleLoggedOnlyMenuPanel" data-panel="fileBrowserPanel">
                    <i class="fa fa-cloud"></i>
                    <span class="option-text">Study Browser</span>
                </div>
                
                <div class="flex"></div>
            </div>

            <stv-dropdown dark="" class="helpmenu" selected-option="{{selectedOption}}">
                <div data-button=""><i class="fa fa-question-circle"></i></div>
                <ul data-menu="" id="dropmenu">
                    <li>
                        <a href="https://github.com/babelomics/bierapp/wiki" target="_blank">
                            <i class="fa fa-book"></i> &nbsp; Documentation
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/babelomics/bierapp/wiki/Tutorial" target="_blank">
                            <i class="fa fa-compass"></i> &nbsp; Tutorial
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/babelomics/bierapp/" target="_blank">
                            <i class="fa fa-github"></i> &nbsp; Source code
                        </a>
                    </li>
                </ul>
            </stv-dropdown>
        </jso-opencga-header>

        <jso-opencga-footer menu-option="home,loging,singup,profile,remember">
            BierTool 2016
            <br> Created by <b>Computational Genomics Department</b> at <b>Centro de Investigacin Principe Felipe</b>
        </jso-opencga-footer>
    </template>

    <script>
        Polymer({
            is: "biertool-element",
            behaviors: [JsoApplicationBehavior],
            properties: {
                userData: {
                    type: Object,
                    notify: true,
                    observer: 'userDataChanged'
                },
                projects: {
                    type: Array,
                    notify: true,
                    observer: 'projectsChanged'
                },
                allowedTools: {
                    type: Array,
                    value: function() {
                        return ["bierapp"];
                    }
                },
                browserHidden: {
                    type: Boolean,
                    value: true,
                    reflectToAttribute: true
                },
                uploadHidden: {
                    type: Boolean,
                    value: true,
                    reflectToAttribute: true
                },
                createStudyHidden: {
                    type: Boolean,
                    value: true,
                    reflectToAttribute: true
                },
                createProjectHidden: {
                    type: Boolean,
                    value: true,
                    reflectToAttribute: true
                },
                bioformats: {
                    type: Array,
                    notify: true,
                    value: [{
                        text: "VCF 4.0",
                        value: "VARIANT",
                        validator: VCFValidator
                    }]
                },
                samples: {
                    type: Array,
                    value: function() {
                        return [];
                    },
                    observer: "samplesChanged"
                },
                filteredSamples: {
                    type: Array,
                    value: function() {
                        return [];
                    },
                    observer: "filteredSamplesChanged"
                },
                sampleSelected: {
                    type: Array,
                    value: function() {
                        return [];
                    },
                    observer: "sampleSelectedChanged"
                },

            },
            annonymousLogin: function() {
                this.$.jsoHeader.anonymousSign();
            },
            ready: function() {
                var me = this;
                this.selectedOption = "home";
                this.checkShowMenuOnLogin();
            },
            handleFileSelect: function(e) {},
            handleJobSelect: function(e) {
                var me = this;
                var job = e.detail;
                if (job && job.status === 'DONE') {
                    this.set('selectedOption', 'job');
                    this.$.report.hideJobInformation = true;
                    this.$.report.set('job', job);
                }
            },
            handleLogin: function() {
                if (Cookies('bioinfo_user').indexOf("anonymous___") != -1) {
                    this.setMenu('home');
                } else {
                    this.setMenu('home');
                }
                if (this._lastLoggedPanel) {
                    this._lastLoggedPanel.show();
                    this._lastLoggedPanel = null;
                }
                if (this._lastLoggedMenu) {
                    this.setMenu(this._lastLoggedMenu);
                    this._lastLoggedMenu = null;
                }
                this.$.home.isLogged = true;
                this.checkShowMenuOnLogin();
            },
            handleLogout: function() {
                this.$.home.isLogged = false;
                this.setMenu('home');
                this.checkShowMenuOnLogin();
            },
            userDataChanged: function(neo, old) {
                var me = this;
                if (this.userData) {
                    var projectIds = [];
                    for (var i = 0; i < this.userData.projects.length; i++) {
                        var p = this.userData.projects[i];
                        projectIds.push(p.id);
                    }
                    var projects = [];
                    OpencgaManager.projects.studies({
                        id: projectIds.join(','),
                        query: {
                            sid: Cookies("bioinfo_sid")
                        },
                        request: {
                            success: function(response) {
                                if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                                    for (var i = 0; i < response.response.length; i++) {
                                        var r = response.response[i];
                                        me.userData.projects[i].studies = r.result;
                                        projects.push(me.userData.projects[i]);
                                    }
                                    /* update projects property*/
                                    me.projects = projects;
                                } else {
                                    console.log(response.error);
                                    console.log(response.response[0].errorMsg);
                                }
                                me.loading = false;
                            },
                            error: function() {
                                console.log('Server error, try again later.');
                                me.loading = false;
                            }
                        }
                    });
                } else {
                    console.log("no user data")
                }
            },
            projectsChanged: function(neo, old) {},
            handleUserNeedRefresh: function() {
                this.$.jsoHeader.getUserInfo(true);
            },
            handleFeedback: function() {
                this.$.feedback.hidden = !this.$.feedback.hidden;
            },
            // handleSampleSelect: function(e) {
            //     var samplesArray = [];
            //     var samplesIds = [];
            //     var samples = e.currentTarget.querySelectorAll('jso-opencga-sample-list-item[selected]');
            //
            //     if (samples.length == 0) {
            //         if (this.filteredSamples.length == 0) {
            //             alert('You must select at least one sample');
            //             return;
            //         } else {
            //             for (var i = 0; i < this.filteredSamples.length; i++) {
            //                 var s = this.filteredSamples[i];
            //                 if (s.status != 'READY') {
            //                     alert('All selected samples must be READY');
            //                     return;
            //                 }
            //             }
            //             this.$.variantBrowser.samples = this.filteredSamples;
            //             this.$.variantBrowser.study = this.$.sampleBrowser.selectedStudy.study;
            //         }
            //
            //     } else {
            //         for (var i = 0; i < samples.length; i++) {
            //             samplesIds.push(samples[i].sample.id);
            //             samplesArray.push(samples[i].sample);
            //         }
            //         for (var i = 0; i < samplesArray.length; i++) {
            //             var s = samplesArray[i];
            //             if (s.status != 'READY') {
            //                 alert('All selected samples must be READY');
            //                 return;
            //             }
            //         }
            //
            //         var selectedStudy = this.$.sampleBrowser.selectedStudy.study;
            //
            //         this.$.variantBrowser.samples = samplesArray;
            //         this.$.variantBrowser.study = selectedStudy;
            //     }
            //     this.setMenu('variantbrowser');
            //     this.$.sampleBrowserPanel.hidden = true;
            //     this.$.fileBrowserPanel.hidden = true;
            //
            // },
            handleSampleSelect2: function(e) {
                var samplesArray = [];
                var samplesIds = [];
                if (this.sampleSelected.length == 0) {
                    alert('You must select at least one sample');
                    return;
                } else {
                    for (var i = 0; i < this.sampleSelected.length; i++) {
                        samplesIds.push(this.sampleSelected[i].id);
                        samplesArray.push(this.sampleSelected[i]);
                    }
                    for (var i = 0; i < this.sampleSelected.length; i++) {
                        var s = this.sampleSelected[i];
                        if (s.status != 'READY') {
                            alert('All selected samples must be READY! Select samples from VCF in READY status.');
                            return;
                        }
                    }
                    this.$.variantBrowser.samples = samplesArray;
                    this.$.variantBrowser.study = this.$.browser.selectedStudy.study;
                }

                this.setMenu('variantbrowser');
                this.$.fileBrowserPanel.hidden = true;

            },
            handleVariantBrowserFam: function(e) {
                this.$.variantBrowser.samples = [];
                this.$.variantBrowser.samples = e.detail.samples;
                this.$.variantBrowser.study = this.$.browser.selectedStudy.study;
                this.setMenu('variantbrowser');
                this.$.fileBrowserPanel.hidden = true;
            },
            samplesChanged: function(neo, old) {},
            filteredSamplesChanged: function(neo, old) {},
            sampleSelectedChanged: function(neo, old) {}
        });
    </script>
</dom-module>
</body></html>